<Type Name="SerialPort" FullName="System.IO.Ports.SerialPort">
  <Metadata><Meta Name="ms.openlocfilehash" Value="af6a2cdcc75357d8b55ed45356eaf513da121349" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56776312" /></Metadata><TypeSignature Language="C#" Value="public class SerialPort : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SerialPort extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.IO.Ports.SerialPort" />
  <TypeSignature Language="VB.NET" Value="Public Class SerialPort&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class SerialPort : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type SerialPort = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Ports</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("SerialPortDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente une ressource de port série.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette classe pour contrôler une ressource de fichier de port série. Cette classe fournit synchrones et pilotées par les événements d’e/s, d’accès aux États d’épinglage et d’arrêt et d’accès aux propriétés des pilotes série. En outre, les fonctionnalités de cette classe peuvent être encapsulée dans une liste interne <xref:System.IO.Stream> objet, accessible via la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété et passé aux classes qui encapsulent ou utilisent des flux.  
  
 Le <xref:System.IO.Ports.SerialPort> classe prend en charge les encodages suivants : <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF32Encoding>et n’importe quel encodage défini dans mscorlib.dll où la page de codes est inférieure à 50000 ou la page de codes est 54936.  Vous pouvez utiliser d’autres encodages, mais vous devez utiliser le <xref:System.IO.Ports.SerialPort.ReadByte%2A> ou <xref:System.IO.Ports.SerialPort.Write%2A> (méthode) et exécuter l’encodage vous-même.  
  
 Vous utilisez la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> méthode pour récupérer les ports valides pour l’ordinateur actuel.  
  
 Si un <xref:System.IO.Ports.SerialPort> objet devienne bloqué pendant une opération de lecture, ne pas abandonner le thread. Au lieu de cela, fermez la base de diffuser en continu ou de supprimer le <xref:System.IO.Ports.SerialPort> objet.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Les deux ordinateurs doivent exécuter le programme pour obtenir toutes les fonctionnalités de cet exemple.  
  
 [!code-cpp[System.IO.Ports.SerialPort#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#10)]
 [!code-csharp[System.IO.Ports.SerialPort#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#10)]
 [!code-vb[System.IO.Ports.SerialPort#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#10)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur utilise les valeurs de propriété par défaut lorsque aucune n’est spécifiée. Par exemple, le <xref:System.IO.Ports.SerialPort.DataBits%2A> propriété valeur par défaut est 8, le <xref:System.IO.Ports.SerialPort.Parity%2A> propriété par défaut le `None` valeur d’énumération, le <xref:System.IO.Ports.SerialPort.StopBits%2A> propriété valeur par défaut est 1 et un nom de port par défaut de COM1.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : System.ComponentModel.IContainer -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Interface avec un conteneur.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> à l'aide de l'objet <see cref="T:System.ComponentModel.IContainer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur utilise les valeurs de propriété par défaut lorsque aucune n’est spécifiée. Par exemple, le <xref:System.IO.Ports.SerialPort.DataBits%2A> propriété valeur par défaut est 8, le <xref:System.IO.Ports.SerialPort.Parity%2A> propriété par défaut le `None` valeur d’énumération, le <xref:System.IO.Ports.SerialPort.StopBits%2A> propriété valeur par défaut est 1 et un nom de port par défaut de COM1.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort portName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="portName">Port à utiliser (par exemple, COM1).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> avec le nom de port spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour créer une nouvelle instance de la <xref:System.IO.Ports.SerialPort> classe lorsque vous souhaitez spécifier le nom de port.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (portName As String, baudRate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Port à utiliser (par exemple, COM1).</param>
        <param name="baudRate">Vitesse en bauds.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> avec le nom de port et la vitesse (en bauds) spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour créer une nouvelle instance de la <xref:System.IO.Ports.SerialPort> classe lorsque vous souhaitez spécifier le nom de port et la vitesse de transmission.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
      </Parameters>
      <Docs>
        <param name="portName">Port à utiliser (par exemple, COM1).</param>
        <param name="baudRate">Vitesse en bauds.</param>
        <param name="parity">Une des valeurs de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> avec le nom de port, la vitesse (en bauds) et le bit de parité spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour créer une nouvelle instance de la <xref:System.IO.Ports.SerialPort> classe lorsque vous souhaitez spécifier le nom de port, la vitesse de transmission et le bit de parité.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="portName">Port à utiliser (par exemple, COM1).</param>
        <param name="baudRate">Vitesse en bauds.</param>
        <param name="parity">Une des valeurs de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valeur des bits de données.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> avec le nom de port, la vitesse (en bauds), le bit de parité et les bits de données spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour créer une nouvelle instance de la <xref:System.IO.Ports.SerialPort> classe lorsque vous souhaitez spécifier le nom de port, la vitesse de transmission, le bit de parité et les bits de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SerialPort (string portName, int baudRate, System.IO.Ports.Parity parity, int dataBits, System.IO.Ports.StopBits stopBits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string portName, int32 baudRate, valuetype System.IO.Ports.Parity parity, int32 dataBits, valuetype System.IO.Ports.StopBits stopBits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.#ctor(System.String,System.Int32,System.IO.Ports.Parity,System.Int32,System.IO.Ports.StopBits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SerialPort(System::String ^ portName, int baudRate, System::IO::Ports::Parity parity, int dataBits, System::IO::Ports::StopBits stopBits);" />
      <MemberSignature Language="F#" Value="new System.IO.Ports.SerialPort : string * int * System.IO.Ports.Parity * int * System.IO.Ports.StopBits -&gt; System.IO.Ports.SerialPort" Usage="new System.IO.Ports.SerialPort (portName, baudRate, parity, dataBits, stopBits)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="portName" Type="System.String" />
        <Parameter Name="baudRate" Type="System.Int32" />
        <Parameter Name="parity" Type="System.IO.Ports.Parity" />
        <Parameter Name="dataBits" Type="System.Int32" />
        <Parameter Name="stopBits" Type="System.IO.Ports.StopBits" />
      </Parameters>
      <Docs>
        <param name="portName">Port à utiliser (par exemple, COM1).</param>
        <param name="baudRate">Vitesse en bauds.</param>
        <param name="parity">Une des valeurs de <see cref="P:System.IO.Ports.SerialPort.Parity" />.</param>
        <param name="dataBits">Valeur des bits de données.</param>
        <param name="stopBits">Une des valeurs de <see cref="P:System.IO.Ports.SerialPort.StopBits" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Ports.SerialPort" /> avec le nom de port, la vitesse (en bauds), le bit de parité, les bits de données et le bit d'arrêt spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur pour créer une nouvelle instance de la <xref:System.IO.Ports.SerialPort> classe lorsque vous souhaitez spécifier le nom de port, le débit en bauds, le bit de parité, les bits de données et le bit d’arrêt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Le port spécifié est introuvable ou n'a pas pu être ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.Ports.SerialPort.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.IO.Stream" /> sous-jacent pour un objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Objet <see cref="T:System.IO.Stream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour les opérations d’e/s asynchrones explicites ou pour passer le <xref:System.IO.Ports.SerialPort> de l’objet à un <xref:System.IO.Stream> classe wrapper telle que <xref:System.IO.StreamWriter>.  
  
 Une ouverture du port série <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété retourne un objet qui dérive de la classe abstraite <xref:System.IO.Stream> classe et implémente méthodes read et write à l’aide des prototypes hérités de la <xref:System.IO.Stream> classe : <xref:System.IO.Stream.BeginRead%2A>, <xref:System.IO.Stream.BeginWrite%2A>, <xref:System.IO.Stream.Read%2A> , <xref:System.IO.Stream.ReadByte%2A>, <xref:System.IO.Stream.Write%2A>, et <xref:System.IO.Stream.WriteByte%2A>. Ces méthodes peuvent être utiles lors du passage d’une ressource série encapsulée à un <xref:System.IO.Stream> classe wrapper.  
  
 En raison de l’inaccessibilité du handle de fichier encapsulé, le <xref:System.IO.Stream.Length%2A> et <xref:System.IO.Stream.Position%2A> propriétés ne sont pas prises en charge et le <xref:System.IO.Stream.Seek%2A> et <xref:System.IO.Stream.SetLength%2A> méthodes ne sont pas prises en charge.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
        <exception cref="T:System.NotSupportedException">Le flux se trouve dans une application .NET Compact Framework et l'une des méthodes suivantes a été appelée : 
 <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /><see cref="M:System.IO.Stream.EndRead(System.IAsyncResult)" /><see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />  
  
Le .NET Compact Framework ne prend pas en charge le modèle asynchrone avec des flux de base.</exception>
      </Docs>
    </Member>
    <Member MemberName="BaudRate">
      <MemberSignature Language="C#" Value="public int BaudRate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BaudRate" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BaudRate" />
      <MemberSignature Language="VB.NET" Value="Public Property BaudRate As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BaudRate { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BaudRate : int with get, set" Usage="System.IO.Ports.SerialPort.BaudRate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(9600)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("BaudRate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la vitesse en bauds série.</summary>
        <value>Vitesse en bauds.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La vitesse de transmission doit être pris en charge par les pilotes de série de l’utilisateur. La valeur par défaut est 9 600 bits par seconde (bps).  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.IO.Ports.SerialPort.BaudRate%2A> propriété `9600`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 L’exemple suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La vitesse en bauds spécifiée est inférieure ou égale à zéro ou est supérieure à la vitesse en bauds maximale autorisée pour le périphérique.</exception>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="BreakState">
      <MemberSignature Language="C#" Value="public bool BreakState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BreakState" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BreakState" />
      <MemberSignature Language="VB.NET" Value="Public Property BreakState As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BreakState { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BreakState : bool with get, set" Usage="System.IO.Ports.SerialPort.BreakState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'état du signal d'arrêt.</summary>
        <value><see langword="true" /> si le port est dans un état d'arrêt ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’état de signal d’arrêt se produit lorsqu’une transmission est interrompue et la ligne est placée dans un état d’arrêt (tous de poids faible, aucun bit d’arrêt) jusqu'à ce que libéré. Pour entrer un état d’arrêt, définissez cette propriété sur `true`. Si le port est déjà dans un état d’arrêt, définition de cette propriété à nouveau à `true` n’entraîne pas une exception. Il n’est pas possible d’écrire dans le <xref:System.IO.Ports.SerialPort> objet lors de la <xref:System.IO.Ports.SerialPort.BreakState%2A> est `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToRead">
      <MemberSignature Language="C#" Value="public int BytesToRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToRead As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToRead { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToRead : int" Usage="System.IO.Ports.SerialPort.BytesToRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'octets de données dans la mémoire tampon de réception.</summary>
        <value>Nombre d'octets de données dans la mémoire tampon de réception.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mémoire tampon de réception inclut le pilote série mémoire tampon de réception, ainsi que la mise en mémoire tampon interne dans le <xref:System.IO.Ports.SerialPort> objet lui-même.  
  
 Étant donné que le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété représente à la fois le <xref:System.IO.Ports.SerialPort> mémoire tampon et la mémoire tampon créée de Windows, elle peut retourner une valeur supérieure à celle la <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propriété, qui représente uniquement la mémoire tampon créée par Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port n'est pas ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName="BytesToWrite">
      <MemberSignature Language="C#" Value="public int BytesToWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesToWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesToWrite As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesToWrite { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesToWrite : int" Usage="System.IO.Ports.SerialPort.BytesToWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'octets de données dans la mémoire tampon d'envoi.</summary>
        <value>Nombre d'octets de données dans la mémoire tampon d'envoi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La mémoire tampon d’envoi inclut le pilote série mémoire tampon d’envoi, ainsi que la mise en mémoire tampon interne dans le <xref:System.IO.Ports.SerialPort> objet lui-même.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="CDHolding">
      <MemberSignature Language="C#" Value="public bool CDHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CDHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CDHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CDHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CDHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CDHolding : bool" Usage="System.IO.Ports.SerialPort.CDHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état de la ligne de détection de porteuse pour le port.</summary>
        <value><see langword="true" /> si la porteuse est détectée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut être utilisée pour surveiller l’état de la ligne de détection de porteuse pour un port. Aucun opérateur n’indique généralement que le récepteur a raccroché et que l’opérateur a été supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="serialPort.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la connexion au port, affecte à la propriété <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> la valeur <see langword="false" /> et supprime l'objet <see cref="T:System.IO.Stream" /> interne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode ferme le <xref:System.IO.Ports.SerialPort> de l’objet et efface les deux la réception et transmettre les mémoires tampons. Cette méthode appelle la <xref:System.ComponentModel.Component.Dispose?displayProperty=nameWithType> (méthode), qui appelle la méthode protégée <xref:System.IO.Ports.SerialPort.Dispose%28System.Boolean%29?displayProperty=nameWithType> méthode avec le `disposing` paramètre défini sur `true`.  
  
 La meilleure pratique pour toute application consiste à attendre d’une certaine quantité de temps après avoir appelé la <xref:System.IO.Ports.SerialPort.Close%2A> méthode avant d’essayer d’appeler le <xref:System.IO.Ports.SerialPort.Open%2A> (méthode), comme le port peut ne pas être fermé instantanément.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="CtsHolding">
      <MemberSignature Language="C#" Value="public bool CtsHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CtsHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.CtsHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CtsHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CtsHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CtsHolding : bool" Usage="System.IO.Ports.SerialPort.CtsHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état de la ligne CTS (Clear-To-Send).</summary>
        <value><see langword="true" /> si la ligne CTS est détectée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La ligne Clear to Send (CTS) est utilisée dans la demande d’envoi/invite pour envoyer le protocole de transfert matériel RTS/CTS (). La ligne CTS est interrogée par un port avant l’envoi de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataBits">
      <MemberSignature Language="C#" Value="public int DataBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DataBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DataBits" />
      <MemberSignature Language="VB.NET" Value="Public Property DataBits As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DataBits { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DataBits : int with get, set" Usage="System.IO.Ports.SerialPort.DataBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(8)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DataBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longueur standard des bits de données par octet.</summary>
        <value>Longueur des bits de données.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La plage de valeurs pour cette propriété est comprise entre 5 et 8. La valeur par défaut est 8.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur des bits de données est inférieure à 5 ou supérieure à 8.</exception>
      </Docs>
    </Member>
    <Member MemberName="DataReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialDataReceivedEventHandler DataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialDataReceivedEventHandler DataReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.DataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataReceived As SerialDataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialDataReceivedEventHandler ^ DataReceived;" />
      <MemberSignature Language="F#" Value="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " Usage="member this.DataReceived : System.IO.Ports.SerialDataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialDataReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialDataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique que des données ont été reçues via un port représenté par l'objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Événements de données peuvent être provoqués par un des éléments dans le <xref:System.IO.Ports.SerialData> énumération. Étant donné que le système d’exploitation détermine s’il faut déclencher cet événement ou non, pas toutes les erreurs de parité peuvent être signalées.  
  
 Le <xref:System.IO.Ports.SerialPort.DataReceived> est également déclenché si un caractère Eof est reçu, quel que soit le nombre d’octets dans la mémoire tampon d’entrée interne et la valeur de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propriété.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, et <xref:System.IO.Ports.SerialPort.ErrorReceived> événements peuvent être appelés en désordre, et il peut y avoir un léger délai entre lorsque le flux sous-jacent signale l’erreur et lorsque le Gestionnaire d’événements est exécuté. Gestionnaire d’événements qu’une seule peut exécuter simultanément.  
  
 Le <xref:System.IO.Ports.SerialPort.DataReceived> événement n’est pas garanti être déclenché pour chaque octet reçu. Utilisez le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété afin de déterminer la quantité de données reste à lire dans la mémoire tampon.  
  
 Le <xref:System.IO.Ports.SerialPort.DataReceived> événement est déclenché sur un thread secondaire lorsque les données sont reçues à partir de la <xref:System.IO.Ports.SerialPort> objet. Étant donné que cet événement est déclenché sur un thread secondaire, et pas le thread principal, tente de modifier certains éléments dans le thread principal, tels que des éléments d’interface utilisateur, peut lever une exception de thread. S’il est nécessaire de modifier des éléments dans le principal <xref:System.Windows.Forms.Form> ou <xref:System.Windows.Forms.Control>, valider les demandes de modification à l’aide de <xref:System.Windows.Forms.Control.Invoke%2A>, qui effectuent l’opération sur le thread approprié.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Cet exemple ajoute un <xref:System.IO.Ports.SerialDataReceivedEventHandler> à <xref:System.IO.Ports.SerialPort.DataReceived> pour lire les données disponibles est reçues sur le port COM1. Notez que, pour tester ce code, il est nécessaire de disposer du matériel connecté au port COM1 qui envoie des données.  
  
 [!code-cpp[System.IO.Ports.SerialPort#06](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#06)]
 [!code-csharp[System.IO.Ports.SerialPort#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#06)]
 [!code-vb[System.IO.Ports.SerialPort#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#06)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardInBuffer">
      <MemberSignature Language="C#" Value="public void DiscardInBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardInBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardInBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardInBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardInBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardInBuffer : unit -&gt; unit" Usage="serialPort.DiscardInBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignore les données de la mémoire tampon de réception du pilote série.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode équivaut au code Visual Basic suivant : `MSComm1.InBufferCount = 0`. Il efface la mémoire tampon de réception, mais n’affecte pas la mémoire tampon de transmission.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardNull">
      <MemberSignature Language="C#" Value="public bool DiscardNull { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DiscardNull" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DiscardNull" />
      <MemberSignature Language="VB.NET" Value="Public Property DiscardNull As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DiscardNull { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DiscardNull : bool with get, set" Usage="System.IO.Ports.SerialPort.DiscardNull" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DiscardNull")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les octets null sont ignorés lorsqu'ils sont transmis entre le port et la mémoire tampon de réception.</summary>
        <value><see langword="true" /> si les octets null sont ignorés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur doit normalement être définie `false`, en particulier pour les transmissions binaires.  Si cette propriété `true` peut provoquer des résultats inattendus pour les octets encodés en UTF32 et UTF16.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="DiscardOutBuffer">
      <MemberSignature Language="C#" Value="public void DiscardOutBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardOutBuffer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.DiscardOutBuffer" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardOutBuffer ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardOutBuffer();" />
      <MemberSignature Language="F#" Value="member this.DiscardOutBuffer : unit -&gt; unit" Usage="serialPort.DiscardOutBuffer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignore les données de la mémoire tampon de transmission du pilote série.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode équivaut au code Visual Basic suivant : `MSComm1.OutBufferCount = 0`. Il efface la mémoire tampon de transmission, mais n’affecte pas la mémoire tampon de réception.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serialPort.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour libérer uniquement les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.IO.Ports.SerialPort" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public <xref:System.ComponentModel.Component.Dispose%2A> (méthode) et le <xref:System.Object.Finalize%2A> (méthode). <xref:System.ComponentModel.Component.Dispose%2A> appelle la méthode protégée <xref:System.IO.Ports.SerialPort.Dispose%2A> méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle <xref:System.IO.Ports.SerialPort.Dispose%2A> avec `disposing` défini sur `false`.  
  
 Si le paramètre `disposing` a la valeur `true`, cette méthode libère toutes les ressources détenues par les objets managés référencés par ce <xref:System.IO.Ports.SerialPort>. Cette méthode appelle la méthode <xref:System.ComponentModel.Component.Dispose%2A> de chaque objet référencé.  
  
 Cette méthode vide et ferme l’objet de flux dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution de <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, veillez à ne pas référencer des objets qui ont été préalablement supprimés lors d'un appel précédent à <see cref="M:System.ComponentModel.Component.Dispose" />. Pour plus d’informations sur l’implémentation <see cref="M:System.IO.Ports.SerialPort.Dispose(System.Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see cref="M:System.ComponentModel.Component.Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DsrHolding">
      <MemberSignature Language="C#" Value="public bool DsrHolding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DsrHolding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DsrHolding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DsrHolding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DsrHolding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.DsrHolding : bool" Usage="System.IO.Ports.SerialPort.DsrHolding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'état du signal DSR (Data Set Ready).</summary>
        <value><see langword="true" /> si un signal DSR (Data Set Ready) a été envoyé au port ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est utilisée dans une négociation Data Set Ready/Data Terminal Ready DSR/DTR (). Le signal DSR Data Set Ready () est généralement envoyé par un modem à un port pour indiquer qu’il est prêt pour la transmission de données ou de réception de données.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le flux est fermé. Cela peut être dû au fait que la méthode <see cref="M:System.IO.Ports.SerialPort.Open" /> n'a pas été appelée ou que la méthode <see cref="M:System.IO.Ports.SerialPort.Close" /> a été appelée.</exception>
      </Docs>
    </Member>
    <Member MemberName="DtrEnable">
      <MemberSignature Language="C#" Value="public bool DtrEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DtrEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.DtrEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property DtrEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DtrEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DtrEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.DtrEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("DtrEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui active le signal DTR lors d'une communication série.</summary>
        <value><see langword="true" /> pour activer le signal DTR ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Données Terminal prêt (DTR) est généralement activée au cours de transfert logiciel XON/XOFF et demande d’envoi/invite pour le protocole de transfert matériel RTS/CTS () et les communications de modem.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding with get, set" Usage="System.IO.Ports.SerialPort.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Encoding")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'octet d'encodage pour la conversion de texte avant et après la transmission.</summary>
        <value>Objet <see cref="T:System.Text.Encoding" />. La valeur par défaut est <see cref="T:System.Text.ASCIIEncoding" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.IO.Ports.SerialPort.Encoding" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.IO.Ports.SerialPort.Encoding" /> s'est vue affecter un encodage autre que <see cref="T:System.Text.ASCIIEncoding" />, <see cref="T:System.Text.UTF8Encoding" />, <see cref="T:System.Text.UTF32Encoding" />, <see cref="T:System.Text.UnicodeEncoding" />, l'un des encodages à octet unique de Windows ou l'un des encodages à deux octets de Windows.</exception>
      </Docs>
    </Member>
    <Member MemberName="ErrorReceived">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialErrorReceivedEventHandler ErrorReceived" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.ErrorReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorReceived As SerialErrorReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialErrorReceivedEventHandler ^ ErrorReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " Usage="member this.ErrorReceived : System.IO.Ports.SerialErrorReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialErrorReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialErrorReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique qu'une erreur s'est produite par rapport à un port représenté par l'objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Événements d’erreur peuvent résulter d’un des éléments dans le <xref:System.IO.Ports.SerialError> énumération. Étant donné que le système d’exploitation détermine s’il faut déclencher cet événement ou non, pas toutes les erreurs de parité peuvent être signalées.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, et <xref:System.IO.Ports.SerialPort.ErrorReceived> événements peuvent être appelés en désordre, et il peut y avoir un léger délai entre lorsque le flux sous-jacent signale l’erreur et le moment lorsque le Gestionnaire d’événements est exécuté. Gestionnaire d’événements qu’une seule peut exécuter simultanément.  
  
 Si une erreur de parité se produit sur l’octet de fin d’un flux, un octet supplémentaire sera ajouté à la mémoire tampon d’entrée avec une valeur de 126.  
  
 Le <xref:System.IO.Ports.SerialPort.ErrorReceived> événement est déclenché sur un thread secondaire lorsqu’une erreur est reçue depuis le <xref:System.IO.Ports.SerialPort> objet. Étant donné que cet événement est déclenché sur un thread secondaire, et pas le thread principal, tente de modifier certains éléments dans le thread principal, tels que des éléments d’interface utilisateur, peut lever une exception de thread. S’il est nécessaire de modifier des éléments dans le principal <xref:System.Windows.Forms.Form> ou <xref:System.Windows.Forms.Control>, valider les demandes de modification à l’aide de <xref:System.Windows.Forms.Control.Invoke%2A>, qui effectuent l’opération sur le thread approprié.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPortNames">
      <MemberSignature Language="C#" Value="public static string[] GetPortNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetPortNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.GetPortNames" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPortNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetPortNames();" />
      <MemberSignature Language="F#" Value="static member GetPortNames : unit -&gt; string[]" Usage="System.IO.Ports.SerialPort.GetPortNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient un tableau de noms de ports série pour l'ordinateur actuel.</summary>
        <returns>Tableau de noms de ports série pour l'ordinateur actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre des noms de port retournés à partir de <xref:System.IO.Ports.SerialPort.GetPortNames%2A> n’est pas spécifié.  
  
 Utilisez le <xref:System.IO.Ports.SerialPort.GetPortNames%2A> méthode pour interroger l’ordinateur actuel pour obtenir la liste des noms de port série valide. Par exemple, vous pouvez utiliser cette méthode pour déterminer si COM1 et COM2 sont des ports série valides pour l’ordinateur actuel.  
  
 Les noms de port sont obtenus à partir du Registre système (par exemple, HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\SERIALCOMM). Si le Registre contient des données obsolètes ou incorrectes, le <xref:System.IO.Ports.SerialPort.GetPortNames%2A> méthode retournera des données incorrectes.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.IO.Ports.SerialPort.GetPortNames%2A> méthode pour afficher les noms des ports série dans la console.  
  
 [!code-cpp[IO.Ports.GetPortNames#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.Ports.GetPortNames/cpp/example.cpp#1)]
 [!code-csharp[IO.Ports.GetPortNames#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.Ports.GetPortNames/CS/example.cs#1)]
 [!code-vb[IO.Ports.GetPortNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.Ports.GetPortNames/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Les noms de ports série n'ont pas pu être interrogés.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handshake">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Handshake Handshake { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Handshake Handshake" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Handshake" />
      <MemberSignature Language="VB.NET" Value="Public Property Handshake As Handshake" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Handshake Handshake { System::IO::Ports::Handshake get(); void set(System::IO::Ports::Handshake value); };" />
      <MemberSignature Language="F#" Value="member this.Handshake : System.IO.Ports.Handshake with get, set" Usage="System.IO.Ports.SerialPort.Handshake" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handshake")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Handshake</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le protocole de négociation pour la transmission de données par le port série en utilisant une valeur de <see cref="T:System.IO.Ports.Handshake" />.</summary>
        <value>Une des valeurs de <see cref="T:System.IO.Ports.Handshake" />. La valeur par défaut est <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de la négociation est utilisée, l’appareil est connecté à la <xref:System.IO.Ports.SerialPort> objet est tenue d’arrêter l’envoi des données lorsqu’il existe au moins (<xref:System.IO.Ports.SerialPort.ReadBufferSize%2A>-1024) octets dans la mémoire tampon. L’appareil est invité à commencer à envoyer des données lorsqu’il y a 1024 octets ou moins dans la mémoire tampon. Si l’appareil envoie des données dans les blocs qui sont supérieures à 1 024 octets, cela peut entraîner le dépassement de capacité de la mémoire tampon.  
  
 Si le <xref:System.IO.Ports.SerialPort.Handshake%2A> propriété est définie sur <xref:System.IO.Ports.Handshake.RequestToSendXOnXOff> et <xref:System.IO.Ports.SerialPort.CtsHolding%2A> est défini sur `false`, le caractère XOff ne sera pas envoyé. Si <xref:System.IO.Ports.SerialPort.CtsHolding%2A> est ensuite définie sur `true`, davantage de données doit être envoyés avant que le caractère XOff est envoyé.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur passée n'est pas une valeur valide dans l'énumération <see cref="T:System.IO.Ports.Handshake" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public const int InfiniteTimeout = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 InfiniteTimeout = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Const InfiniteTimeout As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int InfiniteTimeout = -1;" />
      <MemberSignature Language="F#" Value="val mutable InfiniteTimeout : int" Usage="System.IO.Ports.SerialPort.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Indique qu'aucun dépassement du délai d'attente ne doit se produire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est utilisée avec la <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> et <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propriétés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool" Usage="System.IO.Ports.SerialPort.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant l'état ouvert ou fermé de l'objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value><see langword="true" /> si le port série est ouvert ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Ports.SerialPort.IsOpen%2A> effectue le suivi de propriété si le port est ouvert pour une utilisation par l’appelant, pas si le port est ouvert par n’importe quelle application sur l’ordinateur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> transmise est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur <see cref="P:System.IO.Ports.SerialPort.IsOpen" /> transmise est une chaîne vide ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public string NewLine { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NewLine { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string with get, set" Usage="System.IO.Ports.SerialPort.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("\n")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("NewLine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur utilisée pour interpréter la fin d'un appel aux méthodes <see cref="M:System.IO.Ports.SerialPort.ReadLine" /> et <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" />.</summary>
        <value>Valeur qui représente la fin d'une ligne. La valeur par défaut est un saut de ligne, <see cref="P:System.Environment.NewLine" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété détermine quelle valeur (octets) définit la fin d’une ligne pour le <xref:System.IO.Ports.SerialPort.ReadLine%2A> et <xref:System.IO.Ports.SerialPort.WriteLine%2A> méthodes. Par défaut la valeur de fin de ligne est <xref:System.Environment.NewLine%2A>. Vous devez modifier cela sur une autre valeur si l’appareil de série particulier avec lequel vous travaillez utilise une valeur différente dans le même but.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété de la propriété est vide.</exception>
        <exception cref="T:System.ArgumentNullException">La valeur de la propriété est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public void Open ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Open() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Open" />
      <MemberSignature Language="VB.NET" Value="Public Sub Open ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Open();" />
      <MemberSignature Language="F#" Value="member this.Open : unit -&gt; unit" Usage="serialPort.Open " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une nouvelle connexion de port série.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qu’une connexion ouverte peut exister par <xref:System.IO.Ports.SerialPort> objet.  
  
 La meilleure pratique pour toute application consiste à attendre d’une certaine quantité de temps après avoir appelé la <xref:System.IO.Ports.SerialPort.Close%2A> méthode avant d’essayer d’appeler le <xref:System.IO.Ports.SerialPort.Open%2A> (méthode), comme le port peut ne pas être fermé instantanément.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">L'accès au port est refusé.  
  
ou 
Le processus actuel, ou un autre processus sur le système, a déjà le port COM spécifié ouvert par une instance <see cref="T:System.IO.Ports.SerialPort" /> ou dans le code non managé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Une ou plusieurs propriétés de cette instance ne sont pas valides. Par exemple, les propriétés <see cref="P:System.IO.Ports.SerialPort.Parity" />, <see cref="P:System.IO.Ports.SerialPort.DataBits" /> ou <see cref="P:System.IO.Ports.SerialPort.Handshake" /> n'ont pas des valeurs valides ; <see cref="P:System.IO.Ports.SerialPort.BaudRate" /> est inférieure ou égale à zéro ; la propriété <see cref="P:System.IO.Ports.SerialPort.ReadTimeout" /> ou <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> est inférieure à zéro et n'a pas la valeur <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ArgumentException">Le nom de port ne commence pas par "COM".  
  
ou 
Le type de fichier du port n'est pas pris en charge.</exception>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié sur l'instance actuelle du <see cref="T:System.IO.Ports.SerialPort" /> est déjà ouvert.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parity">
      <MemberSignature Language="C#" Value="public System.IO.Ports.Parity Parity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.Parity Parity" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.Parity" />
      <MemberSignature Language="VB.NET" Value="Public Property Parity As Parity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::Parity Parity { System::IO::Ports::Parity get(); void set(System::IO::Ports::Parity value); };" />
      <MemberSignature Language="F#" Value="member this.Parity : System.IO.Ports.Parity with get, set" Usage="System.IO.Ports.SerialPort.Parity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("Parity")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.Parity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le protocole de contrôle de parité.</summary>
        <value>Une des valeurs d'énumération qui représente le protocole de contrôle de parité. La valeur par défaut est <see cref="F:System.IO.Ports.Parity.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parité est une procédure de vérification des erreurs dans lequel le nombre de 1 doit toujours être le même - pair ou impair - pour chaque groupe de bits qui est transmis sans erreur. Dans les communications modem-modem, parité est souvent l’un des paramètres qui doivent être convenus par envoi de tiers et la réception de placer des parties avant de pouvoir effectuer la transmission.  
  
 Si une erreur de parité se produit sur l’octet de fin d’un flux, un octet supplémentaire sera ajouté à la mémoire tampon d’entrée avec une valeur de 126.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.Parity" /> passée n'est pas une valeur valide dans l'énumération <see cref="T:System.IO.Ports.Parity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ParityReplace">
      <MemberSignature Language="C#" Value="public byte ParityReplace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8 ParityReplace" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ParityReplace" />
      <MemberSignature Language="VB.NET" Value="Public Property ParityReplace As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Byte ParityReplace { System::Byte get(); void set(System::Byte value); };" />
      <MemberSignature Language="F#" Value="member this.ParityReplace : byte with get, set" Usage="System.IO.Ports.SerialPort.ParityReplace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(63)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ParityReplace")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'octet qui remplace les octets non valides dans un flux de données quand une erreur de parité se produit.</summary>
        <value>Octet qui remplace des octets non valides.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur est définie sur le caractère null, le remplacement de parité est désactivé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="PinChanged">
      <MemberSignature Language="C#" Value="public event System.IO.Ports.SerialPinChangedEventHandler PinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.IO.Ports.SerialPinChangedEventHandler PinChanged" />
      <MemberSignature Language="DocId" Value="E:System.IO.Ports.SerialPort.PinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PinChanged As SerialPinChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::IO::Ports::SerialPinChangedEventHandler ^ PinChanged;" />
      <MemberSignature Language="F#" Value="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " Usage="member this.PinChanged : System.IO.Ports.SerialPinChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("SerialPinChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.SerialPinChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique qu'un événement de signal non lié aux données s'est produit sur le port représenté par l'objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modification de la broche série événements peuvent être provoqués par les éléments dans le <xref:System.IO.Ports.SerialPinChange> énumération. Étant donné que le système d’exploitation détermine s’il faut déclencher cet événement ou non, pas toutes les erreurs de parité peuvent être signalées. Dans le cadre de l’événement, la nouvelle valeur de la marque est définie.  
  
 Le <xref:System.IO.Ports.SerialPort.PinChanged> événement est déclenché quand un <xref:System.IO.Ports.SerialPort> objet entre dans le <xref:System.IO.Ports.SerialPort.BreakState%2A>, mais pas lorsque le port sort le <xref:System.IO.Ports.SerialPort.BreakState%2A>. Ce comportement ne s’applique pas à d’autres valeurs dans le <xref:System.IO.Ports.SerialPinChange> énumération.  
  
 <xref:System.IO.Ports.SerialPort.PinChanged>, <xref:System.IO.Ports.SerialPort.DataReceived>, et <xref:System.IO.Ports.SerialPort.ErrorReceived> événements peuvent être appelés en désordre, et il peut y avoir un léger délai entre lorsque le flux sous-jacent signale l’erreur et lorsque le Gestionnaire d’événements est exécuté. Gestionnaire d’événements qu’une seule peut exécuter simultanément.  
  
 Le <xref:System.IO.Ports.SerialPort.PinChanged> événement est déclenché sur un thread secondaire. Étant donné que cet événement est déclenché sur un thread secondaire, et pas le thread principal, tente de modifier certains éléments dans le thread principal, tels que des éléments d’interface utilisateur, peut lever une exception de thread. S’il est nécessaire de modifier des éléments dans le principal <xref:System.Windows.Forms.Form> ou <xref:System.Windows.Forms.Control>, valider les demandes de modification à l’aide de <xref:System.Windows.Forms.Control.Invoke%2A>, qui effectuent l’opération sur le thread approprié.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PortName">
      <MemberSignature Language="C#" Value="public string PortName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PortName" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.PortName" />
      <MemberSignature Language="VB.NET" Value="Public Property PortName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PortName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PortName : string with get, set" Usage="System.IO.Ports.SerialPort.PortName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue("COM1")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("PortName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le port pour les communications, y compris mais non limité à tous les ports COM disponibles.</summary>
        <value>Port de communication. La valeur par défaut est COM1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une liste de noms de port valide peut être obtenue à l’aide de la <xref:System.IO.Ports.SerialPort.GetPortNames%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la propriété <see cref="P:System.IO.Ports.SerialPort.PortName" /> a une longueur de zéro.  
  
ou 
La propriété <see cref="P:System.IO.Ports.SerialPort.PortName" /> a été est définie sur une valeur qui commence par " \\\\ ".  
  
ou 
Le nom de port n'est pas valide.</exception>
        <exception cref="T:System.ArgumentNullException">La propriété <see cref="P:System.IO.Ports.SerialPort.PortName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié est ouvert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit la mémoire tampon d'entrée <see cref="T:System.IO.Ports.SerialPort" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : byte[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets dans lequel l'entrée doit être écrite.</param>
        <param name="offset">Offset dans <paramref name="buffer" /> où sont écrits les octets.</param>
        <param name="count">Nombre maximal d'octets à lire. Moins d'octets sont lus si <paramref name="count" /> est supérieur au nombre d'octets contenus dans le tampon d'entrée.</param>
        <summary>Lit un certain nombre d'octets de la mémoire tampon d'entrée <see cref="T:System.IO.Ports.SerialPort" /> et écrit ces octets dans un tableau d'octets au décalage spécifié.</summary>
        <returns>Nombre d'octets lus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
 Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre d’octets disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des octets à lire, mais ces octets est peut-être pas accessible dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 Le <xref:System.IO.Ports.SerialPort.Read%2A> méthode ne bloque pas les autres opérations lorsque le nombre d’octets lus est égal à `count` mais non lus octets sont disponibles sur le port série.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La mémoire tampon passée a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Les paramètres <paramref name="offset" /> ou <paramref name="count" /> sont à l'extérieur d'une région valide du <paramref name="buffer" /> qui est passé. <paramref name="offset" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> plus <paramref name="count" /> est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.TimeoutException">Aucun octet n'était disponible en lecture.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public int Read (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Read(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Read (buffer As Char(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Read(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Read : char[] * int * int -&gt; int" Usage="serialPort.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères dans lequel l'entrée doit être écrite.</param>
        <param name="offset">Offset dans <paramref name="buffer" /> où sont écrits les caractères.</param>
        <param name="count">Nombre maximal de caractères à lire. Moins de caractères sont lus si <paramref name="count" /> est supérieur au nombre de caractères contenus dans le tampon d'entrée.</param>
        <summary>Lit un certain nombre de caractères de la mémoire tampon d'entrée <see cref="T:System.IO.Ports.SerialPort" /> et écrit ces caractères dans un tableau de caractères à un décalage donné.</summary>
        <returns>Nombre de caractères à lire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire des caractères à partir du port série.  
  
 S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
 Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre de caractères disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des caractères à lire, mais ces caractères ne sont peut-être pas accessibles au flux contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 Le <xref:System.IO.Ports.SerialPort.Read%2A> méthode ne bloque pas les autres opérations lorsque le nombre d’octets lus est égal à `count` mais non lus octets sont disponibles sur le port série.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> plus <paramref name="count" /> est supérieur à la longueur de la mémoire tampon.  
  
ou 
 <paramref name="count" /> est égal à 1 et un caractère de substitution se trouve dans la mémoire tampon.</exception>
        <exception cref="T:System.ArgumentNullException">Le <paramref name="buffer" /> passé a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Les paramètres <paramref name="offset" /> ou <paramref name="count" /> sont à l'extérieur d'une région valide du <paramref name="buffer" /> qui est passé. <paramref name="offset" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.TimeoutException">Aucun caractère n'était disponible en lecture.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBufferSize">
      <MemberSignature Language="C#" Value="public int ReadBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.ReadBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(4096)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la mémoire tampon <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <value>Taille de la mémoire tampon en octets. La valeur par défaut est 4096 ; la valeur maximale est celle d'un entier positif ou 2147483647.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propriété ignore toute valeur inférieure à 4096.  
  
 Étant donné que le <xref:System.IO.Ports.SerialPort.ReadBufferSize%2A> propriété représente uniquement la mémoire tampon créée par Windows, elle peut retourner une valeur inférieure à celle la <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété, qui représente à la fois le <xref:System.IO.Ports.SerialPort> mémoires tampon et la création de Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> définie est inférieure ou égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> a été définie pendant que le flux était ouvert.</exception>
        <exception cref="T:System.IO.IOException">La propriété <see cref="P:System.IO.Ports.SerialPort.ReadBufferSize" /> a une valeur entière impaire.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadByte();" />
      <MemberSignature Language="F#" Value="member this.ReadByte : unit -&gt; int" Usage="serialPort.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon synchrone un octet de la mémoire tampon d'entrée <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Octet, converti en type (transtypage) <see cref="T:System.Int32" />, ou -1 si la fin du flux a été lue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit un octet.  
  
 Soyez prudent lorsque vous utilisez <xref:System.IO.Ports.SerialPort.ReadByte%2A> et <xref:System.IO.Ports.SerialPort.ReadChar%2A> ensemble. Basculement entre les octets et la lecture des caractères peut provoquer des données supplémentaires à lire et/ou un autre comportement inattendu. S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
> [!NOTE]
>  Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre d’octets disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des octets à lire, mais ces octets est peut-être pas accessible dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.  
  
ou 
Aucun octet n'a été lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadChar">
      <MemberSignature Language="C#" Value="public int ReadChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadChar" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChar () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChar();" />
      <MemberSignature Language="F#" Value="member this.ReadChar : unit -&gt; int" Usage="serialPort.ReadChar " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit de façon synchrone un caractère de la mémoire tampon d’entrée <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Caractère qui a été lu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit un caractère complet en fonction du codage.  
  
 Soyez prudent lorsque vous utilisez <xref:System.IO.Ports.SerialPort.ReadByte%2A> et <xref:System.IO.Ports.SerialPort.ReadChar%2A> ensemble. Basculement entre les octets et la lecture des caractères peut provoquer des données supplémentaires à lire et/ou un autre comportement inattendu. S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
> [!NOTE]
>  Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre d’octets disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des octets à lire, mais ces octets est peut-être pas accessible dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.  
  
ou 
Aucun caractère n'était disponible dans le délai d'attente imparti.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadExisting">
      <MemberSignature Language="C#" Value="public string ReadExisting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadExisting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadExisting" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadExisting () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadExisting();" />
      <MemberSignature Language="F#" Value="member this.ReadExisting : unit -&gt; string" Usage="serialPort.ReadExisting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit tous les octets immédiatement disponibles, en fonction de l'encodage, dans le flux et dans la mémoire tampon d'entrée de l'objet <see cref="T:System.IO.Ports.SerialPort" />.</summary>
        <returns>Contenu du flux et de la mémoire tampon d'entrée de l'objet <see cref="T:System.IO.Ports.SerialPort" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le contenu du flux et la mémoire tampon interne de le <xref:System.IO.Ports.SerialPort> objet sous forme de chaîne. Cette méthode n’utilise pas un délai d’attente. Notez que cette méthode peut laisser à la fin des octets de tête dans la mémoire tampon interne, ce qui rend le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> valeur supérieure à zéro.  
  
 S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
> [!NOTE]
>  Le <xref:System.IO.Ports.SerialPort> classe met les données, mais l’objet de flux de données contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A?displayProperty=nameWithType> n’est pas le cas de propriété. Par conséquent, le <xref:System.IO.Ports.SerialPort> objet et l’objet de flux peuvent différer sur le nombre d’octets à lire. Lorsque les octets sont mis en mémoire tampon pour le <xref:System.IO.Ports.SerialPort> objet, le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété inclut ces octets dans sa valeur ; Toutefois, ces octets peuvent ne pas accessibles dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="member this.ReadLine : unit -&gt; string" Usage="serialPort.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit jusqu'à la valeur <see cref="P:System.IO.Ports.SerialPort.NewLine" /> dans la mémoire tampon d'entrée.</summary>
        <returns>Contenu de la mémoire tampon d'entrée jusqu'à la première occurrence d'une valeur <see cref="P:System.IO.Ports.SerialPort.NewLine" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que bien que cette méthode ne retourne pas le <xref:System.IO.Ports.SerialPort.NewLine%2A> valeur, le <xref:System.IO.Ports.SerialPort.NewLine%2A> valeur est supprimée de la mémoire tampon d’entrée.  
  
 Par défaut, le <xref:System.IO.Ports.SerialPort.ReadLine%2A> méthode se bloque jusqu'à la réception d’une ligne. Si ce comportement est indésirable, définissez le <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propriété une valeur non nulle pour forcer la <xref:System.IO.Ports.SerialPort.ReadLine%2A> méthode lève un <xref:System.TimeoutException> si une ligne n’est pas disponible sur le port.  
  
 S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
> [!NOTE]
>  Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre d’octets disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des octets à lire, mais ces octets est peut-être pas accessible dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.  
  
ou 
Aucun octet n'a été lu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReadTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre de millisecondes avant un dépassement du délai d'attente quand une opération de lecture ne se termine pas.</summary>
        <value>Nombre de millisecondes avant un dépassement du délai d'attente quand une opération de lecture ne se termine pas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de délai d’attente de lecture a été définie à l’origine de 500 millisecondes dans l’API de Communications Win32. Cette propriété vous permet de définir cette valeur. Le délai d’attente peut être définie à n’importe quelle valeur supérieure à zéro, ou la valeur <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, auquel cas aucun délai d’attente se produit. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> est la valeur par défaut.  
  
> [!NOTE]
>  Les utilisateurs de non managé `COMMTIMEOUTS` structure peut s’attendent à configurer la valeur de délai d’attente à zéro pour supprimer des délais d’attente. Pour supprimer des délais d’attente avec le <xref:System.IO.Ports.SerialPort.ReadTimeout%2A> propriété, toutefois, vous devez spécifier <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Cette propriété n’affecte pas la <xref:System.IO.Stream.BeginRead%2A> méthode du flux retourné par la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur du délai d'attente de lecture est inférieure à zéro et différente de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadTo">
      <MemberSignature Language="C#" Value="public string ReadTo (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ReadTo(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.ReadTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadTo (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ReadTo(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.ReadTo : string -&gt; string" Usage="serialPort.ReadTo value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valeur qui indique où l'opération de lecture s'arrête.</param>
        <summary>Lit une chaîne jusqu'à la valeur <paramref name="value" /> spécifiée dans la mémoire tampon d'entrée.</summary>
        <returns>Contenu de la mémoire tampon d'entrée jusqu'à l'élément <paramref name="value" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode lit une chaîne jusqu'à spécifié `value`. Bien que la chaîne retournée n’inclut pas le `value`, le `value` est supprimé de la mémoire tampon d’entrée.  
  
 S’il est nécessaire de basculer entre le texte et la lecture des données binaires à partir du flux, sélectionnez un protocole qui définit avec précision la limite entre les données texte et binaires, tels que la lecture des octets et le décodage des données manuellement.  
  
> [!NOTE]
>  Étant donné que le <xref:System.IO.Ports.SerialPort> classe met les données et le flux de données contenues dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> n’est pas le cas de propriété, les deux peuvent entrer en conflit sur le nombre d’octets disponible à lire.  Le <xref:System.IO.Ports.SerialPort.BytesToRead%2A> propriété peut indiquer qu’il existe des octets à lire, mais ces octets est peut-être pas accessible dans le flux de contenu dans le <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété, car ils ont été mis en mémoire tampon pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La longueur du paramètre <paramref name="value" /> est égale à 0.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceivedBytesThreshold">
      <MemberSignature Language="C#" Value="public int ReceivedBytesThreshold { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceivedBytesThreshold" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceivedBytesThreshold As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceivedBytesThreshold { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceivedBytesThreshold : int with get, set" Usage="System.IO.Ports.SerialPort.ReceivedBytesThreshold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ReceivedBytesThreshold")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre d'octets dans la mémoire tampon d'entrée interne avant qu'un événement <see cref="E:System.IO.Ports.SerialPort.DataReceived" /> ne se produise.</summary>
        <value>Nombre d'octets dans la mémoire tampon d'entrée interne avant qu'un événement <see cref="E:System.IO.Ports.SerialPort.DataReceived" /> ne soit déclenché. La valeur par défaut est 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Ports.SerialPort.DataReceived> est également déclenché si un <xref:System.IO.Ports.SerialData.Eof> caractère est reçu, quel que soit le nombre d’octets dans la mémoire tampon d’entrée interne et la valeur de la <xref:System.IO.Ports.SerialPort.ReceivedBytesThreshold%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.ReceivedBytesThreshold" /> est inférieure ou égale à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="RtsEnable">
      <MemberSignature Language="C#" Value="public bool RtsEnable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RtsEnable" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.RtsEnable" />
      <MemberSignature Language="VB.NET" Value="Public Property RtsEnable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RtsEnable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RtsEnable : bool with get, set" Usage="System.IO.Ports.SerialPort.RtsEnable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("RtsEnable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le signal RTS (Request to Send) est activé lors d'une communication série.</summary>
        <value><see langword="true" /> pour activer le signal RTS ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La demande de signal de transmission (RTS) est généralement utilisée dans la demande d’envoi/invite à envoyer le protocole de transfert matériel RTS/CTS ().  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La valeur de la propriété <see cref="P:System.IO.Ports.SerialPort.RtsEnable" /> a été définie ou récupérée alors que la propriété <see cref="P:System.IO.Ports.SerialPort.Handshake" /> a la valeur <see cref="F:System.IO.Ports.Handshake.RequestToSend" /> ou <see cref="F:System.IO.Ports.Handshake.RequestToSendXOnXOff" />.</exception>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <Member MemberName="StopBits">
      <MemberSignature Language="C#" Value="public System.IO.Ports.StopBits StopBits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Ports.StopBits StopBits" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.StopBits" />
      <MemberSignature Language="VB.NET" Value="Public Property StopBits As StopBits" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Ports::StopBits StopBits { System::IO::Ports::StopBits get(); void set(System::IO::Ports::StopBits value); };" />
      <MemberSignature Language="F#" Value="member this.StopBits : System.IO.Ports.StopBits with get, set" Usage="System.IO.Ports.SerialPort.StopBits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("StopBits")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Ports.StopBits</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre standard de bits d'arrêt par octet.</summary>
        <value>Une des valeurs de <see cref="T:System.IO.Ports.StopBits" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut de <xref:System.IO.Ports.SerialPort.StopBits%2A> est <xref:System.IO.Ports.StopBits.One>.  
  
 Le <xref:System.IO.Ports.StopBits.None?displayProperty=nameWithType> valeur n’est pas prise en charge.  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.IO.Ports.SerialPort.StopBits%2A> propriété `One`.  
  
 [!code-cpp[System.IO.Ports.SerialPort#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/datareceived.cpp#20)]
 [!code-csharp[System.IO.Ports.SerialPort#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/datareceived.cs#20)]
 [!code-vb[System.IO.Ports.SerialPort#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/datareceived.vb#20)]  
  
 L’exemple suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un exemple plus complet fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.StopBits" /> est <see cref="F:System.IO.Ports.StopBits.None" />.</exception>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les données dans la mémoire tampon de sortie du port série.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public void Write (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="serialPort.Write str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Chaîne de sortie.</param>
        <param name="str">To be added.</param>
        <summary>Écrit la chaîne spécifiée sur le port série.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque vous souhaitez écrire une chaîne en tant que sortie à un port série.  
  
 S’il n’y a trop grand nombre d’octets dans le tampon de sortie et <xref:System.IO.Ports.SerialPort.Handshake%2A> a la valeur <xref:System.IO.Ports.Handshake.XOnXOff> le <xref:System.IO.Ports.SerialPort> objet peut déclencher un <xref:System.ServiceProcess.TimeoutException> en attendant que l’appareil soit prêt à accepter plus de données.  
  
 Par défaut, <xref:System.IO.Ports.SerialPort> utilise <xref:System.Text.ASCIIEncoding> pour encoder les caractères. <xref:System.Text.ASCIIEncoding> encode tous les caractères supérieurs à 127 comme (char) 63 ou ' ?'. Pour prendre en charge des caractères supplémentaires dans cette plage, définissez <xref:System.IO.Ports.SerialPort.Encoding%2A> à <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, ou <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="text" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : byte[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau d'octets qui contient les données à écrire sur le port.</param>
        <param name="offset">Dans le paramètre <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer la copie des octets vers le port.</param>
        <param name="count">Nombre d'octets à écrire.</param>
        <summary>Écrit un nombre spécifié d'octets sur le port série en utilisant les données d'une mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque vous souhaitez écrire dans une mémoire tampon d’octets pour créer une sortie à un port série.  
  
 S’il n’y a trop grand nombre d’octets dans le tampon de sortie et <xref:System.IO.Ports.SerialPort.Handshake%2A> a la valeur <xref:System.IO.Ports.Handshake.XOnXOff> le <xref:System.IO.Ports.SerialPort> objet peut déclencher un <xref:System.ServiceProcess.TimeoutException> en attendant que l’appareil soit prêt à accepter plus de données.  
  
 Par défaut, <xref:System.IO.Ports.SerialPort> utilise <xref:System.Text.ASCIIEncoding> pour encoder les caractères. <xref:System.Text.ASCIIEncoding> encode tous les caractères supérieurs à 127 comme (char) 63 ou ' ?'. Pour prendre en charge des caractères supplémentaires dans cette plage, définissez <xref:System.IO.Ports.SerialPort.Encoding%2A> à <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, ou <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <paramref name="buffer" /> passé a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Les paramètres <paramref name="offset" /> ou <paramref name="count" /> sont à l'extérieur d'une région valide du <paramref name="buffer" /> qui est passé. <paramref name="offset" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> plus <paramref name="count" /> est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.Write : char[] * int * int -&gt; unit" Usage="serialPort.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères qui contient les données à écrire sur le port.</param>
        <param name="offset">Dans le paramètre <paramref name="buffer" />, décalage d'octet de base zéro auquel commencer la copie des octets vers le port.</param>
        <param name="count">Nombre de caractères à écrire.</param>
        <summary>Écrit un nombre spécifié de caractères sur le port série en utilisant les données d'une mémoire tampon.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode lorsque vous souhaitez écrire dans une mémoire tampon de caractères pour créer une sortie à un port série.  
  
 S’il n’y a trop grand nombre d’octets dans le tampon de sortie et <xref:System.IO.Ports.SerialPort.Handshake%2A> a la valeur <xref:System.IO.Ports.Handshake.XOnXOff> le <xref:System.IO.Ports.SerialPort> objet peut déclencher un <xref:System.ServiceProcess.TimeoutException> en attendant que l’appareil soit prêt à accepter plus de données.  
  
 Par défaut, <xref:System.IO.Ports.SerialPort> utilise <xref:System.Text.ASCIIEncoding> pour encoder les caractères. <xref:System.Text.ASCIIEncoding> encode tous les caractères supérieurs à 127 comme (char) 63 ou ' ?'. Pour prendre en charge des caractères supplémentaires dans cette plage, définissez <xref:System.IO.Ports.SerialPort.Encoding%2A> à <xref:System.Text.UTF8Encoding>, <xref:System.Text.UTF32Encoding>, ou <xref:System.Text.UnicodeEncoding>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le <paramref name="buffer" /> passé a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Les paramètres <paramref name="offset" /> ou <paramref name="count" /> sont à l'extérieur d'une région valide du <paramref name="buffer" /> qui est passé. <paramref name="offset" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="offset" /> plus <paramref name="count" /> est supérieur à la longueur de <paramref name="buffer" />.</exception>
        <exception cref="T:System.ServiceProcess.TimeoutException">L'opération ne s'est pas terminée avant la fin du délai d'attente.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteBufferSize">
      <MemberSignature Language="C#" Value="public int WriteBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteBufferSize : int with get, set" Usage="System.IO.Ports.SerialPort.WriteBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(2048)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteBufferSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la mémoire tampon de sortie du port série.</summary>
        <value>Taille de la mémoire tampon de sortie. La valeur par défaut est 2048.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.IO.Ports.SerialPort.WriteBufferSize%2A> propriété ignore toute valeur inférieure à 2048.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> est inférieure ou égale à zéro.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> a été définie pendant que le flux était ouvert.</exception>
        <exception cref="T:System.IO.IOException">La propriété <see cref="P:System.IO.Ports.SerialPort.WriteBufferSize" /> a une valeur entière impaire.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public void WriteLine (string text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string text) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (text As String)" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ text);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public void WriteLine (string str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteLine(string str) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (str As String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteLine(System::String ^ str);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IO.Ports.SerialPort.WriteLine(System.String)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.WriteLine : string -&gt; unit" Usage="serialPort.WriteLine str" FrameworkAlternate="xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="text">Chaîne à écrire dans la mémoire tampon de sortie.</param>
        <param name="str">To be added.</param>
        <summary>Écrit la chaîne spécifiée et la valeur <see cref="P:System.IO.Ports.SerialPort.NewLine" /> dans la mémoire tampon de sortie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe trop d’octets dans le tampon d’entrée et <xref:System.IO.Ports.SerialPort.Handshake%2A> a la valeur <xref:System.IO.Ports.Handshake.XOnXOff> le <xref:System.IO.Ports.SerialPort> objet peut déclencher un <xref:System.ServiceProcess.TimeoutException> en attendant que l’appareil soit prêt à accepter plus de données.  
  
 La sortie écrite inclut le <xref:System.IO.Ports.SerialPort.NewLine%2A> chaîne.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="text" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le port spécifié n'est pas ouvert.</exception>
        <exception cref="T:System.TimeoutException">La méthode <see cref="M:System.IO.Ports.SerialPort.WriteLine(System.String)" /> n'a pas pu écrire dans le flux.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WriteTimeout : int with get, set" Usage="System.IO.Ports.SerialPort.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Ports</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("WriteTimeout")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre de millisecondes avant qu'un dépassement du délai d'attente se produise quand une opération d'écriture ne se termine pas.</summary>
        <value>Nombre de millisecondes avant qu'un dépassement du délai d'attente se produise. La valeur par défaut est <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de délai d’attente d’écriture a été définie à l’origine de 500 millisecondes dans l’API de Communications Win32. Cette propriété vous permet de définir cette valeur. Le délai d’attente peut être définie à n’importe quelle valeur supérieure à zéro, ou la valeur <xref:System.IO.Ports.SerialPort.InfiniteTimeout>, auquel cas aucun délai d’attente se produit. <xref:System.IO.Ports.SerialPort.InfiniteTimeout> est la valeur par défaut.  
  
> [!NOTE]
>  Les utilisateurs de non managé `COMMTIMEOUTS` structure peut s’attendent à configurer la valeur de délai d’attente à zéro pour supprimer des délais d’attente. Pour supprimer des délais d’attente avec le <xref:System.IO.Ports.SerialPort.WriteTimeout%2A> propriété, toutefois, vous devez spécifier <xref:System.IO.Ports.SerialPort.InfiniteTimeout>.  
  
 Cette propriété n’affecte pas la <xref:System.IO.Stream.BeginWrite%2A> méthode du flux retourné par la <xref:System.IO.Ports.SerialPort.BaseStream%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.IO.Ports.SerialPort> classe pour permettre aux utilisateurs de deux à discuter à partir de deux ordinateurs distincts reliés par un câble null modem. Dans cet exemple, les utilisateurs sont invités pour les paramètres de port et un nom d’utilisateur avant de la conversation. Cet exemple de code fait partie d’un plus grand exemple fourni pour la <xref:System.IO.Ports.SerialPort> classe.  
  
 [!code-cpp[System.IO.Ports.SerialPort#01](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cpp/serialport.cpp#01)]
 [!code-csharp[System.IO.Ports.SerialPort#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/cs/SerialPort.cs#01)]
 [!code-vb[System.IO.Ports.SerialPort#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Ports.SerialPort/vb/SerialPort.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">L'état du port n'est pas valide.  
  
ou 
Une tentative de définition de l'état du port sous-jacent a échoué. Par exemple, les paramètres passés de cet objet <see cref="T:System.IO.Ports.SerialPort" /> n'étaient pas valides.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur <see cref="P:System.IO.Ports.SerialPort.WriteTimeout" /> est inférieure à zéro et différente de <see cref="F:System.IO.Ports.SerialPort.InfiniteTimeout" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>