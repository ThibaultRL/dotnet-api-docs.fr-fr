<Type Name="ZipArchive" FullName="System.IO.Compression.ZipArchive">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="44700288efa40a62dcfb905b8498c969824ffaee" />
    <Meta Name="ms.sourcegitcommit" Value="e1a67db2e206daee8a9e2370b6cda8b921644a0a" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="09/19/2018" />
    <Meta Name="ms.locfileid" Value="46321677" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ZipArchive : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ZipArchive extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Compression.ZipArchive" />
  <TypeSignature Language="VB.NET" Value="Public Class ZipArchive&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ZipArchive : IDisposable" />
  <TypeSignature Language="F#" Value="type ZipArchive = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Compression</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Représente un package de fichiers compressés au format d'archivage zip.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les méthodes permettant de manipuler des archives zip et leurs entrées de fichier sont réparties sur trois classes : <xref:System.IO.Compression.ZipFile>, <xref:System.IO.Compression.ZipArchive>, et <xref:System.IO.Compression.ZipArchiveEntry>.  
  
|À|Utilisez|  
|--------|---------|  
|Créer une archive zip à partir d’un répertoire|<xref:System.IO.Compression.ZipFile.CreateFromDirectory%2A?displayProperty=nameWithType>|  
|Extraire le contenu d’une archive zip dans un répertoire|<xref:System.IO.Compression.ZipFile.ExtractToDirectory%2A?displayProperty=nameWithType>|  
|Ajoutez de nouveaux fichiers dans une archive zip existant|<xref:System.IO.Compression.ZipArchive.CreateEntry%2A?displayProperty=nameWithType>|  
|Récupérer un fichier à partir d’une archive zip|<xref:System.IO.Compression.ZipArchive.GetEntry%2A?displayProperty=nameWithType>|  
|Récupérer tous les fichiers à partir d’une archive zip|<xref:System.IO.Compression.ZipArchive.Entries%2A?displayProperty=nameWithType>|  
|Ouvrir un flux de données dans un fichier unique contenu dans une archive zip|<xref:System.IO.Compression.ZipArchiveEntry.Open%2A?displayProperty=nameWithType>|  
|Supprimer un fichier à partir d’une archive zip|<xref:System.IO.Compression.ZipArchiveEntry.Delete%2A?displayProperty=nameWithType>|  
  
 Lorsque vous créez une nouvelle entrée, le fichier est compressé et ajouté au package zip. Le <xref:System.IO.Compression.ZipArchive.CreateEntry%2A> méthode vous permet de spécifier une hiérarchie de répertoires lors de l’ajout de l’entrée. Vous incluez le chemin d’accès relatif de la nouvelle entrée dans le fichier zip. Par exemple, créez une nouvelle entrée avec un chemin d’accès relatif `AddedFolder\NewFile.txt` crée un fichier texte compressé dans un répertoire nommé AddedFolder.  
  
 Si vous référencez le `System.IO.Compression.FileSystem` assembly dans votre projet, vous pouvez accéder aux trois méthodes d’extension (à partir de la <xref:System.IO.Compression.ZipFileExtensions> classe) pour le <xref:System.IO.Compression.ZipArchive> classe : <xref:System.IO.Compression.ZipFileExtensions.CreateEntryFromFile%2A>, <xref:System.IO.Compression.ZipFileExtensions.CreateEntryFromFile%2A>, et <xref:System.IO.Compression.ZipFileExtensions.ExtractToDirectory%2A>. Ces méthodes d’extension permettent de compresser et décompresser le contenu de l’entrée à un fichier. Le `System.IO.Compression.FileSystem` assembly n’est pas disponible pour [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, vous pouvez compresser et décompresser les fichiers à l’aide de la <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream> classe, ou vous pouvez utiliser la [!INCLUDE[wrt](~/includes/wrt-md.md)] types [compresseurs](http://go.microsoft.com/fwlink/p/?LinkID=246357) et [décompresseur](http://go.microsoft.com/fwlink/p/?LinkID=246358).  
  
   
  
## Examples  
 Le premier exemple montre comment créer une nouvelle entrée et en écriture à ce dernier à l’aide d’un flux de données.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program1.vb#1)]  
  
 L’exemple suivant montre comment ouvrir une archive zip et effectuer une itération dans la collection d’entrées.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program1.vb#1)]  
  
 Le troisième exemple montre comment utiliser les méthodes d’extension pour créer une nouvelle entrée dans une archive zip à partir d’un fichier existant et extraire le contenu de l’archive. Vous devez référencer le `System.IO.Compression.FileSystem` assembly à exécuter le code.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program3.cs#3)]
 [!code-vb[System.IO.Compression.ZipArchive#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program3.vb#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IO.Compression.ZipFile" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Compression.ZipArchive" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux qui contient l'archive à lire.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Compression.ZipArchive" /> à partir du flux spécifié.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le flux ne prend pas en charge l’écriture ou bien il est déjà fermé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.InvalidDataException">Le contenu du flux de données n’est pas au format d’archivage ZIP.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de sortie ou d'entrée.</param>
        <param name="mode">Une des valeurs d'énumération qui indique si l'archive zip est utilisée pour lire, créer ou mettre à jour des entrées.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Compression.ZipArchive" /> à partir du flux spécifié et avec le mode spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Read>, le flux doit prendre en charge la lecture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Create>, le flux doit prendre en charge écriture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Update>, le flux doit prendre en charge lecture, écriture et la recherche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le flux de données est déjà fermé, ou les fonctions du flux de données ne correspondent pas au mode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.IO.InvalidDataException">Le contenu du flux de données n’a pas pu être interprété comme une archive ZIP.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et l’entrée est manquante dans l’archive, ou est endommagée et ne peut pas être lue.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et une entrée est trop grande pour être contenue dans la mémoire.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode * bool -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de sortie ou d'entrée.</param>
        <param name="mode">Une des valeurs d'énumération qui indique si l'archive zip est utilisée pour lire, créer ou mettre à jour des entrées.</param>
        <param name="leaveOpen">
          <see langword="true" /> pour maintenir le flux ouvert après avoir supprimé l'objet <see cref="T:System.IO.Compression.ZipArchive" /> ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Compression.ZipArchive" /> sur le flux de données spécifié pour le mode spécifié, et laisse éventuellement le flux ouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Read>, le flux doit prendre en charge la lecture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Create>, le flux doit prendre en charge écriture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Update>, le flux doit prendre en charge lecture, écriture et la recherche.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le flux de données est déjà fermé, ou les fonctions du flux de données ne correspondent pas au mode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.IO.InvalidDataException">Le contenu du flux de données n’a pas pu être interprété comme une archive ZIP.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et l’entrée est manquante dans l’archive, ou est endommagée et ne peut pas être lue.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et une entrée est trop grande pour être contenue dans la mémoire.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ZipArchive (System.IO.Stream stream, System.IO.Compression.ZipArchiveMode mode, bool leaveOpen, System.Text.Encoding entryNameEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, valuetype System.IO.Compression.ZipArchiveMode mode, bool leaveOpen, class System.Text.Encoding entryNameEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.#ctor(System.IO.Stream,System.IO.Compression.ZipArchiveMode,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ZipArchive(System::IO::Stream ^ stream, System::IO::Compression::ZipArchiveMode mode, bool leaveOpen, System::Text::Encoding ^ entryNameEncoding);" />
      <MemberSignature Language="F#" Value="new System.IO.Compression.ZipArchive : System.IO.Stream * System.IO.Compression.ZipArchiveMode * bool * System.Text.Encoding -&gt; System.IO.Compression.ZipArchive" Usage="new System.IO.Compression.ZipArchive (stream, mode, leaveOpen, entryNameEncoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de sortie ou d'entrée.</param>
        <param name="mode">Une des valeurs d'énumération qui indique si l'archive zip est utilisée pour lire, créer ou mettre à jour des entrées.</param>
        <param name="leaveOpen">
          <see langword="true" /> pour maintenir le flux ouvert après avoir supprimé l'objet <see cref="T:System.IO.Compression.ZipArchive" /> ; sinon, <see langword="false" />.</param>
        <param name="entryNameEncoding">Encodage à utiliser lors de la lecture ou de l'écriture des noms d'entrée dans cette archive. Spécifie une valeur pour ce paramètre seulement quand un encodage est obligatoire pour l'interopérabilité avec les outils et les bibliothèques d'archivage zip qui ne prennent pas en charge l'encodage UTF-8 pour les noms d'entrée.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Compression.ZipArchive" /> sur le flux spécifié pour le mode spécifié, utilise l’encodage spécifié pour les noms d’entrée, et permet éventuellement de laisser le flux ouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Read>, le flux doit prendre en charge la lecture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Create>, le flux doit prendre en charge écriture. Si le `mode` paramètre est défini sur <xref:System.IO.Compression.ZipArchiveMode.Update>, le flux doit prendre en charge lecture, écriture et la recherche.  
  
 Lorsque vous ouvrez un fichier d’archive zip pour la lecture et `entryNameEncoding` a la valeur `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Lorsque le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) n’est pas défini, la page de codes système par défaut actuel est utilisée pour décoder le nom d’entrée.  
  
-   Lorsque l’indicateur d’encodage linguistique est définie, UTF-8 est utilisé pour décoder le nom d’entrée.  
  
 Lorsque vous ouvrez un fichier d’archive zip pour la lecture et `entryNameEncoding` est défini sur une valeur autre que `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Lorsque le code d’indicateur de langue n'est pas défini, le texte spécifié `entryNameEncoding` est utilisé pour décoder le nom d’entrée.  
  
-   Lorsque l’indicateur d’encodage linguistique est définie, UTF-8 est utilisé pour décoder le nom d’entrée.  
  
 Lorsque vous écrivez archiver des fichiers et `entryNameEncoding` a la valeur `null`, noms d’entrée sont encodées selon les règles suivantes :  
  
-   Pour les noms d’entrée qui contiennent des caractères en dehors de la plage ASCII, l’indicateur d’encodage linguistique est défini et noms d’entrée sont encodés en UTF-8.  
  
-   Pour les noms d’entrée qui contiennent uniquement des caractères ASCII, l’indicateur d’encodage de langue n’est pas défini et noms d’entrée sont encodés à l’aide de la page de codes système par défaut actuel.  
  
 Lorsque vous écrivez archiver des fichiers et `entryNameEncoding` est défini sur une valeur autre que `null`, spécifié `entryNameEncoding` est utilisé pour encoder les noms d’entrée en octets. Le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) est défini uniquement lorsque l’encodage spécifié est un encodage UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le flux de données est déjà fermé, ou les fonctions du flux de données ne correspondent pas au mode.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> n’est pas une valeur valide.</exception>
        <exception cref="T:System.IO.InvalidDataException">Le contenu du flux de données n’a pas pu être interprété comme une archive ZIP.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et l’entrée est manquante dans l’archive, ou est endommagée et ne peut pas être lue.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" /> et une entrée est trop grande pour être contenue dans la mémoire.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEntry">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une entrée vide dans l'archive zip.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry CreateEntry (string entryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry CreateEntry(string entryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.CreateEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateEntry (entryName As String) As ZipArchiveEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ CreateEntry(System::String ^ entryName);" />
      <MemberSignature Language="F#" Value="member this.CreateEntry : string -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.CreateEntry entryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entryName">Chemin d’accès relatif à la racine de l’archive, qui spécifie le nom de l’entrée à créer.</param>
        <summary>Crée une entrée vide qui a le chemin d’accès et le nom d’entrée spécifiés dans l’archive zip.</summary>
        <returns>Entrée vide dans l'archive zip.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `entryName` chaîne doit refléter le chemin d’accès relatif de l’entrée que vous souhaitez créer dans l’archive zip. Il n’existe aucune restriction sur la chaîne que vous fournissez. Toutefois, si elle n’est pas mise en forme comme un chemin d’accès relatif, l’entrée est créée, mais vous pouvez obtenir une exception lorsque vous extrayez le contenu de l’archive zip. Si une entrée avec le nom et le chemin d’accès spécifié existe déjà dans l’archive, une deuxième entrée est créée avec le même chemin d’accès et le même nom.  
  
 La valeur de la <xref:System.IO.Compression.ZipArchiveEntry.LastWriteTime%2A> propriété pour la nouvelle entrée est définie sur l’heure actuelle. L’entrée est compressée à l’aide du niveau de compression par défaut de l’algorithme de compression sous-jacente. Si vous souhaitez spécifier un niveau de compression différent, utilisez la <xref:System.IO.Compression.ZipArchive.CreateEntry%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une entrée et en écriture à ce dernier à l’aide d’un flux de données.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="entryName" /> est <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’archive zip ne prend pas en charge l’écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">L’archive zip de a été supprimée.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry CreateEntry (string entryName, System.IO.Compression.CompressionLevel compressionLevel);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry CreateEntry(string entryName, valuetype System.IO.Compression.CompressionLevel compressionLevel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.CreateEntry(System.String,System.IO.Compression.CompressionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ CreateEntry(System::String ^ entryName, System::IO::Compression::CompressionLevel compressionLevel);" />
      <MemberSignature Language="F#" Value="member this.CreateEntry : string * System.IO.Compression.CompressionLevel -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.CreateEntry (entryName, compressionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" />
      </Parameters>
      <Docs>
        <param name="entryName">Chemin d’accès relatif à la racine de l’archive, qui spécifie le nom de l’entrée à créer.</param>
        <param name="compressionLevel">Une des valeurs d'énumération qui indique s'il faut privilégier la rapidité ou l'efficacité de la compression lors de la création de l'entrée.</param>
        <summary>Crée une entrée vide qui a le nom d'entrée et le niveau de compression spécifiés dans l'archive zip.</summary>
        <returns>Entrée vide dans l'archive zip.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `entryName` chaîne doit refléter le chemin d’accès relatif de l’entrée que vous souhaitez créer dans l’archive zip. Il n’existe aucune restriction sur la chaîne que vous fournissez. Toutefois, si elle n’est pas mise en forme comme un chemin d’accès relatif, l’entrée est créée, mais vous pouvez obtenir une exception lorsque vous extrayez le contenu de l’archive zip. Si une entrée avec le nom spécifié existe déjà dans l’archive, une deuxième entrée est créée avec le même nom.  
  
 La valeur de la <xref:System.IO.Compression.ZipArchiveEntry.LastWriteTime%2A> propriété pour la nouvelle entrée est définie sur l’heure actuelle. Définir le `compressionLevel` paramètre <xref:System.IO.Compression.CompressionLevel.Optimal> si vous souhaitez que le fichier doit être compressé autant que possible. Définir le `compressionLevel` paramètre <xref:System.IO.Compression.CompressionLevel.Fastest> uniquement si vous craignez que l’opération de compression se terminera pas assez rapidement pour votre scénario.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer une entrée avec le niveau de compression optimale. Elle écrit également à la nouvelle entrée à l’aide d’un flux de données.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveMode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.ZipArchiveMode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchivemode/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="entryName" /> est <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’archive zip ne prend pas en charge l’écriture.</exception>
        <exception cref="T:System.ObjectDisposedException">L’archive zip de a été supprimée.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'objet <see cref="T:System.IO.Compression.ZipArchive" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="zipArchive.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.IO.Compression.ZipArchive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode finit d’écrire l’archive et libère toutes les ressources utilisées par le <xref:System.IO.Compression.ZipArchive> objet. Sauf si vous construisez l’objet à l’aide de la <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> surcharge de constructeur et définissez son `leaveOpen` paramètre à `true`, tous les flux sous-jacents sont fermées et ne sont plus disponibles pour les opérations suivantes d’écriture.  
  
 Lorsque vous avez terminé à l’aide de cette instance de <xref:System.IO.Compression.ZipArchive>, appelez <xref:System.IO.Compression.ZipArchive.Dispose> pour libérer toutes les ressources utilisées par cette instance. Vous devez supprimer les références à ce <xref:System.IO.Compression.ZipArchive> afin que le garbage collector puisse récupérer la mémoire de l’instance au lieu de garder actif pour la finalisation de l’instance.  
  
 <xref:System.IO.Compression.ZipArchive.Dispose> appelle le <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> (méthode), qui contient le code pour libérer les ressources managées et non managées. Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="zipArchive.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour finir l’écriture de l’archive et libérer les ressources managées et non managées ; <see langword="false" /> pour libérer seulement des ressources non managées.</param>
        <summary>Appelée par les méthodes <see cref="M:System.IO.Compression.ZipArchive.Dispose" /> et <see cref="M:System.Object.Finalize" /> pour libérer les ressources non managées utilisées par l’instance actuelle de la classe <see cref="T:System.IO.Compression.ZipArchive" />, et éventuellement finit d’écrire l’archive et libère les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `disposing` a la valeur `true`, tous les flux sous-jacents sont fermées et ne sont plus disponibles pour les opérations d’écriture consécutive, sauf si vous construisez l’objet à l’aide de la <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> surcharge de constructeur et définissez son `leaveOpen` paramètre `true`.  
  
 Cette méthode est appelée uniquement par le public <xref:System.IO.Compression.ZipArchive.Dispose> et <xref:System.Object.Finalize> méthodes ; n’appelez pas cette méthode directement.  
  
 Lorsque vous implémentez le modèle de suppression, le paramètre booléen de la <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> méthode doit être utilisée comme suit :  
  
-   Le <xref:System.IO.Compression.ZipArchive.Dispose> méthode de l’objet actuel doit appeler <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> avec le paramètre booléen défini sur `true` pour libérer les ressources managées et non managées.  
  
-   Le <xref:System.Object.Finalize> méthode de l’objet actuel doit appeler <xref:System.IO.Compression.ZipArchive.Dispose%28System.Boolean%29> avec le paramètre booléen défini sur `false` pour libérer uniquement les ressources non managées.
  
 Pour plus d’informations, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt; Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IO.Compression.ZipArchiveEntry&gt; Entries" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.ZipArchive.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As ReadOnlyCollection(Of ZipArchiveEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::Compression::ZipArchiveEntry ^&gt; ^ Entries { System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IO::Compression::ZipArchiveEntry ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt;" Usage="System.IO.Compression.ZipArchive.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IO.Compression.ZipArchiveEntry&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection d’entrées figurant actuellement dans l’archive zip.</summary>
        <value>Collection d’entrées figurant actuellement dans l’archive zip.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.IO.Compression.ZipArchive.Entries%2A> propriété à récupérer de la collection entière d’entrées. Utilisez le <xref:System.IO.Compression.ZipArchive.GetEntry%2A> méthode pour récupérer une seule entrée par nom.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une archive zip et effectuer une itération dans la collection d’entrées.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’archive ZIP ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">L’archive zip de a été supprimée.</exception>
        <exception cref="T:System.IO.InvalidDataException">L’archive ZIP est endommagée et ses entrées ne peuvent pas être récupérées.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEntry">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveEntry GetEntry (string entryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Compression.ZipArchiveEntry GetEntry(string entryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipArchive.GetEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEntry (entryName As String) As ZipArchiveEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::Compression::ZipArchiveEntry ^ GetEntry(System::String ^ entryName);" />
      <MemberSignature Language="F#" Value="member this.GetEntry : string -&gt; System.IO.Compression.ZipArchiveEntry" Usage="zipArchive.GetEntry entryName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="entryName">Chemin d’accès relatif à la racine de l’archive, qui identifie l’entrée à récupérer.</param>
        <summary>Récupère un wrapper pour l'entrée spécifiée dans l'archive zip.</summary>
        <returns>Wrapper pour l’entrée spécifiée dans l’archive ; <see langword="null" /> si l’entrée n’existe pas dans l’archive.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si plusieurs entrées portant le nom spécifié existent dans l’archive, la première est renvoyée. Le nom de l’entrée est comparé à `entryName` à l’aide de la comparaison ordinale.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.IO.Compression.ZipArchive.GetEntry%2A> méthode pour récupérer une entrée.  
  
 [!code-csharp[System.IO.Compression.ZipArchiveEntry#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchiveentry/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.ZipArchiveEntry#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchiveentry/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="entryName" /> est <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="entryName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’archive ZIP ne prend pas en charge la lecture.</exception>
        <exception cref="T:System.ObjectDisposedException">L’archive zip de a été supprimée.</exception>
        <exception cref="T:System.IO.InvalidDataException">L’archive ZIP est endommagée et ses entrées ne peuvent pas être récupérées.</exception>
      </Docs>
    </Member>
    <Member MemberName="Mode">
      <MemberSignature Language="C#" Value="public System.IO.Compression.ZipArchiveMode Mode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.Compression.ZipArchiveMode Mode" />
      <MemberSignature Language="DocId" Value="P:System.IO.Compression.ZipArchive.Mode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mode As ZipArchiveMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Compression::ZipArchiveMode Mode { System::IO::Compression::ZipArchiveMode get(); };" />
      <MemberSignature Language="F#" Value="member this.Mode : System.IO.Compression.ZipArchiveMode" Usage="System.IO.Compression.ZipArchive.Mode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchiveMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui décrit le type d'action que l'archive zip peut effectuer sur des entrées.</summary>
        <value>Une des valeurs d'énumération qui décrit le type d'action (lecture, création ou mise à jour) que l'archive zip peut effectuer sur les entrées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous spécifiez une valeur pour le <xref:System.IO.Compression.ZipArchive> propriété lorsque vous créez une instance de la <xref:System.IO.Compression.ZipArchive> classe. Utilisez le <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%29> ou <xref:System.IO.Compression.ZipArchive.%23ctor%28System.IO.Stream%2CSystem.IO.Compression.ZipArchiveMode%2CSystem.Boolean%29> constructeur pour fournir une valeur pour le <xref:System.IO.Compression.ZipArchive.Mode%2A> propriété.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>