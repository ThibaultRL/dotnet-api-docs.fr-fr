<Type Name="ZipFile" FullName="System.IO.Compression.ZipFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c86835f7010a95402104c4c2190562362b25a27d" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52206368" /></Metadata><TypeSignature Language="C#" Value="public static class ZipFile" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ZipFile extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Compression.ZipFile" />
  <TypeSignature Language="VB.NET" Value="Public Class ZipFile" />
  <TypeSignature Language="C++ CLI" Value="public ref class ZipFile abstract sealed" />
  <TypeSignature Language="F#" Value="type ZipFile = class" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des méthodes statiques permettant la création, l’extraction et l’ouverture d’archives zip.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  À utiliser le <xref:System.IO.Compression.ZipFile> (classe), vous devez ajouter une référence à la `System.IO.Compression.FileSystem` assembly dans votre projet ; sinon, vous obtiendrez le message d’erreur suivant lorsque vous essayez de compiler : **le nom de fichier « zip » n’existe pas dans le contexte actuel**. Pour plus d’informations sur la façon d’ajouter une référence à votre projet dans Visual Studio, consultez [Comment : ajouter ou supprimer des références à l’aide du Gestionnaire de références](https://msdn.microsoft.com/library/1aabb520-99b0-46c6-9368-21b4d84793eb).  
  
 Les méthodes permettant de manipuler des archives zip et leurs fichiers sont réparties sur trois classes : <xref:System.IO.Compression.ZipFile>, <xref:System.IO.Compression.ZipArchive> et <xref:System.IO.Compression.ZipArchiveEntry>.  
  
|À...|Utilisez...|  
|---------|----------|  
|Créer une archive zip à partir d’un répertoire|<xref:System.IO.Compression.ZipFile.CreateFromDirectory%2A?displayProperty=nameWithType>|  
|Extraire le contenu d’une archive zip dans un répertoire|<xref:System.IO.Compression.ZipFile.ExtractToDirectory%2A?displayProperty=nameWithType>|  
|Ajoutez de nouveaux fichiers dans une archive zip existant|<xref:System.IO.Compression.ZipArchive.CreateEntry%2A?displayProperty=nameWithType>|  
|Récupérer un fichier dans une archive zip|<xref:System.IO.Compression.ZipArchive.GetEntry%2A?displayProperty=nameWithType>|  
|Récupérer tous les fichiers dans une archive zip|<xref:System.IO.Compression.ZipArchive.Entries%2A?displayProperty=nameWithType>|  
|Pour ouvrir un flux de données à un fichier individuel contenu dans une archive zip|<xref:System.IO.Compression.ZipArchiveEntry.Open%2A?displayProperty=nameWithType>|  
|Supprimer un fichier à partir d’une archive zip|<xref:System.IO.Compression.ZipArchiveEntry.Delete%2A?displayProperty=nameWithType>|  
  
 Vous ne pouvez pas utiliser le <xref:System.IO.Compression.ZipFile> ou <xref:System.IO.Compression.ZipFileExtensions> classes de [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications. Dans [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] applications, vous devez utiliser les classes suivantes pour travailler avec des fichiers compressés.  
  
-   <xref:System.IO.Compression.ZipArchive>  
  
-   <xref:System.IO.Compression.ZipArchiveEntry>  
  
-   <xref:System.IO.Compression.DeflateStream>  
  
-   <xref:System.IO.Compression.GZipStream>  
  
   
  
## Examples  
 Cet exemple montre comment créer et extraire une archive zip à l’aide de la <xref:System.IO.Compression.ZipFile> classe. Il compresse le contenu d’un dossier dans une archive zip et extrait ensuite ce contenu vers un nouveau dossier.  
  
> [!TIP]
>  Pour utiliser la classe <xref:System.IO.Compression.ZipFile>, vous devez référencer l’assembly `System.IO.Compression.FileSystem` dans votre projet.  
  
 [!code-csharp[System.IO.Compression.ZipFile#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.zipfile/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.zipfile/vb/program1.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/1aabb520-99b0-46c6-9368-21b4d84793eb">Guide pratique pour ajouter ou supprimer des références à l’aide du gestionnaire de références</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateFromDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une archive zip qui contient les fichiers et les répertoires du répertoire spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateFromDirectory">
      <MemberSignature Language="C#" Value="public static void CreateFromDirectory (string sourceDirectoryName, string destinationArchiveFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.CreateFromDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateFromDirectory (sourceDirectoryName As String, destinationArchiveFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateFromDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationArchiveFileName);" />
      <MemberSignature Language="F#" Value="static member CreateFromDirectory : string * string -&gt; unit" Usage="System.IO.Compression.ZipFile.CreateFromDirectory (sourceDirectoryName, destinationArchiveFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationArchiveFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès au répertoire à archiver, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="destinationArchiveFileName">Chemin d’accès de l’archive à créer, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <summary>Crée une archive zip qui contient les fichiers et les répertoires du répertoire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La structure de répertoires du système de fichiers est conservée dans l’archive. Si le répertoire est vide, une archive vide est créée. Cette surcharge de méthode n’inclut pas le répertoire de base dans l’archive et ne pas vous permet de spécifier un niveau de compression. Si vous souhaitez inclure le répertoire de base ou spécifiez un appel de niveau, la compression la <xref:System.IO.Compression.ZipFile.CreateFromDirectory%28System.String%2CSystem.String%2CSystem.IO.Compression.CompressionLevel%2CSystem.Boolean%29> surcharge de méthode.  
  
 Si l’archive existe déjà, un <xref:System.IO.IOException> exception est levée. Si une entrée avec le nom spécifié existe déjà dans l’archive, une deuxième entrée est créée avec un nom identique.  
  
 Si un fichier dans le répertoire ne peut pas être ajouté à l’archive, l’archive est incomplète et non valide et la méthode lève un <xref:System.IO.IOException> exception.  
  
   
  
## Examples  
 Cet exemple montre comment créer et extraire une archive zip à l’aide de la <xref:System.IO.Compression.ZipFile> classe. Il compresse le contenu d’un dossier dans une archive zip et extrait ensuite ce contenu vers un nouveau dossier. Pour utiliser la classe <xref:System.IO.Compression.ZipFile>, vous devez référencer l’assembly `System.IO.Compression.FileSystem` dans votre projet.  
  
 [!code-csharp[System.IO.Compression.ZipFile#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.zipfile/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.zipfile/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient qu’un espace blanc ou contient au moins un caractère non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceDirectoryName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destinationArchiveFileName" /> existe déjà.  
  
- ou - 
Un fichier dans le répertoire spécifié n’a pu être ouvert.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destinationArchiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au répertoire spécifié dans <paramref name="sourceDirectoryName" /> ou dans le fichier spécifié dans <paramref name="destinationArchiveFileName" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> contient un format non valide.  
  
- ou - 
L’archive zip ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromDirectory">
      <MemberSignature Language="C#" Value="public static void CreateFromDirectory (string sourceDirectoryName, string destinationArchiveFileName, System.IO.Compression.CompressionLevel compressionLevel, bool includeBaseDirectory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, valuetype System.IO.Compression.CompressionLevel compressionLevel, bool includeBaseDirectory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.CreateFromDirectory(System.String,System.String,System.IO.Compression.CompressionLevel,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateFromDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationArchiveFileName, System::IO::Compression::CompressionLevel compressionLevel, bool includeBaseDirectory);" />
      <MemberSignature Language="F#" Value="static member CreateFromDirectory : string * string * System.IO.Compression.CompressionLevel * bool -&gt; unit" Usage="System.IO.Compression.ZipFile.CreateFromDirectory (sourceDirectoryName, destinationArchiveFileName, compressionLevel, includeBaseDirectory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationArchiveFileName" Type="System.String" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" />
        <Parameter Name="includeBaseDirectory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès au répertoire à archiver, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="destinationArchiveFileName">Chemin d’accès de l’archive à créer, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="compressionLevel">Une des valeurs d'énumération qui indique s'il faut privilégier la rapidité ou l'efficacité de la compression lors de la création de l'entrée.</param>
        <param name="includeBaseDirectory"><see langword="true" /> pour inclure le nom de répertoire de <paramref name="sourceDirectoryName" /> à la racine de l'archive ; <see langword="false" /> pour inclure uniquement le contenu du répertoire.</param>
        <summary>Crée une archive zip qui contient les fichiers et les répertoires du répertoire spécifié, utilise le niveau de compression spécifié et inclut éventuellement le répertoire de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La structure de répertoires du système de fichiers est conservée dans l’archive. Si le répertoire est vide, une archive vide est créée. Utilisez cette surcharge de méthode pour spécifier le niveau de compression et s’il faut inclure le répertoire de base dans l’archive.  
  
 Si l’archive existe déjà, un <xref:System.IO.IOException> exception est levée. Si une entrée avec le nom spécifié existe déjà dans l’archive, une deuxième entrée est créée avec un nom identique.  
  
 Si un fichier dans le répertoire ne peut pas être ajouté à l’archive, l’archive est incomplète et non valide et la méthode lève un <xref:System.IO.IOException> exception.  
  
   
  
## Examples  
 Cet exemple montre comment créer et extraire une archive zip à l’aide de la <xref:System.IO.Compression.ZipFile> classe. Il compresse le contenu d’un dossier dans une archive zip et extrait ensuite ce contenu vers un nouveau dossier. Lors de la compression de l’archive, le répertoire de base est inclus et le niveau de compression est défini pour mettre en évidence la vitesse de l’opération sur l’efficacité. Pour utiliser la classe <xref:System.IO.Compression.ZipFile>, vous devez référencer l’assembly `System.IO.Compression.FileSystem` dans votre projet.  
  
 [!code-csharp[System.IO.Compression.ZipFile#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.zipfile/cs/program2.cs#2)]
 [!code-vb[System.IO.Compression.ZipFile#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.zipfile/vb/program2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient qu’un espace blanc ou contient au moins un caractère non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceDirectoryName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destinationArchiveFileName" /> existe déjà.  
  
- ou - 
Un fichier dans le répertoire spécifié n’a pu être ouvert.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destinationArchiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au répertoire spécifié dans <paramref name="sourceDirectoryName" /> ou dans le fichier spécifié dans <paramref name="destinationArchiveFileName" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> contient un format non valide.  
  
- ou - 
L’archive zip ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateFromDirectory">
      <MemberSignature Language="C#" Value="public static void CreateFromDirectory (string sourceDirectoryName, string destinationArchiveFileName, System.IO.Compression.CompressionLevel compressionLevel, bool includeBaseDirectory, System.Text.Encoding entryNameEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateFromDirectory(string sourceDirectoryName, string destinationArchiveFileName, valuetype System.IO.Compression.CompressionLevel compressionLevel, bool includeBaseDirectory, class System.Text.Encoding entryNameEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.CreateFromDirectory(System.String,System.String,System.IO.Compression.CompressionLevel,System.Boolean,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateFromDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationArchiveFileName, System::IO::Compression::CompressionLevel compressionLevel, bool includeBaseDirectory, System::Text::Encoding ^ entryNameEncoding);" />
      <MemberSignature Language="F#" Value="static member CreateFromDirectory : string * string * System.IO.Compression.CompressionLevel * bool * System.Text.Encoding -&gt; unit" Usage="System.IO.Compression.ZipFile.CreateFromDirectory (sourceDirectoryName, destinationArchiveFileName, compressionLevel, includeBaseDirectory, entryNameEncoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationArchiveFileName" Type="System.String" />
        <Parameter Name="compressionLevel" Type="System.IO.Compression.CompressionLevel" />
        <Parameter Name="includeBaseDirectory" Type="System.Boolean" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Chemin d’accès au répertoire à archiver, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="destinationArchiveFileName">Chemin d’accès de l’archive à créer, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="compressionLevel">Une des valeurs d'énumération qui indique s'il faut privilégier la rapidité ou l'efficacité de la compression lors de la création de l'entrée.</param>
        <param name="includeBaseDirectory"><see langword="true" /> pour inclure le nom de répertoire de <paramref name="sourceDirectoryName" /> à la racine de l'archive ; <see langword="false" /> pour inclure uniquement le contenu du répertoire.</param>
        <param name="entryNameEncoding">Encodage à utiliser lors de la lecture ou de l'écriture des noms d'entrée dans cette archive. Spécifie une valeur pour ce paramètre seulement quand un encodage est obligatoire pour l'interopérabilité avec les outils et les bibliothèques d'archivage zip qui ne prennent pas en charge l'encodage UTF-8 pour les noms d'entrée.</param>
        <summary>Crée une archive zip qui contient les fichiers et les répertoires du répertoire spécifié, utilise le niveau de compression et l'encodage de caractères spécifiés pour les noms d'entrée, et inclut éventuellement le répertoire de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La structure de répertoires du système de fichiers est conservée dans l’archive. Si le répertoire est vide, une archive vide est créée. Utilisez cette surcharge de méthode pour spécifier le niveau de compression et codage de caractères et s’il faut inclure le répertoire de base dans l’archive.  
  
 Si l’archive existe déjà, un <xref:System.IO.IOException> exception est levée. Si une entrée avec le nom spécifié existe déjà dans l’archive, une deuxième entrée est créée avec un nom identique.  
  
 Si un fichier dans le répertoire ne peut pas être ajouté à l’archive, l’archive est incomplète et non valide et la méthode lève un <xref:System.IO.IOException> exception.  
  
 Si `entryNameEncoding` est défini sur une valeur autre que `null`, les noms d’entrée sont encodés à l’aide de l’encodage spécifié. Si l’encodage spécifié est un format UTF-8, le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) est défini pour chaque entrée,  
  
 Si `entryNameEncoding` a la valeur `null`, les noms d’entrée sont encodées selon les règles suivantes :  
  
-   Pour les noms d’entrée qui contiennent des caractères en dehors de la plage ASCII, l’indicateur d’encodage linguistique est défini, et UTF-8 est utilisé pour encoder le nom d’entrée.  
  
-   Pour les noms d’entrée qui contiennent uniquement des caractères ASCII, l’indicateur d’encodage linguistique est défini, et la page de codes système par défaut actuel est utilisée pour encoder les noms d’entrée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient qu’un espace blanc ou contient au moins un caractère non valide.  
  
- ou - 
 <paramref name="entryNameEncoding" /> a pour valeur un encodage Unicode autre qu’UTF-8.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceDirectoryName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="destinationArchiveFileName" /> existe déjà.  
  
- ou - 
Un fichier dans le répertoire spécifié n’a pu être ouvert.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="destinationArchiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au répertoire spécifié dans <paramref name="sourceDirectoryName" /> ou dans le fichier spécifié dans <paramref name="destinationArchiveFileName" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="sourceDirectoryName" /> ou <paramref name="destinationArchiveFileName" /> contient un format non valide.  
  
- ou - 
L’archive zip ne prend pas en charge l’écriture.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExtractToDirectory">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Extrait tous les fichiers de l'archive zip spécifiée vers un répertoire sur le système de fichiers.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExtractToDirectory">
      <MemberSignature Language="C#" Value="public static void ExtractToDirectory (string sourceArchiveFileName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.ExtractToDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExtractToDirectory (sourceArchiveFileName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExtractToDirectory(System::String ^ sourceArchiveFileName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="static member ExtractToDirectory : string * string -&gt; unit" Usage="System.IO.Compression.ZipFile.ExtractToDirectory (sourceArchiveFileName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArchiveFileName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceArchiveFileName">Chemin d’accès à l’archive qui doit être extraite.</param>
        <param name="destinationDirectoryName">Chemin d’accès au répertoire où placer les fichiers extraits, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <summary>Extrait tous les fichiers de l'archive zip spécifiée vers un répertoire sur le système de fichiers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée le répertoire spécifié et tous les sous-répertoires. Le répertoire de destination ne peut pas déjà exister. Exceptions liées à la validation les chemins d’accès dans le `destinationDirectoryName` ou `sourceArchiveFileName` paramètres sont levées avant l’extraction. Sinon, si une erreur se produit lors de l’extraction, l’archive reste partiellement extraite. Chaque fichier extrait a le même chemin d’accès relatif au répertoire spécifié par `destinationDirectoryName` comme source d’entrée comporte à la racine de l’archive.  
  
   
  
## Examples  
 Cet exemple montre comment créer et extraire une archive zip à l’aide de la <xref:System.IO.Compression.ZipFile> classe. Il compresse le contenu d’un dossier dans une archive zip et extrait ce contenu vers un nouveau dossier. Pour utiliser la classe <xref:System.IO.Compression.ZipFile>, vous devez référencer l’assembly `System.IO.Compression.FileSystem` dans votre projet.  
  
 [!code-csharp[System.IO.Compression.ZipFile#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.zipfile/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipFile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.zipfile/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient qu’un espace blanc ou contient au moins un caractère non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès spécifié dans <paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="destinationDirectoryName" /> existe déjà.  
  
- ou - 
Le nom d’une entrée dans l’archive est <see cref="F:System.String.Empty" />, ne contient que des espaces blancs ou contient au moins un caractère non valide.  
  
- ou - 
L’extraction d’une entrée d’archivage pourrait créer un fichier qui se trouve en dehors du répertoire spécifié par <paramref name="destinationDirectoryName" />. (Par exemple, cela peut se produire si le nom d’entrée contient des accesseurs du répertoire parent.) 
- ou - 
Une entrée d’archive à extraire porte le même nom qu’une entrée qui a été extraite de la même archive.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’appelant n’a pas l’autorisation requise pour accéder à l’archive ou au répertoire de destination.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> contient un format non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceArchiveFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.InvalidDataException">L’archive spécifiée par <paramref name="sourceArchiveFileName" /> n’est pas une archive ZIP valide.  
  
- ou - 
Une entrée d’archivage introuvable ou endommagée.  
  
- ou - 
Une entrée d’archive a été compressée à l’aide d’une méthode de compression qui n’est pas prise en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtractToDirectory">
      <MemberSignature Language="C#" Value="public static void ExtractToDirectory (string sourceArchiveFileName, string destinationDirectoryName, bool overwriteFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, bool overwriteFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.ExtractToDirectory(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExtractToDirectory (sourceArchiveFileName As String, destinationDirectoryName As String, overwriteFiles As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExtractToDirectory(System::String ^ sourceArchiveFileName, System::String ^ destinationDirectoryName, bool overwriteFiles);" />
      <MemberSignature Language="F#" Value="static member ExtractToDirectory : string * string * bool -&gt; unit" Usage="System.IO.Compression.ZipFile.ExtractToDirectory (sourceArchiveFileName, destinationDirectoryName, overwriteFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArchiveFileName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="overwriteFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceArchiveFileName">To be added.</param>
        <param name="destinationDirectoryName">To be added.</param>
        <param name="overwriteFiles">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtractToDirectory">
      <MemberSignature Language="C#" Value="public static void ExtractToDirectory (string sourceArchiveFileName, string destinationDirectoryName, System.Text.Encoding entryNameEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, class System.Text.Encoding entryNameEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.ExtractToDirectory(System.String,System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExtractToDirectory (sourceArchiveFileName As String, destinationDirectoryName As String, entryNameEncoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExtractToDirectory(System::String ^ sourceArchiveFileName, System::String ^ destinationDirectoryName, System::Text::Encoding ^ entryNameEncoding);" />
      <MemberSignature Language="F#" Value="static member ExtractToDirectory : string * string * System.Text.Encoding -&gt; unit" Usage="System.IO.Compression.ZipFile.ExtractToDirectory (sourceArchiveFileName, destinationDirectoryName, entryNameEncoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArchiveFileName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="sourceArchiveFileName">Chemin d’accès à l’archive qui doit être extraite.</param>
        <param name="destinationDirectoryName">Chemin d’accès au répertoire où placer les fichiers extraits, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="entryNameEncoding">Encodage à utiliser lors de la lecture ou de l'écriture des noms d'entrée dans cette archive. Spécifie une valeur pour ce paramètre seulement quand un encodage est obligatoire pour l'interopérabilité avec les outils et les bibliothèques d'archivage zip qui ne prennent pas en charge l'encodage UTF-8 pour les noms d'entrée.</param>
        <summary>Extrait tous les fichiers de l'archive zip spécifiée vers un répertoire sur le système de fichiers et utilise l'encodage de caractères spécifié pour les noms d'entrée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode crée le répertoire spécifié et tous les sous-répertoires. Le répertoire de destination ne peut pas déjà exister. Exceptions liées à la validation les chemins d’accès dans le `destinationDirectoryName` ou `sourceArchiveFileName` paramètres sont levées avant l’extraction. Sinon, si une erreur se produit lors de l’extraction, l’archive reste partiellement extraite. Chaque fichier extrait a le même chemin d’accès relatif au répertoire spécifié par `destinationDirectoryName` comme source d’entrée comporte à la racine de l’archive.  
  
 Si `entryNameEncoding` est défini sur une valeur autre que `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Pour les noms d’entrée où le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) n’est pas défini, les noms d’entrée sont décodés à l’aide de l’encodage spécifié.  
  
-   Pour les entrées où l’indicateur d’encodage linguistique est définie, les noms d’entrée sont décodées en UTF-8.  
  
 Si `entryNameEncoding` a la valeur `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Pour les entrées lorsque le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) n’est pas défini, noms d’entrée sont décodés à l’aide de la page de codes système par défaut actuel.  
  
-   Pour les entrées où l’indicateur d’encodage linguistique est définie, les noms d’entrée sont décodées en UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient qu’un espace blanc ou contient au moins un caractère non valide.  
  
- ou - 
 <paramref name="entryNameEncoding" /> a pour valeur un encodage Unicode autre qu’UTF-8.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Le chemin d’accès spécifié dans <paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> dépasse la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Le chemin spécifié n’est pas valide (par exemple, il est sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException">Le répertoire spécifié par <paramref name="destinationDirectoryName" /> existe déjà.  
  
- ou - 
Le nom d’une entrée dans l’archive est <see cref="F:System.String.Empty" />, ne contient que des espaces blancs ou contient au moins un caractère non valide.  
  
- ou - 
L’extraction d’une entrée d’archivage pourrait créer un fichier qui se trouve en dehors du répertoire spécifié par <paramref name="destinationDirectoryName" />. (Par exemple, cela peut se produire si le nom d’entrée contient des accesseurs du répertoire parent.) 
- ou - 
Une entrée d’archive à extraire porte le même nom qu’une entrée qui a été extraite de la même archive.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L’appelant n’a pas l’autorisation requise pour accéder à l’archive ou au répertoire de destination.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="destinationDirectoryName" /> ou <paramref name="sourceArchiveFileName" /> contient un format non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceArchiveFileName" /> est introuvable.</exception>
        <exception cref="T:System.IO.InvalidDataException">L’archive spécifiée par <paramref name="sourceArchiveFileName" /> n’est pas une archive ZIP valide.  
  
- ou - 
Une entrée d’archivage introuvable ou endommagée.  
  
- ou - 
Une entrée d’archive a été compressée à l’aide d’une méthode de compression qui n’est pas prise en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtractToDirectory">
      <MemberSignature Language="C#" Value="public static void ExtractToDirectory (string sourceArchiveFileName, string destinationDirectoryName, System.Text.Encoding entryNameEncoding, bool overwriteFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExtractToDirectory(string sourceArchiveFileName, string destinationDirectoryName, class System.Text.Encoding entryNameEncoding, bool overwriteFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.ExtractToDirectory(System.String,System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExtractToDirectory (sourceArchiveFileName As String, destinationDirectoryName As String, entryNameEncoding As Encoding, overwriteFiles As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExtractToDirectory(System::String ^ sourceArchiveFileName, System::String ^ destinationDirectoryName, System::Text::Encoding ^ entryNameEncoding, bool overwriteFiles);" />
      <MemberSignature Language="F#" Value="static member ExtractToDirectory : string * string * System.Text.Encoding * bool -&gt; unit" Usage="System.IO.Compression.ZipFile.ExtractToDirectory (sourceArchiveFileName, destinationDirectoryName, entryNameEncoding, overwriteFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArchiveFileName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
        <Parameter Name="overwriteFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceArchiveFileName">To be added.</param>
        <param name="destinationDirectoryName">To be added.</param>
        <param name="entryNameEncoding">To be added.</param>
        <param name="overwriteFiles">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ouvre une archive zip dans le chemin d’accès et le mode spécifiés.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Compression.ZipArchive Open (string archiveFileName, System.IO.Compression.ZipArchiveMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Compression.ZipArchive Open(string archiveFileName, valuetype System.IO.Compression.ZipArchiveMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.Open(System.String,System.IO.Compression.ZipArchiveMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (archiveFileName As String, mode As ZipArchiveMode) As ZipArchive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Compression::ZipArchive ^ Open(System::String ^ archiveFileName, System::IO::Compression::ZipArchiveMode mode);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.Compression.ZipArchiveMode -&gt; System.IO.Compression.ZipArchive" Usage="System.IO.Compression.ZipFile.Open (archiveFileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchive</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveFileName" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
      </Parameters>
      <Docs>
        <param name="archiveFileName">Chemin d’accès de l’archive à ouvrir, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="mode">Une des valeurs d'énumération spécifiant les actions qui sont autorisées sur les entrées de l'archive ouverte.</param>
        <summary>Ouvre une archive zip dans le chemin d’accès et le mode spécifiés.</summary>
        <returns>Archive zip ouverte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Read>, l’archive est ouvert avec <xref:System.IO.FileMode.Open> à partir de la <xref:System.IO.FileMode> énumération comme valeur de mode de fichier. Si l’archive n’existe pas, un <xref:System.IO.FileNotFoundException> exception est levée. Définition de la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Read> équivaut à appeler le <xref:System.IO.Compression.ZipFile.OpenRead%2A> (méthode).  
  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Create>, l’archive est ouvert avec <xref:System.IO.FileMode.CreateNew?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive existe déjà, un <xref:System.IO.IOException> est levée.  
  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Update>, l’archive est ouvert avec <xref:System.IO.FileMode.OpenOrCreate?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive existe, il est ouvert. Les entrées existantes sont modifiables et les nouvelles entrées peuvent être créées. Si l’archive n’existe pas, une nouvelle archive est créée ; Toutefois, création d’une archive zip dans <xref:System.IO.Compression.ZipArchiveMode.Update> mode n’est pas aussi efficace que celui dans <xref:System.IO.Compression.ZipArchiveMode.Create> mode.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une archive zip dans le mode de mise à jour et ajouter une entrée à l’archive.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program3.cs#3)]
 [!code-vb[System.IO.Compression.ZipArchive#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="archiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient que des espaces blancs ou contient au moins un caractère non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="archiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="archiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="archiveFileName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="archiveFileName" /> n’a pas pu être ouvert.  
  
- ou - 
 <paramref name="mode" /> est défini sur <see cref="F:System.IO.Compression.ZipArchiveMode.Create" />, mais le fichier spécifié dans le <paramref name="archiveFileName" /> existe déjà.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="archiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au fichier spécifié dans <paramref name="archiveFileName" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> est défini sur <see cref="F:System.IO.Compression.ZipArchiveMode.Read" />, mais le fichier spécifié dans le <paramref name="archiveFileName" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="archiveFileName" /> contient un format non valide.</exception>
        <exception cref="T:System.IO.InvalidDataException"><paramref name="archiveFileName" /> n’a pas pu être interprété comme une archive ZIP.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" />, mais une entrée est manquante ou endommagée et ne peut pas être lue.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" />, mais une entrée est trop grande pour être contenue dans la mémoire.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Compression.ZipArchive Open (string archiveFileName, System.IO.Compression.ZipArchiveMode mode, System.Text.Encoding entryNameEncoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Compression.ZipArchive Open(string archiveFileName, valuetype System.IO.Compression.ZipArchiveMode mode, class System.Text.Encoding entryNameEncoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.Open(System.String,System.IO.Compression.ZipArchiveMode,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Open (archiveFileName As String, mode As ZipArchiveMode, entryNameEncoding As Encoding) As ZipArchive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Compression::ZipArchive ^ Open(System::String ^ archiveFileName, System::IO::Compression::ZipArchiveMode mode, System::Text::Encoding ^ entryNameEncoding);" />
      <MemberSignature Language="F#" Value="static member Open : string * System.IO.Compression.ZipArchiveMode * System.Text.Encoding -&gt; System.IO.Compression.ZipArchive" Usage="System.IO.Compression.ZipFile.Open (archiveFileName, mode, entryNameEncoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchive</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveFileName" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.Compression.ZipArchiveMode" />
        <Parameter Name="entryNameEncoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="archiveFileName">Chemin d’accès de l’archive à ouvrir, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <param name="mode">Une des valeurs d'énumération spécifiant les actions qui sont autorisées sur les entrées de l'archive ouverte.</param>
        <param name="entryNameEncoding">Encodage à utiliser lors de la lecture ou de l'écriture des noms d'entrée dans cette archive. Spécifie une valeur pour ce paramètre seulement quand un encodage est obligatoire pour l'interopérabilité avec les outils et les bibliothèques d'archivage zip qui ne prennent pas en charge l'encodage UTF-8 pour les noms d'entrée.</param>
        <summary>Ouvre une archive zip dans le chemin d’accès spécifié, dans le mode spécifié et avec un encodage de caractères spécifié pour les noms d’entrée.</summary>
        <returns>Archive zip ouverte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Read>, l’archive est ouvert avec <xref:System.IO.FileMode.Open?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive n’existe pas, un <xref:System.IO.FileNotFoundException> exception est levée. Définition de la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Read> équivaut à appeler le <xref:System.IO.Compression.ZipFile.OpenRead%2A> (méthode).  
  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Create>, l’archive est ouvert avec <xref:System.IO.FileMode.CreateNew?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive existe déjà, un <xref:System.IO.IOException> est levée.  
  
 Lorsque vous définissez la `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Update>, l’archive est ouvert avec <xref:System.IO.FileMode.OpenOrCreate?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive existe, il est ouvert. Les entrées existantes sont modifiables et les nouvelles entrées peuvent être créées. Si l’archive n’existe pas, une nouvelle archive est créée ; Toutefois, création d’une archive zip dans <xref:System.IO.Compression.ZipArchiveMode.Update> mode n’est pas aussi efficace que celui dans <xref:System.IO.Compression.ZipArchiveMode.Create> mode.  
  
 Lorsque vous ouvrez un fichier d’archive zip pour la lecture et `entryNameEncoding` a la valeur `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Lorsque le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) n’est pas défini, la page de codes système par défaut actuel est utilisée pour décoder le nom d’entrée.  
  
-   Lorsque l’indicateur d’encodage linguistique est définie, UTF-8 est utilisé pour décoder le nom d’entrée.  
  
 Lorsque vous ouvrez un fichier d’archive zip pour la lecture et `entryNameEncoding` est défini sur une valeur autre que `null`, noms d’entrée sont décodés selon les règles suivantes :  
  
-   Lorsque le code d’indicateur de langue n'est pas défini, le texte spécifié `entryNameEncoding` est utilisé pour décoder le nom d’entrée.  
  
-   Lorsque l’indicateur d’encodage linguistique est définie, UTF-8 est utilisé pour décoder le nom d’entrée.  
  
 Lorsque vous écrivez archiver des fichiers et `entryNameEncoding` a la valeur `null`, noms d’entrée sont encodées selon les règles suivantes :  
  
-   Pour les noms d’entrée qui contiennent des caractères en dehors de la plage ASCII, l’indicateur d’encodage linguistique est défini et noms d’entrée sont encodés en UTF-8.  
  
-   Pour les noms d’entrée qui contiennent uniquement des caractères ASCII, l’indicateur d’encodage de langue n’est pas défini et noms d’entrée sont encodés à l’aide de la page de codes système par défaut actuel.  
  
 Lorsque vous écrivez archiver des fichiers et `entryNameEncoding` est défini sur une valeur autre que `null`, spécifié `entryNameEncoding` est utilisé pour encoder les noms d’entrée en octets. Le langage de codage d’indicateur (dans l’indicateur de bit à usage général de l’en-tête de fichier local) est défini uniquement lorsque l’encodage spécifié est un encodage UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="archiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient que des espaces blancs ou contient au moins un caractère non valide.  
  
- ou - 
 <paramref name="entryNameEncoding" /> a pour valeur un encodage Unicode autre qu’UTF-8.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="archiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="archiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="archiveFileName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="archiveFileName" /> n’a pas pu être ouvert.  
  
- ou - 
 <paramref name="mode" /> est défini sur <see cref="F:System.IO.Compression.ZipArchiveMode.Create" />, mais le fichier spécifié dans le <paramref name="archiveFileName" /> existe déjà.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="archiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au fichier spécifié dans <paramref name="archiveFileName" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="mode" /> spécifie une valeur non valide.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="mode" /> est défini sur <see cref="F:System.IO.Compression.ZipArchiveMode.Read" />, mais le fichier spécifié dans le <paramref name="archiveFileName" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="archiveFileName" /> contient un format non valide.</exception>
        <exception cref="T:System.IO.InvalidDataException"><paramref name="archiveFileName" /> n’a pas pu être interprété comme une archive ZIP.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" />, mais une entrée est manquante ou endommagée et ne peut pas être lue.  
  
- ou - 
 <paramref name="mode" /> est <see cref="F:System.IO.Compression.ZipArchiveMode.Update" />, mais une entrée est trop grande pour être contenue dans la mémoire.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.Compression.ZipArchive OpenRead (string archiveFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Compression.ZipArchive OpenRead(string archiveFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Compression.ZipFile.OpenRead(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenRead (archiveFileName As String) As ZipArchive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Compression::ZipArchive ^ OpenRead(System::String ^ archiveFileName);" />
      <MemberSignature Language="F#" Value="static member OpenRead : string -&gt; System.IO.Compression.ZipArchive" Usage="System.IO.Compression.ZipFile.OpenRead archiveFileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.ZipFile</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.Compression.FileSystem</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Compression.ZipArchive</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="archiveFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="archiveFileName">Chemin d’accès de l’archive à ouvrir, spécifié sous forme de chemin d’accès relatif ou absolu. Un chemin d’accès relatif est interprété comme étant relatif au répertoire de travail actif.</param>
        <summary>Ouvre une archive zip pour la lecture au chemin d’accès spécifié.</summary>
        <returns>Archive zip ouverte.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode équivaut à appeler le <xref:System.IO.Compression.ZipFile.Open%2A> (méthode) et en définissant le `mode` paramètre <xref:System.IO.Compression.ZipArchiveMode.Read>. L’archive est ouvert avec <xref:System.IO.FileMode.Open?displayProperty=nameWithType> en tant que la valeur de mode de fichier. Si l’archive n’existe pas, un <xref:System.IO.FileNotFoundException> exception est levée.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une archive zip pour la lecture.  
  
 [!code-csharp[System.IO.Compression.ZipArchive#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.compression.ziparchive/cs/program1.cs#1)]
 [!code-vb[System.IO.Compression.ZipArchive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.compression.ziparchive/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="archiveFileName" /> est <see cref="F:System.String.Empty" />, ne contient que des espaces blancs ou contient au moins un caractère non valide.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="archiveFileName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">Dans <paramref name="archiveFileName" />, le chemin d’accès spécifié, le nom de fichier spécifié ou les deux dépassent la longueur maximale définie par le système.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="archiveFileName" /> n’est pas valide ou n’existe pas (par exemple, il se trouve sur un lecteur non mappé).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="archiveFileName" /> n’a pas pu être ouvert.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="archiveFileName" /> spécifie un répertoire.  
  
- ou - 
L’appelant n’a pas l’autorisation requise pour accéder au fichier spécifié dans <paramref name="archiveFileName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Le fichier spécifié dans <paramref name="archiveFileName" /> est introuvable.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="archiveFileName" /> contient un format non valide.</exception>
        <exception cref="T:System.IO.InvalidDataException"><paramref name="archiveFileName" /> n’a pas pu être interprété comme une archive ZIP.</exception>
      </Docs>
    </Member>
  </Members>
</Type>