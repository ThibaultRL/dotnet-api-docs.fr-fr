<Type Name="ButtonBase" FullName="System.Windows.Forms.ButtonBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="91879cdf0f12667abb8a218f2c79399503e88f20" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39736227" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ButtonBase : System.Windows.Forms.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ButtonBase extends System.Windows.Forms.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ButtonBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ButtonBase&#xA;Inherits Control" />
  <TypeSignature Language="C++ CLI" Value="public ref class ButtonBase abstract : System::Windows::Forms::Control" />
  <TypeSignature Language="F#" Value="type ButtonBase = class&#xA;    inherit Control" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ButtonBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ButtonBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implémente les fonctionnalités de base communes aux contrôles bouton.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous n’héritez pas généralement de <xref:System.Windows.Forms.ButtonBase>. Pour créer votre propre classe de bouton, héritez de la <xref:System.Windows.Forms.Button>, <xref:System.Windows.Forms.CheckBox>, ou <xref:System.Windows.Forms.RadioButton> classe.  
  
 Pour que le contrôle bouton dérivé d’afficher une image, définissez la <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété ou le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> et <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriétés. L’image peut être aligné sur le contrôle de bouton en définissant le <xref:System.Windows.Forms.ButtonBase.ImageAlign%2A> propriété. De même, pour aligner le <xref:System.Windows.Forms.Control.Text%2A> affichée sur le contrôle de bouton, définissez le <xref:System.Windows.Forms.ButtonBase.TextAlign%2A> propriété.  
  
 Le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété détermine le style et l’apparence du contrôle. Si le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété est définie sur <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>, système d’exploitation de l’utilisateur détermine l’apparence du contrôle.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Control" />
    <altmember cref="T:System.Windows.Forms.Button" />
    <altmember cref="T:System.Windows.Forms.CheckBox" />
    <altmember cref="T:System.Windows.Forms.RadioButton" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ButtonBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ButtonBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.ButtonBase" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoEllipsis">
      <MemberSignature Language="C#" Value="public bool AutoEllipsis { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoEllipsis" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.AutoEllipsis" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoEllipsis As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoEllipsis { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoEllipsis : bool with get, set" Usage="System.Windows.Forms.ButtonBase.AutoEllipsis" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si les points de suspension (...) apparaissent sur le bord droit du contrôle, dénotant ainsi que le texte du contrôle s'étend au-delà de la longueur spécifiée du contrôle.</summary>
        <value>
          <see langword="true" /> si le texte supplémentaire de l'étiquette doit être indiqué par des points de sélection ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définissez <xref:System.Windows.Forms.ButtonBase.AutoEllipsis%2A> à `true` pour afficher le texte qui s’étend au-delà de la largeur du contrôle lorsque l’utilisateur passe sur le contrôle avec la souris. Vous devez définir le contrôle `AutoSize` propriété `false` si vous souhaitez <xref:System.Windows.Forms.ButtonBase.AutoEllipsis%2A> être `true`. Si `AutoSize` est `true`, le contrôle atteint pour s’ajuster le texte et les points de suspension n’apparaîtra pas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.ButtonBase.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le contrôle est redimensionné en fonction de son contenu.</summary>
        <value>
          <see langword="true" /> si le contrôle est redimensionné automatiquement en fonction de son contenu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ButtonBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.ButtonBase.AutoSize" /> change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.ButtonBase.AutoSizeChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance d’un type qui hérite de <xref:System.Windows.Forms.ButtonBase>, comme un <xref:System.Windows.Forms.Button> ou <xref:System.Windows.Forms.CheckBox>. Ensuite, nommez l’instance `ButtonBase1` et vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.ButtonBase.AutoSizeChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#136](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#136)]
 [!code-vb[System.Windows.Forms.EventExamples#136](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#136)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.ButtonBase.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur d'arrière-plan du contrôle.</summary>
        <value>Valeur <see cref="T:System.Drawing.Color" /> qui représente la couleur d'arrière-plan.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="buttonBase.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un nouvel objet d'accessibilité pour le contrôle.</summary>
        <returns>Nouveau <see cref="T:System.Windows.Forms.AccessibleObject" /> pour le contrôle.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.ButtonBase.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paramètre de création requis lors de la création du handle du contrôle.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CreateParams" /> qui contient les paramètres de création requis quand le handle du contrôle est créé.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour opérer avec du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.ButtonBase.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le mode d'éditeur de méthode d'entrée (IME, Input Method Editor) par défaut pris en charge par ce contrôle.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tel qu’implémenté dans le <xref:System.Windows.Forms.ButtonBase> classe, cette propriété retourne toujours la `Disable` valeur <xref:System.Windows.Forms.ImeMode?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.ButtonBase.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille par défaut du contrôle.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> par défaut du contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="buttonBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Windows.Forms.ButtonBase" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Windows.Forms.ButtonBase> références. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d’autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlatAppearance">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FlatButtonAppearance FlatAppearance { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.FlatButtonAppearance FlatAppearance" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.FlatAppearance" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FlatAppearance As FlatButtonAppearance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FlatButtonAppearance ^ FlatAppearance { System::Windows::Forms::FlatButtonAppearance ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FlatAppearance : System.Windows.Forms.FlatButtonAppearance" Usage="System.Windows.Forms.ButtonBase.FlatAppearance" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FlatButtonAppearance</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'apparence de la bordure et des couleurs utilisées pour indiquer l'état d'activation et celui de la souris.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.FlatButtonAppearance" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Forms.ButtonBase.FlatAppearance%2A> propriété uniquement avec <xref:System.Windows.Forms.Button> contrôles dont <xref:System.Windows.Forms.FlatStyle> est <xref:System.Windows.Forms.FlatStyle.Flat>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlatStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FlatStyle FlatStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FlatStyle FlatStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.FlatStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FlatStyle As FlatStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FlatStyle FlatStyle { System::Windows::Forms::FlatStyle get(); void set(System::Windows::Forms::FlatStyle value); };" />
      <MemberSignature Language="F#" Value="member this.FlatStyle : System.Windows.Forms.FlatStyle with get, set" Usage="System.Windows.Forms.ButtonBase.FlatStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FlatStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style à deux dimensions (flat) du contrôle bouton.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.FlatStyle" />. La valeur par défaut est <see langword="Standard" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété de la <xref:System.Windows.Forms.RadioButton> et <xref:System.Windows.Forms.CheckBox> classes est définie sur `System`, le contrôle est dessiné par le système d’exploitation de l’utilisateur et l’alignement de vérification est basé sur le `CheckAlign` et <xref:System.Windows.Forms.ButtonBase.TextAlign%2A> les valeurs de propriété. Le `CheckAlign` valeur de propriété n’est pas modifiée, mais l’apparence du contrôle peut être affectée. La case à cocher est alignée horizontalement sur le bord gauche ou droit du contrôle (un alignement à gauche ou au centre apparaît à gauche reste, aligné à droite inchangé,) et le même que le texte descriptif aligné verticalement. Par exemple, si vous avez un <xref:System.Windows.Forms.CheckBox> contrôler avec un `CheckAlign` valeur de propriété `ContentAlignment`. `MiddleCenter`, un <xref:System.Windows.Forms.ButtonBase.TextAlign%2A> valeur de propriété de `ContentAlignment.TopRight`et le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété a la valeur `System`, l’alignement de la case à cocher semblent être `ContentAlignment.TopLeft` tandis que l’alignement du texte reste inchangé.  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété est définie sur `FlatStyle.System`, les images assignées à la <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété ne sont pas affichés.  
  
   
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit certaines de ses propriétés communes. Le résultat sera un bouton à deux dimensions avec le texte sur la gauche et une image sur la droite. Ce code nécessite que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory et qui une référence à la <xref:System.Drawing?displayProperty=nameWithType> espace de noms est inclus.  
  
 [!code-cpp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur assignée ne fait pas partie des valeurs <see cref="T:System.Windows.Forms.FlatStyle" />.</exception>
        <altmember cref="T:System.Drawing.ContentAlignment" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="buttonBase.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Zone de taille personnalisée pour un contrôle.</param>
        <summary>Récupère la taille d'une zone rectangulaire qui peut contenir un contrôle.</summary>
        <returns>Paire ordonnée de type <see cref="T:System.Drawing.Size" /> représentant la largeur et la hauteur d'un rectangle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de <xref:System.Windows.Forms.ButtonBase.GetPreferredSize%2A> diffère par contrôle. Le <xref:System.Windows.Forms.Control.LayoutEngine%2A> peut être impossible d’affecter la taille retournée au contrôle. Vous pouvez retourner une taille plus grande que les contraintes indiquées dans le `proposedSize` paramètre, mais `proposedSize` doit diminuer lorsque les contraintes diminuent. Par exemple, `GetPreferredSize(new Size(100, 0))` ne doit pas être plus large que `GetPreferredSize(new Size(200, 0))`. L’exception est un `proposedSize` 0 ou `Size.Empty`, qui sont définis en tant que sans contrainte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Image">
      <MemberSignature Language="C#" Value="public System.Drawing.Image Image { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image Image" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.Image" />
      <MemberSignature Language="VB.NET" Value="Public Property Image As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Image ^ Image { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Image : System.Drawing.Image with get, set" Usage="System.Windows.Forms.ButtonBase.Image" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'image affichée sur un contrôle bouton.</summary>
        <value>
          <see cref="T:System.Drawing.Image" /> affiché sur le contrôle bouton. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété est définie, le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriété sera définie `null`et le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété sera définie sur sa valeur par défaut, -1.  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.ButtonBase.FlatStyle%2A> propriété est définie sur `FlatStyle.System`, les images assignées à la <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété ne sont pas affichés.  
  
   
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit certaines de ses propriétés communes. Le résultat sera un bouton à deux dimensions avec le texte sur la gauche et une image sur la droite. Ce code nécessite que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory et qui une référence à la <xref:System.Drawing?displayProperty=nameWithType> espace de noms est inclus.  
  
 [!code-cpp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImageList" />
        <altmember cref="P:System.Windows.Forms.ButtonBase.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="ImageAlign">
      <MemberSignature Language="C#" Value="public System.Drawing.ContentAlignment ImageAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.ContentAlignment ImageAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.ImageAlign" />
      <MemberSignature Language="VB.NET" Value="Public Property ImageAlign As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::ContentAlignment ImageAlign { System::Drawing::ContentAlignment get(); void set(System::Drawing::ContentAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.ImageAlign : System.Drawing.ContentAlignment with get, set" Usage="System.Windows.Forms.ButtonBase.ImageAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'alignement de l'image sur le contrôle bouton.</summary>
        <value>Une des valeurs de <see cref="T:System.Drawing.ContentAlignment" />. La valeur par défaut est <see langword="MiddleCenter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit certaines de ses propriétés communes. Le résultat sera un bouton à deux dimensions avec le texte sur la gauche et une image sur la droite. Ce code nécessite que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory et qui une référence à la <xref:System.Drawing?displayProperty=nameWithType> espace de noms est inclus.  
  
 [!code-cpp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur assignée ne fait pas partie des valeurs <see cref="T:System.Drawing.ContentAlignment" />.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.TextAlign" />
      </Docs>
    </Member>
    <Member MemberName="ImageIndex">
      <MemberSignature Language="C#" Value="public int ImageIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ImageIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.ImageIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property ImageIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ImageIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ImageIndex : int with get, set" Usage="System.Windows.Forms.ButtonBase.ImageIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.ImageIndexConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur d'index de liste de l'image affichée sur le contrôle bouton.</summary>
        <value>Index de base zéro représentant la position de l'image dans <see cref="T:System.Windows.Forms.ImageList" />. La valeur par défaut est -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> ou <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriétés sont définies, le <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété est définie sur sa valeur par défaut, `null`.  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> valeur de propriété est modifiée pour `null`, le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété retourne sa valeur par défaut, -1. Toutefois, l’attribué <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> valeur est conservée en interne et utilisée lorsqu’un autre <xref:System.Windows.Forms.ImageList> objet est assigné à la <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriété. Si la nouvelle <xref:System.Windows.Forms.ImageList> affectée à la <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriété a une <xref:System.Windows.Forms.ImageList.ImageCollection.Count%2A?displayProperty=nameWithType> valeur de propriété qui est inférieur ou égal à la valeur attribuée à la <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété moins 1 (pour prendre en compte pour la collection en cours d’un index de base zéro), le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A>valeur de propriété est ajustée à inférieure à la <xref:System.Windows.Forms.ImageList.ImageCollection.Count%2A> valeur de propriété. Par exemple, considérez un bouton de contrôle dont <xref:System.Windows.Forms.ImageList> a trois images et dont la propriété <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété est définie sur 2. Si un nouveau <xref:System.Windows.Forms.ImageList> qui a uniquement deux images est assignée au bouton, le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> valeur change à 1.  
  
   
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> et <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriétés. Ce code requiert qu’un <xref:System.Windows.Forms.ImageList> a été créée et d’un minimum d’un <xref:System.Drawing.Image> a été attribué à ce dernier. Ce code nécessite également que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory.  
  
 [!code-cpp[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur assignée est inférieure aux limites inférieures de <see cref="P:System.Windows.Forms.ButtonBase.ImageIndex" />.</exception>
        <altmember cref="T:System.Windows.Forms.ImageList" />
      </Docs>
    </Member>
    <Member MemberName="ImageKey">
      <MemberSignature Language="C#" Value="public string ImageKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.ImageKey" />
      <MemberSignature Language="VB.NET" Value="Public Property ImageKey As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ImageKey { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ImageKey : string with get, set" Usage="System.Windows.Forms.ButtonBase.ImageKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.ImageKeyConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'accesseur de clé pour l'image dans <see cref="P:System.Windows.Forms.ButtonBase.ImageList" />.</summary>
        <value>Chaîne représentant la clé de l'image.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.ButtonBase.ImageKey%2A> propriété spécifie l’image à partir de la liste d’images à afficher sur le contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageList">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImageList ImageList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ImageList ImageList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.ImageList" />
      <MemberSignature Language="VB.NET" Value="Public Property ImageList As ImageList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImageList ^ ImageList { System::Windows::Forms::ImageList ^ get(); void set(System::Windows::Forms::ImageList ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ImageList : System.Windows.Forms.ImageList with get, set" Usage="System.Windows.Forms.ButtonBase.ImageList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Forms.ImageList" /> qui contient le <see cref="T:System.Drawing.Image" /> affiché sur un contrôle bouton.</summary>
        <value>Élément <see cref="T:System.Windows.Forms.ImageList" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> ou <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété est définie, le <xref:System.Windows.Forms.ButtonBase.Image%2A> propriété a la valeur `null`, qui est sa valeur par défaut.  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> valeur de propriété est modifiée pour `null`, le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété retourne sa valeur par défaut, -1. Toutefois, l’attribué <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> valeur est conservée en interne et utilisée lorsqu’un autre <xref:System.Windows.Forms.ImageList> est affectée à la <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriété. Si la nouvelle <xref:System.Windows.Forms.ImageList> affectée à la <xref:System.Windows.Forms.ButtonBase.ImageList%2A> propriété a une <xref:System.Windows.Forms.ImageList.ImageCollection.Count%2A?displayProperty=nameWithType> valeur de propriété qui est inférieur ou égal à la valeur attribuée à la <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété moins un (car la collection est un index de base zéro), la <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> valeur de propriété est ajustée à inférieure à la <xref:System.Windows.Forms.ImageList.ImageCollection.Count%2A> valeur de propriété. Par exemple, considérez un bouton de contrôle dont <xref:System.Windows.Forms.ImageList> a trois images et dont la propriété <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriété est définie sur 2. Si un nouveau <xref:System.Windows.Forms.ImageList> qui a uniquement deux images est assignée au bouton, le <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> valeur change à 1.  
  
   
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit le <xref:System.Windows.Forms.ButtonBase.ImageList%2A> et <xref:System.Windows.Forms.ButtonBase.ImageIndex%2A> propriétés. Ce code requiert qu’un <xref:System.Windows.Forms.ImageList> a été créée et d’un minimum d’un <xref:System.Drawing.Image> a été attribué à ce dernier. Ce code nécessite également que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory.  
  
 [!code-cpp[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.ImageIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.ImageIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="P:System.Windows.Forms.ButtonBase.ImageIndex" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.ButtonBase.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode d'éditeur de méthode d'entrée (IME, Input Method Editor) pris en charge par ce contrôle. Cette propriété ne s'applique pas à cette classe.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.ButtonBase.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ButtonBase.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la propriété <see cref="P:System.Windows.Forms.ButtonBase.ImeMode" /> est modifiée. Cet événement ne s'applique pas à cette classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="protected internal bool IsDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool IsDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool with get, set" Usage="System.Windows.Forms.ButtonBase.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contrôle bouton est le bouton par défaut.</summary>
        <value>
          <see langword="true" /> si le contrôle bouton est le bouton par défaut ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.ButtonBase.IsDefault%2A> propriété est définie sur `true`, le bouton est le bouton par défaut pour le <xref:System.Windows.Forms.Form>. Cela signifie que le bouton est activé lorsque la touche entrée est enfoncée si aucun autre bouton, ou tout autre contrôle qui capture la touche entrée a le focus.  
  
 Pour spécifier le bouton par défaut d’un formulaire, définissez la <xref:System.Windows.Forms.Form.AcceptButton%2A> propriété du formulaire sur le bouton souhaité.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="buttonBase.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : EventArgs -&gt; unit" Usage="buttonBase.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnGotFocus%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnGotFocus(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnGotFocus(System.EventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnLostFocus(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Forms.KeyEventArgs kevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs kevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (kevent As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ kevent);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyDown kevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kevent" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="kevent">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
> [!NOTE]
>  N’appelez pas <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A> si le bouton est désactivé (Cela inclut les appels à la classe de base <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A> méthode lorsque vous substituez <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A> dans une classe dérivée). Lorsque vous désactivez le bouton dans une substitution de <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A>, appelez la classe de base <xref:System.Windows.Forms.ButtonBase.OnKeyDown%2A> méthode avant de désactiver le bouton, ou ne l’appelez pas du tout.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Forms.KeyEventArgs kevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs kevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (kevent As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ kevent);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="buttonBase.OnKeyUp kevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kevent" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="kevent">
          <see cref="T:System.Windows.Forms.KeyEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnKeyUp%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected override void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLostFocus : EventArgs -&gt; unit" Usage="buttonBase.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.ButtonBase.OnLostFocus(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnLostFocus%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnLostFocus(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnLostFocus(System.EventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnGotFocus(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseDown mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="mevent">
          <see cref="T:System.Windows.Forms.MouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
> [!NOTE]
>  N’appelez pas <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A> si le bouton est désactivé (Cela inclut les appels à la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A> méthode lorsque vous substituez <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A> dans une classe dérivée). Lorsque vous désactivez le bouton dans une substitution de <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A>, appelez la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseDown%2A> méthode avant de désactiver le bouton, ou ne l’appelez pas du tout.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected override void OnMouseEnter (EventArgs eventargs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseEnter(class System.EventArgs eventargs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseEnter(EventArgs ^ eventargs);" />
      <MemberSignature Language="F#" Value="override this.OnMouseEnter : EventArgs -&gt; unit" Usage="buttonBase.OnMouseEnter eventargs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventargs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="eventargs">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
> [!NOTE]
>  N’appelez pas <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A> si le bouton est désactivé (Cela inclut les appels à la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A> méthode lorsque vous substituez <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A> dans une classe dérivée). Lorsque vous désactivez le bouton dans une substitution de <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A>, appelez la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseEnter%2A> méthode avant de désactiver le bouton, ou ne l’appelez pas du tout.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnMouseEnter(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnMouseEnter(System.EventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnMouseLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (EventArgs eventargs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.EventArgs eventargs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(EventArgs ^ eventargs);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : EventArgs -&gt; unit" Usage="buttonBase.OnMouseLeave eventargs" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventargs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="eventargs">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnMouseLeave%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnMouseLeave(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnMouseLeave(System.EventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnMouseEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseMove mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="mevent">
          <see cref="T:System.Windows.Forms.MouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
> [!NOTE]
>  N’appelez pas <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A> si le bouton est désactivé (Cela inclut les appels à la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A> méthode lorsque vous substituez <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A> dans une classe dérivée). Lorsque vous désactivez le bouton dans une substitution de <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A>, appelez la classe de base <xref:System.Windows.Forms.ButtonBase.OnMouseMove%2A> méthode avant de désactiver le bouton, ou ne l’appelez pas du tout.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="buttonBase.OnMouseUp mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="mevent">
          <see cref="T:System.Windows.Forms.MouseEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.ButtonBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnMouseUp%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
        <altmember cref="M:System.Windows.Forms.ButtonBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="buttonBase.OnPaint pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">
          <see cref="T:System.Windows.Forms.PaintEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="M:System.Windows.Forms.ButtonBase.OnPaint(System.Windows.Forms.PaintEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.ButtonBase.OnPaint%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Lors de la substitution <see cref="M:System.Windows.Forms.ButtonBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.Forms.ButtonBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnParentChanged : EventArgs -&gt; unit" Usage="buttonBase.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.ParentChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="buttonBase.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="buttonBase.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objet <see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ResetFlagsandPaint">
      <MemberSignature Language="C#" Value="protected void ResetFlagsandPaint ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetFlagsandPaint() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.ResetFlagsandPaint" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetFlagsandPaint ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetFlagsandPaint();" />
      <MemberSignature Language="F#" Value="member this.ResetFlagsandPaint : unit -&gt; unit" Usage="buttonBase.ResetFlagsandPaint " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réinitialise le contrôle <see cref="T:System.Windows.Forms.Button" /> à l'état avant que vous n'appuyiez dessus, puis le redessine.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.ButtonBase.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.MultilineStringEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte associé à ce contrôle.</summary>
        <value>Texte associé à ce contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TextAlign">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.ContentAlignment TextAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.ContentAlignment TextAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.TextAlign" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property TextAlign As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::ContentAlignment TextAlign { System::Drawing::ContentAlignment get(); void set(System::Drawing::ContentAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlign : System.Drawing.ContentAlignment with get, set" Usage="System.Windows.Forms.ButtonBase.TextAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'alignement du texte sur le contrôle bouton.</summary>
        <value>Une des valeurs de <see cref="T:System.Drawing.ContentAlignment" />. La valeur par défaut est <see langword="MiddleCenter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant utilise la classe dérivée, <xref:System.Windows.Forms.Button> et définit certaines de ses propriétés communes. Le résultat sera un bouton à deux dimensions avec le texte sur la gauche et une image sur la droite. Ce code nécessite que vous avez une image bitmap nommée `MyBitMap.bmp` stockés dans le `C:\Graphics` directory et qui une référence à la <xref:System.Drawing?displayProperty=nameWithType> espace de noms est inclus.  
  
 [!code-cpp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/CS/source.cs#1)]
 [!code-vb[Classic ButtonBase.FlatStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ButtonBase.FlatStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur assignée ne fait pas partie des valeurs <see cref="T:System.Drawing.ContentAlignment" />.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.ImageAlign" />
      </Docs>
    </Member>
    <Member MemberName="TextImageRelation">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TextImageRelation TextImageRelation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.TextImageRelation TextImageRelation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.TextImageRelation" />
      <MemberSignature Language="VB.NET" Value="Public Property TextImageRelation As TextImageRelation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::TextImageRelation TextImageRelation { System::Windows::Forms::TextImageRelation get(); void set(System::Windows::Forms::TextImageRelation value); };" />
      <MemberSignature Language="F#" Value="member this.TextImageRelation : System.Windows.Forms.TextImageRelation with get, set" Usage="System.Windows.Forms.ButtonBase.TextImageRelation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TextImageRelation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du texte et de l'image l'un par rapport à l'autre.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.TextImageRelation" />. La valeur par défaut est <see cref="F:System.Windows.Forms.TextImageRelation.Overlay" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur ne fait pas partie des valeurs <see cref="T:System.Windows.Forms.TextImageRelation" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseCompatibleTextRendering">
      <MemberSignature Language="C#" Value="public bool UseCompatibleTextRendering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCompatibleTextRendering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCompatibleTextRendering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCompatibleTextRendering { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCompatibleTextRendering : bool with get, set" Usage="System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine s'il faut utiliser la classe <see cref="T:System.Drawing.Graphics" /> ([!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]) ou <see cref="T:System.Windows.Forms.TextRenderer" /> ([!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]) pour restituer le texte.</summary>
        <value>
          <see langword="true" /> si la classe <see cref="T:System.Drawing.Graphics" /> doit être utilisée afin d'effectuer un rendu du texte pour la compatibilité avec les versions 1.0 et 1.1. du .NET Framework ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `UseCompatibleTextRendering` propriété vise à assurer la compatibilité visuelle entre les contrôles Windows Forms ce texte rendu à l’aide du <xref:System.Windows.Forms.TextRenderer> classe et [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] et [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] les applications qui effectuent le rendu de texte personnalisé à l’aide de la <xref:System.Drawing.Graphics>classe. Dans la plupart des cas, si votre application n’est pas mis à niveau à partir de [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] ou [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], il est recommandé de laisser `UseCompatibleTextRendering` la valeur par défaut de `false`.  
  
 Le [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] en <xref:System.Windows.Forms.TextRenderer> classe a été introduite dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] pour améliorer les performances, rendre du texte améliorer l’aspect et la prise en charge des polices internationales. Dans les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basé <xref:System.Drawing.Graphics> classe a été utilisée pour effectuer le rendu du texte. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] calcule l’espacement des caractères et habillage différemment à partir de word [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Dans une application Windows Forms qui utilise le <xref:System.Drawing.Graphics> class pour restituer le texte, cela peut entraîner le texte pour les contrôles qui utilisent <xref:System.Windows.Forms.TextRenderer> différente du reste du texte dans l’application. Pour résoudre cette incompatibilité, vous pouvez définir le `UseCompatibleTextRendering` propriété `true` pour un contrôle spécifique. Pour définir `UseCompatibleTextRendering` à `true` pour tous les contrôles pris en charge dans l’application, appelez le <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A?displayProperty=nameWithType> méthode avec un paramètre de `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
      </Docs>
    </Member>
    <Member MemberName="UseMnemonic">
      <MemberSignature Language="C#" Value="public bool UseMnemonic { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseMnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.UseMnemonic" />
      <MemberSignature Language="VB.NET" Value="Public Property UseMnemonic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseMnemonic { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseMnemonic : bool with get, set" Usage="System.Windows.Forms.ButtonBase.UseMnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le premier caractère précédé par un « et commercial » (&amp;) est utilisé comme touche mnémonique du contrôle.</summary>
        <value>
          <see langword="true" /> Si le premier caractère qui est précédée par une esperluette (&amp;) est utilisé comme touche mnémonique du contrôle ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyleBackColor">
      <MemberSignature Language="C#" Value="public bool UseVisualStyleBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseVisualStyleBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ButtonBase.UseVisualStyleBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseVisualStyleBackColor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseVisualStyleBackColor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyleBackColor : bool with get, set" Usage="System.Windows.Forms.ButtonBase.UseVisualStyleBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui détermine si l'arrière-plan est dessiné à l'aide de styles visuels, si ceux-ci sont pris en charge.</summary>
        <value>
          <see langword="true" /> si l'arrière-plan est dessiné à l'aide de styles visuels ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Styles visuels sont des spécifications pour l’apparence des contrôles. Par exemple, les styles visuels peuvent définir la couleur, la taille et la police des contrôles, et permettent de configurer l’interface visuelle pour coordonner avec votre interface d’application. En outre, ils fournissent un mécanisme pour toutes les applications Windows appliquer des styles visuels.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ButtonBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="buttonBase.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">
          <see cref="T:System.Windows.Forms.Message" /> Windows à traiter.</param>
        <summary>Traite les messages Windows.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>