<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="438b97ff2ea6c6c81c81530113b51827b6ecc05c" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65005440" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un contrôle RichTextBox Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avec la <xref:System.Windows.Forms.RichTextBox> contrôle, l’utilisateur peut entrer et modifier du texte. Le contrôle fournit également des fonctionnalités de mise en forme plus avancées que la norme <xref:System.Windows.Forms.TextBox> contrôle. Texte peut être assigné directement au contrôle, ou peut être chargé à partir d’un format de texte enrichi (RTF) ou un fichier texte brut. Le texte dans le contrôle peut avoir de caractère et de mise en forme du paragraphe.  
  
 Le <xref:System.Windows.Forms.RichTextBox> contrôle fournit un nombre de propriétés que vous pouvez utiliser pour appliquer la mise en forme à une partie du texte dans le contrôle. Pour modifier la mise en forme du texte, il doit être sélectionné en premier. Seul le texte sélectionné peut être affecté de caractère et de mise en forme du paragraphe. Une fois qu’un paramètre a été établie avec une section de texte sélectionnée, tout le texte entré après que la sélection est également mis en forme avec les mêmes paramètres jusqu'à ce qu’un paramètre est modifié ou une autre section du document du contrôle est sélectionnée. Le <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> propriété permet de rendre du texte en gras ou italique. Vous pouvez également utiliser cette propriété pour modifier la taille et la police du texte. Le <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriété vous permet de modifier la couleur du texte. Pour créer des listes à puces, vous pouvez utiliser le <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriété. Vous pouvez également ajuster la mise en forme en définissant le <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>, et <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriétés.  
  
 Le <xref:System.Windows.Forms.RichTextBox> contrôle fournit des méthodes qui fournissent des fonctionnalités pour ouvrir et enregistrer des fichiers. Le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode vous permet de charger un fichier texte ASCII ou RTF existant dans le contrôle. Vous pouvez également charger des données à partir d’un flux de données déjà ouvert. Le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> vous permet d’enregistrer un fichier texte ASCII ou RTF. Similaire à la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode), vous pouvez également utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode pour enregistrer dans un flux de données ouvert. Le <xref:System.Windows.Forms.RichTextBox> contrôle fournit également des fonctionnalités pour rechercher des chaînes de texte. Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode est surchargée pour trouver des chaînes de texte comme des caractères spécifiques dans le texte du contrôle.  
  
 Vous pouvez également initialiser le <xref:System.Windows.Forms.RichTextBox> contrôle aux données stockées en mémoire. Par exemple, vous pouvez initialiser le <xref:System.Windows.Forms.RichTextBox.Rtf%2A> en une chaîne qui contient le texte à afficher, y compris les codes RTF qui déterminent comment le texte doit être mis en forme.  
  
 Si le texte dans le contrôle contient des liens, telles qu’un lien vers un site Web, vous pouvez utiliser le <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> propriété pour afficher le lien de manière appropriée dans le texte du contrôle. Vous pouvez ensuite gérer le <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement pour effectuer les tâches associées au lien. Le <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> propriété vous permet de protéger le texte dans le contrôle à partir de la manipulation par l’utilisateur. Avec texte protégé dans votre contrôle, vous pouvez gérer le <xref:System.Windows.Forms.RichTextBox.Protected> événement pour déterminer quand l’utilisateur a tenté de modifier du texte protégé et avertir l’utilisateur que le texte est protégé ou fournir un moyen standard pour manipuler le texte protégé à l’utilisateur.  
  
 Les applications qui utilisent déjà <xref:System.Windows.Forms.TextBox> contrôles peuvent être facilement adaptés pour utiliser de <xref:System.Windows.Forms.RichTextBox> contrôles. Toutefois, le <xref:System.Windows.Forms.RichTextBox> contrôle n’a pas la même limite de capacité de caractère 64 Ko de la <xref:System.Windows.Forms.TextBox> contrôle. Le <xref:System.Windows.Forms.RichTextBox> est généralement utilisé pour fournir de manipulation de texte et d’affichage des fonctionnalités similaires aux applications de traitement de texte tel que Microsoft Word.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType> méthode ne fonctionne pas avec le <xref:System.Windows.Forms.Control.KeyPress> ou <xref:System.Windows.Forms.Control.TextChanged> événements.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.RichTextBox> contrôle qui charge un fichier RTF dans le contrôle et recherche la première occurrence du mot « Texte ». Le code modifie le style de police, la taille de police et la couleur de police du texte sélectionné, puis enregistre les modifications apportées au fichier d’origine. L’exemple de code se termine en ajoutant le contrôle à son <xref:System.Windows.Forms.Form>. Cet exemple nécessite que la méthode créée dans l’exemple de code est ajoutée à un <xref:System.Windows.Forms.Form> classe et appelé à partir du constructeur du formulaire. L’exemple suppose également qu’un fichier RTF est créé, à la racine du lecteur C, contenant le mot « Texte ».  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propriété du contrôle est définie sur `true`.  
  
   
  
## Examples  
 L’exemple de code suivant crée un <xref:System.Windows.Forms.RichTextBox> contrôle qui charge un fichier RTF dans le contrôle et recherche la première occurrence du mot « Texte ». Le code modifie le style de police, la taille de police et la couleur de police du texte sélectionné, puis enregistre les modifications apportées au fichier d’origine. L’exemple de code se termine en ajoutant le contrôle à son <xref:System.Windows.Forms.Form>. Cet exemple nécessite que la méthode créée dans l’exemple de code est ajoutée à un <xref:System.Windows.Forms.Form> classe et appelé à partir du constructeur du formulaire. L’exemple suppose également qu’un fichier RTF est créé, à la racine du lecteur C, contenant le mot « Texte ».  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le contrôle autorise les opérations de glisser-déplacer.</summary>
        <value><see langword="true" /> si le contrôle autorise les opérations de glisser-déplacer ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment effectuer les opérations de glisser-déplacer en utilisant un <xref:System.Windows.Forms.ListBox> contrôle qui contient les éléments à placer dans un <xref:System.Windows.Forms.RichTextBox> contrôle. Le constructeur des jeux de formulaire le <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> propriété `true` pour activer les opérations glisser-déplacer dans le <xref:System.Windows.Forms.RichTextBox>. L’exemple utilise le <xref:System.Windows.Forms.Control.MouseDown> événements de la <xref:System.Windows.Forms.ListBox> pour démarrer l’opération glisser en appelant le <xref:System.Windows.Forms.Control.DoDragDrop%2A> (méthode). L’exemple utilise le <xref:System.Windows.Forms.Control.DragEnter> événement pour déterminer si un élément déplacé dans le <xref:System.Windows.Forms.RichTextBox> est un type de données valide. Le <xref:System.Windows.Forms.Control.DragDrop> événement effectue la suppression réelle d’un élément déplacé dans le <xref:System.Windows.Forms.RichTextBox> contrôle à l’emplacement du curseur dans le <xref:System.Windows.Forms.RichTextBox>. Cet exemple requiert que le <xref:System.Windows.Forms.Control.DragDrop> et <xref:System.Windows.Forms.Control.DragEnter> événements ont été connectés aux gestionnaires d’événements définis dans l’exemple.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette propriété ne s'applique pas à cette classe.</summary>
        <value><see langword="true" /> si activé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Cette propriété ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sélection automatique des mots est activée.</summary>
        <value><see langword="true" /> si la sélection automatique des mots est activée ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est définie sur `true`, sélection d’une partie du texte dans le contrôle sélectionne le mot entier.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Windows.Forms.RichTextBox> qui se concentre sur le texte, sélectionne automatiquement des mots dans le texte du contrôle lorsque l’utilisateur double-clique sur un mot et comporte une marge à droite de la zone cliente du contrôle. Si le <xref:System.Windows.Forms.RichTextBox> contrôle a une largeur de petites, à l’aide de ce code crée un <xref:System.Windows.Forms.RichTextBox> où chaque caractère du texte s’affiche sur sa propre ligne. Dans cette position d’affichage vertical, en cliquant sur n’importe quelle partie d’un mot sélectionne tous les caractères du mot indépendamment du fait que le texte est affiché verticalement. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette propriété ne s'applique pas à cette classe.</summary>
        <value>Image d'arrière-plan affichée dans le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette propriété ne s'applique pas à cette classe.</summary>
        <value>La disposition de l'image d'arrière-plan affichée dans le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de la propriété <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne concerne pas cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la mise en retrait utilisée dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> lorsque le style de liste à puces est appliqué au texte.</summary>
        <value>Nombre de pixels insérés comme mise en retrait après une puce. La valeur par défaut est zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour appliquer le style de puce à un paragraphe de texte, définissez la <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriété `true` puis définissez le <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriété au nombre de pixels que le texte doit être mis en retrait. Le paragraphe aura le style de puce appliqué avec la quantité spécifiée de la mise en retrait après la puce. Cette propriété affecte uniquement le paragraphe actuel dans le texte du contrôle et la puce sélectionnée dans une liste d’éléments à puces. Pour appliquer un niveau de mise en retrait différente à l’ensemble de la liste d’éléments à puces, tout le texte de la liste doit être sélectionné avant de définir le <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriété avec le <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, et <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriétés pour créer une liste à puces dans un <xref:System.Windows.Forms.RichTextBox> contrôle. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` est créé sur un formulaire.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La mise en retrait spécifiée est inférieure à zéro.</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Une des valeurs de <see cref="T:System.Windows.Forms.DataFormats.Format" />.</param>
        <summary>Détermine si vous pouvez coller des informations du Presse-papiers dans le format de données spécifié.</summary>
        <returns><see langword="true" /> si vous pouvez coller des données provenant du Presse-papiers dans le format de données spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour déterminer si le contenu actuel du Presse-papiers est dans un format de données du Presse-papiers spécifié avant d’activer l’utilisateur coller les informations dans le <xref:System.Windows.Forms.RichTextBox> contrôle. Par exemple, vous pouvez créer un gestionnaire d’événements pour un <xref:System.Windows.Forms.MenuItem.Popup> événements d’une commande Coller <xref:System.Windows.Forms.MenuItem> et utilisez cette méthode pour déterminer si le collage <xref:System.Windows.Forms.MenuItem> doit être activé en fonction du type de données dans le Presse-papiers.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode pour coller une bitmap dans le <xref:System.Windows.Forms.RichTextBox> contrôle. Après l’ouverture d’une image bitmap à partir du fichier, l’exemple utilise le <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> méthode pour copier l’image bitmap dans le Presse-papiers Windows. Enfin, l’exemple récupère le format de la <xref:System.Drawing.Bitmap> objet, utilise le <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> méthode pour vérifier que le format peut être collé dans le <xref:System.Windows.Forms.RichTextBox> contrôle, puis utilise le <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode pour coller les données.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des actions qui se sont produites dans <see cref="T:System.Windows.Forms.RichTextBox" /> peuvent être appliquées à nouveau.</summary>
        <value><see langword="true" /> s'il existe des opérations qui ont été annulées et qui peuvent être appliquées à nouveau au contenu du contrôle ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour déterminer si la dernière opération annulée dans le <xref:System.Windows.Forms.RichTextBox> peut être appliquée à nouveau à l’aide de la <xref:System.Windows.Forms.RichTextBox.Redo%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> et <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriétés et le <xref:System.Windows.Forms.RichTextBox.Redo%2A> (méthode), pour limiter une opération de restauration par progression à une action à l’exception de la suppression de texte. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle et qui une opération dans le <xref:System.Windows.Forms.RichTextBox> a été effectuée et annulée avant le code dans cet exemple est appelé.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contenu du contrôle est redimensionné.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.ContentsResized> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.ContentsResized> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le paramètre de création requis lors de la création du handle du contrôle.</summary>
        <value><see cref="T:System.Windows.Forms.CreateParams" /> qui contient les paramètres de création requis quand le handle du contrôle est créé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet compatible avec <see langword="IRichEditOleCallback" /> pour gérer les opérations de rappel RichEdit.</summary>
        <returns>Objet qui implémente l'interface <see langword="IRichEditOleCallback" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Vous pouvez remplacer cette méthode dans votre classe dérivée pour activer l’accès aux fonctionnalités RichEdit sous-jacentes. Si vous substituez cette méthode, tous les événements de glisser-déplacer ne seront pas déclenchés. Par conséquent, vous devrez fournir votre propre prise en charge pour les opérations de glisser-déplacer. Pour plus d’informations sur la <see langword="IRichEditOleCallback" /> l’interface, consultez la documentation Platform SDK sur http://msdn.microsoft.com.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille par défaut du contrôle.</summary>
        <value>Valeur <see cref="T:System.Drawing.Size" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="T:System.Windows.Forms.RichTextBox" /> met automatiquement en forme les URL entrées par l'utilisateur dans le contrôle.</summary>
        <value><see langword="true" /> si <see cref="T:System.Windows.Forms.RichTextBox" /> applique automatiquement le format de lien aux URL tapées dans le contrôle ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété est définie sur `true`, tout texte entré dans le contrôle est déterminé par la <xref:System.Windows.Forms.RichTextBox> pour être une URL est automatiquement mis en forme sous forme de lien. Vous pouvez créer un gestionnaire d’événements pour le <xref:System.Windows.Forms.RichTextBox.LinkClicked> effectué d’événement à gérer tous les liens dans le contrôle. Le <xref:System.Windows.Forms.LinkClickedEventArgs> qui est fourni au gestionnaire d’événements pour le <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement fournit des données qui vous permet de déterminer quelle liaison a été utilisé dans le contrôle afin de traiter le lien.  
  
   
  
## Examples  
 L’exemple de code suivant contient un gestionnaire d’événements pour le <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement. Le Gestionnaire d’événements traite les clics sur le lien dans le document d’un <xref:System.Windows.Forms.RichTextBox> contrôler et lance une instance du navigateur par défaut (à l’aide de la <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> méthode), affichant la page pour le lien qui a été cliqué. Cet exemple nécessite que le Gestionnaire d’événements a été connecté à la <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement pour un <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur double-clique sur le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur termine une opération de glisser-déplacer.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un objet est déplacé dans les limites d'un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.DragEnter> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.DragEnter> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un objet est déplacé en dehors des limites d'un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne concerne pas cette classe. Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un objet est déplacé sur les limites d'un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne concerne pas cette classe. Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap"><see cref="T:System.Drawing.Bitmap" /></param>
        <param name="targetBounds"><see cref="T:System.Drawing.Rectangle" /></param>
        <summary>Cette méthode ne s'applique pas à cette classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui autorise des opérations de glisser-déplacer sur le texte, les images et d'autres données.</summary>
        <value><see langword="true" /> pour autoriser des opérations de glisser-déplacer ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche du texte dans le contenu de <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tableau de caractères à rechercher.</param>
        <summary>Recherche dans le texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> la première occurrence d'un caractère issu d'une liste.</summary>
        <returns>Emplacement dans le contrôle où les caractères de recherche ont été trouvés ou  -1 si les caractères de recherche sont introuvables ou si un jeu de caractères de recherche vide est spécifié dans le paramètre <paramref name="char" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche la première occurrence d’un caractère dans une liste de caractères spécifiés dans le `characterSet` paramètre et retourne l’emplacement du caractère. Par exemple, vous passez un tableau de caractères contenant le caractère « Q ». Si le contrôle contenue le texte « The Quick Brown Fox », le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode retournerait la valeur 4. Un caractère majuscule et un caractère minuscule sont considérés comme des valeurs différentes dans la recherche.  
  
 Si la propriété retourne une valeur négative, les caractères recherchés sont introuvables dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour rechercher un groupe de caractères dans le contrôle. Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode requiert que le document entier contenu dans le contrôle est recherché pour les caractères. Si un caractère à partir de la liste de caractères spécifiés dans la méthode `characterSet` paramètre est trouvé, la valeur retournée par cette méthode est un index de base zéro de la position du caractère dans le contrôle. Un espace est considéré comme un caractère par la méthode lors de la détermination de l’emplacement d’un caractère.  
  
   
  
## Examples  
 L’exemple de code suivant recherche dans le contenu d’un <xref:System.Windows.Forms.RichTextBox> pour les caractères qui sont passés à la méthode dans le `text` paramètre. Si le contenu de la `text` tableau se trouvent dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne l’index de la valeur est trouvée ; sinon, elle retourne -1. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` et un <xref:System.Windows.Forms.Button> contrôle nommé `button1`, qui est connecté à la `Click` Gestionnaire d’événements défini dans l’exemple.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Texte recherché dans le contrôle.</param>
        <summary>Recherche une chaîne donnée dans le texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Emplacement dans le contrôle où le texte recherché a été trouvé ou -1 si la chaîne recherchée est introuvable ou si une chaîne recherchée vide est spécifiée dans le paramètre <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche le texte spécifié dans le `str` paramètre et retourne l’emplacement du premier caractère dans le contrôle. Si la propriété retourne une valeur négative, la chaîne de texte recherchée est introuvable dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour créer des fonctionnalités de recherche qui peuvent être fournie à l’utilisateur du contrôle. Vous pouvez également utiliser cette méthode pour rechercher du texte à remplacer dans un format spécifique. Par exemple, si l’utilisateur a entré des dates dans le contrôle, vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher toutes les dates dans le document et les remplacer par le format approprié avant d’utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode du contrôle.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthodes qui acceptent un `string` comme un paramètre ne peut pas rechercher du texte qui se trouve sur plusieurs lignes de texte dans le <xref:System.Windows.Forms.RichTextBox>. Ce type de recherche retournera la valeur moins un (-1).  
  
   
  
## Examples  
 L’exemple de code suivant parcourt le contenu d’un <xref:System.Windows.Forms.RichTextBox> pour la première instance d’une chaîne de recherche passé dans le paramètre de texte de la méthode. Si la chaîne recherchée est trouvée dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne une valeur de `true` et met en surbrillance le texte de recherche, sinon elle retourne `false`. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tableau de caractères à rechercher.</param>
        <param name="start">Position à laquelle débute la recherche dans le texte du contrôle.</param>
        <summary>Recherche dans le texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" />, à partir d'un point spécifique, la première occurrence d'un caractère parmi une liste de caractères.</summary>
        <returns>Emplacement du contrôle où les caractères recherchés ont été trouvés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche la première occurrence d’un caractère dans une liste de caractères spécifiés dans le `characterSet` paramètre et retourne l’emplacement du caractère. Par exemple, vous passez un tableau de caractères contenant le caractère « Q ». Si le contrôle contenue le texte « The Quick Brown Fox », le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode retournerait la valeur 4. Un caractère majuscule et un caractère minuscule sont considérés comme des valeurs différentes dans la recherche.  
  
 Si la propriété retourne une valeur négative, les caractères recherchés sont introuvables dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour rechercher un groupe de caractères dans le contrôle. Si un caractère à partir de la liste de caractères spécifiés dans la méthode `characterSet` paramètre est trouvé, la valeur retournée par cette méthode est un index de base zéro de la position du caractère dans le contrôle. Un espace est considéré comme un caractère par la méthode lors de la détermination de l’emplacement d’un caractère.  
  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode vous permet de rechercher un jeu de caractères à partir d’une position de début spécifiée dans le texte du contrôle en spécifiant une valeur pour le `start` paramètre. La valeur zéro indique que la recherche doit commencer à partir du début du document du contrôle. Vous pouvez utiliser cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour affiner votre recherche pour éviter le texte que vous connaissez déjà ne contient pas les caractères spécifiés, vous recherchez ou ne sont pas importantes dans votre recherche.  
  
   
  
## Examples  
 L’exemple de code suivant recherche dans le contenu d’un <xref:System.Windows.Forms.RichTextBox> pour les caractères qui sont passés à la méthode dans le `text` paramètre. La recherche commence à partir de l’emplacement dans le <xref:System.Windows.Forms.RichTextBox> spécifié par le `start` paramètre de la `FindMyText` (méthode). Si le contenu du tableau de texte se trouve dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne l’index de la valeur est trouvée ; sinon, elle retourne -1. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` et un <xref:System.Windows.Forms.Button> contrôle nommé `button1` qui est connecté à la <xref:System.Windows.Forms.Control.Click> Gestionnaire d’événements défini dans le exemple.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Texte recherché dans le contrôle.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Recherche une chaîne dans le texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> en appliquant des options de recherche spécifiques.</summary>
        <returns>Emplacement du contrôle où le texte recherché a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche le texte spécifié dans le `str` paramètre et retourne l’emplacement du premier caractère dans le contrôle. Si la propriété retourne une valeur négative, la chaîne de texte recherchée est introuvable dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour créer des fonctionnalités de recherche qui peuvent être fournie à l’utilisateur du contrôle. Vous pouvez également utiliser cette méthode pour rechercher du texte à remplacer dans un format spécifique. Par exemple, si l’utilisateur a entré des dates dans le contrôle, vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher toutes les dates dans le document et les remplacer par le format approprié avant d’utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode du contrôle.  
  
 Avec cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> (méthode), vous pouvez spécifier des options qui vous permettent de développer ou affiner votre recherche. Vous pouvez spécifier des options qui permettent de vous pour correspondre à la casse du mot recherché ou pour rechercher des mots entiers au lieu de mots partiels. En spécifiant le `RichTextBoxFinds.Reverse` énumération dans le `options` paramètre, vous pouvez rechercher du texte à partir du bas du document vers le haut, au lieu de haut par défaut pour la méthode de recherche en bas.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthodes qui acceptent un `string` comme un paramètre ne peut pas rechercher du texte qui se trouve sur plusieurs lignes de texte dans le <xref:System.Windows.Forms.RichTextBox>. Ce type de recherche retournera la valeur moins un (-1).  
  
   
  
## Examples  
 L’exemple de code suivant parcourt le contenu d’un <xref:System.Windows.Forms.RichTextBox> pour la première instance d’une chaîne de recherche passé dans le paramètre de texte de la méthode. Si la chaîne recherchée est trouvée dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne une valeur de `true` et met en surbrillance le texte ; Sinon, elle retourne `false`. L’exemple spécifie également des options dans la recherche pour correspondre à la casse de la chaîne de recherche spécifié. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tableau de caractères à rechercher.</param>
        <param name="start">Position à laquelle débute la recherche dans le texte du contrôle.</param>
        <param name="end">Position à laquelle se termine la recherche dans le texte du contrôle.</param>
        <summary>Recherche dans une plage de texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> la première occurrence d'un caractère issu d'une liste.</summary>
        <returns>Emplacement du contrôle où les caractères recherchés ont été trouvés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche la première occurrence d’un caractère dans une liste de caractères spécifiés dans le `characterSet` paramètre et retourne l’emplacement du caractère. Par exemple, vous passez un tableau de caractères contenant le caractère « Q ». Si le contrôle contenue le texte « The Quick Brown Fox », le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode retournerait la valeur 4. Un caractère majuscule et un caractère minuscule sont considérés comme des valeurs différentes dans la recherche.  
  
 Si la propriété retourne une valeur négative, les caractères recherchés sont introuvables dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour rechercher un groupe de caractères dans le contrôle. Si un caractère à partir de la liste de caractères spécifiés dans la méthode `characterSet` paramètre est trouvé, la valeur retournée par cette méthode est une valeur de base zéro index de la position du caractère dans le contrôle. Un espace est considéré comme un caractère par la méthode lors de la détermination de l’emplacement d’un caractère.  
  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode vous permet de rechercher un jeu de caractères à partir d’une plage de texte dans le contrôle en spécifiant une valeur pour le `start` et `end` paramètres. Une valeur égale à zéro pour le `start` paramètre indique que la recherche doit commencer à partir du début du document du contrôle. Une valeur de-1 pour le `end` paramètre indique que la recherche doit se terminer à la fin du texte dans le contrôle. Vous pouvez utiliser cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour affiner votre recherche à une plage spécifique de texte dans le contrôle afin d’éviter de parcourir les parties du document qui ne sont pas importantes pour les besoins de votre application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="characterSet" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="start" /> est inférieur à 0 ou supérieur à la longueur du texte dans le contrôle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Texte recherché dans le contrôle.</param>
        <param name="start">Position à laquelle débute la recherche dans le texte du contrôle.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Recherche une chaîne à un emplacement spécifique dans le texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> en appliquant des options de recherche spécifiques.</summary>
        <returns>Emplacement du contrôle où le texte recherché a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche le texte spécifié dans le `str` paramètre et retourne l’emplacement du premier caractère de la recherche de chaîne dans le contrôle. Si la propriété retourne une valeur négative, la chaîne de texte recherchée est introuvable dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour créer des fonctionnalités de recherche qui peuvent être fournie à l’utilisateur du contrôle. Vous pouvez également utiliser cette méthode pour rechercher du texte à remplacer dans un format spécifique. Par exemple, si l’utilisateur a entré des dates dans le contrôle, vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher toutes les dates dans le document et les remplacer par le format approprié avant d’utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode du contrôle.  
  
 Avec cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> (méthode), vous pouvez spécifier des options qui vous permettent de développer ou affiner votre recherche. Vous pouvez spécifier des options qui permettent de vous pour correspondre à la casse du mot recherché ou pour rechercher des mots entiers au lieu de mots partiels. En spécifiant le `RichTextBoxFinds.Reverse` énumération dans le `options` paramètre, vous pouvez rechercher du texte à partir du bas du document vers le haut, au lieu de haut par défaut pour la méthode de recherche en bas. Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode vous permet également d’affiner la recherche de texte en sélectionnant une position de départ dans le texte du contrôle. Cette fonctionnalité peut vous permettre d’éviter le texte qui peut avoir déjà été recherché ou où le texte spécifique que vous recherchez ne connaît ne pas exister. Lorsque le `RichTextBoxFinds.Reverse` valeur est spécifiée dans le `options` paramètre, la valeur de le `start` paramètre indique la position où la recherche inversée prendra fin dans la mesure où la recherche démarre au bas du document lors de l’utilisation de cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> (méthode).  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthodes qui acceptent un `string` comme un paramètre ne peut pas rechercher du texte qui se trouve sur plusieurs lignes de texte dans le <xref:System.Windows.Forms.RichTextBox>. Ce type de recherche retournera la valeur moins un (-1).  
  
   
  
## Examples  
 L’exemple de code suivant parcourt le contenu d’un <xref:System.Windows.Forms.RichTextBox> pour la première instance d’une chaîne de recherche passé dans le paramètre de texte de la méthode. Emplacement de départ de la recherche est spécifiée par le paramètre start de la méthode. Si la chaîne recherchée est trouvée dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne l’emplacement d’index du premier caractère du texte trouvé et met en surbrillance le texte est trouvé ; sinon, elle retourne la valeur -1. L’exemple spécifie également des options dans la recherche pour correspondre à la casse de la chaîne de recherche spécifié. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> nommé `richTextBox1`. Vous pouvez utiliser cet exemple pour effectuer un type d’opération de « Suivant ». Une fois qu’une instance du texte recherché a été trouvée, vous trouverez d’autres instances du texte en modifiant la valeur de la `start` paramètre effectuer la recherche à un emplacement situé après la position de la correspondance actuelle.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Texte recherché dans le contrôle.</param>
        <param name="start">Position à laquelle débute la recherche dans le texte du contrôle.</param>
        <param name="end">Position à laquelle se termine la recherche dans le texte du contrôle. Cette valeur doit être égale à-1 ou supérieur ou égal à la <paramref name="start" /> paramètre.</param>
        <param name="options">Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Recherche une chaîne dans une plage de texte d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> en appliquant des options de recherche spécifiques.</summary>
        <returns>Emplacement du contrôle où le texte recherché a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode recherche le texte spécifié dans le `str` paramètre et retourne l’emplacement du premier caractère de la recherche de chaîne dans le contrôle. Si la propriété retourne une valeur négative, la chaîne de texte recherchée est introuvable dans le contenu du contrôle. Vous pouvez utiliser cette méthode pour créer des fonctionnalités de recherche qui peuvent être fournie à l’utilisateur du contrôle. Vous pouvez également utiliser cette méthode pour rechercher du texte à remplacer dans un format spécifique. Par exemple, si l’utilisateur a entré des dates dans le contrôle, vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher toutes les dates dans le document et les remplacer par le format approprié avant d’utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode du contrôle.  
  
 Avec cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> (méthode), vous pouvez spécifier des options qui vous permettent de développer ou affiner votre recherche. Vous pouvez spécifier des options qui permettent de vous pour correspondre à la casse du mot recherché ou pour rechercher des mots entiers au lieu de mots partiels. En spécifiant le `RichTextBoxFinds.Reverse` énumération dans le `options` paramètre, vous pouvez rechercher du texte à partir du bas du document vers le haut, au lieu de haut par défaut pour la méthode de recherche en bas. Cette version de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode vous permet également d’affiner la recherche de texte en sélectionnant une position de début et de fin spécifique dans le texte du contrôle. Cette fonctionnalité peut vous permettre de limiter la plage de recherche à une section spécifique du texte du contrôle. Si la valeur moins un (-1) est affecté à la `end` paramètre, la méthode recherche jusqu'à la fin du texte dans le <xref:System.Windows.Forms.RichTextBox> pour les recherches normales. Pour les recherches inversées, une valeur de négatif (-1 affecté à) la `end` paramètre indique le texte sera recherché à partir de la fin du texte (du bas) à la position définie par `start` paramètre. Lorsque le `start` et `end` paramètres sont fournis à la même valeur de l’ensemble du contrôle est recherchée pour les recherches normales. Pour une recherche inversée, l’ensemble du contrôle est recherché mais la recherche commence au bas du document vers le haut du document.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthodes qui acceptent un `string` comme un paramètre ne peut pas rechercher du texte qui se trouve sur plusieurs lignes de texte dans le <xref:System.Windows.Forms.RichTextBox>. Ce type de recherche retournera la valeur moins un (-1).  
  
   
  
## Examples  
 L’exemple de code suivant recherche dans une section de texte dans un <xref:System.Windows.Forms.RichTextBox> pour la première instance d’une chaîne de recherche passé dans le `searchText` paramètre de la méthode. La plage de recherche du texte dans le contrôle est spécifié par le `searchStart` et `searchEnd` paramètres de la méthode. Si la chaîne recherchée est trouvée dans le <xref:System.Windows.Forms.RichTextBox>, la méthode retourne l’emplacement d’index du premier caractère du texte trouvé et met en surbrillance le texte est trouvé ; sinon, elle retourne la valeur -1. L’exemple utilise également le `options` paramètre de la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour spécifier que le texte trouvé doit correspondre à la casse de la chaîne recherchée. L’exemple suppose que cette méthode est placée dans la classe d’un <xref:System.Windows.Forms.Form> qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`. Après la première instance de la chaîne recherchée a été trouvée, vous pouvez utiliser cet exemple pour rechercher d’autres instances dans le texte.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur du paramètre <paramref name="str" /> était <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="start" /> paramètre était inférieur à zéro.

ou 
Le paramètre <paramref name="end" /> était inférieur au paramètre <paramref name="start" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la police du texte affiché par le contrôle.</summary>
        <value><see cref="T:System.Drawing.Font" /> à appliquer au texte affiché par le contrôle. La valeur par défaut est la valeur de la propriété <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur de premier plan du contrôle.</summary>
        <value><see cref="T:System.Drawing.Color" /> qui représente la couleur de premier plan du contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetCharFromPosition : System.Drawing.Point -&gt; char" Usage="richTextBox.GetCharFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="pt">Emplacement où rechercher.</param>
        <summary>Récupère le caractère le plus proche de l'emplacement spécifié.</summary>
        <returns>Caractère situé à l'emplacement spécifié.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Emplacement où rechercher.</param>
        <summary>Récupère l'index du caractère le plus proche de l'emplacement spécifié.</summary>
        <returns>Index de base zéro du caractère situé à l'emplacement spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne l’index de caractère le plus proche de la position spécifiée dans le `pt` paramètre. L’index de caractère est un index de base zéro du texte dans le contrôle, y compris les espaces. Vous pouvez utiliser cette méthode pour déterminer où dans le texte de l’utilisateur dispose de la souris en passant des coordonnées de la souris à cette méthode. Cela peut être utile si vous souhaitez effectuer des tâches lorsque l’utilisateur place le pointeur de la souris sur un mot dans le texte du contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> méthode avec le <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher une chaîne spécifique dans un <xref:System.Windows.Forms.RichTextBox> contrôler et d’afficher l’index de caractère où la chaîne trouvée est située dans le <xref:System.Windows.Forms.RichTextBox> contrôle. L’exemple recherche le mot « brown » dans le contenu du contrôle et retourne la position d’index de caractère où la chaîne recherchée est trouvée. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` qui contient du texte. Il suppose également que le code dans l’exemple est associé à la <xref:System.Windows.Forms.Control.MouseDown> événements de la <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position de l'index de caractère à rechercher.</param>
        <summary>Récupère le numéro de ligne à partir de la position de caractère spécifiée dans le texte du contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Numéro (base zéro) de la ligne où se trouve l'index de caractère.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vous permet de déterminer le numéro de ligne en fonction de l’index de caractère spécifié dans le `index` paramètre de la méthode. La première ligne de texte dans le contrôle retourne la valeur zéro. Le <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> méthode retourne le numéro de ligne physique où le caractère indexé se trouve dans le contrôle. Par exemple, si une partie de la première ligne logique du texte dans le contrôle est renvoyé à la ligne suivante, le <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> méthode retourne 1 si le caractère situé à l’index de caractère spécifié a encapsulé à la deuxième ligne physique. Si <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> a la valeur `false`, aucune partie de la ligne est renvoyé à l’autre, et la méthode retourne 0 pour l’index de caractère spécifié. Vous pouvez utiliser cette méthode pour déterminer la ligne à laquelle un index de caractère spécifique dans. Par exemple, après avoir appelé la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour rechercher du texte, vous pouvez obtenir l’index de caractère à où sont trouvent les résultats de recherche. Vous pouvez appeler cette méthode avec l’index de caractère retourné par la <xref:System.Windows.Forms.RichTextBox.Find%2A> méthode pour déterminer quelle ligne le mot a été trouvé.  
  
 Dans certains cas, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> ne lève pas d’exception lorsque le `index` paramètre est une valeur non valide. Exemple :  
  
-   Si le `index` paramètre est <xref:System.Int32.MinValue> ou -1, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> retourne 0.  
  
-   Si le `index` paramètre est la longueur du texte ou <xref:System.Int32.MaxValue>, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> renvoie le numéro de la dernière ligne de texte, qui n’est pas nécessairement le même en tant que `Lines.Length-1`, selon la valeur de la <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> propriété.  
  
 Dans ces cas, validez l’entrée avant d’appeler <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>.  
  
> [!NOTE]
>  Si l’index de caractère spécifié dans le `index` paramètre est au-delà du nombre de lignes contenues dans le contrôle, le dernier numéro de ligne est renvoyé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> (méthode). Pour exécuter l’exemple, collez le code suivant dans un formulaire contenant un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `RichTextBox1`, un bouton nommé `Button1` et deux zones de texte nommés `TextBox1` et `TextBox2`. Lorsque l’exemple est en cours d’exécution, entrez une chaîne de recherche dans `TextBox2` et cliquez sur le bouton pour obtenir des résultats de la recherche.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index du caractère dont l'emplacement doit être récupéré.</param>
        <summary>Récupère l'emplacement de l'index de caractère spécifié dans le contrôle.</summary>
        <returns>Emplacement du caractère spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vous permet de déterminer où se trouve un index de caractère spécifique dans le contrôle. Vous pouvez utiliser cette méthode pour des tâches telles que l’affichage de menu contextuel éléments ou à l’aide des informations d’un mot dans le contrôle. Par exemple, si vous souhaitez afficher un menu d’options à l’utilisateur lorsque l’utilisateur clique le bouton droit sur un mot dans le contrôle, vous pouvez utiliser cette méthode pour déterminer la position du mot pour afficher correctement un <xref:System.Windows.Forms.ContextMenu> contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit pendant une opération glisser.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne concerne pas cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique sur la barre de défilement horizontale du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.HScroll> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.HScroll> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur change de méthode d'entrée dans une version asiatique du système d'exploitation Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.ImeChange> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.ImeChange> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique des paramètres <see cref="T:System.Windows.Forms.RichTextBox" /> pour l'Éditeur de méthode d'entrée (IME) et la prise en charge des langues asiatiques.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" />. La valeur par défaut est <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique sur un lien dans le texte du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez créer un gestionnaire d’événements pour cet événement traiter un lien qui a été cliqué dans le contrôle. Avec les informations fournies au gestionnaire d’événements, vous pouvez déterminer un utilisateur a cliqué sur le lien dans le document.  
  
> [!IMPORTANT]
>  Par défaut, les liens sont affichés sous forme de texte et ne sont pas interactifs. Pour les rendre ensemble interactif le <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> propriété `true`.  
  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant contient un gestionnaire d’événements pour le <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement. Le Gestionnaire d’événements traite les clics sur le lien dans le document d’un <xref:System.Windows.Forms.RichTextBox> contrôler et lance une instance du navigateur par défaut (à l’aide de la <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> méthode), affichant la page pour le lien qui a été cliqué. Cet exemple nécessite que le Gestionnaire d’événements a été connecté à la <xref:System.Windows.Forms.RichTextBox.LinkClicked> événement pour un <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge le contenu d'un fichier dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom et emplacement du fichier à charger dans le contrôle.</param>
        <summary>Charge un fichier RTF ou un fichier texte ASCII standard dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du chargement d’un fichier avec le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode), le contenu du fichier en cours de chargement remplace tout le contenu de la <xref:System.Windows.Forms.RichTextBox> contrôle. Ainsi, les valeurs de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> et <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriétés à modifier. Vous pouvez utiliser cette méthode pour charger un document RTF ou un texte créé précédemment dans le contrôle pour la manipulation. Si vous souhaitez enregistrer le fichier, vous pouvez utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> (méthode).  
  
> [!NOTE]
>  Avec cette version de la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode), si le fichier chargé n’est pas un document RTF, une exception se produira. Pour charger un autre type de fichier tel qu’un fichier texte ASCII, utilisez les autres versions de cette méthode qui accepte une valeur comprise entre le <xref:System.Windows.Forms.RichTextBoxStreamType> énumération en tant que paramètre.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode s’ouvre pas un fichier jusqu'à ce que la création d’un handle pour le <xref:System.Windows.Forms.RichTextBox>. Assurez-vous que le handle du contrôle est créé avant d’appeler le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant ouvre un fichier RTF dans le <xref:System.Windows.Forms.RichTextBox> contrôle. L’exemple utilise la <xref:System.Windows.Forms.OpenFileDialog> classe pour afficher une boîte de dialogue pour demander le fichier à partir de l’utilisateur. Le code charge ensuite ce fichier en supposant qu’il s’agit d’un RTF fichier du document. Si le fichier n’est pas, l’exemple de code lève une exception. Cet exemple requiert que le code est placé dans un <xref:System.Windows.Forms.Form> classe a un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur s'est produite lors du chargement du fichier dans le contrôle.</exception>
        <exception cref="T:System.ArgumentException">Le fichier chargé n'est pas un document RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour ouvrir un fichier. Énumération associée : Le <see langword="Read" /> valeur <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Flux de données à charger dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</param>
        <param name="fileType">Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Charge le contenu d'un flux de données existant dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette version de la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour charger le <xref:System.Windows.Forms.RichTextBox> avec des données à partir d’un flux de données existant. Les données sont chargées dans le contrôle remplacent tout le contenu de la <xref:System.Windows.Forms.RichTextBox> contrôle. Ainsi, les valeurs de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> et <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriétés à modifier. Vous pouvez utiliser cette méthode pour charger un fichier qui a été précédemment ouvert dans un flux de données dans le contrôle pour la manipulation. Si vous souhaitez enregistrer le contenu du contrôle dans le flux de données, vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode qui accepte un <xref:System.IO.Stream> objet en tant que paramètre.  
  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode vous permet également de spécifier le type de données qui est chargés dans le contrôle. Cette fonctionnalité vous permet d’utiliser des flux de données qui contiennent des données autres que des documents de format RTF de texte enrichi dans le contrôle.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode s’ouvre pas un fichier jusqu'à ce que la création d’un handle pour le <xref:System.Windows.Forms.RichTextBox>. Assurez-vous que le handle du contrôle est créé avant d’appeler le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> et <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthodes avec des flux. Il montre également comment utiliser le <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, et <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> membres.  
  
 Il s’agit d’un exemple complet qui est prêt à exécuter lorsque vous la copiez à votre projet.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur s'est produite lors du chargement du fichier dans le contrôle.</exception>
        <exception cref="T:System.ArgumentException">Le fichier chargé n'est pas un document RTF.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Nom et emplacement du fichier à charger dans le contrôle.</param>
        <param name="fileType">Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Charge un type de fichier spécifique dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du chargement d’un fichier avec le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode), le contenu du fichier en cours de chargement remplace tout le contenu de la <xref:System.Windows.Forms.RichTextBox> contrôle. Ainsi, les valeurs de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> et <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriétés à modifier. Vous pouvez utiliser cette méthode pour charger un texte créé précédemment ou un document de format RTF de texte enrichi dans le contrôle pour la manipulation. Si vous souhaitez enregistrer le fichier, vous pouvez utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> (méthode).  
  
 Vous pouvez utiliser cette version de la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour spécifier le type de fichier du fichier en cours de chargement. Cette fonctionnalité vous permet de charger des fichiers autres que des documents RTF dans le contrôle.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode s’ouvre pas un fichier jusqu'à ce que la création d’un handle pour le <xref:System.Windows.Forms.RichTextBox>. Assurez-vous que le handle du contrôle est créé avant d’appeler le <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant ouvre un fichier texte dans le <xref:System.Windows.Forms.RichTextBox> contrôle. L’exemple utilise la <xref:System.Windows.Forms.OpenFileDialog> classe pour afficher une boîte de dialogue pour demander le fichier à partir de l’utilisateur. Le code charge ensuite ce fichier dans le <xref:System.Windows.Forms.RichTextBox> contrôle. L’exemple utilise cette version de la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour spécifier que le fichier est ouvert en tant que fichier texte ASCII au lieu du format RTF standard. Cet exemple requiert que le code est placé dans un <xref:System.Windows.Forms.Form> classe a un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur s'est produite lors du chargement du fichier dans le contrôle.</exception>
        <exception cref="T:System.ArgumentException">Le fichier chargé n'est pas un document RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour ouvrir un fichier. Énumération associée : Le <see langword="Read" /> valeur <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre maximal de caractères que l'utilisateur peut taper ou coller dans le contrôle RichTextBox.</summary>
        <value>Nombre maximal de caractères pouvant être entré dans le contrôle. La valeur par défaut est <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété est définie sur 0, la longueur maximale du texte qui peut être entré dans le contrôle est de 64 Ko de caractères. Cette propriété est généralement utilisée lorsque le <xref:System.Windows.Forms.RichTextBox> est utilisé pour afficher une seule ligne de texte de format RTF de texte enrichi. Vous pouvez utiliser cette propriété pour limiter la longueur du texte entré dans le contrôle pour les valeurs comme les numéros de téléphone et les codes postaux, ou pour limiter la longueur du texte entré lorsque les données à entrer dans une base de données. Vous pouvez limiter le texte entré dans le contrôle à la longueur maximale du champ correspondant dans la base de données.  
  
> [!NOTE]
>  Dans le code, vous pouvez définir la valeur de la <xref:System.Windows.Forms.TextBoxBase.Text%2A> propriété une valeur qui a une longueur supérieure à la valeur spécifiée par le <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propriété. Cette propriété affecte uniquement le texte entré dans le contrôle au moment de l’exécution.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> propriété afin de déterminer si le texte assigné à un <xref:System.Windows.Forms.RichTextBox> contrôle est supérieur à la valeur affectée à la <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> propriété. Si le texte n’est pas supérieur, l’exemple utilise le <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> propriété à attribuer le texte au contrôle. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté à un formulaire et que la méthode dans l’exemple est appelée avec le texte fourni au paramètre qui doit être collé dans le contrôle. L’exemple exige également que le <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> propriété a été définie sur une valeur pour limiter la saisie de texte dans le <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur assignée à la propriété est inférieure à 0.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant s'il s'agit d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> multiligne.</summary>
        <value><see langword="true" /> si le contrôle est un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> multiligne ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.ContentsResizedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.HScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.LinkClickedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.Protected" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected override void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">Objet qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.SystemColorsChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="richTextBox.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">Objet qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.RichTextBox.VScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Format de Presse-papiers dans lequel les données doivent être obtenues du Presse-papiers.</param>
        <summary>Colle le contenu du Presse-papiers dans le format de Presse-papiers spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour coller des données à partir du Presse-papiers dans le contrôle. Cette version de la <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode diffère de la <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> de la méthode vous permet de coller uniquement du texte dans un format de Presse-papiers spécifié. Vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> méthode pour déterminer si les données dans le Presse-papiers sont au format de Presse-papiers spécifié. Vous pouvez ensuite appeler cette version de la <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode pour vous assurer que l’opération de collage est effectuée avec le format de données approprié.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode pour coller une bitmap dans le <xref:System.Windows.Forms.RichTextBox> contrôle. Après l’ouverture d’une image bitmap à partir du fichier, l’exemple utilise le <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> méthode pour copier l’image bitmap dans le Presse-papiers Windows. Enfin, l’exemple récupère le format de la <xref:System.Drawing.Bitmap> d’objet, vérifie que le format peut être collé dans le <xref:System.Windows.Forms.RichTextBox> contrôle et utilise le <xref:System.Windows.Forms.RichTextBox.Paste%2A> méthode pour coller les données.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour la lecture à partir du Presse-papiers. Énumération associée : le <see langword="AllClipboard" /> valeur <see cref="T:System.Security.Permissions.UIPermissionClipboard" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" />, passé par référence, qui représente le message de fenêtre à traiter.</param>
        <param name="keyData">Une des valeurs <see cref="T:System.Windows.Forms.Keys" /> qui représente la touche à traiter.</param>
        <summary>Traite une touche de commande.</summary>
        <returns><see langword="true" /> si le caractère a été traité par le contrôle ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur essaie de modifier du texte protégé dans le contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez créer un gestionnaire d’événements pour cet événement dans vos applications pour déterminer quand l’utilisateur a tenté de modifier le texte qui a été marqué comme protégé dans le contrôle. Le Gestionnaire d’événements peut être utilisé pour notifier l’utilisateur que le texte de l’utilisateur tente de modifier est protégé ou pour afficher une boîte de dialogue qui permet à l’utilisateur d’apporter les modifications appropriées au texte. Par exemple, si la zone protégée est une date, vous pouvez afficher une boîte de dialogue qui permet à l’utilisateur à choisir une date qui peut ensuite être appliquée au texte du contrôle.  
  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.Protected> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.Protected> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cet événement ne concerne pas cette classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement ne concerne pas cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applique à nouveau la dernière opération qui a été annulée dans le contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez ensuite utiliser le <xref:System.Windows.Forms.RichTextBox.Redo%2A> méthode réappliquer la dernière opération d’annulation au contrôle. Le <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> méthode vous permet de déterminer si la dernière opération annulée par l’utilisateur peut être réappliquée au contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> et <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriétés et le <xref:System.Windows.Forms.RichTextBox.Redo%2A> (méthode), pour limiter une opération de restauration par progression à une action à l’exception de la suppression de texte. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle et qui une opération dans le <xref:System.Windows.Forms.RichTextBox> a été effectuée et annulée avant le code dans cet exemple est appelé.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'action qui peut être appliquée à nouveau au contrôle lorsque la méthode <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> est appelée.</summary>
        <value>Chaîne représentant le nom de l'action qui sera effectuée lors d'un appel à la méthode <see cref="M:System.Windows.Forms.RichTextBox.Redo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété retourne une chaîne vide (" »), il n’existe aucune opération pouvant être réappliquée au contrôle. Vous pouvez utiliser cette méthode pour déterminer la dernière action annulée dans le <xref:System.Windows.Forms.RichTextBox> contrôle qui peut ensuite être appliquée à nouveau le contrôle lorsqu’un appel à la <xref:System.Windows.Forms.RichTextBox.Redo%2A> méthode est effectuée. Vous pouvez déterminer s’il existe des opérations à être réappliquée au contrôle à l’aide de la <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> et <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> propriétés et le <xref:System.Windows.Forms.RichTextBox.Redo%2A> (méthode), pour limiter une opération de restauration par progression à une action à l’exception de la suppression de texte. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle et qui une opération dans le <xref:System.Windows.Forms.RichTextBox> a été effectuée et annulée avant le code dans cet exemple est appelé.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cette propriété ne s'applique pas à cette classe.</summary>
        <value><see langword="true" /> si les touches de raccourci sont activées ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété ne s'applique pas à cette classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille d'une seule ligne de texte dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Taille en pixels d'une ligne de texte dans le contrôle. La valeur par défaut est zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une valeur supérieure à zéro est entrée dans le contrôle, une marge non visibles est placée dans le contrôle au nombre spécifié de pixels compris entre le côté gauche du contrôle. Tout texte entré qui s’étend au-delà de cette marge est placé sur la ligne suivante du texte dans le contrôle. Cette propriété affecte tout le texte entré actuellement dans le contrôle ainsi que le texte entré dans le contrôle une fois que la propriété est définie. Vous pouvez utiliser cette propriété pour spécifier une largeur de ligne maximale pour tout le texte entré dans un <xref:System.Windows.Forms.RichTextBox> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Windows.Forms.RichTextBox> qui se concentre sur le texte, sélectionne automatiquement des mots dans le texte du contrôle lorsque l’utilisateur double-clique sur un mot et comporte une marge à droite de la zone cliente du contrôle. Si le <xref:System.Windows.Forms.RichTextBox> contrôle a une largeur de petites, à l’aide de ce code crée un <xref:System.Windows.Forms.RichTextBox> où chaque caractère du texte s’affiche sur sa propre ligne. Dans cette position d’affichage vertical, en cliquant sur n’importe quelle partie d’un mot sélectionne tous les caractères du mot indépendamment du fait que le texte est affiché verticalement. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée est inférieure à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte du contrôle <see cref="T:System.Windows.Forms.RichTextBox" />, y compris tous les codes RTF (Rich Text Format).</summary>
        <value>Texte du contrôle au format RTF.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour positionner le texte au format RTF dans le contrôle pour l’affichage ou pour extraire le texte du contrôle de mise en forme de RTF spécifié défini dans le texte du contrôle. Cette propriété est généralement utilisée lorsque vous affectez texte RTF à partir d’une autre source RTF, tels que Microsoft Word ou WordPad de Windows, au contrôle.  
  
 Si vous modifiez le <xref:System.Windows.Forms.Control.RightToLeft%2A> propriété au moment de l’exécution, seul le texte brut sans mise en forme est conservée.  
  
 Pour les codes RTF, consultez « format texte enrichi (RTF) Specification, version 1.6 » dans MSDN library à le http://msdn.microsoft.com/library.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Enregistre le contenu du contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> dans un fichier.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom et emplacement du fichier à enregistrer.</param>
        <summary>Enregistre le contenu de <see cref="T:System.Windows.Forms.RichTextBox" /> dans un fichier RTF.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode vous permet d’enregistrer tout le contenu du contrôle dans un fichier RTF qui peut être utilisé par d’autres programmes tels que Microsoft Word et WordPad de Windows. Si le nom du fichier qui est passée à la `path` paramètre existe déjà dans le répertoire spécifié, le fichier est remplacé sans préavis. Vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour charger le contenu d’un fichier dans le <xref:System.Windows.Forms.RichTextBox>.  
  
> [!NOTE]
>  Pour enregistrer le contenu du contrôle dans un autre type de format de fichier comme texte ASCII, utilisez les autres versions de cette méthode qui accepte une valeur comprise entre le <xref:System.Windows.Forms.RichTextBoxStreamType> énumération en tant que paramètre.  
  
   
  
## Examples  
 L’exemple de code suivant enregistre le contenu d’un <xref:System.Windows.Forms.RichTextBox> contrôle dans un fichier RTF. L’exemple utilise la <xref:System.Windows.Forms.SaveFileDialog> classe pour afficher une boîte de dialogue pour demander à l’utilisateur, le chemin d’accès et le nom du fichier à enregistrer. Le code enregistre ensuite le fichier en supposant que le contenu est au format RTF. Si le fichier existe déjà, il est automatiquement remplacé. Cet exemple requiert que le code est placé dans un <xref:System.Windows.Forms.Form> classe a un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">une erreur s'est produite durant l'enregistrement du contenu du contrôle dans un fichier.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Flux de données qui contient le fichier de destination.</param>
        <param name="fileType">Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Enregistre le contenu d'un contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> dans un flux de données ouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode vous permet d’enregistrer tout le contenu du contrôle dans le flux de données qui est déjà ouvert. Le flux de données peut ensuite enregistrer les informations dans un fichier. Vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour charger le contenu d’un fichier dans le <xref:System.Windows.Forms.RichTextBox>.  
  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode vous permet également de spécifier un format de données des informations qui seront envoyées à la <xref:System.IO.Stream> objet.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> et <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthodes avec des flux. Il montre également comment utiliser le <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, et <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> membres.  
  
 Il s’agit d’un exemple complet qui est prêt à exécuter lorsque vous la copiez à votre projet.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="fileType" /> contient un type de fichier non valide.</exception>
        <exception cref="T:System.IO.IOException">une erreur s'est produite durant l'enregistrement du contenu du contrôle dans un fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la création ou modification d’un fichier. Énumération associée : Le <see langword="Write" /> valeur <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Nom et emplacement du fichier à enregistrer.</param>
        <param name="fileType">Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Enregistre le contenu du contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> dans un type de fichier spécifique.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode vous permet d’enregistrer tout le contenu du contrôle dans un fichier RTF qui peut être utilisé par d’autres programmes tels que Microsoft Word et WordPad de Windows. Si le nom du fichier qui est passée à la `path` paramètre existe déjà dans le répertoire spécifié, le fichier est remplacé sans préavis. Vous pouvez utiliser la <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> méthode pour charger le contenu d’un fichier dans le <xref:System.Windows.Forms.RichTextBox>.  
  
 Cette version de la <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode vous permet de spécifier un type de fichier pour enregistrer le contenu du contrôle à. Vous pouvez utiliser cette fonctionnalité pour vous assurer que le fichier est enregistré dans le format approprié en fonction du contenu du contrôle. Par exemple, si votre document n’a pas de différences dans le style de police ou la coloration, vous pouvez enregistrer le fichier en tant que fichier texte ASCII en définissant le `fileType` paramètre `RichTextBoxStreamType.PlainText`.  
  
   
  
## Examples  
 L’exemple de code suivant enregistre le contenu de la <xref:System.Windows.Forms.RichTextBox> dans un fichier texte ASCII. L’exemple utilise la <xref:System.Windows.Forms.SaveFileDialog> classe pour afficher une boîte de dialogue pour demander le chemin d’accès et le nom de l’utilisateur. Le code enregistre ensuite le contenu du contrôle à ce fichier. L’exemple utilise cette version de la <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> méthode pour spécifier que le fichier est enregistré en tant que fichier texte ASCII au lieu du format RTF standard. Cet exemple requiert que le code est placé dans un <xref:System.Windows.Forms.Form> classe a un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="fileType" /> contient un type de fichier non valide.</exception>
        <exception cref="T:System.IO.IOException">une erreur s'est produite durant l'enregistrement du contenu du contrôle dans un fichier.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour la création ou modification d’un fichier. Énumération associée : Le <see langword="Write" /> valeur <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de barres de défilement à afficher dans le contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />. La valeur par défaut est <see langword="RichTextBoxScrollBars.Both" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de fournir des barres de défilement horizontale et verticale à l’utilisateur de la <xref:System.Windows.Forms.RichTextBox> contrôle pour faire défiler le texte dans le contrôle qui se trouve en dehors des physiques dimensions du contrôle. Vous pouvez également utiliser cette propriété pour supprimer les barres de défilement du contrôle à restreindre faisant défiler le contenu du contrôle.  
  
> [!NOTE]
>  Barres de défilement horizontale n’apparaît pas si le <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> est `true`, quelle que soit la valeur de la <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée n'est pas définie dans l'énumération <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />.</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte mis en forme au format RTF actuellement sélectionné dans le contrôle.</summary>
        <value>Texte RTF sélectionné dans le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet d’obtenir le texte sélectionné dans le contrôle, y compris la mise en forme des codes RTF. Vous pouvez utiliser cette propriété pour copier du texte à partir de votre contrôle, avec mise en forme et coller le texte dans d’autres applications qui acceptent RTF texte mis en forme, telles que Microsoft Word et WordPad de Windows. Pour obtenir le texte sélectionné, sans les codes de mise en forme RTF, utilisez la <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> propriété.  
  
 Si aucun texte n’est actuellement sélectionné, le texte spécifié dans cette propriété est inséré au point d’insertion. Si le texte est sélectionné, n’importe quel texte assigné à cette propriété remplace le texte sélectionné.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte sélectionné dans <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Chaîne qui représente le texte sélectionné dans le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriété avec le <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, et <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriétés pour créer une liste à puces dans un <xref:System.Windows.Forms.RichTextBox> contrôle. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` est créé sur un formulaire.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'alignement à appliquer à la sélection ou au point d'insertion en cours.</summary>
        <value>Une des valeurs de <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun paragraphe n’est sélectionné dans le contrôle, cette propriété s’applique le paramètre d’alignement pour le paragraphe dans lequel le point d’insertion apparaît également aux paragraphes créés après le paragraphe qui a le paramètre de propriété d’alignement. Par exemple, s’il existe deux paragraphes dans un <xref:System.Windows.Forms.RichTextBox> contrôle et le point d’insertion se trouve dans le second. Si vous définissez la <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> propriété `HorizontalAlignment.Center`, le paragraphe au point d’insertion sera centré dans le contrôle. Si un troisième paragraphe est créé après le deuxième paragraphe, il est également aligné au centre du contrôle.  
  
 Si une sélection est effectuée dans le contrôle lorsque la propriété est définie, tous les paragraphes sélectionnés sont alignés en fonction de ce paramètre de propriété. Vous pouvez utiliser cette propriété pour aligner les paragraphes d’un document en cours de création dans le <xref:System.Windows.Forms.RichTextBox>. Par exemple, si vous souhaitez que tous les paragraphes d’un document est centrée, vous pouvez sélectionner tous les paragraphes dans le contrôle et définir le <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> propriété `HorizontalAlignment.Center`.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> Retourne `SelectionAlignment.Left` lorsque la sélection de texte contient plusieurs paragraphes avec un alignement mixte.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment aligner le texte dans le <xref:System.Windows.Forms.RichTextBox>. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">La valeur spécifiée n'est pas une valeur définie dans la classe <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur du texte lorsque le texte est sélectionné dans un contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value><see cref="T:System.Drawing.Color" /> qui représente la couleur du texte lorsque le texte est sélectionné. La valeur par défaut est la valeur de la propriété <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> pour obtenir ou définir la couleur du texte sélectionné dans le <xref:System.Windows.Forms.RichTextBox>. Si aucun texte n’est actuellement sélectionné, le <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> propriété s’applique à la position actuelle du signe insertion. Les caractères qui sont entrés à partir de cette position ont spécifié <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le style de liste à puces est appliqué à la sélection actuelle ou au point d'insertion.</summary>
        <value><see langword="true" /> si la sélection actuelle ou le point d'insertion reçoit le style de liste à puces ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun texte n’est sélectionné, le style de puce est appliqué au point d’insertion actuel et à tous les paragraphes entrée par l’utilisateur après le point d’insertion. Le style de puce est appliqué au texte du contrôle jusqu'à ce que le point d’insertion est déplacé ou lorsque l’utilisateur appuie sur la touche entrée sur un élément de liste vide.  
  
 Si le texte est sélectionné dans le contrôle lorsque cette propriété est définie, tous les paragraphes dans le texte sélectionné sont convertis en éléments de liste à puces dans la liste à puces. Vous pouvez utiliser cette propriété pour créer des listes à puces dans les documents que vous créez dans le <xref:System.Windows.Forms.RichTextBox> contrôle.  
  
 Le <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> propriété vous permet de spécifier la quantité de mise en retrait à appliquer entre la puce et le texte de l’élément de liste.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> propriété avec le <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, et <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriétés pour créer une liste à puces dans un <xref:System.Windows.Forms.RichTextBox> contrôle. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1` est créé sur un formulaire.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit suite à la modification du texte sélectionné dans le contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez créer un gestionnaire d’événements pour cet événement déterminer quand l’utilisateur a modifié la sélection de texte dans le contrôle. Un gestionnaire d’événements pour cet événement peut être utilisé pour conserver le texte sélectionné jusqu'à ce que l’utilisateur a terminé une tâche dans l’application.  
  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.SelectionChanged> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.SelectionChanged> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le texte du contrôle s'affiche sur la ligne de base, au-dessus de la ligne de base (exposant) ou au-dessous de la ligne de base (indice).</summary>
        <value>Nombre qui signifie l'offset des caractères.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété doit être comprise entre -2000 et 2000.  
  
 Si cette propriété est définie à zéro, le texte apparaît sur la ligne de base. Si c’est un nombre positif, le nombre indique le nombre de pixels à utiliser déclencher la sélection de texte au-dessus de la ligne de base. Si c’est un nombre négatif, ce nombre spécifie le nombre de pixels selon lequel indice la sélection de texte. Vous pouvez utiliser cette propriété pour spécifier le texte en exposant ou indice.  
  
 Si aucun texte n’est sélectionné, l’offset est appliqué au point d’insertion actuel et à tout le texte que l’utilisateur tape après le point d’insertion. L’offset de caractère s’applique jusqu'à ce que la propriété est modifiée sur une autre valeur, ou jusqu'à ce que le point d’insertion est déplacé vers une autre section dans le contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour créer du texte en exposant et indice pour des applications telles que les expressions mathématiques.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment spécifier du texte en exposant et indice dans le <xref:System.Windows.Forms.RichTextBox> à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> propriété. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée est inférieure à -2000 ou supérieure à 2000.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur du texte de la sélection actuelle ou du point d'insertion.</summary>
        <value><see cref="T:System.Drawing.Color" /> qui représente la couleur à appliquer à la sélection de texte en cours ou au texte entré après le point d'insertion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la sélection de texte actuelle a plus d’une couleur spécifiée, cette propriété retourne `Color.Empty`. Si aucun texte n’est actuellement sélectionné, la couleur du texte spécifiée dans cette propriété est appliquée au point d’insertion actuel et à tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de couleur de texte s’applique jusqu'à ce que la propriété est modifiée sur une couleur différente ou jusqu'à ce que le point d’insertion est déplacé vers une autre section dans le contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour modifier la couleur du texte dans le <xref:System.Windows.Forms.RichTextBox>.  
  
 Pour rendre le texte en gras dans le contrôle, utilisez le <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> propriété à attribuer une nouvelle police qui a le style de police gras spécifié.  
  
   
  
## Examples  
 Le code suivant exemple affiche un <xref:System.Windows.Forms.ColorDialog> à l’utilisateur de spécifier une couleur pour le texte actuellement sélectionné ou le texte entré après l’insertion actuelle point dans un <xref:System.Windows.Forms.RichTextBox> contrôle. Cet exemple suppose que la méthode définie dans l’exemple est ajoutée à un <xref:System.Windows.Forms.Form> classe qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la police du texte de la sélection actuelle ou du point d'insertion.</summary>
        <value><see cref="T:System.Drawing.Font" /> qui représente la police à appliquer à la sélection de texte en cours ou au texte entré après le point d'insertion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la sélection de texte actuelle a plus d’une police spécifiée, cette propriété est `null`. Si aucun texte n’est actuellement sélectionné, la police spécifiée dans cette propriété est appliquée au point d’insertion actuel et à tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de police s’applique jusqu'à ce que la propriété est modifiée de police ou jusqu'à ce que le point d’insertion est déplacé vers une autre section dans le contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour modifier le style de police du texte dans le <xref:System.Windows.Forms.RichTextBox>. Vous pouvez mettre le texte dans le contrôle en gras, italique et souligné. Vous pouvez également modifier la taille du texte et la police appliquée au texte.  
  
 Pour modifier la couleur du texte dans le contrôle, utilisez le <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant modifie le style gras de la police actuelle pour la sélection de texte ou le texte entré après le point d’insertion dans la <xref:System.Windows.Forms.RichTextBox> contrôle. Cet exemple requiert que le code est contenu dans une méthode dans un <xref:System.Windows.Forms.Form>. L’exemple exige également qu’un <xref:System.Windows.Forms.RichTextBox>, nommé `richTextBox1`, a été ajouté à la <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la distance entre le bord gauche de la première ligne de texte dans le paragraphe sélectionné et le bord gauche des lignes de texte suivantes dans le même paragraphe.</summary>
        <value>Distance en pixels du retrait négatif appliqué au texte actuellement sélectionné ou au point d'insertion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun texte n’est actuellement sélectionné, le retrait négatif est appliqué au paragraphe dans lequel le point d’insertion apparaît et à tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de mise en retrait négatif s’applique jusqu'à ce que la propriété est modifiée sur une autre valeur, ou jusqu'à ce que le point d’insertion est déplacé vers un autre paragraphe du contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour appliquer un retrait négatif à vos paragraphes.  
  
 Pour définir la mise en retrait de la première ligne d’une sélection de paragraphe, utilisez la <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment spécifier des retraits dans le <xref:System.Windows.Forms.RichTextBox> à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriété. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la longueur, en pixels, de la mise en retrait de la ligne d'où la sélection démarre.</summary>
        <value>Distance en pixels de la mise en retrait appliquée à gauche du texte actuellement sélectionné ou au point d'insertion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun texte n’est actuellement sélectionné, le paramètre de mise en retrait est appliqué pour le paragraphe dans lequel le point d’insertion apparaît et tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de mise en retrait s’applique jusqu'à ce que la propriété est modifiée sur une autre valeur, ou jusqu'à ce que le point d’insertion est déplacé vers un autre paragraphe du contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour mettre en retrait des paragraphes du document de la <xref:System.Windows.Forms.RichTextBox>. Vous pouvez utiliser cette propriété conjointement avec la <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> pour créer des paragraphes affichés dans les paragraphes.  
  
 Pour créer un retrait négatif des paragraphes dans le contrôle, utilisez le <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment spécifier du texte mis en retrait dans les <xref:System.Windows.Forms.RichTextBox> à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> propriété. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nombre de caractères sélectionnés dans le contrôle.</summary>
        <value>Nombre de caractères sélectionnés dans la zone de texte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour déterminer si des caractères sont actuellement sélectionnés dans le contrôle de zone de texte avant d’effectuer des opérations sur le texte sélectionné. Vous pouvez également utiliser cette propriété pour déterminer le nombre total de caractères (y compris les espaces) qui soient sélectionnés lors de l’exécution de caractère unique des tâches dans un `for` boucle.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> propriété afin de déterminer si le texte est sélectionné dans le <xref:System.Windows.Forms.RichTextBox>. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire. L’exemple exige également que `richTextBox1` contient le texte est sélectionné dans le contrôle.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si la sélection de texte actuelle est protégée.</summary>
        <value><see langword="true" /> si la sélection actuelle empêche toute modification de son contenu ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun texte n’est actuellement sélectionné, le paramètre de protection est appliqué au paragraphe dans lequel le point d’insertion apparaît et à tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de protection s’applique jusqu'à ce que la propriété est modifiée sur une autre valeur, ou jusqu'à ce que le point d’insertion est déplacé vers un autre paragraphe du contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour empêcher l’utilisateur de modifier des sections de texte dans le contrôle.  
  
 Si cette propriété est définie sur `true`, le <xref:System.Windows.Forms.RichTextBox.Protected> événement est déclenché lorsque l’utilisateur tente de modifier la sélection de texte actuelle.  
  
> [!NOTE]
>  Cette propriété retourne `true` uniquement si l’ensemble de la sélection dans le contrôle contient un contenu protégé.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment spécifier du texte protégé dans le <xref:System.Windows.Forms.RichTextBox> à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> propriété. Cet exemple suppose qu’un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, a été ajouté au formulaire et qui le <xref:System.Windows.Forms.RichTextBox> contrôle a le texte qui contient le mot « RichTextBox ».  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Distance (en pixels) entre le bord droit du contrôle <see cref="T:System.Windows.Forms.RichTextBox" /> et le bord droit du texte sélectionné ou ajouté au point d'insertion actuel.</summary>
        <value>Mise en retrait en pixels à droite de la sélection en cours ou du point d'insertion.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si aucun texte n’est actuellement sélectionné, le paramètre de mise en retrait est appliqué pour le paragraphe dans lequel le point d’insertion apparaît et tout le texte tapé dans le contrôle après le point d’insertion. Le paramètre de mise en retrait s’applique jusqu'à ce que la propriété est modifiée sur une autre valeur, ou jusqu'à ce que le point d’insertion est déplacé vers un autre paragraphe du contrôle.  
  
 Si le texte est sélectionné dans le contrôle, le texte sélectionné et le texte entré après que la sélection de texte aura la valeur de cette propriété appliquée à ce dernier. Vous pouvez utiliser cette propriété pour mettre en retrait des paragraphes du document de la <xref:System.Windows.Forms.RichTextBox>. Vous pouvez utiliser cette propriété conjointement avec la <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> pour créer des paragraphes affichés dans les paragraphes.  
  
 Pour créer un retrait négatif des paragraphes dans le contrôle, utilisez le <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer une marge de droite dans un <xref:System.Windows.Forms.RichTextBox> à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> propriété. L’exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`, et que l’exemple de code est appelée à partir d’un événement dans la classe du formulaire.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position absolue des taquets de tabulation dans un contrôle <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Tableau dont chaque membre spécifie un offset de tabulation en pixels.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet d’obtenir un tableau qui contient l’espacement pour chaque onglet dans le texte sélectionné le <xref:System.Windows.Forms.RichTextBox> contrôle. Vous pouvez ensuite utiliser cette propriété pour ajuster la taille de chaque onglet au sein de la sélection de texte. Par exemple, si vous souhaitez ajuster l’espacement des tabulations dans le document, vous pouvez sélectionner la totalité du document et obtenir la liste des espaces de tabulation à l’aide de la <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> propriété. Vous pouvez les adapter aux nouvelles valeurs, puis les réaffecter à cette propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le tableau comporte davantage d'éléments que les 32 autorisés.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type de sélection dans le contrôle.</summary>
        <value>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour déterminer le type de données qui sont actuellement sélectionnés dans le contrôle afin de gérer correctement la sélection lors de l’exécution des tâches dans le contrôle sur la sélection actuelle. La propriété peut représenter n’importe quelle combinaison de valeurs à partir de la <xref:System.Windows.Forms.RichTextBoxSelectionTypes> énumération représentant les nombreux types d’objets dans la sélection actuelle.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si une marge de sélection s'affiche dans <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value><see langword="true" /> si une marge de sélection est activée dans le contrôle ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette propriété pour permettre à l’utilisateur sélectionner facilement les lignes de texte dans le <xref:System.Windows.Forms.RichTextBox>. La marge de sélection est ajoutée à la partie gauche de la <xref:System.Windows.Forms.RichTextBox>. Cette marge facilite l’utilisateur de sélectionner le texte commençant sur le côté gauche du contrôle. L’utilisateur peut cliquer dans la marge de sélection pour sélectionner une seule ligne de texte ou double-cliquez dessus pour sélectionner l’ensemble du paragraphe contenue dans la ligne double-cliqué.  
  
> [!NOTE]
>  Si le <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> propriété est définie sur `true`, ce qui affecte le <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriété `RichTextBoxScrollBars.Horizontal`, `RichTextBoxScrollBars.Vertical`, ou `RichTextBoxScrollBars.Both` n’entraîne pas de barres de défilement à afficher. Pour afficher les barres de défilement lorsque le <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> propriété est définie sur `true`, définissez le <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> propriété `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`, ou `RichTextBoxScrollBars.ForcedBoth`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte actuel de la zone de texte.</summary>
        <value>Texte affiché dans le contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour afficher plusieurs lignes de texte dans un <xref:System.Windows.Forms.RichTextBox>, définissez le <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> propriété `true`. Pour lire ou définir le texte d’une zone de texte multiligne, utilisez le <xref:System.Windows.Forms.TextBoxBase.Lines%2A> propriété. Le <xref:System.Windows.Forms.RichTextBox.Text%2A> propriété ne retourne pas d’informations sur la mise en forme appliquée au contenu de la <xref:System.Windows.Forms.RichTextBox>. Pour obtenir le texte enrichi (RTF) codes de format, utilisez le <xref:System.Windows.Forms.RichTextBox.Rtf%2A> propriété. La quantité de texte qui peut être entré dans le <xref:System.Windows.Forms.RichTextBox> contrôle est limité uniquement par la mémoire système disponible.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la longueur du texte dans le contrôle.</summary>
        <value>Nombre de caractères contenus dans le texte du contrôle.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l'action qui peut être annulée dans le contrôle lorsque la méthode <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> est appelée.</summary>
        <value>Nom (texte) de l'action qui peut être annulée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété vous permet de déterminer la dernière action qui a été effectuée dans le contrôle qui peut être annulé. Vous pouvez utiliser cette propriété pour limiter les opérations peuvent être annulées par l’utilisateur du contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique sur la barre de défilement verticale du contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la façon de gérer les événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.RichTextBox.VScroll> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.RichTextBox> nommé `RichTextBox1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.RichTextBox.VScroll> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Objet de message Windows.</param>
        <summary>Traite les messages Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le niveau de zoom actuel de <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Facteur de zoom appliqué au contenu du contrôle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété peut être comprise entre 1/64 (0,015625) et 64,0, non inclus. La valeur 1.0 indique qu’aucun zoom n’est appliqué au contrôle. La fonctionnalité de zoom des performances optimales lorsque le document contient des polices TrueType. Lorsqu’une police non TrueType est utilisée dans le document du contrôle, le <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> propriété utilisera la valeur de nombre entier le plus proche. Vous pouvez utiliser cette propriété pour permettre aux utilisateurs de le <xref:System.Windows.Forms.RichTextBox> contrôle pour effectuer un zoom dans les sections de la documentation qui sont trop petites pour afficher ou condenser la vue de la plus grande partie du document à afficher sur l’écran.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un <xref:System.Windows.Forms.RichTextBox> qui se concentre sur le texte, sélectionne automatiquement des mots dans le texte du contrôle lorsque l’utilisateur double-clique sur un mot et comporte une marge à droite de la zone cliente du contrôle. Si le <xref:System.Windows.Forms.RichTextBox> contrôle a une largeur de petites, à l’aide de ce code crée un <xref:System.Windows.Forms.RichTextBox> où chaque caractère du texte s’affiche sur sa propre ligne. Dans cette position d’affichage vertical, en cliquant sur n’importe quelle partie d’un mot sélectionne tous les caractères du mot indépendamment du fait que le texte est affiché verticalement. Cet exemple nécessite que vous disposez d’un formulaire qui contient un <xref:System.Windows.Forms.RichTextBox> contrôle nommé `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le facteur de zoom spécifié n'est pas compris dans la plage autorisée.</exception>
      </Docs>
    </Member>
  </Members>
</Type>