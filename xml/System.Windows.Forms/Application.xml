<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e030aa8a8801c2db61e3fbd8cbc521c6e064615" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65016206" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit des propriétés et des méthodes <see langword="static" /> pour gérer une application, comme des méthodes permettant de démarrer et d'arrêter une application et de traiter des messages Windows, et des propriétés permettant d'obtenir des informations sur une application. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Application> classe a des méthodes pour démarrer et arrêter des applications et des threads et pour traiter les messages Windows, comme suit :  
  
-   <xref:System.Windows.Forms.Application.Run%2A> démarre une boucle de messages d’application sur le thread actuel et, éventuellement, affiche un formulaire.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> ou <xref:System.Windows.Forms.Application.ExitThread%2A> s’arrête une boucle de message.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> traite les messages pendant que votre programme est dans une boucle.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Ajoute un filtre de messages à la pompe de messages d’application pour surveiller les messages Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> vous permet d’empêcher un événement d’être déclenchés ou effectuer des opérations spéciales avant d’appeler un gestionnaire d’événements.  
  
 Cette classe a <xref:System.Windows.Forms.Application.CurrentCulture%2A> et <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> propriétés pour obtenir ou définir les informations de culture du thread actuel.  
  
 Vous ne pouvez pas créer une instance de cette classe.  
  
   
  
## Examples  
 L’exemple de code suivant répertorie les numéros dans une zone de liste sur un formulaire. Chaque fois que vous cliquez sur `button1`, l’application ajoute un autre numéro à la liste.  
  
 Le `Main` les appels de méthode <xref:System.Windows.Forms.Application.Run%2A> pour démarrer l’application, ce qui crée le formulaire, `listBox1` et `button1`. Lorsque l’utilisateur clique sur `button1`, le `button1_Click` méthode affiche une <xref:System.Windows.Forms.MessageBox>. Si l’utilisateur clique sur `No` sur le <xref:System.Windows.Forms.MessageBox>, le `button1_Click` méthode ajoute un nombre à la liste. Si l’utilisateur clique sur `Yes`, l’application appelle <xref:System.Windows.Forms.Application.Exit%2A> pour traiter tous les messages restants dans la file d’attente, puis s’arrêter.  
  
> [!NOTE]
>  L’appel à <xref:System.Windows.Forms.Application.Exit%2A> échouera avec une confiance partielle.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implémentation de l'interface <see cref="T:System.Windows.Forms.IMessageFilter" /> que vous souhaitez installer.</param>
        <summary>Ajoute un filtre de messages permettant de surveiller les messages Windows lors de leur routage vers leur destination.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser un filtre de messages pour empêcher le déclenchement des événements spécifiques ou pour effectuer des opérations spéciales pour un événement avant d’être passé au gestionnaire d’événements. Filtres de messages sont propres à un thread spécifique.  
  
 Pour empêcher un message d’être distribués, le `value` instance de paramètre que vous passez à cette méthode doit substituer la <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> méthode par le code pour gérer le message. La méthode doit retourner `false`.  
  
> [!CAUTION]
>  Ajout de filtres de message à la pompe de messages pour une application peut dégrader les performances.  
  
   
  
## Examples  
 L’exemple de code suivant crée un filtre de messages appelé `TestMessageFilter`. Ce filtre bloque tous les messages relatifs au bouton gauche de la souris. Avant de pouvoir utiliser un filtre de messages, vous devez fournir une implémentation pour le <xref:System.Windows.Forms.IMessageFilter> interface.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'appelant peut quitter cette application.</summary>
        <value><see langword="true" /> si l'appelant peut quitter cette application ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `false` si elle est appelée à partir d’un <xref:System.Windows.Forms.Control> hébergé dans un navigateur Web. Par conséquent, le <xref:System.Windows.Forms.Control> ne peut pas quitter le <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'application est sur le point de s'arrêter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez attacher les gestionnaires d’événements pour le `ApplicationExit` événement effectuer non prise en charge, les tâches requises avant l’arrêt de l’application. Vous pouvez fermer les fichiers ouverts par cette application, ou supprimez les objets que le garbage collection n’a pas récupéré.  
  
 Comme il s’agit d’un événement statique, vous devez détacher les gestionnaires d’événements associés à cet événement dans le `ApplicationExit` Gestionnaire d’événements lui-même. Si vous ne détachez pas ces gestionnaires, ils seront restent attachées à l’événement et continuent de consommer de mémoire.  
  
   
  
## Examples  
 L’exemple de code suivant affiche deux formulaires et quitte l’application lorsque les deux formes sont fermés. Lorsque l’application démarre et s’arrête, la position de chaque formulaire est mémorisée. Cet exemple montre comment utiliser le `ApplicationExit` événement savoir lorsque les positions de formulaire doivent être persistante dans le fichier et lorsque le `FileStream` doit être fermé.  
  
 La classe `MyApplicationContext` hérite <xref:System.Windows.Forms.ApplicationContext> et effectue le suivi de chaque formulaire est fermé, puis quitte le thread actuel lorsque les deux sont. La classe mémorise la position de chaque formulaire lorsqu’il est fermé. Lorsque le `ApplicationExit` événement se produit, la classe écrit les positions de chacun d’eux pour l’utilisateur dans le fichier. Les données de position du formulaire sont stockées dans un fichier intitulé `appdata.txt` qui est créé à l’emplacement déterminé par <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Le `Main` les appels de méthode `Application.Run(context)` pour démarrer l’application étant donnée le <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ce code est un extrait de l’exemple illustré dans la <xref:System.Windows.Forms.ApplicationContext> vue d’ensemble de la classe. Consultez <xref:System.Windows.Forms.ApplicationContext> pour obtenir la liste de l’ensemble du code.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin des données d’application partagé par tous les utilisateurs.</summary>
        <value>Chemin des données d’application partagé par tous les utilisateurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un chemin d’accès n’existe pas, un est créé dans le format suivant :  
  
 *Chemin d’accès de base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> Détermine si l’assembly contenant le fichier exécutable principal a d’abord le `AssemblyInformationalVersion` attribut dessus. Si cet attribut existe, il est utilisé pour les deux <xref:System.Windows.Forms.Application.ProductVersion%2A> et <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Si cet attribut n’existe pas, les deux propriétés utilisent la version du fichier exécutable à la place.  
  
 Le chemin d’accès sera différent selon que l’application Windows Forms est déployée à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] les applications sont stockées dans un cache d’application par utilisateur dans le C:\Documents and Settings\\*nom d’utilisateur* directory. Pour plus d’informations, consultez [l’accès aux données locales et distantes dans les Applications ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la clé de Registre des données d'application partagées entre tous les utilisateurs.</summary>
        <value><see cref="T:Microsoft.Win32.RegistryKey" /> représentant la clé de Registre des données d'application partagées entre tous les utilisateurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé n’existe pas, il est créé dans le format suivant :  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de la société associée à l'application.</summary>
        <value>Nom de la société.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations sur la culture du thread en cours.</summary>
        <value><see cref="T:System.Globalization.CultureInfo" /> représentant les informations sur la culture du thread en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour toutes les fenêtres définir cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le langage d'entrée actuel du thread en cours.</summary>
        <value><see cref="T:System.Windows.Forms.InputLanguage" /> représentant le langage d'entrée actuel du thread en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Traite tous les messages Windows présents dans la file d'attente de messages.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous exécutez un formulaire Windows, il crée le nouveau formulaire, puis attend des événements à gérer. Chaque fois que le formulaire gère un événement, il traite tout le code associé à cet événement. Tous les autres événements attendent dans la file d’attente. Pendant que votre code gère l’événement, votre application ne répond pas. Par exemple, la fenêtre ne repeint pas si une autre fenêtre est déplacée en haut.  
  
 Si vous appelez <xref:System.Windows.Forms.Application.DoEvents%2A> dans votre code, votre application peut gérer les autres événements. Par exemple, si vous disposez d’un formulaire qui ajoute des données à un <xref:System.Windows.Forms.ListBox> et ajoutez <xref:System.Windows.Forms.Application.DoEvents%2A> à votre code, votre formulaire se repeint lorsqu’une autre fenêtre est déplacée sur celui-ci. Si vous supprimez <xref:System.Windows.Forms.Application.DoEvents%2A> à partir de votre code, votre formulaire se repeint pas jusqu'à la fin du Gestionnaire d’événements click du bouton de l’exécution. Pour plus d’informations sur la messagerie, consultez [entrée d’utilisateur dans les Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 Contrairement à Visual Basic 6.0, le <xref:System.Windows.Forms.Application.DoEvents%2A> méthode n’appelle pas le <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> (méthode).  
  
 En règle générale, vous utilisez cette méthode dans une boucle pour traiter les messages.  
  
> [!CAUTION]
>  Appeler cette méthode provoque le thread actuel est suspendu pendant le traitement de tous les messages de fenêtre en attente. Si un message provoque un événement à déclencher, autres zones du code de votre application peuvent s’exécuter. Cela peut entraîner de votre application à présenter des comportements inattendus qui sont difficiles à déboguer. Si vous effectuez des opérations ou des calculs qui prennent un certain temps, il est souvent préférable d’effectuer ces opérations sur un nouveau thread. Pour plus d’informations sur la programmation asynchrone, consultez [modèle de programmation asynchrone (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.Application.DoEvents%2A> (méthode). Lorsque l’exemple s’exécute, un utilisateur peut sélectionner des fichiers graphiques à partir d’un <xref:System.Windows.Forms.OpenFileDialog>. Les fichiers sélectionnés sont affichés sous la forme. Le <xref:System.Windows.Forms.Application.DoEvents%2A> méthode force à repeindre l’écran pour chaque fichier graphique ouvert. Pour exécuter cet exemple, collez le code suivant dans un formulaire contenant un <xref:System.Windows.Forms.PictureBox> nommé `PictureBox1`, un <xref:System.Windows.Forms.OpenFileDialog> nommé `OpenFileDialog1`et un bouton nommé `fileButton`. Appelez le `InitializePictureBox` et `InitializeOpenFileDialog` méthodes à partir du constructeur du formulaire ou `Load` (méthode).  
  
> [!NOTE]
>  Dans Visual Studio, si vous ajoutez un <xref:System.Windows.Forms.OpenFileDialog> à votre formulaire à l’aide d’une opération glisser, vous devrez modifier les éléments suivants `InitializeOpenFileDialog` méthode en supprimant la ligne qui crée une nouvelle instance de <xref:System.Windows.Forms.OpenFileDialog>.  
  
 L’exemple exige également que le <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> événements de la <xref:System.Windows.Forms.Button> contrôle et le <xref:System.Windows.Forms.FileDialog.FileOk> événements de la <xref:System.Windows.Forms.OpenFileDialog> sont connectés aux gestionnaires d’événements définis dans l’exemple. Lorsque l’exemple est en cours d’exécution, afficher la boîte de dialogue en cliquant sur le bouton.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Active les styles visuels pour l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode active les styles visuels pour l’application. Styles visuels sont les couleurs, polices et autres éléments visuels qui forment un thème du système d’exploitation. Si le contrôle et le système d’exploitation prennent en charge, les contrôles sont dessinés avec des styles visuels. Pour avoir un effet, <xref:System.Windows.Forms.Application.EnableVisualStyles> doit être appelée avant la création de contrôles dans l’application ; en règle générale, <xref:System.Windows.Forms.Application.EnableVisualStyles> est la première ligne dans le `Main` (fonction). Un manifeste distinct n’est pas nécessaire pour activer des styles visuels lors de l’appel <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Avant le .NET Framework 2.0, le `FlatStyle` propriété de certains contrôles, tels que les contrôles qui dérivent de <xref:System.Windows.Forms.ButtonBase>, devaient être définie sur <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> afin que les contrôles à dessiner avec des styles visuels. Dans les applications écrites avec .NET Framework 2.0, cela n’est plus nécessaire.  
  
> [!NOTE]
>  Cette méthode n’a aucun effet pour les contrôles hébergés dans Internet Explorer.  
  
   
  
## Examples  
 L’exemple de code suivant montre l’appel <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> dans le `Main` (fonction) pour activer des styles visuels pour l’application.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'application est sur le point d'activer l'état modal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  S'agissant d'un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, faute de quoi des fuites mémoire vont se produire.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.Application.EnterThreadModal> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un formulaire Windows et vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Application.EnterThreadModal> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requiert <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> autorisation d’écouter l’événement.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès au fichier exécutable ayant démarré l’application, y compris le nom de l’exécutable.</summary>
        <value>Chemin d’accès et nom du fichier exécutable ayant démarré l’application.  
  
Ce chemin d’accès sera différent selon que l’application Windows Forms est déployée à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] les applications sont stockées dans un cache d’application par utilisateur dans le C:\Documents and Settings\\*nom d’utilisateur* directory. Pour plus d’informations, consultez [l’accès aux données locales et distantes dans les Applications ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour obtenir le chemin d’accès. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informe toutes les pompes de messages qu'elles doivent se terminer, puis ferme toutes les fenêtres d'application une fois les messages traités.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informe toutes les pompes de messages qu'elles doivent se terminer, puis ferme toutes les fenêtres d'application une fois les messages traités.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Application.Exit%2A> méthode s’arrête en cours d’exécution toutes les boucles de messages sur tous les threads et ferme toutes les fenêtres de l’application. Cette méthode ne force pas nécessairement la fermeture de l’application. Le <xref:System.Windows.Forms.Application.Exit%2A> (méthode) est généralement appelée dans une boucle de messages et force <xref:System.Windows.Forms.Application.Run%2A> à retourner. Pour quitter une boucle de message pour le thread actuel uniquement, appelez <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> déclenche les événements suivants et exécute les opérations conditionnelles associées :  
  
-   Un <xref:System.Windows.Forms.Form.FormClosing> événement est déclenché pour chaque formulaire représenté par la <xref:System.Windows.Forms.Application.OpenForms%2A> propriété. Cet événement peut être annulé en définissant le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de leurs <xref:System.Windows.Forms.FormClosingEventArgs> paramètre `true`.  
  
-   Si un ou plusieurs des gestionnaires annule l’événement, puis <xref:System.Windows.Forms.Application.Exit%2A> retourne sans aucune autre action. Sinon, un <xref:System.Windows.Forms.Form.FormClosed> événement est déclenché pour chaque formulaire ouvert, puis toutes les boucles de messages et des formulaires en cours d’exécution sont fermés.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.Application.Exit%2A> méthode ne déclenche pas le <xref:System.Windows.Forms.Form.Closed> et <xref:System.Windows.Forms.Form.Closing> événements, qui sont obsolètes à partir de [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 L’exemple de code suivant répertorie les numéros dans une zone de liste sur un formulaire. Chaque fois que vous cliquez sur `button1`, l’application ajoute un autre numéro à la liste.  
  
 Le `Main` les appels de méthode <xref:System.Windows.Forms.Application.Run%2A> pour démarrer l’application, ce qui crée le formulaire, `listBox1`, et `button1`. Lorsque l’utilisateur clique sur `button1`, le `button1_Click` méthode ajoute un à trois à la zone de liste de nombres et affiche un <xref:System.Windows.Forms.MessageBox>. Si l’utilisateur clique sur **non** sur le <xref:System.Windows.Forms.MessageBox>, le `button1_Click` méthode ajoute un autre numéro à la liste. Si l’utilisateur clique sur **Oui**, l’application appelle <xref:System.Windows.Forms.Application.Exit%2A>, pour traiter tous les messages restants dans la file d’attente, puis s’arrêter.  
  
 L’exemple exige que `listBox1` et `button1` ont été instancié et placé dans un formulaire.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Spécifie par retour si tout <see cref="T:System.Windows.Forms.Form" /> dans l'application a annulé la sortie.</param>
        <summary>Informe toutes les pompes de messages qu'elles doivent se terminer, puis ferme toutes les fenêtres d'application une fois les messages traités.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Autorisation de mettre fin à une exécution de thread d’application. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quitte la boucle de messages du thread en cours et ferme toutes les fenêtres du thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour quitter la boucle de messages du thread actuel. Cette méthode provoque l’appel à <xref:System.Windows.Forms.Application.Run%2A> pour le thread actuel à retourner. Pour quitter l’application entière, appeler <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Message d'événement Windows à filtrer.</param>
        <summary>Applique tous les filtres à un message de fenêtre et retourne une copie du message modifié.</summary>
        <returns><see langword="true" /> si les filtres ont été traités ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'application termine le traitement et est sur le point de passer à l'état inactif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous avez des tâches que vous devez effectuer avant que le thread ne devienne inactif, attachez-les à cet événement.  
  
> [!CAUTION]
>  S'agissant d'un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, faute de quoi des fuites mémoire vont se produire.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.Application.Idle> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un formulaire Windows et vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Application.Idle> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'application est sur le point de quitter l'état modal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  S'agissant d'un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, faute de quoi des fuites mémoire vont se produire.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.Application.LeaveThreadModal> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un formulaire Windows et vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Application.LeaveThreadModal> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès aux données d’application d’un utilisateur local non itinérant.</summary>
        <value>Chemin d’accès aux données d’application d’un utilisateur local non itinérant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un utilisateur local est un utilisateur dont le profil est stocké sur le système sur lequel l’utilisateur connecté. Si un chemin d’accès n’existe pas, un est créé dans le format suivant :  
  
 *Chemin d’accès de base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Un chemin d’accès de base par défaut est C:\Documents and Settings\\*nom d’utilisateur*\Local Settings\Application données. Ce chemin d’accès sera différent, toutefois, si l’application Windows Forms est déployée à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] crée son propre répertoire de données d’application qui est isolée de toutes les autres applications. Pour plus d’informations, consultez [l’accès aux données locales et distantes dans les Applications ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 L’exemple de code suivant affiche deux formulaires et quitte l’application lorsque les deux formes sont fermés. Lorsque l’application démarre et s’arrête, la position de chaque formulaire est mémorisée. Bien que cet exemple montre comment utiliser le <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propriété pour stocker les données d’application pour l’utilisateur, le <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> peut être utilisé à la place.  
  
 Le `MyApplicationContext` hérite de la classe <xref:System.Windows.Forms.ApplicationContext> et assure le suivi lorsque chaque formulaire est fermé, puis quitte le thread actuel lorsque les deux sont. La classe stocke les positions de chaque formulaire pour l’utilisateur. Les données de position du formulaire sont stockées dans un fichier intitulé `Appdata.txt` qui est créé à l’emplacement déterminé par <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Le `Main` les appels de méthode `Application.Run(context)` pour démarrer l’application étant donnée le <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ce code est un extrait de l’exemple illustré dans la <xref:System.Windows.Forms.ApplicationContext> vue d’ensemble de la classe. Du code n’est pas affiché à des fins de concision. Consultez <xref:System.Windows.Forms.ApplicationContext> pour obtenir la liste de l’ensemble du code.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si une boucle de messages existe sur ce thread.</summary>
        <value><see langword="true" /> si une boucle de messages existe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de l’hébergement de Windows Forms dans d’autres environnements, tels que les applications non managées, cette propriété retourne toujours `false`. Utilisez <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> pour indiquer à Windows Forms si l’environnement d’hébergement a toujours une boucle de messages actifs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialise OLE sur le thread en cours.</summary>
        <returns>Une des valeurs de <see cref="T:System.Threading.ApartmentState" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant d’appeler une `Microsoft.Win32` méthode nécessitant OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> tout d’abord vérifie pour voir si OLE a été initialisé sur le thread actuel. Si ce n’est pas le cas, il initialise le thread d’OLE.  
  
> [!NOTE]
>  Sauf si un thread appelle directement les méthodes OLE, vous n’avez pas besoin d’appeler cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t"><see cref="T:System.Exception" /> représentant l'exception qui a été levée.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Application.ThreadException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez <xref:System.Windows.Forms.Application.OnThreadException%2A> pour lever une exception qui arrêtera le traitement de l’application.  
  
 Le <xref:System.Windows.Forms.Application> classe a un <xref:System.Windows.Forms.Application.ThreadException> événement. Vous pouvez attacher un gestionnaire d’événements à cet événement pour effectuer le traitement personnalisé que vous avez besoin pour les exceptions non gérées. Si vous n’attachez pas un gestionnaire d’événements, <xref:System.Windows.Forms.Application.OnThreadException%2A> exécutera le comportement par défaut, ce qui implique l’affichage d’une boîte de dialogue pour informer l’utilisateur qu’il y a eu une erreur.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> implémente uniquement le comportement d’exception par défaut pour les exceptions non gérées qui se produisent sur les threads détenus par les Windows Forms. Les exceptions non gérées sur d’autres threads sont gérées par le <xref:System.AppDomain.UnhandledException> événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de formulaires ouverts possédée par l’application.</summary>
        <value><see cref="T:System.Windows.Forms.FormCollection" /> qui contient tous les formulaires actuellement ouverts appartenant à cette application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Application.OpenForms%2A> propriété représente une collection en lecture seule de formulaires appartenant à l’application. Cette collection peut être recherchée par la position d’index ou par le <xref:System.Windows.Forms.Control.Name%2A> de la <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">L’appelant doit être autorisé à accéder à toutes les fenêtres, tel que défini par le <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> valeur de la <see cref="T:System.Security.Permissions.UIPermissionWindow" /> énumération.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom du produit associé à cette application.</summary>
        <value>Nom du produit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` est extrait des métadonnées de l’assembly contenant le formulaire principal de l’application actuelle. Vous pouvez la définir en définissant <xref:System.Reflection.AssemblyProductAttribute> à l’intérieur de votre manifeste d’assembly. Pour plus d’informations, consultez [Manifeste d’assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la version du produit associé à cette application.</summary>
        <value>Version du produit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, un numéro de version s’affiche en tant que *numéro principal*. *mineure nombre*. *numéro de build*. *numéro de référence privé*. Vous pouvez le définir explicitement en définissant la version d’assembly dans votre manifeste d’assembly. Pour plus d’informations, consultez [Manifeste d’assembly](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> Détermine si l’assembly contenant le fichier exécutable principal a d’abord le `AssemblyInformationalVersion` attribut dessus. Si cet attribut existe, il est utilisé pour les deux <xref:System.Windows.Forms.Application.ProductVersion%2A> et <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Si cet attribut n’existe pas, les deux propriétés utilisent la version du fichier exécutable à la place.  
  
   
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Objets <see cref="T:System.EventArgs" /> à passer à l'événement <see cref="E:System.Windows.Forms.Application.Idle" />.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.Application.Idle" /> dans les scénarios hébergés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée lors de l’hébergement de Windows Forms dans un autre environnement, tel qu’une application non managée. Vous devez appeler <xref:System.Windows.Forms.Application.RaiseIdle%2A> lorsque l’application d’hébergement entre dans un état inactif. Ainsi, certains composants pour effectuer des tâches d’arrière-plan importantes pendant que l’utilisateur n’interagit pas avec l’application et les contrôles Windows Forms.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Méthode à appeler lorsque les Windows Forms doivent vérifier si l'environnement d'hébergement envoie encore des messages.</param>
        <summary>Enregistre un rappel pour vérifier si la boucle de message s'exécute dans des environnements hébergés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée lors de l’hébergement de Windows Forms dans un autre environnement, tel qu’une application non managée. Dans les environnements hébergés, la <xref:System.Windows.Forms.Application.MessageLoop%2A> propriété retournera toujours la valeur false si Windows Forms ne traite pas les messages. Utilisez ce rappel pour indiquer à Windows Forms si l’environnement d’hébergement traite encore des messages.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implémentation de <see cref="T:System.Windows.Forms.IMessageFilter" /> à enlever de l'application.</param>
        <summary>Enlève un filtre de messages de la pompe de messages de l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez supprimer un filtre de messages lorsque vous ne souhaitez plus capturer les messages de Windows avant qu’ils soient distribués.  
  
   
  
## Examples  
 Avant de pouvoir utiliser un filtre de messages, vous devez fournir une implémentation pour le <xref:System.Windows.Forms.IMessageFilter> interface. La classe suivante crée un filtre de messages appelé `TestMessageFilter`. Ce filtre bloque tous les messages relatifs au bouton gauche de la souris.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie si l'application actuelle dessine des contrôles avec des styles visuels.</summary>
        <value><see langword="true" /> si les styles visuels sont activés pour les contrôles dans la zone cliente des fenêtres d'application ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous dessinez un contrôle personnalisé, utilisez cette propriété pour décider s’il faut dessiner le contrôle avec ou sans styles visuels, afin que son apparence est cohérente avec d’autres contrôles dans l’application.  
  
 Le tableau suivant présente les quatre conditions qui doivent exister pour <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> pour retourner `true`.  
  
|Condition|Description|  
|---------------|-----------------|  
|Le système d’exploitation prend en charge les styles visuels|Pour vérifier cette condition séparément, utilisez la propriété <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> de la classe <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|L’utilisateur a activé des styles visuels dans le système d’exploitation|Pour vérifier cette condition séparément, utilisez la propriété <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> de la classe <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> .|  
|Styles visuels sont activés dans l’application|Les styles visuels peuvent être activés dans une application en appelant la méthode <xref:System.Windows.Forms.Application.EnableVisualStyles> ou un utilisant un manifeste d’application qui spécifie que ComCtl32.dll version 6 ou ultérieure doit être utilisé pour dessiner les contrôles.|  
|Styles visuels sont utilisés pour dessiner la zone cliente des fenêtres d’application|Pour vérifier cette condition séparément, utilisez la propriété <xref:System.Windows.Forms.Application.VisualStyleState%2A> de la classe <xref:System.Windows.Forms.Application>, et vérifiez qu’elle a la valeur <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType><xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme l'application et lance immédiatement une nouvelle instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La raison la plus courante d’appeler `Restart` consiste à démarrer une nouvelle version de l’application que vous avez téléchargé via [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] à l’aide de la `Update` ou `UpdateAsync` (méthode).  
  
 Les applications sont redémarrées dans le contexte dans lequel ils ont été initialement exécutés. Si votre application a été démarrée à l’aide d’une URL qui pointe directement vers le fichier exécutable principal de l’application, elle est redémarrée à l’aide de la même URL. Si votre application est un [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] application, celui-ci est redémarré à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Si votre application a été fourni à l’origine des options de ligne de commande lors de sa première exécution, <xref:System.Windows.Forms.Application.Restart%2A> lancera l’application en utilisant les mêmes options.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Votre code n’est pas une application Windows Forms. Vous ne pouvez pas appeler cette méthode dans ce contexte.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Requiert <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> autorisation.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence à exécuter une boucle de messages d'application standard sur le thread en cours.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Commence à exécuter une boucle de messages d'application standard sur le thread en cours, sans formulaire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans un Win32 ou Windows Forms application, une boucle de message est une routine dans le code qui traite les événements de l’utilisateur, telles que les clics de souris et les frappes au clavier. Chaque application basée sur Windows en cours d’exécution requiert une boucle de messages actifs, appelée la boucle de messages principale. Lorsque la boucle de messages principale est fermée, l’application se ferme. Dans les Windows Forms, cette boucle est fermée lorsque le <xref:System.Windows.Forms.Application.Exit%2A> méthode est appelée, ou lorsque le <xref:System.Windows.Forms.Application.ExitThread%2A> méthode est appelée sur le thread qui exécute la boucle de messages principale.  
  
 La plupart des développeurs Windows Forms ne devrez pas utiliser cette version de la méthode. Vous devez utiliser le <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> surcharge pour démarrer une application avec un formulaire principal, afin que l’application se termine lorsque le formulaire principal est fermé. Pour toutes les autres situations, utilisez la <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> de surcharge, qui prend en charge en fournissant un <xref:System.Windows.Forms.ApplicationContext> objet pour mieux contrôler la durée de vie de l’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une boucle de messages principale est déjà en cours d’exécution sur ce thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Windows.Forms.ApplicationContext" /> dans lequel l'application est exécutée.</param>
        <summary>Commence à exécuter une boucle de messages d'application standard sur le thread en cours, avec <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La boucle de messages s’exécute jusqu'à ce que <xref:System.Windows.Forms.Application.Exit%2A> ou <xref:System.Windows.Forms.Application.ExitThread%2A> est appelée ou la <xref:System.Windows.Forms.Application.ThreadExit> événement est déclenché sur l’objet de contexte.  
  
   
  
## Examples  
 L’exemple affiche deux formulaires et quitte l’application lorsque les deux formes sont fermés. Lorsque l’application démarre et s’arrête, la position de chaque formulaire est mémorisée. Cet exemple montre comment utiliser un <xref:System.Windows.Forms.ApplicationContext>, ainsi que le `Application.Run(context)` (méthode), pour afficher plusieurs formulaires lorsque l’application démarre.  
  
 La classe `MyApplicationContext` hérite <xref:System.Windows.Forms.ApplicationContext> et assure le suivi lorsque chaque formulaire est fermé, puis quitte le thread actuel lorsque les deux sont. La classe stocke les positions de chaque formulaire pour l’utilisateur. Les données de position du formulaire sont stockées dans un fichier intitulé `Appdata.txt` qui est créé à l’emplacement déterminé par <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Le `Main` les appels de méthode `Application.Run(context)` pour démarrer l’application étant donnée le <xref:System.Windows.Forms.ApplicationContext>.  
  
 Le code pour le `AppForm1` et `AppForm2` forms n’est pas indiqué pour des raisons de concision. Consultez le <xref:System.Windows.Forms.ApplicationContext> vue d’ensemble de la classe pour obtenir la liste de l’ensemble du code.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une boucle de messages principale est déjà en cours d’exécution sur ce thread.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm"><see cref="T:System.Windows.Forms.Form" /> représentant le formulaire à afficher.</param>
        <summary>Commence à exécuter une boucle de messages d'application standard sur le thread en cours et affiche le formulaire spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, la fonction principale d’une application appelle cette méthode et lui passe la fenêtre principale de l’application.  
  
 Cette méthode ajoute un gestionnaire d’événements pour le `mainForm` paramètre pour le <xref:System.Windows.Forms.Form.Closed> événement. Le Gestionnaire d’événements appelle <xref:System.Windows.Forms.Application.ExitThread%2A> pour nettoyer l’application.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.Control.Dispose%2A> méthode de la <xref:System.Windows.Forms.Form> classe sera appelée avant le retour de cette méthode.  
  
   
  
## Examples  
 L’exemple de code suivant répertorie les numéros dans une zone de liste sur un formulaire. Chaque fois que vous cliquez sur `button1`, l’application ajoute un autre numéro à la liste.  
  
 Le `Main` les appels de méthode <xref:System.Windows.Forms.Application.Run%2A> pour démarrer l’application, ce qui crée le formulaire, `listBox1`, et `button1`. Lorsque l’utilisateur clique sur `button1`, le `button1_Click` méthode ajoute un à trois à la zone de liste de nombres et affiche un <xref:System.Windows.Forms.MessageBox>. Si l’utilisateur clique sur **non** sur le <xref:System.Windows.Forms.MessageBox>, le `button1_Click` méthode ajoute un autre numéro à la liste. Si l’utilisateur clique sur **Oui**, l’application appelle <xref:System.Windows.Forms.Application.Exit%2A> pour traiter tous les messages restants dans la file d’attente, puis s’arrêter.  
  
 L’exemple exige que `listBox1` et `button1` ont été créés et placés dans un formulaire.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une boucle de messages principale est déjà en cours d’exécution sur le thread actuel.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne de format à appliquer aux titres des fenêtres de niveau supérieur lorsqu'ils s'affichent avec une bannière d'avertissement.</summary>
        <value>Chaîne de format à appliquer aux titres des fenêtres de niveau supérieur.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour toutes les fenêtres définir cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Valeur par défaut à utiliser pour les nouveaux contrôles. Si <see langword="true" />, les nouveaux contrôles qui prennent en charge <c>UseCompatibleTextRendering</c> utilisent [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basé sur la classe <see cref="T:System.Drawing.Graphics" /> pour le rendu de texte ; si <see langword="false" />, les nouveaux contrôles utilisent [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] basé sur la classe <see cref="T:System.Windows.Forms.TextRenderer" />.</param>
        <summary>Définit la valeur par défaut à l’échelle de l’application destinée à la propriété <c>UseCompatibleTextRendering</c> définie sur certains contrôles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains contrôles Windows Forms peuvent restituer leur texte à l’aide la <xref:System.Windows.Forms.TextRenderer> (classe), qui est basée sur le [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] bibliothèque de graphiques, ou le <xref:System.Drawing.Graphics> (classe), qui est basée sur le [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] bibliothèque de graphiques. Cette modification a été apportée dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] en raison de problèmes de performance et de localisation avec [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Utilisez <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> pour définir la valeur par défaut de la `UseCompatibleTextRendering` propriété pour les contrôles qui prennent en charge.  
  
 Le `UseCompatibleTextRendering` propriété vise à assurer la compatibilité visuelle entre les contrôles Windows Forms ce texte rendu à l’aide du <xref:System.Windows.Forms.TextRenderer> classe et [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] et [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] les applications qui effectuent le rendu de texte personnalisé à l’aide de la <xref:System.Drawing.Graphics>classe. Dans la plupart des cas, si votre application n’est pas mis à niveau à partir de [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] ou [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], il est recommandé de laisser `UseCompatibleTextRendering` la valeur par défaut de `false`.  
  
 Le [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] en <xref:System.Windows.Forms.TextRenderer> classe a été introduite dans le [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] pour améliorer les performances, rendre du texte améliorer l’aspect et la prise en charge des polices internationales. Dans les versions antérieures de la [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], le [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] basé <xref:System.Drawing.Graphics> classe a été utilisée pour effectuer le rendu du texte. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] calcule l’espacement des caractères et habillage différemment à partir de word [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Dans une application Windows Forms qui utilise le <xref:System.Drawing.Graphics> class pour restituer le texte, cela peut entraîner le texte pour les contrôles qui utilisent <xref:System.Windows.Forms.TextRenderer> différente du reste du texte dans l’application. Pour résoudre cette incompatibilité, vous pouvez définir le `UseCompatibleTextRendering` propriété `true`. Pour définir `UseCompatibleTextRendering` à `true` pour tous les contrôles pris en charge dans l’application, appelez le <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> méthode avec un paramètre de `true`.  
  
 Vous ne devez jamais appeler cette méthode si votre code Windows Forms est hébergé dans une autre application, tel qu’Internet Explorer. Appelez uniquement cette méthode dans les applications Windows Forms autonomes.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Pour définir la valeur par défaut `UseCompatibleTextRendering` dans [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] ou version ultérieure, consultez <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 Dans [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ou version ultérieure, un appel à <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> est généré automatiquement dans le fichier Program.cs. Pour modifier la valeur par défaut du rendu de texte, modifiez le code généré.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Vous pouvez uniquement appeler cette méthode avant que la première fenêtre est créée par votre application Windows Forms.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Windows.Forms.PowerState" /> qui indique le mode d'alimentation vers lequel basculer.</param>
        <param name="force"><see langword="true" /> pour forcer immédiatement le mode suspendu ; <see langword="false" /> pour que Windows envoie une demande de suspension à chaque application.</param>
        <param name="disableWakeEvent"><see langword="true" /> pour désactiver la restauration de l'activation de l'état d'alimentation du système sur un événement de sortie de veille, <see langword="false" /> pour activer la restauration de l'activation de l'état d'alimentation du système sur un événement de sortie de veille.</param>
        <summary>Suspend ou met en veille prolongée le système, ou demande que le système soit suspendu ou mis en veille prolongée.</summary>
        <returns><see langword="true" /> si le système est en cours de suspension ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une application ne répond pas à une demande de suspension dans les 20 secondes, Windows détermine qu’il est dans un état non réactif, et que l’application peut être mise en veille ou s’est arrêtée. Une fois une application répond à une demande de suspension, toutefois, il peut prendre le temps nécessaire pour nettoyer les ressources et arrêter les processus actifs.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique à l'application comment répondre aux exceptions non gérées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant définit des gestionnaires d’événements pour les exceptions qui se produisent sur les threads Windows Forms et les exceptions qui se produisent sur d’autres threads. Il définit <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> afin que toutes les exceptions soient gérées par l’application, quels que soient les paramètres dans le fichier de configuration de l’application utilisateur. Il utilise l'événement <xref:System.Windows.Forms.Application.ThreadException> pour gérer les exceptions de thread d’interface utilisateur et l'événement <xref:System.AppDomain.UnhandledException> pour gérer les exceptions issues de threads autres que celui de l’interface utilisateur. Dans la mesure où <xref:System.AppDomain.UnhandledException> ne peut pas empêcher une application de se terminer, l’exemple enregistre simplement l’erreur dans le journal des événements d’application avant l’arrêt.  
  
 Cet exemple suppose que vous avez défini deux contrôles <xref:System.Windows.Forms.Button>, `button1` et `button2`, dans votre classe <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Valeur <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> décrivant comment l'application doit se comporter si une exception est levée sans être interceptée.</param>
        <summary>Indique à l'application comment répondre aux exceptions non gérées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est souvent possible d’intercepter toutes les exceptions levées par les Windows Forms. À l’aide de cette méthode, vous pouvez demander à votre application si elle doit intercepter des exceptions non gérées levées par des composants Windows Forms et continuer à fonctionner, ou s’il doit les exposer à l’utilisateur et arrêter l’exécution.  
  
 Appelez <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> avant d’instancier le formulaire principal de votre application à l’aide de la <xref:System.Windows.Forms.Application.Run%2A> (méthode).  
  
 Pour intercepter les exceptions qui se produisent dans les threads non créés et détenus par Windows Forms, utilisez l'événement <xref:System.AppDomain.UnhandledException>.  
  
   
  
## Examples  
 L’exemple de code suivant définit des gestionnaires d’événements pour les exceptions qui se produisent sur les threads Windows Forms et les exceptions qui se produisent sur d’autres threads. Il définit <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> afin que toutes les exceptions soient gérées par l’application, quels que soient les paramètres dans le fichier de configuration de l’application utilisateur. Il utilise l'événement <xref:System.Windows.Forms.Application.ThreadException> pour gérer les exceptions de thread d’interface utilisateur et l'événement <xref:System.AppDomain.UnhandledException> pour gérer les exceptions issues de threads autres que celui de l’interface utilisateur. Dans la mesure où <xref:System.AppDomain.UnhandledException> ne peut pas empêcher une application de se terminer, l’exemple enregistre simplement l’erreur dans le journal des événements d’application avant l’arrêt.  
  
 Cet exemple suppose que vous avez défini deux contrôles <xref:System.Windows.Forms.Button>, `button1` et `button2`, dans votre classe <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible de définir le mode d’exceptions après que l’application a créé sa première fenêtre.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Valeur <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> décrivant comment l'application doit se comporter si une exception est levée sans être interceptée.</param>
        <param name="threadScope"><see langword="true" /> pour définir le mode d'exceptions du thread ; sinon, <see langword="false" />.</param>
        <summary>Indique à l'application comment répondre aux exceptions non gérées, en appliquant éventuellement un comportement spécifique au thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il est souvent possible d’intercepter toutes les exceptions levées par les Windows Forms. À l’aide de cette méthode, vous pouvez demander à votre application si elle doit intercepter des exceptions non gérées levées par des composants Windows Forms et continuer à fonctionner, ou s’il doit les exposer à l’utilisateur et arrêter l’exécution.  
  
 Appelez <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> avant d’instancier le formulaire principal de votre application à l’aide de la <xref:System.Windows.Forms.Application.Run%2A> (méthode).  
  
 Lorsque `threadScope` est `true`, le mode d’exception de thread est défini. Le mode d’exceptions du thread remplace le mode d’exceptions application si `mode` n’a pas la valeur <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Lorsque `threadScope` est `false`, le mode d’exception application est défini. Mode d’exception de l’application est utilisé pour tous les threads qui ont le <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> mode. Définition du mode d’exception application n’affecte pas le paramètre du thread actuel.  
  
 Pour intercepter les exceptions qui se produisent dans les threads non créés et détenus par Windows Forms, utilisez l'événement <xref:System.AppDomain.UnhandledException>.  
  
   
  
## Examples  
 L’exemple de code suivant définit des gestionnaires d’événements pour les exceptions qui se produisent sur les threads Windows Forms et les exceptions qui se produisent sur d’autres threads. Il définit <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> afin que toutes les exceptions soient gérées par l’application, quels que soient les paramètres dans le fichier de configuration de l’application utilisateur. Il utilise l'événement <xref:System.Windows.Forms.Application.ThreadException> pour gérer les exceptions de thread d’interface utilisateur et l'événement <xref:System.AppDomain.UnhandledException> pour gérer les exceptions issues de threads autres que celui de l’interface utilisateur. Dans la mesure où <xref:System.AppDomain.UnhandledException> ne peut pas empêcher une application de se terminer, l’exemple enregistre simplement l’erreur dans le journal des événements d’application avant l’arrêt.  
  
 Cet exemple suppose que vous avez défini deux contrôles <xref:System.Windows.Forms.Button>, `button1` et `button2`, dans votre classe <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible de définir le mode d’exceptions après que l’application a créé sa première fenêtre.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès au fichier exécutable ayant démarré l’application, sans le nom de l’exécutable.</summary>
        <value>Chemin d’accès au fichier exécutable ayant démarré l’application.  
  
Ce chemin d’accès sera différent selon que l’application Windows Forms est déployée à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] les applications sont stockées dans un cache d’application par utilisateur dans le C:\Documents and Settings\\*nom d’utilisateur* directory. Pour plus d’informations, consultez [l’accès aux données locales et distantes dans les Applications ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant obtient cette propriété et affiche sa valeur dans une zone de texte. L’exemple exige que `textBox1` a été placé sur un formulaire.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour obtenir le chemin d’accès. Énumération associée : <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une exception non gérée est levée sur un thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement permet à votre application Windows Forms de gérer les exceptions non prises en charge qui se produisent dans les threads de Windows Forms. Attachez vos gestionnaires d’événements à l'événement <xref:System.Windows.Forms.Application.ThreadException> pour traiter ces exceptions, qui laisseront votre application dans un état indeterminé. Dans la mesure du possible, les exceptions doivent être gérées localement par un bloc structuré de gestion des exceptions.  
  
 Vous pouvez choisir si ce rappel doit être utilisé pour les exceptions Windows Forms non gérées en définissant <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Pour intercepter les exceptions qui se produisent dans les threads non créés et détenus par Windows Forms, utilisez l'événement <xref:System.AppDomain.UnhandledException>.  
  
> [!NOTE]
>  Pour garantir qu’aucune activation de cet événement ne soit manquée, vous devez attacher un gestionnaire avant d’appeler <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  S'agissant d'un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, faute de quoi des fuites mémoire vont se produire.  
  
   
  
## Examples  
 L’exemple de code suivant définit des gestionnaires d’événements pour les exceptions qui se produisent sur les threads Windows Forms et les exceptions qui se produisent sur d’autres threads. Il définit <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> afin que toutes les exceptions soient gérées par l’application, quels que soient les paramètres dans le fichier de configuration de l’application utilisateur. Il utilise l'événement <xref:System.Windows.Forms.Application.ThreadException> pour gérer les exceptions de thread d’interface utilisateur et l'événement <xref:System.AppDomain.UnhandledException> pour gérer les exceptions issues de threads autres que celui de l’interface utilisateur. Dans la mesure où <xref:System.AppDomain.UnhandledException> ne peut pas empêcher une application de se terminer, l’exemple enregistre simplement l’erreur dans le journal des événements d’application avant l’arrêt.  
  
 Cet exemple suppose que vous avez défini deux contrôles <xref:System.Windows.Forms.Button>, `button1` et `button2`, dans votre classe <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">à l’appelant immédiat d’appeler du code non managé lors de l’ajout d’un gestionnaire à cet événement. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un thread est sur le point de s'arrêter. Lorsque le principal thread d'une application est sur le point de s'arrêter, cet événement commence par se déclencher, suivi d'un événement <see cref="E:System.Windows.Forms.Application.ApplicationExit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez attacher les gestionnaires d’événements pour le <xref:System.Windows.Forms.Application.ThreadExit> événement pour effectuer les non prise en charge, les tâches requises avant que le thread s’arrête en cours d’exécution. Fermez les fichiers ouverts par ce thread, ou supprimez les objets que le garbage collector n’a pas récupéré.  
  
> [!CAUTION]
>  S'agissant d'un événement statique, vous devez détacher vos gestionnaires d’événements lorsque votre application est supprimée, faute de quoi des fuites mémoire vont se produire.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.Application.ThreadExit> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un formulaire Windows et vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.Application.ThreadExit> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l'enregistrement du rappel de boucle de message réalisé avec <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès aux données d’application d’un utilisateur.</summary>
        <value>Chemin d'accès aux données d'application d'un utilisateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un chemin d’accès n’existe pas, un est créé dans le format suivant :  
  
 *Chemin d’accès de base*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Données stockées dans ce chemin d’accès fait partie du profil utilisateur itinérant. Un utilisateur itinérant fonctionne sur plusieurs ordinateurs dans un réseau. Le profil utilisateur pour un utilisateur itinérant est conservé sur un serveur sur le réseau et est chargé sur un système lorsque l’utilisateur ouvre une session. Pour un profil utilisateur à prendre en compte pour l’itinérance, le système d’exploitation doit prendre en charge les profils itinérants et il doit être activé.  
  
 Un chemin d’accès de base par défaut est C:\Documents and Settings\\*nom d’utilisateur*\Application Data. Ce chemin d’accès sera différent, toutefois, si l’application Windows Forms est déployée à l’aide de [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] crée son propre répertoire de données d’application qui est isolée de toutes les autres applications. Pour plus d’informations, consultez [l’accès aux données locales et distantes dans les Applications ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 L’exemple de code suivant affiche deux formulaires et quitte l’application lorsque les deux formes sont fermés. Lorsque l’application démarre et s’arrête, la position de chaque formulaire est mémorisée. Cet exemple montre comment utiliser le <xref:System.Windows.Forms.Application.UserAppDataPath%2A> propriété pour stocker les données d’application pour l’utilisateur.  
  
 La classe `MyApplicationContext` hérite <xref:System.Windows.Forms.ApplicationContext> et assure le suivi lorsque chaque formulaire est fermé, puis quitte le thread actuel lorsque les deux sont. La classe stocke les positions de chaque formulaire pour l’utilisateur. Les données de position du formulaire sont stockées dans un fichier intitulé `Appdata.txt` qui est créé à l’emplacement déterminé par <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. Le `Main` les appels de méthode `Application.Run(context)` pour démarrer l’application étant donnée le <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ce code est un extrait de l’exemple illustré dans la <xref:System.Windows.Forms.ApplicationContext> vue d’ensemble de la classe. Du code n’est pas affiché à des fins de concision. Consultez <xref:System.Windows.Forms.ApplicationContext> pour obtenir la liste de l’ensemble du code.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la clé de Registre pour les données d'application d'un utilisateur.</summary>
        <value><see cref="T:Microsoft.Win32.RegistryKey" /> représentant la clé de Registre pour les données d'application propres à l'utilisateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la clé n’existe pas, il est créé dans le format suivant :  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Données stockées dans cette clé fait partie du profil utilisateur itinérant. Un utilisateur itinérant fonctionne sur plusieurs ordinateurs dans un réseau. Le profil utilisateur pour un utilisateur itinérant est conservé sur un serveur sur le réseau et est chargé sur un système lorsque l’utilisateur ouvre une session. Pour un profil utilisateur à prendre en compte pour l’itinérance, le système d’exploitation doit prendre en charge les profils itinérants et il doit être activé.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si le curseur d'attente est utilisé pour tous les formulaires ouverts de l'application.</summary>
        <value><see langword="true" /> si le curseur d'attente est utilisé pour tous les formulaires ouverts ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque cette propriété a la valeur `true`, le <xref:System.Windows.Forms.Control.UseWaitCursor%2A> propriété de tous les formulaires ouverts dans l’application est définie `true`. Cet appel ne retournera pas jusqu'à ce que cette propriété a été définie sur tous les formulaires. Utilisez cette propriété lorsque vous avez une opération longue, pour indiquer de tous les formulaires de l’application que l’opération traite toujours.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui spécifie l'application de styles visuels aux fenêtres d'application.</summary>
        <value>Combinaison d'opérations de bits des valeurs <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela <xref:System.Windows.Forms.Application.VisualStyleState%2A> propriété détermine si les styles visuels sont activés dans les zones clientes ou non cliente des fenêtres d’application. En règle générale, cette propriété doit être définie dans le constructeur du formulaire principal ou <xref:System.Windows.Forms.Form.Load> Gestionnaire d’événements.  
  
   
  
## Examples  
 Le code suivant exemple définit le <xref:System.Windows.Forms.Application.VisualStyleState%2A> propriété de la <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> valeurs au sein de la <xref:System.Windows.Forms.Control.Click> Gestionnaire d’événements pour un <xref:System.Windows.Forms.Button> contrôle. Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> énumération.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>