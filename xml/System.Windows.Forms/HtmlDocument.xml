<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ffcf3d024b51e703932694c17e3acae59b372be7" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51883987" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <TypeSignature Language="F#" Value="type HtmlDocument = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fournit l'accès par programmation de niveau supérieur à un document HTML hébergé par le contrôle <see cref="T:System.Windows.Forms.WebBrowser" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> fournit un wrapper managé autour d’objet de document Internet Explorer, également connu sous le HTML modèle DOM (Document Object). Pour obtenir une instance de <xref:System.Windows.Forms.HtmlDocument> via la <xref:System.Windows.Forms.WebBrowser.Document%2A> propriété de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 Les balises HTML dans un document HTML peuvent être imbriqués à l’intérieur de l’autre. <xref:System.Windows.Forms.HtmlDocument> représente donc une arborescence de document, dont les enfants sont des instances de la <xref:System.Windows.Forms.HtmlElement> classe. L’exemple de code suivant montre un fichier HTML simple.  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 Dans cet exemple, <xref:System.Windows.Forms.HtmlDocument> représente le document entier à l’intérieur de la `HTML` balises. Le `BODY`, `DIV`, `FORM` et `SPAN` balises sont représentées par une personne <xref:System.Windows.Forms.HtmlElement> objets.  
  
 Il existe plusieurs façons, vous pouvez accéder aux éléments de cette arborescence. Utilisez le <xref:System.Windows.Forms.HtmlDocument.Body%2A> propriété pour accéder à la `BODY` balise et tous ses enfants. Le <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> propriété vous donne le <xref:System.Windows.Forms.HtmlElement> pour l’élément sur une page HTML qui a le focus d’entrée utilisateur. Tous les éléments dans une page HTML peuvent avoir un nom ; le <xref:System.Windows.Forms.HtmlDocument.All%2A> collection fournit l’accès à chaque <xref:System.Windows.Forms.HtmlElement> à l’aide de son nom en tant qu’index. <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> retournera un <xref:System.Windows.Forms.HtmlElementCollection> de tous les <xref:System.Windows.Forms.HtmlElement> objets avec un nom de balise HTML donné, tel que `DIV` ou `TABLE`. <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> Retourne le seul <xref:System.Windows.Forms.HtmlElement> correspondant à l’ID unique que vous fournissez. <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> Retourne le <xref:System.Windows.Forms.HtmlElement> qui peut être trouvée sur l’écran aux coordonnées du pointeur de souris fournies.  
  
 Vous pouvez également utiliser le <xref:System.Windows.Forms.HtmlDocument.Forms%2A> et <xref:System.Windows.Forms.HtmlDocument.Images%2A> collection à itérer les éléments que l’utilisateur représentent entrée formulaires et des graphiques, respectivement.  
  
 <xref:System.Windows.Forms.HtmlDocument> est basé sur les interfaces non managées implémentées par le DOM DHTML d’Internet Explorer : `IHTMLDocument`, `IHTMLDocument2`, `IHTMLDocument3`, et `IHTMLDocument4`. Uniquement les propriétés les plus fréquemment utilisés et les méthodes sur ces interfaces non managées sont exposées par <xref:System.Windows.Forms.HtmlDocument>. Vous pouvez accéder à toutes les autres propriétés et méthodes directement à l’aide de la <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> propriété, vous pouvez effectuer un cast vers le pointeur d’interface non managé désiré.  
  
 Un document HTML peut contenir des frames, qui sont des fenêtres différentes à l’intérieur de la <xref:System.Windows.Forms.WebBrowser> contrôle. Chaque frame affiche sa propre page HTML. Le <xref:System.Windows.Forms.HtmlWindow.Frames%2A> collection est disponible via le <xref:System.Windows.Forms.HtmlDocument.Window%2A> propriété. Vous pouvez également utiliser le <xref:System.Windows.Forms.HtmlDocument.Window%2A> propriété pour redimensionner la page affichée, faites défiler le document ou afficher des alertes et vous invite à l’utilisateur.  
  
 <xref:System.Windows.Forms.HtmlDocument> expose les événements les plus courants que vous rencontrerez lors de l’hébergement de pages HTML. Pour les événements non exposés directement par l’interface, vous pouvez ajouter un gestionnaire pour l’événement à l’aide <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A>.  
  
 Les fichiers HTML peuvent contenir `SCRIPT` balises qui encapsulent le code écrit dans un des langages Active Scripting, tels que JScript ou VBScript. Le <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> méthode permet l’exécution de propriétés et méthodes définies dans un `SCRIPT` balise.  
  
> [!NOTE]
>  Alors que la plupart des propriétés, méthodes et événements sur <xref:System.Windows.Forms.HtmlDocument> ont conservé les mêmes noms que sur le DOM non managé, certains ont été modifiés par souci de cohérence avec le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 L’exemple de code suivant utilise des données à partir de la base de données Northwind pour créer un `HTML TABLE` dynamiquement à l’aide <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. Le <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> méthode est également utilisée, tout d’abord pour ajouter des cellules (`TD` éléments) aux lignes (`TR` éléments), puis pour ajouter des lignes à la table et enfin pour ajouter le tableau à la fin du document actif. L’exemple de code requiert que votre application possède un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`. Le code doit être appelé après le chargement d’un document.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://developer.mozilla.org/en-US/docs/Web/API/Document">document - API Web</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">Interface IHTMLDocument2</related>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fournit le <see cref="T:System.Windows.Forms.HtmlElement" /> qui possède actuellement le focus d'entrée utilisateur.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> qui possède actuellement le focus d'entrée utilisateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le document a le focus, mais aucun élément du document n’a reçu le focus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> retourne l’élément correspondant à la `<BODY>` balise.  
  
 Si le document n’a pas le focus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> retourne `null`.  
  
 Si l’élément actuel avec le focus d’entrée est une cellule (`TD`) dans le code HTML `TABLE` balise, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> retournera l’élément qui contient le `TABLE` élément.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752581(v=vs.85)">Propriété activeElement</related>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Drawing.Color" /> d'un lien hypertexte lorsque l'utilisateur clique dessus.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> pour les liens actifs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un lien est actif quand un utilisateur clique dessus. Modifiez cette propriété pour modifier la couleur du lien avant la navigation.  
  
 Le <xref:System.Drawing.Color> tapez dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] prend en charge un `Alpha` valeur, le modèle DOM HTML ne mais pas. Par conséquent, `Alpha` n’a aucun effet lorsque assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752564.aspx">Propriété alinkColor</related>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une instance de <see cref="T:System.Windows.Forms.HtmlElementCollection" /> qui stocke tous les objets <see cref="T:System.Windows.Forms.HtmlElement" /> pour le document.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> de tous les éléments dans le document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.HtmlDocument.All%2A> collection fournit un accès aléatoire à n’importe quel élément dans le document HTML, quelle que soit sa position dans l’arborescence du document. Utilisez-la pour accéder à n’importe quel élément dans un document HTML par nom, ID, ou d’index. Vous pouvez également itérer sur tous les éléments dans un document.  
  
 Certains éléments, tels que `HEAD` et `TITLE`, n’aura jamais de noms qui s’y rapportent. Tous les autres éléments auront des noms uniquement si vous lui est assigné par l’auteur du fichier HTML. Vous pouvez accéder éléments sans nom par ID ou index.  
  
 Vous ne pouvez pas ajouter des éléments directement à la <xref:System.Windows.Forms.HtmlDocument.All%2A> collection, car tous les éléments dans le code HTML de fichiers en dehors de la `HTML` balise doit avoir un élément parent. Utilisez le <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> méthode ou le <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété sur <xref:System.Windows.Forms.HtmlElement> pour ajouter de nouveaux éléments à l’arborescence.  
  
   
  
## Examples  
 L’exemple de code suivant itère au sein de tous les éléments dans un document et définit `Enabled=True`, l’activation de tous les éléments qui ont été désactivés par défaut pour empêcher l’entrée d’utilisateur lors du chargement du document. L’exemple de code requiert que votre application contient un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752582.aspx">toutes les propriétés</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez gérer.</param>
        <param name="eventHandler">Code managé qui gère l'événement.</param>
        <summary>Ajoute un gestionnaire d'événements pour l'événement nommé sur le modèle DOM HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne devez pas attacher un événement au document ou à un de ses objets jusqu'à ce que le chargement est terminé dans le document. Est le plus ancien que vous devez appeler cette méthode dans le <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> événements de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 Cette méthode vous permet de joindre des gestionnaires aux événements DOM non managés, non exposés par <xref:System.Windows.Forms.HtmlDocument>. Pour plus d’informations sur les événements DOM non managés disponibles, consultez [l’accès à des membres non exposés sur le modèle objet de Document géré du HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) et les interfaces IHTMLDocument : [IHTMLDocument](https://go.microsoft.com/fwlink/?LinkId=104882), [IHTMLDocument2](https://go.microsoft.com/fwlink/?LinkId=104884), [IHTMLDocument3](https://go.microsoft.com/fwlink/?LinkId=104886), [IHTMLDocument4](https://go.microsoft.com/fwlink/?LinkId=104887), [IHTMLDocument5](https://go.microsoft.com/fwlink/?LinkId=104888).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752535.aspx">Méthode attachEvent</related>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur d'arrière-plan du document HTML.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> de l'arrière-plan du document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> affiche si aucun autre élément n’occupe cette zone de l’écran.  
  
 Le <xref:System.Drawing.Color> tapez dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] prend en charge un `Alpha` valeur, le modèle DOM HTML ne mais pas. Par conséquent, `Alpha` n’a aucun effet lorsque assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752565.aspx">Propriété bgColor</related>
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Body : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.HtmlElement" /> pour la balise <c>BODY</c>.</summary>
        <value>Le <see cref="T:System.Windows.Forms.HtmlElement" /> de l’objet pour le <c>corps</c> balise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un document HTML est divisé en deux sections principales :  
  
-   `HEAD`, qui contient le titre du document, les métadonnées de document, et `SCRIPT` éléments.  
  
-   `BODY`, qui contient tous les éléments impliqués dans l’écran apparence du document.  
  
 Il n’existe aucun équivalent `Head` propriété sur <xref:System.Windows.Forms.HtmlDocument>. Pour obtenir le `HEAD` élément, utilisez <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant crée un nouveau `DIV` élément et l’ajoute au bas du document en utilisant le <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> (méthode).  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752585.aspx">corps de la propriété</related>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique dans le document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant détecte un clic sur le document, recherche l’élément et utilise <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> pour aligner l’élément avec le bord supérieur de la page Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752611.aspx">Événement OnClick</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur demande d'afficher le menu contextuel du document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, si vous cliquez sur votre souris sur un document ou un élément dans un document, il affiche un menu de contexte par défaut particulier à l’élément. Utilisez cet événement pour annuler l’affichage du menu contextuel et afficher un des vôtres.  
  
   
  
## Examples  
 Le code suivant exemple capture la <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> événement et l’utilise pour afficher un <xref:System.Windows.Forms.ContextMenuStrip>.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536914.aspx">Événement oncontextmenu</related>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cookie : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les cookies HTTP associés à ce document.</summary>
        <value>
          <see cref="T:System.String" /> contenant une liste de cookies, chaque cookie étant séparé par un point-virgule.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> propriété du <xref:System.Windows.Forms.HtmlDocument> expose tous les cookies définis pour une page Web.  
  
 Un *cookie* est une paire nom/valeur arbitraire associée à une page Web donnée. Les développeurs Web utilisent des cookies pour effectuer le suivi des utilisateurs visitent ou retournent sur un site Web. Un cookie est composé de plusieurs parties, appelées miettes de cookie, qui déterminent les éléments suivants :  
  
-   Le document la valeur à laquelle le cookie s’applique ; son domaine et le chemin d’accès.  
  
-   Le nom et la valeur du cookie.  
  
-   La date d’expiration du cookie.  
  
-   Indique si le cookie ne peut être envoyé à l’aide d’une connexion sécurisée.  
  
 Le <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> propriété peut contenir plusieurs cookies.  
  
 Vous pouvez uniquement utiliser le <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> propriété à définir un cookie à la fois.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752569.aspx">cookie, propriété</related>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.CreateElement elementTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">Nom de l'élément HTML à créer.</param>
        <summary>Crée un <see langword="HtmlElement" /> du type de balise HTML spécifié.</summary>
        <returns>Nouvel élément du type d’étiquette spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` peut être une des balises HTML prises en charge dans Internet Explorer, à l’exception `FRAME` ou `IFRAME`.  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> Retourne un élément non attachés à l’arborescence du document en cours. Pour ajouter l’élément au document, utilisez la <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> ou <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> méthodes.  
  
 Cette méthode n’affecte pas l’état du code source d’un document existant lorsque vous utilisez le <xref:System.Windows.Forms.WebBrowser> du contrôle **afficher la Source** commande de menu contextuel ou la <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> et <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> propriétés de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 Lorsque vous créez de nouveaux éléments avec <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>, vous ne serez pas en mesure de définir certaines propriétés, telles que `Name`. Dans les cas où vous devez définir l’attribut Name, affectez-les au format HTML pour le <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété d’un autre objet dans le document.  
  
   
  
## Examples  
 Le code suivant utilise exemple à l’aide de table de données à partir de la base de données Northwind pour créer un élément HTML <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. Le <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> méthode est également utilisée, tout d’abord pour ajouter des cellules (`TD` éléments) aux lignes (`TR` éléments), puis pour ajouter des lignes à la table et enfin pour ajouter le tableau à la fin du document actif. L’exemple de code requiert que votre application possède un <xref:System.Windows.Forms.WebBrowser> contrôle appelé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752570.aspx">Méthode createElement</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultEncoding : string" Usage="System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'encodage utilisé par défaut pour le document actif.</summary>
        <value>
          <see cref="T:System.String" /> qui représente l'encodage utilisé par le navigateur quand la page s'affiche pour la première fois.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’encodage par défaut est l’encodage va tenter du DOM HTML managé Document objet Model () à utiliser lors de la page est chargée initialement. Cet encodage est dérivé à partir d’Internet Explorer **Encoding** paramètres, ou à partir d’un `META` balise incorporée dans la page.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms537500.aspx">Reconnaissance de jeu de caractères</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms533714.aspx">defaultCharset, propriété</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez cesser de gérer.</param>
        <param name="eventHandler">Code managé qui gère l'événement.</param>
        <summary>Supprime un gestionnaire d'événements d'un événement nommé sur le DOM HTML.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752539.aspx">Méthode detachEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la chaîne qui décrit le domaine de ce document pour des raisons de sécurité.</summary>
        <value>Domaine valide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, deux pages Web dans différents cadres ne peuvent pas accéder au contenu entre eux à l’aide du script ; même www.microsoft.com et msdn.microsoft.com sont, dans ce cas, considérées comme des domaines différents. Pour activer l’écriture de scripts inter-frame pour les pages du même domaine de niveau supérieur, vous pouvez affecter une nouvelle valeur à la <xref:System.Windows.Forms.HtmlDocument.Domain%2A> propriété. Dans l’exemple d’URL précédent, en définissant <xref:System.Windows.Forms.HtmlDocument.Domain%2A> à microsoft.com permettrait deux pages pour communiquer entre eux.  
  
 Chaînes assignées à la <xref:System.Windows.Forms.HtmlDocument.Domain%2A> propriété doit être des domaines de niveau supérieur valides. Dans l’exemple précédent de l’URL, vous pouvez définir <xref:System.Windows.Forms.HtmlDocument.Domain%2A> à microsoft.com, mais pas à .com, qui permettrait à n’importe quelle page sur Internet d’écrire le contenu d’une page.  
  
 Vous ne pouvez pas utiliser le <xref:System.Windows.Forms.HtmlDocument.Domain%2A> propriété pour activer l’écriture de scripts inter-frame pour les pages accédés à l’aide de deux protocoles différents. Si un frame dans votre page provient d’un serveur Web (le protocole http://) et un autre vient du protocole de système (le file://) du fichier, elles ne seront pas en mesure de communiquer entre eux indépendamment de la valeur de la <xref:System.Windows.Forms.HtmlDocument.Domain%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’argument pour la propriété <c>Domain</c> doit être un nom de domaine valide respectant les conventions Domain Name System (DNS).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752575.aspx">Propriété de domaine</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms533028.aspx">Sur la sécurité et des scripts inter-Frame</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms535250.aspx">Objet frame</related>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomDocument : obj" Usage="System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le pointeur d'interface non managé pour ce <see cref="T:System.Windows.Forms.HtmlDocument" />.</summary>
        <value>Un <see cref="T:System.Object" /> représentant un <c>IDispatch</c> pointeur vers le document non managé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> est un wrapper pour l’Internet Explorer modèle DOM (Document Object), qui est écrit dans COM. Si vous avez besoin d’accéder à des propriétés non exposées ou méthodes sur les interfaces COM sous-jacentes, telles que `IHTMLDocument2`, vous pouvez utiliser cet objet à interroger pour eux.  
  
 Pour utiliser les interfaces non managées, importer la bibliothèque MSHTML (mshtml.dll) dans votre application. Toutefois, vous pouvez également exécuter des propriétés non exposées et les méthodes à l’aide de la `IDispatch::Invoke` (méthode).  
  
   
  
## Examples  
 Le code suivant exemple convertit le <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> à un `IHTMLDocument2` pointeur et affiche la valeur de la `lastModified` propriété, qui indique quand le propriétaire du document dernière mise à jour son contenu. L’exemple de code requiert que vous avez un <xref:System.Windows.Forms.Button> sur votre formulaire nommé `Button6`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> autorisation. Énumération associée : <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">Interface IHTMLDocument2</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=128638">Référence MSHTML</related>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'encodage de caractères pour ce document.</summary>
        <value>
          <see cref="T:System.String" /> qui représente l'encodage de caractères actuel.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms537500.aspx">Reconnaissance de jeu de caractères</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752566.aspx">Propriété de jeu de caractères</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlDocument.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à tester.</param>
        <summary>Teste l'objet pour déterminer s'il est égal à l'objet actif.</summary>
        <returns>
          <see langword="true" /> si les objets sont égaux ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ExecCommand : string * bool * obj -&gt; unit" Usage="htmlDocument.ExecCommand (command, showUI, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">Nom de la commande à exécuter.</param>
        <param name="showUI">Indique si les boîtes de dialogue ou messages spécifiques à la commande doivent être présentés à l'utilisateur.</param>
        <param name="value">Valeur à assigner à l'aide de la commande. Non applicable pour toutes les commandes.</param>
        <summary>Exécute la commande spécifiée contre le document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> expose un grand tableau de commandes pour lequel il n’existe aucune méthode exposées sur <xref:System.Windows.Forms.HtmlDocument>. À l’aide de <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> vous pouvez insérer de nouveaux éléments HTML, sélectionner et mettre en forme texte et effacer les mises en cache des informations d’identification de l’authentification. Pour obtenir une liste complète des commandes, consultez [identificateurs de commande](https://go.microsoft.com/fwlink/?LinkId=198814).  
  
> [!NOTE]
>  Certaines commandes, telles que copier, ont des valeurs de retour. Dans l’implémentation actuelle de <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A>, Impossible d’obtenir une valeur de retour à partir de votre appel. Pour récupérer les valeurs de retour, utilisez la méthode non managée correspondante sur un <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> font référence à la place.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536419.aspx">Méthode execCommand</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=198814">Identificateurs de commande</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlDocument.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit le focus d'entrée d'utilisateur sur le document actif.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Windows.Forms.HtmlDocument.Focus%2A> définira le focus sur le <xref:System.Windows.Forms.WebBrowser> contrôler, si le contrôle ne dispose pas actuellement le focus. Si le document est hébergé à l’intérieur d’un `FRAME`, cette méthode mettra le focus sur ce `FRAME` au sein de la `FRAMESET`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> autorisation pour définir le focus sur un formulaire. Énumération associée : <see cref="T:System.Security.Permissions.UIPermissionWindow" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752527.aspx">focus (méthode)</related>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.HtmlDocument.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le document a le focus d'entrée utilisateur.</summary>
        <value>
          <see langword="true" /> si le document a le focus ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant que le focus soit donné au document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.Focusing> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.Focusing> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752520.aspx">Événement onfocusin</related>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur du texte du document.</summary>
        <value>Couleur du texte dans le document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Drawing.Color> <xref:System.Drawing.Color> tapez dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] prend en charge un `Alpha` valeur, le modèle DOM HTML ne mais pas. Par conséquent, `Alpha` n’a aucun effet lorsque assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752580.aspx">Propriété fgColor</related>
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Forms : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Forms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de tous les éléments <c>&lt;FORM&gt;</c> dans le document.</summary>
        <value>Un <see cref="T:System.Windows.Forms.HtmlElementCollection" /> de la <c>&lt;formulaire&gt;</c> éléments dans le document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un document HTML peut avoir un ou plusieurs `FORM` éléments avec des champs d’entrée pour envoyer des données de sauvegarde à un serveur.  
  
 Vous pouvez soumettre par programme un `FORM` en obtenant son <xref:System.Windows.Forms.HtmlElement> et en appelant son `Submit` à l’aide de la méthode le <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> (méthode).  
  
 Pour ajouter un nouveau `FORM` à un document, vous pouvez créer un nouveau `FORM` balise sous forme de chaîne et assignez-la à la <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété d’un élément ajouté précédemment au DOM HTML ; ou vous pouvez utiliser le <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> (méthode), définissez ses propriétés à l’aide de <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, et l’ajouter en tant qu’enfant d’un élément existant à l’aide <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant itère au sein de tous les `Form` éléments sur un serveur Web page et efface toutes les entrées utilisateur, définissant les formulaires à leurs valeurs par défaut.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752591.aspx">Forms, propriété</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752432.aspx">IHTMLFormElement Interface</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetElementById : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">ID de l'attribut de l'élément à récupérer.</param>
        <summary>Récupère un <see cref="T:System.Windows.Forms.HtmlElement" /> en utilisant l’attribut <c>ID</c> de l’élément comme clé de recherche.</summary>
        <returns>Retourne le premier objet comportant le même attribut <c>ID</c> que la valeur spécifiée ou la valeur <see langword="null" /> si <paramref name="id" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il existe plusieurs éléments dans le document avec la même valeur d’ID, <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> retournera la première qu’il trouve.  
  
   
  
## Examples  
 L’exemple de code suivant récupère une nommée `TABLE` à partir d’un document, compte le nombre de lignes et affiche le résultat dans la page Web. L’exemple de code requiert que vous avez un <xref:System.Windows.Forms.WebBrowser> contrôle dans votre projet nommé `WebBrowser1`, et que vous avez chargé une page Web avec un `TABLE` dont `ID` attribut est `Table1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752543.aspx">Méthode getElementById</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromPoint : System.Drawing.Point -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementFromPoint point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Position x,y de l'élément à l'écran, par rapport au coin supérieur gauche du document.</param>
        <summary>Récupère l'élément HTML situé aux coordonnées clientes spécifiées.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElement" /> à l'emplacement d'écran spécifié dans le document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> utilise les coordonnées clientes, dans lequel le coin supérieur gauche du document est affecté à la valeur (0,0). Les coordonnées clientes pour la position actuelle du curseur peuvent être obtenues à l’aide de la <xref:System.Windows.Forms.HtmlWindow.Position%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant détecte un clic sur le document, recherche l’élément et utilise <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> pour aligner l’élément avec le bord supérieur de la page Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752576.aspx">Méthode elementFromPoint</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlDocument.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nom de la balise HTML pour les objets <see cref="T:System.Windows.Forms.HtmlElement" /> que vous souhaitez récupérer</param>
        <summary>Récupère une collection d’éléments avec l’étiquette HTML spécifiée.</summary>
        <returns>Collection d'éléments dont le nom de la balise est identique à l'argument <paramref name="tagName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Pages HTML utilisent souvent le `META` balise pour incorporer des informations arbitraires sur le document. L’exemple de code HTML suivant récupère toutes les `META` balises dans un document HTML, recherche la `META` balise portant le nom `Description`et l’affiche à l’utilisateur. L’exemple de code requiert que votre application possède un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752545.aspx">Méthode getElementsByTagName</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlDocument.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère le code de hachage pour cet objet.</summary>
        <returns>
          <see cref="T:System.Int32" /> représentant un hachage en mémoire de cet objet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Images : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Images" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de toutes les étiquettes d’image dans le document.</summary>
        <value>Collection d'objets <see cref="T:System.Windows.Forms.HtmlElement" />, un pour chaque balise IMG dans le document. Les éléments sont retournés de la collection dans l’ordre de la source.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> Retourne une collection de <xref:System.Windows.Forms.HtmlElement> objets. Accéder à des attributs, tels que `ALT` et `SRC`, qui ne sont pas directement exposées par <xref:System.Windows.Forms.HtmlElement>, utilisez le <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> (méthode).  
  
 Pour ajouter une nouvelle image à un document, créez une nouvelle `IMG` balise sous forme de chaîne et l’assigner à la <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété d’un élément ajouté précédemment au DOM HTML ; ou utilisez le <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> (méthode), définissez ses propriétés à l’aide de <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>et l’ajouter en tant qu’un enfant d’un élément existant à l’aide <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant examine le `ALT` attribut de toutes les images dans le document et définit une valeur par défaut `ALT` attribut si une valeur n’est pas déjà définie.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752593.aspx">images, propriété</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une fonction Active Scripting définie dans une page HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant exécute le contenu d’un script dans une page Web. L’exemple de code requiert que vous avez chargé la page Web suivante.  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="htmlDocument.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nom de la méthode du script à appeler.</param>
        <summary>Exécute une fonction Active Scripting définie dans une page HTML.</summary>
        <returns>Objet retourné par l'appel Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type sous-jacent de l’objet retourné par <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> peuvent varier. Si la fonction Active Scripting appelée retourne des données scalaires, tel qu’une chaîne ou un entier, il s’affichera sous forme de chaîne. Si elle retourne un objet basé sur script, tel qu’un objet créé à l’aide de JScript ou de VBScript `new` opérateur, il sera de type `Object`. (Vous pouvez effectuer des appels sur de tels objets en appelant <xref:System.Object.GetType%2A> et à l’aide de <xref:System.Type.InvokeMember%2A>.) Si elle retourne un élément DOM HTML, comme un `DIV` ou un `TABLE`, il sera de type `Object`; si vous avez ajouté une référence de projet à MSHTML. DLL, toutefois, elle sera convertie en son type DOM non managé spécifique.  
  
 Vous pouvez appeler une fonction écrite dans n’importe quel langage Active Scripting installée sur l’ordinateur de l’utilisateur, y compris JScript et VBScript.  
  
 Le <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> ne fera rien si l’utilisateur a explicitement désactivé de l’exécution du script dans Internet Explorer, ou si la configuration de sécurité actuelle pour la page Web ne l’autorise pas.  
  
   
  
## Examples  
 L’exemple de code suivant exécute le contenu d’un script dans une page Web. L’exemple de code requiert que vous avez un <xref:System.Windows.Forms.WebBrowser> dans votre application appelé `WebBrowser1`, et que vous avez chargé la page Web suivante.  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="htmlDocument.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nom de la méthode du script à appeler.</param>
        <param name="args">Arguments à transmettre à la méthode de script.</param>
        <summary>Exécute une fonction Active Scripting définie dans une page HTML.</summary>
        <returns>Objet retourné par l'appel Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type sous-jacent de l’objet retourné par <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> peuvent varier. Si la fonction Active Scripting appelée retourne des données scalaires, tel qu’une chaîne ou un entier, il s’affichera sous forme de chaîne. Si elle retourne un objet basé sur script, tel qu’un objet créé à l’aide de JScript ou de VBScript `new` opérateur, il sera de type `Object`. (Vous pouvez effectuer des appels sur de tels objets en appelant <xref:System.Object.GetType%2A> et à l’aide de <xref:System.Type.InvokeMember%2A>.) Si elle retourne un élément DOM HTML, comme un `DIV` ou un `TABLE`, il sera de type `Object`; si vous avez ajouté une référence de projet à MSHTML. DLL, toutefois, elle sera convertie en son type DOM non managé spécifique.  
  
 Vous pouvez appeler une fonction écrite dans n’importe quel langage Active Scripting installée sur l’ordinateur de l’utilisateur, y compris JScript et VBScript.  
  
 Cette méthode ne fera rien si l’utilisateur a explicitement désactivé de l’exécution du script dans Internet Explorer, ou si la configuration de sécurité actuelle pour la page Web ne l’autorise pas.  
  
   
  
## Examples  
 L’exemple de code suivant exécute le contenu d’un script dans une page Web. L’exemple de code requiert que vous avez un <xref:System.Windows.Forms.WebBrowser> dans votre application appelé `WebBrowser1`, et que vous avez chargé la page Web suivante.  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur de liens hypertexte.</summary>
        <value>Couleur pour les liens hypertexte dans le document actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Drawing.Color> tapez dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] prend en charge un `Alpha` valeur, le modèle DOM HTML ne mais pas. Par conséquent, `Alpha` n’a aucun effet lorsque assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752608.aspx">Propriété linkColor</related>
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Links : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Links" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste de tous les liens hypertexte dans ce document HTML.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> d'objets <see cref="T:System.Windows.Forms.HtmlElement" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette collection contiendra tous les liens créés à l’aide de la `A`, `LINK`, et `AREA` balises au format HTML.  
  
 Le <xref:System.Windows.Forms.HtmlElement> encapsulent les objets contenus dans cette collection managée `IHTMLLinkElement` interface. Pour accéder en toute sécurité les propriétés de l’interface sous-jacente, utilisez la <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752595.aspx">lie la propriété</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand le focus quitte un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.LosingFocus> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.LosingFocus> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752521.aspx">Événement onfocusout</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique sur le bouton gauche de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.HtmlDocument.MouseDown> événement se produit avant le <xref:System.Windows.Forms.HtmlDocument.Click> événement.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.MouseDown> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.MouseDown> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752619.aspx">Événement onmousedown</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la souris ne survole plus le document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.MouseLeave> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.MouseLeave> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536948.aspx">Événement onmouseout</related>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la souris est placée au-dessus du document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.MouseMove> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.MouseMove> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752620.aspx">Événement OnMouseMove</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la souris est placée au-dessus du document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur la gestion des événements, [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.MouseOver> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.MouseOver> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752622.aspx">Événement onmouseover</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l’utilisateur relâche le bouton gauche de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlDocument.MouseUp> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlDocument> nommé `HtmlDocument1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlDocument.MouseUp> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752623.aspx">Événement onmouseup</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Première instance à comparer.</param>
        <param name="right">Deuxième instance à comparer.</param>
        <summary>Retourne une valeur qui indique si les instances de <see cref="T:System.Windows.Forms.HtmlDocument" /> spécifiées représentent la même valeur.</summary>
        <returns>
          <see langword="true" /> si les instances spécifiées sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="System.Windows.Forms.HtmlDocument.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Première instance à comparer.</param>
        <param name="right">Deuxième instance à comparer.</param>
        <summary>Retourne une valeur qui indique si les instances de <see cref="T:System.Windows.Forms.HtmlDocument" /> spécifiées ne représentent pas la même valeur.</summary>
        <returns>
          <see langword="true" /> si les instances spécifiées ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : bool -&gt; System.Windows.Forms.HtmlDocument" Usage="htmlDocument.OpenNew replaceInHistory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">Si la nouvelle fenêtre de navigation doit remplacer l'élément précédent dans l'historique de navigation du DOM.</param>
        <summary>Obtient un nouveau <see cref="T:System.Windows.Forms.HtmlDocument" /> à utiliser avec la méthode <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />.</summary>
        <returns>Nouveau document pour écrire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> Efface le document chargé précédemment, y compris les États associés, tels que des variables. Cela n’entraînera des événements de navigation dans <xref:System.Windows.Forms.WebBrowser> à signaler.  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> crée toujours un nouveau document dans la fenêtre active. Pour ouvrir un document dans une nouvelle fenêtre, utilisez le <xref:System.Windows.Forms.HtmlWindow.Open%2A> méthode sur le <xref:System.Windows.Forms.HtmlWindow> classe.  
  
   
  
## Examples  
 L’exemple de code suivant prépare le DOM pour écrire et écrit un nouveau document à l’aide du <xref:System.Windows.Forms.HtmlDocument.Write%2A> (méthode).  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752628.aspx">Méthode Open</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool with get, set" Usage="System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la direction du texte dans le document actif.</summary>
        <value>
          <see langword="true" /> si le texte est affiché de droite à gauche ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> aura pas de valeur, sauf si elle a été définie explicitement, dans le code ou au format HTML.  
  
 Contrairement à la <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> propriété sur les contrôles Windows Forms, <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> sur le modèle DOM HTML managé n’affectera pas la direction des caractères latins.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752540.aspx">Propriété dir</related>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la navigation vers une autre page web est arrêtée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chargement d’une page Web s’arrête si le code de programme appelle la <xref:System.Windows.Forms.WebBrowser.Stop%2A> méthode de la <xref:System.Windows.Forms.WebBrowser> contrôle. Défaillances de navigation provoquées par les pannes réseau ou des sites Web ne fonctionnant pas correctement n’entraîne pas <xref:System.Windows.Forms.HtmlDocument.Stop> se produise.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant réinitialise la barre d’état sur une application Windows Forms lorsque le `Stop` événement s’est produit. L’exemple de code requiert que vous avez un <xref:System.Windows.Forms.StatusBar> contrôle nommé `StatusBar1` dans votre application.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752561.aspx">Événement OnStop</related>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur texte de la balise <c>&lt;TITLE&gt;</c> dans le document HTML actif.</summary>
        <value>Titre du document actif.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Forms.HtmlDocument.Title%2A> propriété pour identifier le document par un nom explicite.  
  
 Modifications apportées à cette propriété reflète également dans le <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> propriété de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant crée un lien hypertexte HTML pour le document actif à l’aide de l’URL du document comme emplacement du lien et le titre du document comme texte du lien. L’exemple de code requiert que votre application possède un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlDocument.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URL qui décrit l'emplacement de ce document.</summary>
        <value>
          <see cref="T:System.Uri" /> qui représente l'URL de ce document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est en lecture seule. Pour accéder à un nouveau document, utilisez la <xref:System.Windows.Forms.WebBrowser.Url%2A> propriété sur le <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.VisitedLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur des liens vers les pages HTML que l'utilisateur a déjà visitées.</summary>
        <value>Couleur des liens visités.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Color` tapez dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] prend en charge un `Alpha` valeur, le modèle DOM HTML ne mais pas. Par conséquent, `Alpha` n’a aucun effet lorsque assignée à cette propriété.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752638.aspx">Propriété vlinkColor</related>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Window : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlDocument.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.HtmlWindow" /> associé à ce document.</summary>
        <value>Fenêtre pour ce document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les documents HTML ont un objet DOM HTML appelé fenêtre, qui peut être utilisée pour manipuler la taille d’écran du document et ouvrir de nouvelles fenêtres, mais aussi à d’autres objets importants, comme un <xref:System.Windows.Forms.HtmlHistory>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752599.aspx">Propriété parentWindow</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="htmlDocument.Write text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Texte HTML à écrire dans le document.</param>
        <summary>Écrit une nouvelle page HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tous les appels à <xref:System.Windows.Forms.HtmlDocument.Write%2A> doit être précédé d’un appel à <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A>, ce qui effacera le document actif et toutes ses variables. Vos appels à <xref:System.Windows.Forms.HtmlDocument.Write%2A> créera un nouveau document HTML à la place. Pour modifier uniquement une partie spécifique du document, obtenez approprié <xref:System.Windows.Forms.HtmlElement> et définissez son <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété.  
  
 Il est recommandé que vous écrivez un entier valide HTML document à l’aide de la <xref:System.Windows.Forms.HtmlDocument.Write%2A> (méthode), y compris `HTML` et `BODY` balises. Toutefois, si vous écrivez uniquement les éléments HTML, le modèle DOM (Document Object) vous fournira ces éléments pour vous.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre une nouvelle <xref:System.Windows.Forms.HtmlDocument> et écrit dans un nouveau fichier HTML.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/default.asp?url=/workshop/browser/mshtml/reference/ifaces/document2/write.asp">Écrire (méthode)</related>
      </Docs>
    </Member>
  </Members>
</Type>