<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="64dceccfd2200afd7b30f3838219a566c1a9ab6a" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65006016" /></Metadata><TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingSource&#xA;Inherits Component&#xA;Implements IBindingListView, ICancelAddNew, ICurrencyManagerProvider, IList, ISupportInitializeNotification, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingSource : System::ComponentModel::Component, System::Collections::IList, System::ComponentModel::IBindingListView, System::ComponentModel::ICancelAddNew, System::ComponentModel::ISupportInitializeNotification, System::ComponentModel::ITypedList, System::Windows::Forms::ICurrencyManagerProvider" />
  <TypeSignature Language="F#" Value="type BindingSource = class&#xA;    inherit Component&#xA;    interface IBindingListView&#xA;    interface IBindingList&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ITypedList&#xA;    interface ICancelAddNew&#xA;    interface ISupportInitializeNotification&#xA;    interface ISupportInitialize&#xA;    interface ICurrencyManagerProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsule la source de données pour un formulaire.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource> d’eux a de nombreuses fins. Tout d’abord, il simplifie la liaison de contrôles sur un formulaire à des données en fournissant une gestion des devises, de notification de modification et d’autres services entre les contrôles Windows Forms et les sources de données. Cela est accompli en attachant le <xref:System.Windows.Forms.BindingSource> à votre source de données à l’aide de la <xref:System.Windows.Forms.BindingSource.DataSource%2A> propriété. Pour les scénarios de liaison complexe vous pouvez éventuellement définir le <xref:System.Windows.Forms.BindingSource.DataMember%2A> propriété à une colonne spécifique ou de la liste dans la source de données. Vous pouvez ensuite lier des contrôles à la <xref:System.Windows.Forms.BindingSource>. Toute interaction supplémentaire avec les données est effectuée en appelant le <xref:System.Windows.Forms.BindingSource> composant. Pour obtenir des exemples sur la façon dont le <xref:System.Windows.Forms.BindingSource> peut simplifier le processus de liaison, consultez [Comment : Lier des contrôles Windows Forms à des valeurs de base de données DBNull](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) et [Comment : Gérer les erreurs et Exceptions qui se produisent avec Databinding](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md). Navigation et la mise à jour de la source de données s’effectue via des méthodes telles que <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, et <xref:System.Windows.Forms.BindingSource.Remove%2A>. Opérations telles que le tri et le filtrage sont gérées via le <xref:System.Windows.Forms.BindingSource.Sort%2A> et <xref:System.Windows.Forms.BindingSource.Filter%2A> propriétés. Pour plus d’informations sur l’utilisation de tri et filtrage avec la <xref:System.Windows.Forms.BindingSource>, consultez [Comment : Trier et filtrer des données ADO.NET avec le composant de BindingSource Windows Forms](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md).  
  
 En outre, le <xref:System.Windows.Forms.BindingSource> composant peut agir comme une source de données fortement typées. En règle générale, le type de la source de données sous-jacente est fixe via un des mécanismes suivants :  
  
-   Utilisez le <xref:System.Windows.Forms.BindingSource.Add%2A> méthode pour ajouter un élément à la <xref:System.Windows.Forms.BindingSource> composant.  
  
-   Définir le <xref:System.Windows.Forms.BindingSource.DataSource%2A> à une liste, un objet unique ou un type de propriété.  
  
 Ces deux mécanismes créer une liste fortement typée. Pour plus d’informations sur l’utilisation de la <xref:System.Windows.Forms.BindingSource> pour lier à un type, consultez [Comment : Lier un contrôle de formulaires Windows à un Type](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). Vous pouvez également utiliser le <xref:System.Windows.Forms.BindingSource> pour lier vos contrôles à un objet de fabrique. Pour plus d’informations sur la façon de procéder, consultez [Comment : Lier un contrôle de formulaires Windows à un objet de fabrique](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md).  
  
> [!NOTE]
>  Étant donné qu’un <xref:System.Windows.Forms.BindingSource> gère les deux sources de données simples et complexes, la terminologie est problématique. Dans cette documentation de classe, le terme *liste* fait référence à une collection de données au sein de la source de données hébergé et *élément* désigne un élément unique. Lorsque fonctionnalités associé à des sources de données complexes, les termes équivalents *table* et *ligne* sont utilisés.  
  
 <xref:System.Windows.Forms.BindingSource> Fournit des membres pour l’accès aux données sous-jacentes. L’élément actuel peut être récupéré via la <xref:System.Windows.Forms.BindingSource.Current%2A> propriété et la liste entière peuvent être récupéré via la <xref:System.Windows.Forms.BindingSource.List%2A> propriété. Opérations de modification sont prises en charge sur l’élément actuel via <xref:System.Windows.Forms.BindingSource.Current%2A> et <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>, <xref:System.Windows.Forms.BindingSource.EndEdit%2A>, <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> et <xref:System.Windows.Forms.BindingSource.Add%2A> et <xref:System.Windows.Forms.BindingSource.AddNew%2A> méthodes. Bien que la gestion de la devise est gérée automatiquement pour tous les types de source de données sous-jacente, cette classe expose un nombre d’événements, tels que <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> et <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, qui permettent la personnalisation.  
  
 Sources de données qui sont liés à un <xref:System.Windows.Forms.BindingSource> composant peut également être parcourue et géré avec la <xref:System.Windows.Forms.BindingNavigator> classe, qui fournit une interface utilisateur de type magnétoscope (IU) pour parcourir les éléments d’une liste. Bien que <xref:System.Windows.Forms.BindingNavigator> peut être lié à n’importe quelle source de données, il a été conçu pour s’intégrer avec un <xref:System.Windows.Forms.BindingSource> composant via son <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> propriété.  
  
 La propriété par défaut pour le <xref:System.Windows.Forms.BindingSource> classe est <xref:System.Windows.Forms.BindingSource.DataSource%2A>. L’événement par défaut est <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Nombre de membres de la <xref:System.Windows.Forms.BindingSource> classe fonctionnent dans la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété et simplement référence à leur opération dans la liste sous-jacente. Par conséquent, lorsque le <xref:System.Windows.Forms.BindingSource> est lié à une implémentation personnalisée de <xref:System.Collections.IList>, le comportement exact de ces membres peut différer du comportement décrit dans la documentation de classe. Par exemple, le <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> les appels de méthode <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>. Le <xref:System.Windows.Forms.BindingSource> documentation décrit la <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> méthode avec la présentation qui le <xref:System.Collections.IList.RemoveAt%2A> méthode pour sous-jacent <xref:System.Collections.IList> est correctement implémenté.  
  
   
  
## Examples  
 L’exemple de code suivant montre un <xref:System.Windows.Forms.ListBox> lié à un <xref:System.Windows.Forms.BindingSource>. Le <xref:System.Windows.Forms.BindingSource> est lié à un <xref:System.ComponentModel.BindingList%601> qui contient une liste de polices.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingSource" />
    <altmember cref="T:System.Windows.Forms.BindingNavigator" />
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.CurrencyManager" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.ComponentModel.IBindingList" />
    <altmember cref="T:System.ComponentModel.IEditableObject" />
    <related type="Article" href="~/docs/framework/winforms/controls/bindingsource-component.md">Composant BindingSource</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Windows.Forms.BindingSource" /> classe les valeurs de propriété par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente la valeur par défaut <xref:System.Windows.Forms.BindingSource> les valeurs de propriété initialisées par ce constructeur.  
  
|Propriété|Valeur par défaut|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : System.ComponentModel.IContainer -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Le <see cref="T:System.ComponentModel.IContainer" /> pour ajouter actuel <see cref="T:System.Windows.Forms.BindingSource" /> à.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Windows.Forms.BindingSource" /> classe et ajoute le <see cref="T:System.Windows.Forms.BindingSource" /> au conteneur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur appelle le constructeur par défaut, puis ajoute actuel <xref:System.Windows.Forms.BindingSource> au conteneur spécifié. Il n'est pas généralement utilisé par le programmeur de solutions, mais plutôt par les auteurs des environnements de conception.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : obj * string -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource (dataSource, dataMember)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">La source de données pour le <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">Colonne spécifique ou nom de liste dans la source de données à laquelle effectuer la liaison.</param>
        <summary>Initialise une nouvelle instance de la <see cref="T:System.Windows.Forms.BindingSource" /> classe avec la source de données spécifiée et un membre de données.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="bindingSource.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Un <see cref="T:System.Object" /> à ajouter à la liste interne.</param>
        <summary>Ajoute un élément existant à la liste interne.</summary>
        <returns>Index de base zéro au niveau duquel <paramref name="value" /> a été ajouté à la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Add%2A> méthode fait référence à l’appel à la liste sous-jacente `Add` (méthode).  
  
 La liste interne doit contenir des types homogènes. Si le <xref:System.Windows.Forms.BindingSource.DataSource%2A> propriété n’a pas déjà été définie, puis le premier objet ajouté à la liste définit le type de la liste.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
   
  
## Examples  
 Le code suivant exemple comment utiliser le <xref:System.Windows.Forms.BindingSource.Add%2A> (méthode). Pour exécuter cet exemple, collez le code dans un Windows Form et appelez le `PopulateBindingSourceWithFonts` méthode à partir du constructeur du formulaire.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> diffère selon les types d’éléments existants dans la liste sous-jacente.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AddingNew As AddingNewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AddingNewEventHandler ^ AddingNew;" />
      <MemberSignature Language="F#" Value="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " Usage="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit avant l'ajout d'un élément à la liste sous-jacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.AddingNew> événement se produit avant un nouvel objet est ajouté à la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété. Cet événement est déclenché après le <xref:System.Windows.Forms.BindingSource.AddNew%2A> méthode est appelée, mais avant que le nouvel élément est créé et ajouté à la liste sous-jacente. En gérant cet événement, le programmeur peut fournir la création d’élément personnalisé et le comportement d’insertion sans être obligé de dériver à partir de la <xref:System.Windows.Forms.BindingSource> classe. Cela s’effectue dans le Gestionnaire d’événements en définissant le <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propriété de le <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> paramètre vers le nouvel élément. L’objet créé dans le <xref:System.Windows.Forms.BindingSource.AddingNew> événement doit être du même type que le type contenu dans la liste ou une exception se produit. Vous ne pouvez pas définir le <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propriété lorsqu’elle est liée à un <xref:System.Data.DataView> ou <xref:System.Data.DataTable> , car vous ne pouvez pas ajouter un nouveau <xref:System.Data.DataRowView> à la liste.  
  
 Pour plus d’informations sur la fourniture des fonctionnalités personnalisées de création d’élément, consultez le <xref:System.Windows.Forms.BindingSource.AddNew%2A> (méthode). Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Le code suivant exemple utilise un <xref:System.Windows.Forms.BindingSource> composant pour lier une liste à un <xref:System.Windows.Forms.DataGridView> contrôle. Nouveaux éléments sont ajoutés à la liste en le <xref:System.Windows.Forms.BindingSource.AddingNew> Gestionnaire d’événements. Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : Personnaliser l’ajout d’élément avec le BindingSource Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" /> n’est pas le même type que le type contenu dans la liste.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNew () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ AddNew();" />
      <MemberSignature Language="F#" Value="abstract member AddNew : unit -&gt; obj&#xA;override this.AddNew : unit -&gt; obj" Usage="bindingSource.AddNew " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.AddNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ajoute un nouvel élément à la liste sous-jacente.</summary>
        <returns>Le <see cref="T:System.Object" /> qui a été créé et ajouté à la liste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.AddNew%2A> méthode ajoute un nouvel élément à la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété. Cette méthode configure de la série d’actions suivante :  
  
1.  Le <xref:System.Windows.Forms.BindingSource.EndEdit%2A> méthode est appelée automatiquement pour les opérations de modification en attente de validation.  
  
2.  Le <xref:System.Windows.Forms.BindingSource.AddingNew> événement est déclenché automatiquement. Cet événement peut être géré par programme pour construire le nouvel élément. Cela s’effectue dans le Gestionnaire d’événements en définissant le <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> propriété de le <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> paramètre vers le nouvel élément. L’objet créé dans le <xref:System.Windows.Forms.BindingSource.AddingNew> événement doit être du même type que le type contenu dans la liste ou une exception se produit.  
  
     Si le <xref:System.Windows.Forms.BindingSource.AddingNew> événement n’est pas géré, et la liste sous-jacente est une <xref:System.ComponentModel.IBindingList>, puis la demande est passée à la liste <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> (méthode). Si la liste sous-jacente n'est pas un <xref:System.ComponentModel.IBindingList>, l'élément est créé automatiquement via son constructeur public par défaut. Dans les deux cas, le nouvel élément est ajouté à la fin de la liste.  
  
3.  Le nouvel élément est ajouté immédiatement à la liste interne, sauf si la source de données implémente le <xref:System.ComponentModel.IEditableObject> interface. Dans ce cas, le nouvel élément n’est pas validé tant qu’un appel explicit à <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> est effectuée ou qu’une nouvelle opération de liste soit initialisée. Avant qu’il soit validée, le nouvel élément peut être restauré en appelant <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, auquel cas le nouvel élément est ignoré.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
   
  
## Examples  
 Le code suivant exemple utilise un <xref:System.Windows.Forms.BindingSource> composant pour lier une liste à un <xref:System.Windows.Forms.DataGridView> contrôle. Nouveaux éléments sont ajoutés à la liste en le <xref:System.Windows.Forms.BindingSource.AddingNew> Gestionnaire d’événements. Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : Personnaliser l’ajout d’élément avec le BindingSource Windows Forms](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> a la valeur <see langword="false" />.  
  
ou 
Un constructeur public par défaut est introuvable pour le type d’élément actuel.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
        <altmember cref="T:System.ComponentModel.IBindingList" />
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowEdit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowEdit : bool" Usage="System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.AllowEdit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si les éléments de la liste sous-jacente peuvent être modifiés.</summary>
        <value><see langword="true" /> pour indiquer les éléments de liste peut être modifiées ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> propriété est généralement utilisée par d’autres composants pour déterminer si la modification des éléments de la liste est autorisée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowNew As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowNew { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowNew : bool with get, set" Usage="System.Windows.Forms.BindingSource.AllowNew" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> méthode peut être utilisée pour ajouter des éléments à la liste.</summary>
        <value><see langword="true" /> Si <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> peut être utilisé pour ajouter des éléments à la liste ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur par défaut pour le <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propriété varie selon le type de source de données sous-jacente. Si la liste sous-jacente implémente le <xref:System.ComponentModel.IBindingList> interface, cette propriété délègue à la liste sous-jacente. Sinon, cette propriété retourne `false` si la liste sous-jacente est une des caractéristiques suivantes :  
  
-   Il a une taille fixe, tel que déterminé par le <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> propriété.  
  
-   Elle est en lecture seule, comme déterminé par le <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propriété.  
  
-   Le type de l’élément n’a pas de constructeur par défaut.  
  
> [!NOTE]
>  Une fois que la valeur de cette propriété est définie, la méthode getter ne fait plus référence l’appel à la liste sous-jacente. Au lieu de cela, elle retourne simplement la valeur précédemment définie jusqu'à ce que le <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> méthode est appelée.  
  
 Définition de cette propriété déclenche le <xref:System.Windows.Forms.BindingSource.ListChanged> événement avec <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> défini sur <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>.  
  
 Si vous définissez la <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propriété `true` et le type de liste sous-jacent n’a pas d’un constructeur par défaut, vous devez gérer le <xref:System.Windows.Forms.BindingSource.AddingNew> événement et créer le type approprié.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propriété de la <xref:System.Windows.Forms.BindingSource> composant à l’utilisateur à ajouter de nouveaux éléments à la <xref:System.Windows.Forms.BindingSource> liste sous-jacente du composant. Si cette propriété `true` provoque la limite <xref:System.Windows.Forms.DataGridView> contrôle à afficher sa ligne pour les nouveaux enregistrements.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette propriété est définie sur <see langword="true" /> lorsque la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété a une taille fixe ou est en lecture seule.</exception>
        <exception cref="T:System.MissingMethodException">La propriété est définie sur <see langword="true" /> et <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> événement n’est pas géré lorsque le type de liste sous-jacent n’a pas un constructeur par défaut.</exception>
        <altmember cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowEdit" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowRemove" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowRemove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowRemove { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowRemove : bool" Usage="System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.AllowRemove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si des éléments peuvent être supprimés de la liste sous-jacente.</summary>
        <value><see langword="true" /> pour indiquer la liste des éléments peuvent être supprimés de la liste ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> propriété est généralement utilisée par d’autres composants pour déterminer si la modification des éléments de la liste est autorisée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplySort">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trie la source de données avec les descriptions de tri spécifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (sorts As ListSortDescriptionCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::ListSortDescriptionCollection ^ sorts);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit" Usage="bindingSource.ApplySort sorts" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingListView.ApplySort(System.ComponentModel.ListSortDescriptionCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">Un <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> qui contient les descriptions de tri à appliquer à la source de données.</param>
        <summary>Trie la source de données avec les descriptions de tri spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView> implémente le tri multicolonne comme un ensemble de paires direction-descripteur de propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La source de données n’est pas un <see cref="T:System.ComponentModel.IBindingListView" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (property As PropertyDescriptor, sort As ListSortDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::PropertyDescriptor ^ property, System::ComponentModel::ListSortDirection sort);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit" Usage="bindingSource.ApplySort (property, sort)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">Un <see cref="T:System.ComponentModel.PropertyDescriptor" /> qui décrit la propriété par laquelle trier la source de données.</param>
        <param name="sort">Un <see cref="T:System.ComponentModel.ListSortDirection" /> indiquant comment la liste doit être triée.</param>
        <summary>Trie la source de données avec le descripteur de propriété et la direction de tri spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ComponentModel.IBindingList> implémente le tri de colonne unique à l’aide un <xref:System.ComponentModel.PropertyDescriptor> pour indiquer une propriété par laquelle trier et un <xref:System.ComponentModel.ListSortDirection> indiquant si le contenu de la propriété doit être trié dans l’ordre croissant ou décroissant.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La source de données n’est pas un <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingComplete As BindingCompleteEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingCompleteEventHandler ^ BindingComplete;" />
      <MemberSignature Language="F#" Value="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " Usage="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque tous les clients ont été liés à ce <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.BindingComplete> événement se produit après tous les clients, généralement des contrôles, ont été liés à l’actuel <xref:System.Windows.Forms.BindingSource>. Le Gestionnaire de cet événement peut prendre les mesures appropriées en fonction de la réussite, erreur ou exceptions dans le processus de liaison, en examinant le <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> propriété de le <xref:System.Windows.Forms.BindingCompleteEventArgs> paramètre.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre la gestion du <xref:System.Windows.Forms.BindingSource.BindingComplete> événement. Pour exécuter ce code, collez-le dans un fichier de code vide.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState" />
        <altmember cref="T:System.Windows.Forms.BindingCompleteEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingSource.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Annule l'opération de modification actuelle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ignore les modifications apportées aux données dans la mesure où le dernier enregistrement ou opération de chargement si les deux conditions suivantes sont remplies :  
  
-   La source de données implémente le <xref:System.ComponentModel.IEditableObject> interface.  
  
-   Le <xref:System.Windows.Forms.BindingSource.EndEdit%2A> méthode n’a pas encore été appelée.  
  
 Cette méthode appelle la <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> méthode sous-jacent <xref:System.Windows.Forms.CurrencyManager>et est limité à des modifications apportées au niveau des lignes.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="bindingSource.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Clear%2A> méthode supprime tous les éléments de la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété et définit le <xref:System.Windows.Forms.BindingSource.Count%2A> propriété à zéro.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="bindingSource.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Le <see cref="T:System.Object" /> à localiser dans la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété. La valeur peut être <see langword="null" />.</param>
        <summary>Détermine si un objet est un élément de la liste.</summary>
        <returns><see langword="true" /> Si le <paramref name="value" /> paramètre se trouve dans le <see cref="P:System.Windows.Forms.BindingSource.List" />; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que l’implémentation dépend de la liste sous-jacente `Contains` (méthode), généralement les caractéristiques suivantes s’appliquent :  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> recherche est effectuée à partir du premier élément au dernier élément.  
  
-   La méthode sous-jacente effectue une recherche linéaire ; Par conséquent, la durée d’exécution moyenne est proportionnelle à la valeur de la <xref:System.Windows.Forms.BindingSource.Count%2A> propriété.  
  
-   La méthode sous-jacente détermine l’égalité en appelant le <xref:System.Object.Equals%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (arr As Array, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ arr, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="bindingSource.CopyTo (arr, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Tableau de destination.</param>
        <param name="index">Index dans le tableau de destination auquel commencer l'opération de copie.</param>
        <summary>Copie le contenu de la <see cref="P:System.Windows.Forms.BindingSource.List" /> dans le tableau spécifié, en commençant à la valeur d’index spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette méthode pour combiner des éléments provenant de plusieurs sources dans un seul tableau.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Forms.BindingSource.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d’éléments dans la liste sous-jacente, en prenant cours <see cref="P:System.Windows.Forms.BindingSource.Filter" /> valeur en considération.</summary>
        <value>Nombre total d'éléments filtrés figurant dans la liste sous-jacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Count%2A> propriété obtient le nombre d’éléments dans la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété comme modifiée par la valeur de la <xref:System.Windows.Forms.BindingSource.Filter%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, et <xref:System.Windows.Forms.BindingSource.Count%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1`, deux étiquettes nommées `label1` et `label2`et un bouton nommé `button1`. Associer le `button1_Click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrencyManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::CurrencyManager ^ CurrencyManager { System::Windows::Forms::CurrencyManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrencyManager : System.Windows.Forms.CurrencyManager" Usage="System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.ICurrencyManagerProvider.CurrencyManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le Gestionnaire de devise associé à ce <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <value><see cref="T:System.Windows.Forms.CurrencyManager" /> associé à ce <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez accéder au Gestionnaire de devise pour une autre liaison à l’utilisation de membre de données même le <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : obj" Usage="System.Windows.Forms.BindingSource.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément en cours dans la liste.</summary>
        <value>Un <see cref="T:System.Object" /> qui représente l’élément actuel dans la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété, ou <see langword="null" /> si la liste ne comporte aucun élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser le <xref:System.Windows.Forms.BindingSource.Current%2A> propriété à accéder à l’élément actuel, mais utilisez le <xref:System.Windows.Forms.BindingSource.List%2A> propriété à obtenir la liste entière. Pour déterminer le type de l’objet actuel, utilisez le <xref:System.Object.GetType%2A>, ou <xref:System.Object.ToString%2A> méthodes.  
  
 Pour modifier l’élément actuel, définissez la <xref:System.Windows.Forms.BindingSource.Position%2A> à une nouvelle valeur intégrale, ou utilisez une des méthodes de navigation comme propriété <xref:System.Windows.Forms.BindingSource.MoveNext%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.Current%2A> propriété. Pour exécuter cet exemple, collez le code dans un formulaire et appelez le `PopulateBindingSourceWithFonts` méthode à partir du formulaire <xref:System.Windows.Forms.Form.Load> méthode de gestion d’événements.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanged : EventHandler " Usage="member this.CurrentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'élément actuellement lié change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.CurrentChanged> événement est déclenché chaque fois que le <xref:System.Windows.Forms.BindingSource.Current%2A> des modifications de propriété pour une des raisons suivantes :  
  
-   La position actuelle de la <xref:System.Windows.Forms.BindingSource.List%2A> modifications.  
  
-   Le <xref:System.Windows.Forms.BindingSource.DataSource%2A> ou <xref:System.Windows.Forms.BindingSource.DataMember%2A> modification des propriétés.  
  
-   L’appartenance de l’objet sous-jacent <xref:System.Windows.Forms.BindingSource.List%2A> change, ce qui conduit <xref:System.Windows.Forms.BindingSource.Position%2A> pour faire référence à un autre élément. Exemples incluent l’ajout ou la suppression d’un élément avant l’élément actuel, suppression ou déplacement de l’élément actuel lui-même ou déplacement d’un élément à la position actuelle.  
  
-   La liste sous-jacente est actualisée par un nouveau tri ou une opération de filtrage.  
  
 Lorsque cet événement est déclenché, le <xref:System.Windows.Forms.BindingSource.Current%2A> propriété contiennent déjà sa nouvelle valeur.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged> est l’événement par défaut pour le <xref:System.Windows.Forms.BindingSource> classe.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentItemChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentItemChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentItemChanged : EventHandler " Usage="member this.CurrentItemChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu’une valeur de propriété de la <see cref="P:System.Windows.Forms.BindingSource.Current" /> propriété a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> événement est déclenché en réponse à toutes les circonstances qui déclenchent le <xref:System.Windows.Forms.BindingSource.CurrentChanged> événement. En outre, <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> est également déclenché chaque fois que la valeur de l’une des propriétés de <xref:System.Windows.Forms.BindingSource.Current%2A> est modifiée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataError As BindingManagerDataErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingManagerDataErrorEventHandler ^ DataError;" />
      <MemberSignature Language="F#" Value="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " Usage="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu’une exception relative à la devise est gérée silencieusement par le <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est informatif et signale uniquement les exceptions conformes CLS. Pour déterminer quel type d’exception s’est produite, gérez cet événement et vérifiez la <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> propriété de la <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataMember : string with get, set" Usage="System.Windows.Forms.BindingSource.DataMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la liste spécifique dans la source de données à laquelle le connecteur effectue actuellement des liaisons.</summary>
        <value>Le nom d’une liste (ou ligne) dans le <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Forms.BindingSource.DataSource%2A> contient plusieurs listes (ou tables) de données, vous devez définir le <xref:System.Windows.Forms.BindingSource.DataMember%2A> propriété le nom d’une des sources.  
  
 Définition de cette propriété déclenche le <xref:System.Windows.Forms.BindingSource.DataMemberChanged> événement  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataMemberChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataMemberChanged;" />
      <MemberSignature Language="F#" Value="member this.DataMemberChanged : EventHandler " Usage="member this.DataMemberChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de propriété <see cref="P:System.Windows.Forms.BindingSource.DataMember" /> a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.DataMemberChanged> événement se produit après le <xref:System.Windows.Forms.BindingSource.DataMember%2A> les modifications de propriété.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : obj with get, set" Usage="System.Windows.Forms.BindingSource.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la source de données à laquelle le connecteur effectue une liaison.</summary>
        <value>Un <see cref="T:System.Object" /> qui agit comme une source de données. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.DataSource%2A> propriété peut être définie à un nombre de sources de données, y compris les types, les objets et les listes de types. La source de données qui en résulte sera exposée comme une liste. Le tableau suivant présente certaines des sources de données courantes et l’évaluation de liste résultante.  
  
|Propriété de source de données|Résultats de la liste|  
|-------------------------|------------------|  
|`null`|Vide <xref:System.ComponentModel.IBindingList> d’objets. Ajout d’un élément définit la liste vers le type de l’élément ajouté.|  
|`null` avec <xref:System.Windows.Forms.BindingSource.DataMember%2A> défini|Non pris en charge, déclenche <xref:System.ArgumentException>.|  
|Type non-liste ou objet de type « T »|Vide <xref:System.ComponentModel.IBindingList> de type « T ».|  
|Instance de tableau|<xref:System.ComponentModel.IBindingList> contenant les éléments du tableau.|  
|<xref:System.Collections.IEnumerable> Instance|Un <xref:System.ComponentModel.IBindingList> contenant le <xref:System.Collections.IEnumerable> éléments.|  
|Instance de liste contenant type « T »|<xref:System.ComponentModel.IBindingList> instance contenant le type « T ».|  
  
 En outre, <xref:System.Windows.Forms.BindingSource.DataSource%2A> peut être définie à d’autres types de liste tel que <xref:System.ComponentModel.IListSource> et <xref:System.ComponentModel.ITypedList> et <xref:System.Windows.Forms.BindingSource> seront traiter de manière appropriée. Dans ce cas, le type contenu dans la liste doit avoir un constructeur par défaut.  
  
 Lorsque vous définissez une source de données, si la référence fournie contient plus d’une liste ou une table, vous devez définir le <xref:System.Windows.Forms.BindingSource.DataMember%2A> en une chaîne qui spécifie la liste à lier. Définition de cette propriété déclenche le <xref:System.Windows.Forms.BindingSource.DataSourceChanged> événement.  
  
> [!NOTE]
>  Si vous apportez des modifications à la <xref:System.Windows.Forms.BindingSource.DataSource%2A> valeur de propriété, vous devez le faire sur le thread d’interface utilisateur utilisateur pour vous assurer que l’interface utilisateur reflète les modifications.  
  
 Le <xref:System.Windows.Forms.BindingSource.DataSource%2A> propriété est la propriété par défaut pour le <xref:System.Windows.Forms.BindingSource> classe.  
  
   
  
## Examples  
 L’exemple de code suivant assigne une liste de clients à la <xref:System.Windows.Forms.BindingSource.DataSource%2A> d’un <xref:System.Windows.Forms.BindingSource> composant. Cet exemple de code fait partie d’un exemple plus complet fourni à [Comment : Déclencher des Notifications de modification à l’aide de la méthode ResetItem de BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.ComponentModel.IListSource" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberSignature Language="F#" Value="member this.DataSourceChanged : EventHandler " Usage="member this.DataSourceChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur de propriété <see cref="P:System.Windows.Forms.BindingSource.DataSource" /> a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.DataSourceChanged> événement se produit après le <xref:System.Windows.Forms.BindingSource.DataSource%2A> les modifications de propriété.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bindingSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources non managées utilisées par <see cref="T:System.Windows.Forms.BindingSource" /> et libère éventuellement les ressources managées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le public `Dispose` (méthode) et le <xref:System.Object.Finalize%2A> (méthode). `Dispose` appelle la méthode protégée `Dispose(Boolean)` méthode avec le `disposing` paramètre défini sur `true`. <xref:System.Object.Finalize%2A> appelle `Dispose` avec `disposing` défini sur `false`.  
  
 Lorsque le `disposing` paramètre est true, cette méthode libère toutes les ressources détenues par les objets managés par ce <xref:System.Windows.Forms.BindingSource> références. Cette méthode appelle la méthode `Dispose` de chaque objet référencé.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> peut être appelée plusieurs fois par d'autres objets. Lors de la substitution <see langword="Dispose(Boolean)" /> veillez à ne pas référencer des objets qui ont été supprimés lors d’un appel précédent à <see langword="Dispose" />. Pour plus d’informations sur l’implémentation <see langword="Dispose(Boolean)" />, consultez [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Pour plus d’informations sur <see langword="Dispose" /> et <see cref="M:System.Object.Finalize" />, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [substitution de la méthode Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndEdit();" />
      <MemberSignature Language="F#" Value="member this.EndEdit : unit -&gt; unit" Usage="bindingSource.EndEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Applique des modifications en attente à la source de données sous-jacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.BindingSource.EndEdit%2A> est appelée, toutes les modifications en attente sont appliquées à la source de données sous-jacente.  
  
 Cette méthode n’a aucun effet, sauf si les objets contenus par la source de données implémentent la <xref:System.ComponentModel.IEditableObject> interface. Si les objets n’implémentent pas le <xref:System.ComponentModel.IEditableObject> interface, les modifications apportées aux données sont copiés à la source de données sous-jacente immédiatement après chaque modification.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.Windows.Forms.BindingSource.Filter" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.Filter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'expression utilisée pour filtrer les lignes qui s'affichent.</summary>
        <value>Chaîne qui spécifie la manière dont les lignes sont filtrées. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Généralement utilisé dans des scénarios de liaison de données complexes, le <xref:System.Windows.Forms.BindingSource.Filter%2A> propriété vous permet d’afficher un sous-ensemble de la <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Sous-jacent uniquement les listes qui implémentent le <xref:System.ComponentModel.IBindingListView> interface prise en charge le filtrage.  
  
 Lorsque <xref:System.Windows.Forms.BindingSource.Filter%2A> n’est pas `null`, le <xref:System.Windows.Forms.BindingSource> passe cette propriété à la liste sous-jacente. Si vous définissez cette propriété pendant l’initialisation d’objet, l’appel est différée jusqu'à une fois que l’initialisation est terminée.  
  
 Pour former une valeur de filtre, spécifiez le nom d’une colonne suivie d’un opérateur et une valeur sur laquelle filtrer. La syntaxe de filtre acceptée dépend de la source de données sous-jacente. Si la source de données sous-jacent est un <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, ou <xref:System.Data.DataView>, vous pouvez spécifier des expressions booléennes à l’aide de la syntaxe documentée pour la <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> propriété.  
  
 La valeur de la <xref:System.Windows.Forms.BindingSource.Filter%2A> propriété affecte la valeur de la <xref:System.Windows.Forms.BindingSource.Count%2A> propriété. En outre, le <xref:System.Windows.Forms.BindingSource.Filter%2A> valeur persisteront lorsque les modifications de source de données. Pour arrêter le filtrage du <xref:System.Windows.Forms.BindingSource.DataSource%2A>, appelez le <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.Filter%2A> propriété avec un <xref:System.Data.DataView>. Pour exécuter cet exemple, collez le code dans un Windows Form et appelez `PopulateDataViewAndFilter` à partir du constructeur du formulaire ou <xref:System.Windows.Forms.Form.Load> méthode de gestion des événements. Votre formulaire doit importer le <xref:System.Xml> et <xref:System.IO> espaces de noms.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveFilter" />
        <altmember cref="P:System.ComponentModel.IBindingList.IsSorted" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche l'élément spécifié dans la source de données.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (prop As PropertyDescriptor, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Find(System::ComponentModel::PropertyDescriptor ^ prop, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int&#xA;override this.Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int" Usage="bindingSource.Find (prop, key)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop"><see cref="T:System.ComponentModel.PropertyDescriptor" /> à rechercher.</param>
        <param name="key">La valeur de <paramref name="prop" /> pour faire correspondre.</param>
        <summary>Recherche l'index de l'élément qui a le descripteur de propriété donné.</summary>
        <returns>Index de base zéro de l’élément qui a la valeur donnée pour <see cref="T:System.ComponentModel.PropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement utilisée dans les cas de liaison de données complexes pour trouver la première ligne où la valeur du champ spécifiée par le `prop` paramètre est égal à la valeur de la `key` paramètre  
  
 Cette méthode fait simplement référence à la demande à la liste sous-jacente <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> (méthode). Par exemple, si la source de données sous-jacente est une <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, ou <xref:System.Data.DataView>, cette méthode appelle la <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> (méthode). Le comportement de <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, telles que la valeur retournée si aucun élément correspondant est trouvé, dépend de l’implémentation de la méthode dans la liste sous-jacente.  
  
   
  
## Examples  
 L'exemple de code suivant illustre l'utilisation de la méthode <xref:System.Windows.Forms.BindingSource.Find%2A>. Pour obtenir un exemple complet, consultez la rubrique Vue d’ensemble de la classe.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente n’est pas de type <see cref="T:System.ComponentModel.IBindingList" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (propertyName As String, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ propertyName, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.Find : string * obj -&gt; int" Usage="bindingSource.Find (propertyName, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété à rechercher.</param>
        <param name="key">La valeur de l’élément avec la valeur <paramref name="propertyName" /> à rechercher.</param>
        <summary>Retourne l'index de l'élément dans la liste avec le nom et la valeur de propriété spécifiés.</summary>
        <returns>Index de base zéro de l’élément avec la valeur et le nom de propriété spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Find%2A> méthode peut uniquement être utilisée lorsque la liste sous-jacente est une <xref:System.ComponentModel.IBindingList> avec recherche implémentée. Cette méthode fait simplement référence à la demande à la liste sous-jacente <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> (méthode). Par exemple, si la source de données sous-jacente est une <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, ou <xref:System.Data.DataView>, cette méthode convertit `propertyName` à un <xref:System.ComponentModel.PropertyDescriptor> et appelle le <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> (méthode). Le comportement de <xref:System.Windows.Forms.BindingSource.Find%2A>, telles que la valeur retournée si aucun élément correspondant est trouvé, dépend de l’implémentation de la méthode dans la liste sous-jacente.  
  
 La comparaison de nom de propriété respecte la casse.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.Find%2A> méthode avec un <xref:System.Data.DataView>. Pour exécuter cet exemple, collez le code dans un Windows Form et appelez `PopulateDataViewAndFind` à partir du constructeur du formulaire ou <xref:System.Windows.Forms.Form.Load> méthode de gestion des événements. Votre formulaire doit importer le <xref:System.Xml> et <xref:System.IO> espaces de noms.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La liste sous-jacente n’est pas un <see cref="T:System.ComponentModel.IBindingList" /> avec l’implémentation des fonctionnalités de recherche.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyName" /> ne correspond pas à une propriété dans la liste.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="bindingSource.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un énumérateur pour les <see cref="P:System.Windows.Forms.BindingSource.List" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> pour <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="bindingSource.GetItemProperties listAccessors" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ITypedList.GetItemProperties(System.ComponentModel.PropertyDescriptor[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Un tableau de <see cref="T:System.ComponentModel.PropertyDescriptor" /> objets à rechercher dans la liste comme pouvant être liée.</param>
        <summary>Récupère un tableau de <see cref="T:System.ComponentModel.PropertyDescriptor" /> objets représentant les propriétés pouvant être liées des données de source de type de liste.</summary>
        <returns>Un tableau de <see cref="T:System.ComponentModel.PropertyDescriptor" /> les objets qui représentent les propriétés sur ce type de liste utilisées pour lier des données.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string&#xA;override this.GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string" Usage="bindingSource.GetListName listAccessors" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ITypedList.GetListName(System.ComponentModel.PropertyDescriptor[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Un tableau de <see cref="T:System.ComponentModel.PropertyDescriptor" /> objets à rechercher dans la liste comme pouvant être liée.</param>
        <summary>Obtient le nom de la liste fournissant les données pour la liaison.</summary>
        <returns>Nom de la liste fournissant les données pour la liaison.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelatedCurrencyManager (dataMember As String) As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::CurrencyManager ^ GetRelatedCurrencyManager(System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="abstract member GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager&#xA;override this.GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager" Usage="bindingSource.GetRelatedCurrencyManager dataMember" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.ICurrencyManagerProvider.GetRelatedCurrencyManager(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Nom de la colonne ou de la liste, dans la source de données, pour lequel récupérer le gestionnaire de devise.</param>
        <summary>Obtient le gestionnaire de devise connexe pour le membre de données spécifié.</summary>
        <returns>Connexe <see cref="T:System.Windows.Forms.CurrencyManager" /> pour le membre de données spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `dataMember` est `null` ou une chaîne vide (" »), <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> retourne le Gestionnaire de devise principal ; Sinon, il recherche un autre <xref:System.Windows.Forms.BindingSource> lié à la donnée membre spécifiée et retourne son gestionnaire de devise.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="bindingSource.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Le <see cref="T:System.Object" /> à localiser dans la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété. La valeur peut être <see langword="null" />.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de la première occurrence dans la liste entière.</summary>
        <returns>Index de base zéro de la première occurrence de la <paramref name="value" /> paramètre ; sinon, -1 si <paramref name="value" /> n’est pas dans la liste.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que l’implémentation dépend de la liste sous-jacente `IndexOf` (méthode), généralement les caractéristiques suivantes s’appliquent :  
  
-   Le <xref:System.Windows.Forms.BindingSource.List%2A> recherche est effectuée à partir du premier élément au dernier élément.  
  
-   La méthode sous-jacente effectue une recherche linéaire ; Par conséquent, la durée d’exécution moyenne est proportionnelle à la valeur de la <xref:System.Windows.Forms.BindingSource.Count%2A> propriété.  
  
-   La méthode sous-jacente détermine l’égalité en appelant le <xref:System.Object.Equals%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="bindingSource.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro au niveau duquel <paramref name="value" /> doit être inséré.</param>
        <param name="value"><see cref="T:System.Object" /> à insérer. La valeur peut être <see langword="null" />.</param>
        <summary>Insère un élément dans la liste à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à 0 ou supérieur à <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">La liste est en lecture seule ou a une taille fixe.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBindingSuspended As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBindingSuspended { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBindingSuspended : bool" Usage="System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la liaison de la liste est suspendue.</summary>
        <value><see langword="true" /> pour indiquer que la liaison est suspendue ; Sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la liste sous-jacente est de taille fixe.</summary>
        <value><see langword="true" /> Si la liste sous-jacente a une taille fixe ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste a une taille fixe, il n’autorise pas l’ajout ou la suppression d’éléments une fois que la liste a été créée, mais vous pouvez modifier des éléments existants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la liste sous-jacente est en lecture seule.</summary>
        <value><see langword="true" /> si la liste est en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une liste qui est en lecture seule n’autorise pas l’ajout, la suppression ou la modification de tout élément de liste après la création de la liste.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSorted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSorted : bool" Usage="System.Windows.Forms.BindingSource.IsSorted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.IsSorted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si les éléments dans la liste sous-jacente sont triés.</summary>
        <value><see langword="true" /> Si la liste est un <see cref="T:System.ComponentModel.IBindingList" /> et est triée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A> Retourne toujours `false` si la liste n’est pas un <xref:System.ComponentModel.IBindingList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l’accès à la collection est synchronisé (thread-safe).</summary>
        <value><see langword="true" /> pour indiquer que la liste est synchronisée ; Sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Windows.Forms.BindingSource.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à récupérer.</param>
        <summary>Obtient ou définit l'élément de liste situé à l'index spécifié.</summary>
        <value>Élément au niveau de l'index spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Item%2A> propriété représente l’indexeur de cette classe. Il accepte `null` comme une valeur valide et autorise les éléments en double dans la liste.  
  
 Paramètre une valeur déclenchera le <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à zéro ou supérieure ou égale à <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.List : System.Collections.IList" Usage="System.Windows.Forms.BindingSource.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la liste à laquelle le connecteur est lié.</summary>
        <value>Un <see cref="T:System.Collections.IList" /> qui représente la liste, ou <see langword="null" /> s’il n’existe aucune liste sous-jacente associée à cet <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource> classe gère uniformément différentes sources de données. Dans l’idéal, le <xref:System.Windows.Forms.BindingSource.List%2A> propriété doit être définie sur un grand <xref:System.Collections.IList>. Cependant, parfois, il peut être nécessaire d’effectuer un cast de cette propriété pour un type plus spécifique. Le tableau suivant présente le type sous-jacent de la liste, qui varie selon le type de valeur de la source de données.  
  
|Type de source de données|Description de la liste sous-jacente|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> et <xref:System.Windows.Forms.BindingSource.DataMember%2A> sont `null`|Un <xref:System.Collections.ArrayList> vide.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> est `null`, mais <xref:System.Windows.Forms.BindingSource.DataMember%2A> n’est pas `null`|None ; une tentative d’obtention du <xref:System.Windows.Forms.BindingSource.List%2A> lèvera une <xref:System.ArgumentException>.|  
|Un <xref:System.Array> instance|Élément <xref:System.Array>.|  
|Un <xref:System.ComponentModel.IListSource> instance|La valeur de retour d’un appel à la <xref:System.ComponentModel.IListSource.GetList%2A> méthode de ce <xref:System.ComponentModel.IListSource> instance.|  
|Un <xref:System.ComponentModel.IBindingList> instance|Élément <xref:System.ComponentModel.IBindingList>.|  
|Un <xref:System.Collections.IList> instance|Élément <xref:System.Collections.IList>.|  
|Non -<xref:System.Collections.IList> instance de type « T »|Un <xref:System.ComponentModel.BindingList%601> avec un seul élément.|  
|Un <xref:System.ComponentModel.ICustomTypeDescriptor> instance|Un <xref:System.Collections.ArrayList> avec un seul élément.|  
|Un <xref:System.Collections.IEnumerable>|Un <xref:System.Collections.ArrayList> avec les éléments sont copiés.|  
|Le <xref:System.Array> tapez avec <xref:System.Windows.Forms.BindingSource.DataMember%2A> d’élément de type « T »|<xref:System.ComponentModel.BindingList%601>|  
|Un <xref:System.Type> qui représente un <xref:System.ComponentModel.IListSource> ou <xref:System.ComponentModel.ITypedList>|Une instance créée par un appel à la <xref:System.Activator.CreateInstance%28System.Type%29> méthode de la <xref:System.Activator> classe. Un <xref:System.NotSupportedException> peut être levée.|  
|Le <xref:System.Collections.IList> tapez avec <xref:System.Windows.Forms.BindingSource.DataMember%2A> d’élément de type « T »<br /><br /> ou<br /><br /> Non -<xref:System.Collections.IList> type|<xref:System.ComponentModel.BindingList%601>|  
|Le <xref:System.ComponentModel.ICustomTypeDescriptor> type|None ; une tentative d’obtention du <xref:System.Windows.Forms.BindingSource.List%2A> lèvera une <xref:System.NotSupportedException>.|  
  
 Si le type récupéré est le <xref:System.Collections.IList> interface, la collection sous-jacente peut être plus complexe, comme un <xref:System.Collections.ArrayList> ou <xref:System.Data.DataView> classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, et <xref:System.Windows.Forms.BindingSource.Count%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1`, deux étiquettes nommées `label1` et `label2`et un bouton nommé `button1`. Associer le `button1_Click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberSignature Language="F#" Value="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " Usage="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IBindingList.ListChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit en cas de modification de la liste sous-jacente ou d'un de ses éléments.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.ListChanged> événement se produit lors d’une modification de l’appartenance ou les métadonnées de la liste sous-jacente représentée par la <xref:System.Windows.Forms.BindingSource.List%2A> propriété. Par exemple, cet événement est déclenché lorsque les éléments sont ajoutés, supprimés ou déplacés, ou le <xref:System.Windows.Forms.BindingSource.DataSource%2A> ou <xref:System.Windows.Forms.BindingSource.DataMember%2A> modification des propriétés. Les valeurs de la <xref:System.Windows.Forms.BindingSource.Sort%2A> et <xref:System.Windows.Forms.BindingSource.Filter%2A> propriétés persisteront lorsque cet événement se produit.  
  
 Cet événement peut être totalement supprimé en définissant le <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propriété `false`. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant illustre la gestion du <xref:System.Windows.Forms.BindingSource.ListChanged> événements de la <xref:System.Windows.Forms.BindingSource> composant détecter lorsque le <xref:System.Windows.Forms.BindingSource> liste sous-jacente du composant est modifié.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFirst();" />
      <MemberSignature Language="F#" Value="member this.MoveFirst : unit -&gt; unit" Usage="bindingSource.MoveFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Passe au premier élément de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifie la valeur actuelle de la <xref:System.Windows.Forms.BindingSource.Position%2A> propriété sur 0, le premier élément dans la source de données sous-jacente.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, et <xref:System.Windows.Forms.BindingSource.Position%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui importe le <xref:System.Drawing.Drawing2D> espace de noms et contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1` et un bouton nommé `button1`. Associer le `Form1_Load` et `Form1_Paint` méthodes avec la <xref:System.Windows.Forms.Form.Load> et <xref:System.Windows.Forms.Control.Paint> événements pour le formulaire et associez le `button1_click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveLast();" />
      <MemberSignature Language="F#" Value="member this.MoveLast : unit -&gt; unit" Usage="bindingSource.MoveLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Passe au dernier élément de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifie la valeur actuelle de la <xref:System.Windows.Forms.BindingSource.Position%2A> à l’index du dernier élément dans la source de données sous-jacente, qui est égale à la valeur de propriété le <xref:System.Windows.Forms.BindingSource.Count%2A> propriété moins 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveNext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveNext();" />
      <MemberSignature Language="F#" Value="member this.MoveNext : unit -&gt; unit" Usage="bindingSource.MoveNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Passe à l'élément suivant de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modifie la valeur actuelle de la <xref:System.Windows.Forms.BindingSource.Position%2A> propriété à l’élément suivant dans la source de données sous-jacente.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, et <xref:System.Windows.Forms.BindingSource.Position%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui importe le <xref:System.Drawing.Drawing2D> espace de noms et contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1` et un bouton nommé `button1`. Associer le `Form1_Load` et `Form1_Paint` méthodes avec la <xref:System.Windows.Forms.Form.Load> et <xref:System.Windows.Forms.Control.Paint> événements pour le formulaire et associez le `button1_click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Sub MovePrevious ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MovePrevious();" />
      <MemberSignature Language="F#" Value="member this.MovePrevious : unit -&gt; unit" Usage="bindingSource.MovePrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Passe à l'élément précédent de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode modifie la valeur actuelle de la <xref:System.Windows.Forms.BindingSource.Position%2A> propriété à l’élément précédent dans la source de données sous-jacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAddingNew (e As AddingNewEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAddingNew(System::ComponentModel::AddingNewEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit&#xA;override this.OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit" Usage="bindingSource.OnAddingNew e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.AddingNew" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingComplete (e As BindingCompleteEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingComplete(System::Windows::Forms::BindingCompleteEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit&#xA;override this.OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit" Usage="bindingSource.OnBindingComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.BindingCompleteEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.BindingComplete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentItemChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentItemChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentItemChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataError (e As BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataError(System::Windows::Forms::BindingManagerDataErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit&#xA;override this.OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit" Usage="bindingSource.OnDataError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.DataError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnDataError%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataMemberChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataMemberChanged : EventArgs -&gt; unit&#xA;override this.OnDataMemberChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataMemberChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.  
  
La méthode <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataSourceChanged : EventArgs -&gt; unit&#xA;override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnListChanged (e As ListChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnListChanged(System::ComponentModel::ListChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit&#xA;override this.OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit" Usage="bindingSource.OnListChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.ListChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnListChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPositionChanged : EventArgs -&gt; unit&#xA;override this.OnPositionChanged : EventArgs -&gt; unit" Usage="bindingSource.OnPositionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.ComponentModel.ListChangedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Forms.BindingSource.PositionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le déclenchement d'un événement appelle le gestionnaire des événements par l'intermédiaire d'un délégué. Pour plus d’informations, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 La méthode <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A> permet également aux classes dérivées de gérer l'événement sans y attacher de délégué. Il s'agit de la méthode recommandée pour gérer l'événement dans une classe dérivée.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lors de la substitution de <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> dans une classe dérivée, veillez à appeler la méthode <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> de la classe de base de manière à ce que les délégués inscrits reçoivent l'événement.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberSignature Language="VB.NET" Value="Public Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Position { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int with get, set" Usage="System.Windows.Forms.BindingSource.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'index de l'élément actuel dans la liste sous-jacente.</summary>
        <value>Index de base zéro qui spécifie la position de l'élément actuel dans la liste sous-jacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors de la définition du <xref:System.Windows.Forms.BindingSource.Position%2A> propriété, les valeurs hors limites sont traitées de la manière suivante :  
  
-   Les valeurs négatives sont traitées comme étant 0.  
  
-   Les valeurs supérieures ou égales à <xref:System.Windows.Forms.BindingSource.Count%2A> sont traités comme des <xref:System.Windows.Forms.BindingSource.Count%2A> moins 1.  
  
 Modification de la <xref:System.Windows.Forms.BindingSource.Position%2A> propriété ajustera la <xref:System.Windows.Forms.BindingSource.Current%2A> propriété de la même manière.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, et <xref:System.Windows.Forms.BindingSource.Position%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui importe le <xref:System.Drawing.Drawing2D> espace de noms et contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1` et un bouton nommé `button1`. Associer le `Form1_Load` et `Form1_Paint` méthodes avec la <xref:System.Windows.Forms.Form.Load> et <xref:System.Windows.Forms.Control.Paint> événements pour le formulaire et associez le `button1_click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PositionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PositionChanged;" />
      <MemberSignature Language="F#" Value="member this.PositionChanged : EventHandler " Usage="member this.PositionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la valeur de la <see cref="P:System.Windows.Forms.BindingSource.Position" /> propriété a été modifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.PositionChanged> événement se produit après le <xref:System.Windows.Forms.BindingSource.Position%2A> propriété a été modifiée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property RaiseListChangedEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RaiseListChangedEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RaiseListChangedEvents : bool with get, set" Usage="System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> événements doivent être déclenchés.</summary>
        <value><see langword="true" /> Si <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> événements doivent être déclenchés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propriété est `false`, elle interrompt le déclenchement de <xref:System.Windows.Forms.BindingSource.ListChanged> événements. Cet événement indique que la liste liée a été modifiée d’une certaine façon, y compris l’ajout, de suppression, d’insertion ou de modification d’éléments.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="bindingSource.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">L’élément à supprimer de la liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété.</param>
        <summary>Supprime l'élément spécifié de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Remove%2A> méthode provoque la liste dans laquelle rechercher la `value` paramètre. Si le paramètre est trouvé, cette méthode essaie de supprimer l’élément de la <xref:System.Windows.Forms.BindingSource.List%2A>. Cette tentative échoue si la liste a une taille fixe ou est en lecture seule. Ces deux conditions peuvent être testées avec les <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> et <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> propriétés, respectivement.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente a une taille fixe ou est en lecture seule.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="bindingSource.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l'élément à supprimer.</param>
        <summary>Supprime l'élément au niveau de l'index spécifié dans la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces deux conditions peuvent être testées avec les <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> et <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> propriétés, respectivement.  
  
 Cette méthode déclenche la <xref:System.Windows.Forms.BindingSource.ListChanged> événement.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, et <xref:System.Windows.Forms.BindingSource.Count%2A> membres. Pour exécuter cet exemple, collez le code dans un formulaire qui contient un <xref:System.Windows.Forms.BindingSource> nommé `BindingSource1`, deux étiquettes nommées `label1` et `label2`et un bouton nommé `button1`. Associer le `button1_Click` méthode avec le <xref:System.Windows.Forms.Control.Click> événement pour `button1`. Les utilisateurs de Visual Basic devront ajouter une référence à System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à zéro ou supérieur à la valeur de la <see cref="P:System.Windows.Forms.BindingSource.Count" /> propriété.</exception>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété est en lecture seule ou a une taille fixe.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCurrent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; unit" Usage="bindingSource.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime l'élément sélectionné de la liste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A> méthode est équivalente à la <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Forms.BindingSource.AllowRemove" /> a la valeur <see langword="false" />.  
  
ou 
 <see cref="P:System.Windows.Forms.BindingSource.Position" /> est inférieur à 0 ou supérieur à <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente représentée par la <see cref="P:System.Windows.Forms.BindingSource.List" /> propriété est en lecture seule ou a une taille fixe.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveFilter ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveFilter();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFilter : unit -&gt; unit&#xA;override this.RemoveFilter : unit -&gt; unit" Usage="bindingSource.RemoveFilter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingListView.RemoveFilter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le filtre associé à le <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> méthode fait référence à la demande à la liste sous-jacente <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> (méthode). Répertorie uniquement les qui implémentent <xref:System.ComponentModel.IBindingListView> prennent en charge le filtrage.  
  
 Par défaut, un appel à cette méthode est équivalent à la définition du <xref:System.Windows.Forms.BindingSource.Filter%2A> propriété `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente ne prend pas en charge le filtrage.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveSort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveSort();" />
      <MemberSignature Language="F#" Value="abstract member RemoveSort : unit -&gt; unit&#xA;override this.RemoveSort : unit -&gt; unit" Usage="bindingSource.RemoveSort " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.RemoveSort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le tri associé à la <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> méthode fait référence à la demande à la liste sous-jacente <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> (méthode). Répertorie uniquement les qui implémentent <xref:System.ComponentModel.IBindingList> prennent en charge le tri.  
  
 Par défaut, un appel à cette méthode est équivalent à la définition du <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente ne prend pas en charge le tri.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetAllowNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetAllowNew();" />
      <MemberSignature Language="F#" Value="abstract member ResetAllowNew : unit -&gt; unit&#xA;override this.ResetAllowNew : unit -&gt; unit" Usage="bindingSource.ResetAllowNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réinitialise le <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> propriété.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> méthode réinitialise le <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propriété afin de refléter la valeur correspondante <xref:System.Windows.Forms.BindingSource.AllowNew%2A> propriété dans la liste sous-jacente.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings (metadataChanged As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings(bool metadataChanged);" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : bool -&gt; unit" Usage="bindingSource.ResetBindings metadataChanged" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged"><see langword="true" /> Si le schéma de données a changé ; <see langword="false" /> si seules les valeurs ont changé.</param>
        <summary>Entraîne la relecture par un contrôle lié au <see cref="T:System.Windows.Forms.BindingSource" /> de tous les éléments dans la liste et l'actualisation de leurs valeurs affichées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> méthode informe tous les contrôles liés à la <xref:System.Windows.Forms.BindingSource> à actualiser leurs valeurs. La méthode effectue cela en déclenchant le <xref:System.Windows.Forms.BindingSource.ListChanged> événement au moins une fois ; le `metaDataChanged` paramètre indique la nature de la modification sous-jacente.  
  
-   Un `metaDataChanged` valeur `true` indique que le schéma de données de <xref:System.Windows.Forms.BindingSource> a changé. Un <xref:System.Windows.Forms.BindingSource.ListChanged> événement est déclenché avec <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> défini sur <xref:System.ComponentModel.ListChangedType.PropertyDescriptorChanged?displayProperty=nameWithType>.  
  
-   Un `metaDataChanged` valeur `false` indique que seules les valeurs d’un ou plusieurs éléments ont été modifiés.  
  
 Quelle que soit la valeur de `metaDataChanged`, un <xref:System.Windows.Forms.BindingSource.ListChanged> événement est déclenché avec <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> défini sur <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>. Par conséquent, l’appel <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> avec un paramètre de `true` déclenche deux <xref:System.Windows.Forms.BindingSource.ListChanged> événements.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> est appelé automatiquement chaque fois qu’un autre membre apporte des modifications majeures à la liaison de données, telles que la définition du <xref:System.Windows.Forms.BindingSource.DataSource%2A> ou <xref:System.Windows.Forms.BindingSource.DataMember%2A> propriétés. Toutefois, le programmeur peut également appeler cette méthode explicitement.  
  
   
  
## Examples  
 Le code suivant exemple utilise un <xref:System.Windows.Forms.BindingSource> composant pour lier une liste de tableaux qui ne fournit pas de notification de modification. Un élément est supprimé de la liste, et les contrôles dépendants sont informés de la modification en appelant le <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> (méthode). Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : Refléter les mises à jour de Source de données dans un contrôle de formulaire Windows avec le composant BindingSource](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCurrentItem ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCurrentItem();" />
      <MemberSignature Language="F#" Value="member this.ResetCurrentItem : unit -&gt; unit" Usage="bindingSource.ResetCurrentItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dessine un contrôle lié à la <see cref="T:System.Windows.Forms.BindingSource" /> à relire l’élément actuellement sélectionné et actualise sa valeur affichée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appeler cette méthode provoque la <xref:System.Windows.Forms.BindingSource.ListChanged> événement se produise, spécifiant l’élément modifié à la position actuelle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetItem (itemIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetItem(int itemIndex);" />
      <MemberSignature Language="F#" Value="member this.ResetItem : int -&gt; unit" Usage="bindingSource.ResetItem itemIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Index de base zéro de l'élément modifié.</param>
        <summary>Dessine un contrôle lié à la <see cref="T:System.Windows.Forms.BindingSource" /> à la relecture par l’élément à l’index spécifié et actualise sa valeur affichée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.ResetItem%2A> méthode avertit tous les contrôles liés à l’élément à l’emplacement spécifié <xref:System.Windows.Forms.BindingSource.Position%2A> pour actualiser leurs valeurs. La méthode effectue cela en déclenchant le <xref:System.Windows.Forms.BindingSource.ListChanged> événement avec <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> défini sur <xref:System.ComponentModel.ListChangedType.ItemChanged?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A> est appelé automatiquement chaque fois que les modifications sont apportées à la valeur d’un élément individuel. Toutefois, le programmeur peut également appeler cette méthode explicitement.  
  
   
  
## Examples  
 Le code suivant exemple utilise un <xref:System.Windows.Forms.BindingSource> composant pour lier une liste à un <xref:System.Windows.Forms.DataGridView> contrôle. La liste ne déclenche pas de notifications de modification, donc la <xref:System.Windows.Forms.BindingSource.ResetItem%2A> méthode sur le <xref:System.Windows.Forms.BindingSource> est utilisée pour déclencher le <xref:System.Windows.Forms.BindingSource.ListChanged> événement. Cet exemple de code fait partie d’un exemple plus complet fourni dans [Comment : Déclencher des Notifications de modification à l’aide de la méthode ResetItem de BindingSource](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeBinding();" />
      <MemberSignature Language="F#" Value="member this.ResumeBinding : unit -&gt; unit" Usage="bindingSource.ResumeBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Relance la liaison de données.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> et <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sont deux méthodes qui permettent la suspension temporaire et le rétablissement de la liaison de données dans un scénario de liaison simple. Vous devez généralement suspendre la liaison de données si l’utilisateur doit être autorisé à effectuer plusieurs modifications de champs de données avant la validation. Par exemple, si un champ doit être modifié conformément à une seconde, mais la validation du premier champ provoquerait le deuxième champ en erreur.  
  
> [!NOTE]
>  À l’aide de <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> empêche les modifications soient apportées dans la source de données jusqu'à ce que <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> est appelée, mais n’empêche pas réellement les événements ne se produise. Les contrôles qui utilisent la liaison de données complexes, tels que le <xref:System.Windows.Forms.DataGridView> contrôler, mettre à jour leurs valeurs basées sur les événements de changement tels que le <xref:System.Windows.Forms.CurrencyManager.ListChanged> événement, ainsi, l’appel <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> ne les empêche pas de recevoir des modifications apportées à la source de données. Pour cette raison, cela <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> et <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sont conçus pour une utilisation avec des contrôles liés simples, tels que le <xref:System.Windows.Forms.TextBox> contrôle. Vous pouvez également utiliser ces méthodes dans un scénario de liaison complexes si vous supprimez <xref:System.Windows.Forms.BindingSource.ListChanged> événements en définissant le <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Property Sort As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Sort { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Sort : string with get, set" Usage="System.Windows.Forms.BindingSource.Sort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les noms de colonnes utilisés pour le tri, et l'ordre de tri pour consulter les lignes dans la source de données.</summary>
        <value>Chaîne qui respecte la casse contenant le nom de la colonne suivi de "ASC" (ordre croissant) ou de "DESC" (ordre décroissant). La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété est une chaîne qui respecte la casse qui spécifie les noms de colonne utilisées pour trier les lignes, ainsi que le sens du tri. Les colonnes sont triées par ordre croissant par défaut. Plusieurs colonnes peuvent être séparées par des virgules, tels que `"State, ZipCode DESC"`.  
  
 Pour prendre en charge le tri, la liste sous-jacente doit implémenter le <xref:System.ComponentModel.IBindingList> ou <xref:System.ComponentModel.IBindingListView> interfaces. Cette fonctionnalité peut être interrogée via la <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> propriété. Le tri multicolonne est disponible lorsque le <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> propriété est `true`.  
  
 Définition de la <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété changera la liste interne en fonction de son type :  
  
-   Si la liste est de type <xref:System.ComponentModel.IBindingList>, le <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> et <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> propriétés sont définies dans la liste interne.  
  
-   Si la liste est de type <xref:System.ComponentModel.IBindingListView>, le <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> propriété est définie.  
  
 Propriétés de tri de la liste interne sont modifiées uniquement lorsque la chaîne de tri n’est pas `null`. Le `get` accesseur de cette propriété ne récupérera pas la valeur de tri de la liste interne ; au lieu de cela, elle retournera le `set` valeur de l’accesseur. La valeur de la <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété persisteront lorsque les modifications de source de données.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété pour effectuer le tri de base avec un <xref:System.Data.DataView>. Pour exécuter cet exemple, collez le code dans un Windows Form et appelez `PopulateDataViewAndSort` à partir du constructeur du formulaire ou <xref:System.Windows.Forms.Form.Load> méthode de gestion des événements. Votre formulaire doit importer le <xref:System.Xml> et <xref:System.IO> espaces de noms.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 L’exemple suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.Sort%2A> propriété pour effectuer le tri avec avancé un <xref:System.Data.DataView>. Pour exécuter cet exemple, collez le code dans un Windows Form et appelez `PopulateDataViewAndAdvancedSort` à partir du constructeur du formulaire ou <xref:System.Windows.Forms.Form.Load> méthode de gestion des événements. Votre formulaire doit importer le <xref:System.Xml> et <xref:System.IO> espaces de noms.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveSort" />
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As ListSortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDescriptionCollection ^ SortDescriptions { System::ComponentModel::ListSortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.ListSortDescriptionCollection" Usage="System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SortDescriptions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de descriptions de tri appliquée à la source de données.</summary>
        <value>Si la source de données est un <see cref="T:System.ComponentModel.IBindingListView" />, un <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> qui contient les descriptions de tri appliquées à la liste ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste n’est pas un <xref:System.ComponentModel.IBindingListView>, le <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> retourne toujours `null`.  
  
 Le <xref:System.ComponentModel.ListSortDescriptionCollection> est une collection en lecture seule.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDirection As ListSortDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDirection SortDirection { System::ComponentModel::ListSortDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDirection : System.ComponentModel.ListSortDirection" Usage="System.Windows.Forms.BindingSource.SortDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SortDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la direction dans laquelle les éléments de la liste sont triés.</summary>
        <value>Parmi les <see cref="T:System.ComponentModel.ListSortDirection" /> valeurs indiquant la direction dans laquelle la liste est triée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste sous-jacente n’est pas un <xref:System.ComponentModel.IBindingList>, le <xref:System.Windows.Forms.BindingSource.SortDirection%2A> propriété retournera toujours <xref:System.ComponentModel.ListSortDirection.Ascending>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortProperty As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ SortProperty { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortProperty : System.ComponentModel.PropertyDescriptor" Usage="System.Windows.Forms.BindingSource.SortProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SortProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.ComponentModel.PropertyDescriptor" /> qui est utilisé pour trier la liste.</summary>
        <value>Si la liste est un <see cref="T:System.ComponentModel.IBindingList" />, le <see cref="T:System.ComponentModel.PropertyDescriptor" /> qui est utilisé pour le tri ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste n’est pas un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> retourne toujours `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAdvancedSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAdvancedSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAdvancedSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SupportsAdvancedSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la source de données prend en charge le tri multicolonne.</summary>
        <value><see langword="true" /> Si la liste est un <see cref="T:System.ComponentModel.IBindingListView" /> et prend en charge le tri multicolonne ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste n’est pas un <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeNotification : bool" Usage="System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsChangeNotification</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la source de données prend en charge la notification de modification.</summary>
        <value><see langword="true" /> dans tous les cas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsFiltering { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsFiltering : bool" Usage="System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SupportsFiltering</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la source de données prend en charge le filtrage.</summary>
        <value><see langword="true" /> Si la liste est un <see cref="T:System.ComponentModel.IBindingListView" /> et prend en charge le filtrage ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste n’est pas un <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSearching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSearching { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSearching : bool" Usage="System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsSearching</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la source de données prend en charge la recherche avec le <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" /> (méthode).</summary>
        <value><see langword="true" /> Si la liste est un <see cref="T:System.ComponentModel.IBindingList" /> et prend en charge la recherche avec le <see cref="Overload:System.Windows.Forms.BindingSource.Find" /> méthode ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la source de données n’est pas un <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> membre. Pour obtenir un exemple complet, consultez la rubrique Vue d’ensemble de la classe.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la source de données prend en charge le tri.</summary>
        <value><see langword="true" /> Si la source de données est un <see cref="T:System.ComponentModel.IBindingList" /> et prend en charge le tri ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la source de données n’est pas un <xref:System.ComponentModel.IBindingList>, le <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendBinding();" />
      <MemberSignature Language="F#" Value="member this.SuspendBinding : unit -&gt; unit" Usage="bindingSource.SuspendBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Suspend la liaison de données pour empêcher que les modifications mettent à jour la source de données liée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> et <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sont deux méthodes qui permettent la suspension temporaire et le rétablissement de la liaison de données dans un scénario de liaison simple. Vous devez généralement suspendre la liaison de données si l’utilisateur doit être autorisé à effectuer plusieurs modifications de champs de données avant la validation. Par exemple, si un champ doit être modifié conformément à une seconde, mais la validation du premier champ provoquerait le deuxième champ en erreur.  
  
> [!NOTE]
>  À l’aide de <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> et empêche les modifications soient apportées dans la source de données jusqu'à ce que <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> est appelée, mais n’empêche pas réellement les événements ne se produise. Les contrôles qui utilisent la liaison de données complexes, tels que le <xref:System.Windows.Forms.DataGridView> contrôler, mettre à jour leurs valeurs basées sur les événements de changement tels que le <xref:System.Windows.Forms.CurrencyManager.ListChanged> événement, ainsi, l’appel <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> ne les empêche pas de recevoir des modifications apportées à la source de données. Pour cette raison, cela <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> et <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> sont conçus pour une utilisation avec des contrôles liés simples, tels que le <xref:System.Windows.Forms.TextBox> contrôle. Vous pouvez également utiliser ces méthodes dans un scénario de liaison complexes si vous supprimez <xref:System.Windows.Forms.BindingSource.ListChanged> événements en définissant le <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> propriété `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet pouvant être utilisé pour synchroniser l’accès à la liste sous-jacente.</summary>
        <value>Objet pouvant être utilisé pour synchroniser l’accès à la liste sous-jacente.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIndex (property As PropertyDescriptor) Implements IBindingList.AddIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.AddIndex(System::ComponentModel::PropertyDescriptor ^ property) = System::ComponentModel::IBindingList::AddIndex;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.AddIndex(System.ComponentModel.PropertyDescriptor)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">Le <see cref="T:System.ComponentModel.PropertyDescriptor" /> à ajouter aux index utilisés pour la recherche.</param>
        <summary>Ajoute le <see cref="T:System.ComponentModel.PropertyDescriptor" /> aux index utilisés pour la recherche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste sous-jacente est une <xref:System.ComponentModel.IBindingList> type, cette méthode ajoute la <xref:System.ComponentModel.PropertyDescriptor> aux index ; sinon, en appelant cette méthode lève un <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La liste sous-jacente n’est pas un <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (prop As PropertyDescriptor) Implements IBindingList.RemoveIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.RemoveIndex(System::ComponentModel::PropertyDescriptor ^ prop) = System::ComponentModel::IBindingList::RemoveIndex;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.RemoveIndex(System.ComponentModel.PropertyDescriptor)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop">Le <see cref="T:System.ComponentModel.PropertyDescriptor" /> à supprimer des index utilisés pour la recherche.</param>
        <summary>Supprime la <see cref="T:System.ComponentModel.PropertyDescriptor" /> des index utilisés pour la recherche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la liste sous-jacente n’est pas un <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>, cette méthode lève toujours une <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew (position As Integer) Implements ICancelAddNew.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.CancelNew(int position) = System::ComponentModel::ICancelAddNew::CancelNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Index de l’élément qui a été ajouté à la collection.</param>
        <summary>Élimine un nouvel élément en attente de la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> méthode restaure un ajout en attente d’un élément précédemment ajouté à la collection à l’index spécifié par `position`. Le `position` paramètre est nécessaire car plusieurs nouveaux éléments peuvent être simultanément en attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub EndNew (position As Integer) Implements ICancelAddNew.EndNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.EndNew(int position) = System::ComponentModel::ICancelAddNew::EndNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Index de l’élément qui a été ajouté à la collection.</param>
        <summary>Valide un nouvel élément en attente dans la collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> méthode valide une addition en attente d’un élément précédemment ajouté à la collection à l’index spécifié par `position`. Le `position` paramètre est nécessaire car plusieurs nouveaux éléments peuvent être simultanément en attente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signale le <see cref="T:System.Windows.Forms.BindingSource" /> que l’initialisation démarre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Signale le <see cref="T:System.Windows.Forms.BindingSource" /> que l’initialisation est terminée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.Initialized">
      <MemberSignature Language="C#" Value="event EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#Initialized" />
      <MemberSignature Language="VB.NET" Value="Custom Event Initialized As EventHandler Implements System.ComponentModel.ISupportInitializeNotification" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le <see cref="T:System.Windows.Forms.BindingSource" /> est initialisé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Forms.BindingSource> est castée en interface <xref:System.ComponentModel.ISupportInitializeNotification>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsInitialized As Boolean Implements ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::ISupportInitializeNotification::IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Windows.Forms.BindingSource" /> est initialisé.</summary>
        <value><see langword="true" /> pour indiquer la <see cref="T:System.Windows.Forms.BindingSource" /> est initialisé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Forms.BindingSource> est castée en interface <xref:System.ComponentModel.ISupportInitializeNotification>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>