<Type Name="HtmlWindow" FullName="System.Windows.Forms.HtmlWindow">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4ac69f83b8bb1282ea8edf8c9ba33714d1e06b04" /><Meta Name="ms.sourcegitcommit" Value="2982b8c4cce02c2542285fcaf172f7544d6b80bc" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="04/09/2019" /><Meta Name="ms.locfileid" Value="59352236" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlWindow" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlWindow extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlWindow" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlWindow" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlWindow sealed" />
  <TypeSignature Language="F#" Value="type HtmlWindow = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente la fenêtre logique qui contient une ou plusieurs instances de <see cref="T:System.Windows.Forms.HtmlDocument" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow> ne doit pas être confondu avec le concept d’une fenêtre dans les Windows Forms ou l’API Win32 ; Il existe aucune `HWND` ou une ressource Windows similaire qui correspond directement à une instance de <xref:System.Windows.Forms.HtmlWindow>. Au lieu de cela, <xref:System.Windows.Forms.HtmlWindow> fournit les descriptions de haut niveau de l’emplacement d’un document sur l’utilisateur écran, ainsi que les méthodes permettant d’interagir avec les utilisateurs par le biais d’invites et boîtes de dialogue. <xref:System.Windows.Forms.HtmlWindow> agit comme un conteneur logique pour les documents d’une page Web et ses métadonnées, telles que l’emplacement du document et les fonctionnalités du navigateur Web.  
  
 Une page Web se compose d’un seul document ou un `FRAMESET` contenant un ou plusieurs `FRAME` éléments, dont chacun héberge son propre document. Les développeurs Web utilisent des jeux de frames pour afficher logiquement liés pages côte à côte (par exemple, une page de contenu en regard d’une page de navigation). Lorsqu’une page se compose d’un seul document, vous pouvez y accéder via le <xref:System.Windows.Forms.HtmlWindow.Document%2A> propriété du <xref:System.Windows.Forms.HtmlWindow>; si la page utilise des frames, vous pouvez accéder à leurs documents via la <xref:System.Windows.Forms.HtmlWindow.Frames%2A> collection, qui se compose d’un ou plusieurs <xref:System.Windows.Forms.HtmlWindow> objets.  
  
 Lorsque votre hôte le <xref:System.Windows.Forms.WebBrowser> contrôle dans une application Windows Forms, vous pouvez choisir d’interagir avec l’utilisateur à l’aide des classes Windows Forms standard, tels que <xref:System.Windows.Forms.Form> ou <xref:System.Windows.Forms.MessageBox>, ou vous pouvez utiliser des méthodes sur <xref:System.Windows.Forms.HtmlWindow> défini à cet effet. Le <xref:System.Windows.Forms.HtmlWindow.Alert%2A> méthode présente une boîte de dialogue simple avec du texte personnalisé et un **OK** bouton ; <xref:System.Windows.Forms.HtmlWindow.Prompt%2A> présente une ligne de texte personnalisé et un champ d’entrée de texte à l’utilisateur ; et <xref:System.Windows.Forms.HtmlWindow.Confirm%2A> présente une boîte de dialogue avec une ligne de texte personnalisé et **OK** et **Annuler** boutons.  
  
 Vous pouvez utiliser <xref:System.Windows.Forms.HtmlWindow> pour ouvrir de nouvelles fenêtres contenant de nouveaux documents. <xref:System.Windows.Forms.HtmlWindow.Open%2A> charge l’URL spécifiée dans la fenêtre nommée, créant si elle n’existe pas déjà, tandis que <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> s’ouvre toujours son URL dans une fenêtre qui vient d’être créée.  
  
   
  
## Examples  
 L’exemple de code suivant contient deux méthodes. La première ouvre une URL dans une fenêtre nommée `displayWindow`, qui est créée avec une barre d’état. La seconde ouvre une autre URL dans la même fenêtre, mais spécifie que seule la barre de l’emplacement doit être affichée. Notez que les dimensions de la fenêtre et les contrôles qui sont affichés varie sur lequel URL est d’abord ouvertes. L’exemple de code requiert que votre formulaire contienne un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms535873.aspx">Objet de fenêtre</related>
    <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741505.aspx">Interface de IHTMLWindow2</related>
  </Docs>
  <Members>
    <Member MemberName="Alert">
      <MemberSignature Language="C#" Value="public void Alert (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Alert(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Alert(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Alert (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Alert(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Alert : string -&gt; unit" Usage="htmlWindow.Alert message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.String" /> à afficher dans le message.</param>
        <summary>Affiche une boîte de message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.MessageBox?displayProperty=nameWithType> classe offre une version plus puissante de la <xref:System.Windows.Forms.HtmlWindow.Alert%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms535933.aspx">Alert, méthode</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez gérer.</param>
        <param name="eventHandler">Référence au code managé qui gère l'événement.</param>
        <summary>Ajoute un gestionnaire d'événements pour l'événement nommé sur le modèle DOM HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne devez pas attacher un événement à un document HTML ou un de ses objets jusqu'à ce que le chargement est terminé dans le document. Est le plus ancien que vous devez appeler cette méthode dans le <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> événements de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListenerx">EventTarget.addEventListener()</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="htmlWindow.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Forms.HtmlWindow.IsClosed%2A> propriété afin de déterminer si la fenêtre est déjà fermée. Si la fenêtre est déjà fermée, cette méthode n’aura aucun effet.  
  
 Lorsque vous créez de nouvelles fenêtres à l’aide de <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>, <xref:System.Windows.Forms.HtmlWindow.Close%2A> , le modèle d’objet de Document HTML ouvrir une nouvelle instance d’Internet Explorer. Si vous n’appelez pas <xref:System.Windows.Forms.HtmlWindow.Close%2A> sur toutes les fenêtres que vous avez créé, cette instance d’Internet Explorer restera en cours d’exécution même après la fermeture de votre application.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre une fenêtre et la ferme si l’utilisateur ne le n'a pas utilisé au cours des cinq dernières minutes. L’exemple de code a été écrit en supposant que votre formulaire contient un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`, un <xref:System.Windows.Forms.Button> nommé `Button1`et un <xref:System.Windows.Forms.Timer> classe nommée `Timer1`. Pour exécuter cet exemple, modifiez le premier argument fourni à <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> vers une URL valide.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlWindow#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536367.aspx">Close, méthode</related>
      </Docs>
    </Member>
    <Member MemberName="Confirm">
      <MemberSignature Language="C#" Value="public bool Confirm (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Confirm(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Confirm(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Confirm (message As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Confirm(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.Confirm : string -&gt; bool" Usage="htmlWindow.Confirm message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Texte à afficher à l'intention de l'utilisateur.</param>
        <summary>Affiche une boîte de dialogue avec un message et des boutons pour solliciter une réponse positive/négative.</summary>
        <returns><see langword="true" /> si l’utilisateur a cliqué sur **Oui** ; <see langword="false" /> si l’utilisateur a cliqué sur **Non** ou a fermé la boîte de dialogue.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Confirm%2A> affiche une boîte de dialogue modale ; l’utilisateur ne sera pas en mesure d’accéder à la page HTML sous-jacente sans fermer cette boîte de dialogue au préalable.  
  
## Examples  

Copiez le code HTML suivant et enregistrez-le dans un formulaire nommé orderForm.htm :  

```html
<HTML>
<BODY>
<FORM name="NewOrderForm">
Select Part Type:
<SELECT name="PartType">
  <OPTION>AZ-3700
  <OPTION>AZ-3701
  <OPTION>AZ-3702  
</SELECT><br/>
Quantity: <INPUT type="text" name="PartQty" size="2" maxsize="2" /><br/>
Building/Desk:
<INPUT type="text" name="PartBuilding" size="2" maxsize="2"/> /  
<INPUT type="text" name="PartDesk" size="2" maxsize="2"/><p/>
<INPUT type="submit" value="Transmit Order"/>
</FORM>
</BODY>
</HTML>
```

L’exemple suivant affiche un <xref:System.Windows.Forms.HtmlWindow.Confirm%2A> boîte de dialogue lorsque l’utilisateur soumet `NewOrderForm`.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlWindow#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536376.aspx">Méthode Confirm</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlWindow.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez gérer.</param>
        <param name="eventHandler">Référence au code managé qui gère l'événement.</param>
        <summary>Supprime le gestionnaire d'événements nommé.</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">Méthode detachEvent</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlWindow.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le document HTML contenu dans la fenêtre.</summary>
        <value>Une instance valide de <see cref="T:System.Windows.Forms.HtmlDocument" />, si un document est chargé. Si cette fenêtre contient un <c>FRAMESET</c>, ou aucun document n’est actuellement chargé, elle retournera <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, vous accédez à la <xref:System.Windows.Forms.HtmlWindow.Document%2A> via la <xref:System.Windows.Forms.WebBrowser.Document%2A> propriété de la <xref:System.Windows.Forms.WebBrowser> contrôle. Utilisez cette propriété lorsque vous avez besoin accéder à un document au sein d’un `FRAME` à l’aide de la <xref:System.Windows.Forms.HtmlWindow.Frames%2A> collection.  
  
   
  
## Examples  
 L’exemple de code suivant inspecte chaque document dans une page contenant des frames et crée un tableau de tous les liens hypertexte sortants de chaque page pour une inspection ultérieure.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DomWindow">
      <MemberSignature Language="C#" Value="public object DomWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomWindow As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomWindow { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomWindow : obj" Usage="System.Windows.Forms.HtmlWindow.DomWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'interface non managée encapsulée par cette classe.</summary>
        <value>Un objet pouvant être casté en un <see langword="IHTMLWindow2" />, <see langword="IHTMLWindow3" />, ou <see langword="IHTMLWindow4" /> pointeur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utiliser les pointeurs d’interface non managé sous-jacent pour le modèle DOM (Document Object) pour exécuter des méthodes non exposées par <xref:System.Windows.Forms.HtmlWindow>.  
  
 Vous devez ajouter un référencé au MSHTML.dll non managé afin d’utiliser <xref:System.Windows.Forms.HtmlWindow.DomWindow%2A>. Pour plus d’informations, consultez [l’importation d’une bibliothèque de types en tant qu’Assembly](~/docs/framework/interop/importing-a-type-library-as-an-assembly.md).  
  
   
  
## Examples  
 L’exemple de code suivant obtient un `IHTMLWindow2` pointeur à partir d’un document de la fenêtre et affiche un nouveau document dans une fenêtre modale.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlWindow#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741505.aspx">Interface de IHTMLWindow2</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741356.aspx">Interface de IHTMLWindow3</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/aa741344.aspx">Interface de IHTMLWindow4</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlWindow.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à tester.</param>
        <summary>Teste l'objet pour déterminer s'il est égal à l'objet actif.</summary>
        <returns><see langword="true" /> si les objets sont identiques ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementErrorEventHandler Error;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementErrorEventHandler Error" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Error" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Error As HtmlElementErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementErrorEventHandler ^ Error;" />
      <MemberSignature Language="F#" Value="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " Usage="member this.Error : System.Windows.Forms.HtmlElementErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le script qui s'exécute dans la fenêtre rencontre une erreur d'exécution.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pages HTML peuvent contenir du code de script, généralement écrite dans JScript ou VBScript, ce qui s’exécute lorsqu’une page est chargée. <xref:System.Windows.Forms.HtmlWindow.Error> se produit chaque fois qu’un script rencontre une erreur d’exécution. Code de script étant à liaison tardive, ce qui signifie que les appels sur l’objet ne sont pas résolus avant l’exécution, erreurs peuvent inclure à partir de la référence à un objet null à l’appel d’une propriété ou méthode indéfinie.  
  
 Vous pouvez définir le <xref:System.Windows.Forms.HtmlElementErrorEventArgs.Handled%2A> propriété du <xref:System.Windows.Forms.HtmlElementErrorEventArgs> comme « true » pour empêcher l’affichage de la boîte de dialogue d’erreur native dans Internet Explorer.
  
   
  
## Examples  
 L’exemple de code suivant intercepte l’erreur qui se produit lorsqu’un script sur une page HTML tente d’accéder à un objet qui n’est pas défini dans le document. La page doit être entièrement chargée avant le <xref:System.Windows.Forms.HtmlWindow.Error> Gestionnaire d’événements est attaché, sinon l’exemple ne fonctionnera pas.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#16)]
 [!code-vb[System.Windows.Forms.HtmlWindow#16](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#16)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/cc197053.aspx">Événement onerror</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlWindow.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Place le focus sur la fenêtre active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une autre fenêtre possédait le focus avant <xref:System.Windows.Forms.HtmlWindow.Focus%2A> a été appelée, cette fenêtre perdra le focus.  
  
 N’appelez pas le focus sur un élément à l’intérieur d’une fenêtre jusqu'à ce que la fenêtre <xref:System.Windows.Forms.HtmlWindow.Load> événement a été déclenché.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">focus (méthode)</related>
      </Docs>
    </Member>
    <Member MemberName="Frames">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindowCollection Frames { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindowCollection Frames" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Frames" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Frames As HtmlWindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindowCollection ^ Frames { System::Windows::Forms::HtmlWindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Frames : System.Windows.Forms.HtmlWindowCollection" Usage="System.Windows.Forms.HtmlWindow.Frames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à chacun des éléments <c>FRAME</c> définis dans la page web.</summary>
        <value>Un <see cref="T:System.Windows.Forms.HtmlWindowCollection" /> d’un document <c>FRAME</c> et <c>IFRAME</c> objets.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un `FRAME` est un ensemble de fenêtres défini dans un `FRAMESET`. `FRAME`permettent l’hébergement de plusieurs documents dans un même document. Chaque `FRAME` est défini comme possédant une certaine largeur de ligne et de colonne, et est positionné sur la page par rapport à l’autre `FRAME`s définis dans le `FRAMESET`; la position d’un `FRAME` est fixe, bien qu’un utilisateur peut parfois utiliser la souris curseur pour augmenter ou réduire le `FRAME`. Un `IFRAME` est similaire à un frame, mais il ne doive pas être ancré dans une position fixe.  
  
 Cadres contiendra une seule instance de <xref:System.Windows.Forms.HtmlWindow> pour chaque `FRAME` ou `IFRAME` définis dans une page Web.  
  
   
  
## Examples  
 L’exemple de code suivant inspecte chaque document dans une page contenant des frames et crée un tableau de tous les liens hypertexte sortants de chaque page pour une inspection ultérieure.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlWindow#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms537459.aspx">Collection de frames</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlWindow.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage pour un type particulier.</summary>
        <returns>Code de hachage du <see cref="T:System.Windows.Forms.HtmlWindow" /> actuel.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la fenêtre active obtient le focus de l'entrée d'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.GotFocus> se produit pour :  
  
-   La première fenêtre dans un `FRAMESET` lorsque le `FRAMESET` du premier chargement.  
  
-   Le `FRAME` qui dernière posséder le focus lorsque la fenêtre contenant la <xref:System.Windows.Forms.WebBrowser> contrôle est mis au premier plan.  
  
-   Un `FRAME` cliqué dessus par l’utilisateur, mais uniquement si vous cliquez sur l’utilisateur ne placez pas le focus sur un élément dans la fenêtre.  
  
 Vous ne pouvez pas annuler l’action par défaut pour le <xref:System.Windows.Forms.HtmlWindow.GotFocus> événement, ou l’empêcher de propagation.
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.GotFocus> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.GotFocus> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#452](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#452)]
 [!code-vb[System.Windows.Forms.EventExamples#452](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#452)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">Événement onfocus</related>
      </Docs>
    </Member>
    <Member MemberName="History">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlHistory History { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlHistory History" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.History" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property History As HtmlHistory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlHistory ^ History { System::Windows::Forms::HtmlHistory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.History : System.Windows.Forms.HtmlHistory" Usage="System.Windows.Forms.HtmlWindow.History" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlHistory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet contenant les dernières URL visitées par l'utilisateur.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlHistory" /> pour la fenêtre active.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.History%2A> contient toutes les URL parcourues dans la fenêtre active, ce qui correspond à la *pile de navigation*et fournit des méthodes pour revenir à ces documents.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Windows.Forms.HtmlWindow.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cette fenêtre est ouverte ou fermée.</summary>
        <value><see langword="true" /> Si la fenêtre est encore ouverte sur l’écran ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Windows.Forms.HtmlWindow> a été fermée par l’utilisateur ou par le biais d’un appel à la <xref:System.Windows.Forms.HtmlWindow.Close%2A> méthode, la tentative de navigation vers une nouvelle URL ou d’accès de document de la fenêtre entraînera une erreur. Utilisez cette propriété pour déterminer s’il est déconseillé d’appeler des propriétés et des méthodes sur l’objet actuel de la fenêtre.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre une fenêtre et la ferme si l’utilisateur ne le n'a pas utilisé au cours des cinq dernières minutes. L’exemple de code suppose que votre formulaire contient un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`, un <xref:System.Windows.Forms.Button> nommé `Button1`et un <xref:System.Windows.Forms.Timer> classe nommée `Timer1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms537459.aspx">Propriété fermée</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Load;" />
      <MemberSignature Language="F#" Value="member this.Load : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Load : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le document de la fenêtre et tous ses éléments ont terminé l'initialisation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.HtmlWindow.Load> événement fonctionne de façon similaire à la <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> événement sur le <xref:System.Windows.Forms.WebBrowser> contrôle : elle signale qu’il est déconseillé d’accès aux éléments HTML à l’intérieur du document.  
  
 Vous ne pouvez pas annuler l’action par défaut pour le <xref:System.Windows.Forms.HtmlWindow.Load> événement.
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.Load> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.Load> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#453](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#453)]
 [!code-vb[System.Windows.Forms.EventExamples#453](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#453)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/cc197055.aspx">Événement OnLoad</related>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le focus d'entrée d'utilisateur quitte la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.LostFocus> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.LostFocus> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#454](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#454)]
 [!code-vb[System.Windows.Forms.EventExamples#454](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#454)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Déplace la fenêtre vers les coordonnées spécifiées sur l'écran.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.MoveTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Les coordonnées x et y du coin supérieur gauche de la fenêtre.</param>
        <summary>Déplace la fenêtre vers les coordonnées spécifiées sur l'écran.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas utiliser <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> pour déplacer une fenêtre hors du bord visible de l’écran ; cette méthode est également disponible via un script sur une page Web, et autoriser les scripts non fiables pour rendre des fenêtres invisibles n’est pas considérée comme sécurisée.  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> déclenche un <xref:System.UnauthorizedAccessException> si la fenêtre que vous essayez de déplacer et sa fenêtre parente ont différents domaines de niveau supérieur. Par exemple, si vous hébergez le <xref:System.Windows.Forms.WebBrowser> contrôler pointant vers a.adatum.com, créez une nouvelle fenêtre en utilisant <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> pour afficher b.adatum.com. Dans ce cas, les deux fenêtres sont considérées comme faisant partie du même domaine de niveau supérieur, et l’exception n’est pas levée. Toutefois, si vous appelez <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> pour afficher www.Microsoft.com, les deux fenêtres ont maintenant des différents domaines de niveau supérieur et le <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> opération entraîne l’exception à lever.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le code qui tente d'exécuter cette opération n'est pas autorisé à manipuler cette fenêtre.</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536626.aspx">Méthode moveTo</related>
      </Docs>
    </Member>
    <Member MemberName="MoveTo">
      <MemberSignature Language="C#" Value="public void MoveTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.MoveTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.MoveTo : int * int -&gt; unit" Usage="htmlWindow.MoveTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">La coordonnée x du coin supérieur gauche de la fenêtre.</param>
        <param name="y">La coordonnée y du coin supérieur gauche de la fenêtre.</param>
        <summary>Déplace la fenêtre vers les coordonnées spécifiées sur l'écran.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas utiliser <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> pour déplacer une fenêtre hors du bord visible de l’écran ; cette méthode est également disponible via un script sur une page Web, et autoriser les scripts non fiables pour rendre des fenêtres invisibles n’est pas considérée comme sécurisée.  
  
 <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> déclenche un <xref:System.UnauthorizedAccessException> si la fenêtre que vous essayez de déplacer et sa fenêtre parente ont différents domaines de niveau supérieur. Par exemple, si vous hébergez le <xref:System.Windows.Forms.WebBrowser> contrôle et il pointe vers a.adatum.com, créez une nouvelle fenêtre en utilisant <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> pour afficher b.adatum.com. Dans ce cas, les deux fenêtres sont considérées comme faisant partie du même domaine de niveau supérieur, et l’exception n’est pas levée. Toutefois, si vous appelez <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> pour afficher www.Microsoft.com, les deux fenêtres ont maintenant des différents domaines de niveau supérieur et le <xref:System.Windows.Forms.HtmlWindow.MoveTo%2A> opération entraîne l’exception à lever.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Le code qui tente d'exécuter cette opération n'est pas autorisé à manipuler cette fenêtre.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlWindow.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de la fenêtre.</summary>
        <value><see cref="T:System.String" /> qui représente le nom.</value>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534187.aspx">name, propriété</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affiche ou télécharge le nouveau contenu situé à l'URL spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (string urlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(string urlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (urlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(System::String ^ urlString);" />
      <MemberSignature Language="F#" Value="member this.Navigate : string -&gt; unit" Usage="htmlWindow.Navigate urlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">Ressource à afficher, décrite par une URL.</param>
        <summary>Affiche ou télécharge le nouveau contenu situé à l'URL spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `url` paramètre pointe vers une page HTML, la page actuellement affichée dans la fenêtre sera détruite et remplacée par la nouvelle page ; toutes les références aux objets DOM managés dans l’ancienne page que votre application possède ne seront plus valides. Si `url` pointe vers une ressource qui ne peut pas être affichée par Internet Explorer, l’utilisateur s’affiche une boîte de dialogue vous demandant si vous ouvrez la ressource en dehors de l’application, enregistrez-le sur disque ou d’annuler l’opération de téléchargement.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536638.aspx">Navigate, méthode</related>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public void Navigate (Uri url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Navigate(class System.Uri url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Navigate (url As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Navigate(Uri ^ url);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; unit" Usage="htmlWindow.Navigate url" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="url">L'emplacement, spécifié comme <see cref="T:System.Uri" />, du document ou de l'objet à afficher dans la fenêtre active.</param>
        <summary>Affiche un nouveau document dans la fenêtre active.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Equality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">Premier objet <see cref="T:System.Windows.Forms.HtmlWindow" />.</param>
        <param name="right">Second objet <see cref="T:System.Windows.Forms.HtmlWindow" />.</param>
        <summary>Teste si les deux objets <see cref="T:System.Windows.Forms.HtmlWindow" /> sont égaux.</summary>
        <returns><see langword="true" /> si les deux paramètres sont <see langword="null" /> ou si les deux éléments ont la même interface COM sous-jacente ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’opérateur d’égalité teste le `IUnknown` pointeurs des objets COM sous-jacent encapsulés par fourni <xref:System.Windows.Forms.HtmlWindow> classes.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Windows.Forms.HtmlWindow.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlWindow left, System.Windows.Forms.HtmlWindow right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlWindow left, class System.Windows.Forms.HtmlWindow right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.op_Inequality(System.Windows.Forms.HtmlWindow,System.Windows.Forms.HtmlWindow)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlWindow, right As HtmlWindow) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlWindow ^ left, System::Windows::Forms::HtmlWindow ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlWindow * System.Windows.Forms.HtmlWindow -&gt; bool" Usage="System.Windows.Forms.HtmlWindow.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlWindow" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlWindow" />
      </Parameters>
      <Docs>
        <param name="left">Premier objet <see cref="T:System.Windows.Forms.HtmlWindow" />.</param>
        <param name="right">Second objet <see cref="T:System.Windows.Forms.HtmlWindow" />.</param>
        <summary>Teste si deux objets <see langword="HtmlWindow" /> sont inégaux.</summary>
        <returns><see langword="true" /> si un seul des deux objets est <see langword="null" /> ou si les pointeurs COM sous-jacents ne correspondent pas ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affiche un fichier dans la fenêtre nommée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (string urlString, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(string urlString, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (urlString As String, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(System::String ^ urlString, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : string * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (urlString, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="urlString">L'URL qui décrit l'emplacement du fichier à charger.</param>
        <param name="target">Nom de la fenêtre dans laquelle ouvrir la ressource. Ce peut être un nom fourni par développeur ou l'une des valeurs spéciales suivantes : 
 <c>_blank</c> : Ouvre <paramref name="urlString" /> dans une nouvelle fenêtre. Fonctionne de la même manière qu'un appel à <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />.  
  
 <c>_media</c> : Ouvre <paramref name="urlString" /> dans la barre de médias.  
  
 <c>_parent</c> : Ouvre <paramref name="urlString" /> dans la fenêtre qui a créé la fenêtre active.  
  
 <c>_search</c> : Ouvre <paramref name="urlString" /> dans la barre de recherche.  
  
 <c>_self</c> : Ouvre <paramref name="urlString" /> dans la fenêtre active.  
  
 <c>_top</c> : En cas d’appel pour une fenêtre qui appartient à un élément <c>FRAME</c>, ouvre <paramref name="urlString" /> dans la fenêtre qui héberge son <c>FRAMESET</c>. Sinon, fonctionne de la même manière que <c>_self</c>.</param>
        <param name="windowOptions">Chaîne délimitée par des virgules qui se compose d’aucune ou de plusieurs des options suivantes sous la forme <c>name=value</c>. Hormis les options <c>left</c>, <c>top</c>, <c>height</c> et <c>width</c>, qui prennent des entiers arbitraires, chaque option accepte <c>yes</c> ou <see langword="1" /> et <c>no</c> ou <see langword="0" /> comme valeurs valides.  
  
 <c>channelmode</c> : Utilisé avec la technologie de canaux déconseillée d’Internet Explorer 4.0. La valeur par défaut est <c>no</c>.  
  
 <c>directories</c> : Indique si la fenêtre doit afficher des boutons de navigation de répertoire. La valeur par défaut est <c>yes</c>.  
  
 <c>height</c> : Hauteur en pixels de la zone cliente de la fenêtre. Le minimum est 100 ; toute tentative d'ouverture d'une fenêtre plus petite provoque l'ouverture de la fenêtre en fonction des paramètres par défaut d'Internet Explorer.  
  
 <c>left</c> : Position gauche (coordonnée x) de la fenêtre, relative au coin supérieur gauche de l’écran de l’utilisateur, en pixels. Doit être un entier positif.  
  
 <c>location</c> : Indique s’il faut afficher la barre d’adresses, qui permet aux utilisateurs de naviguer dans la fenêtre vers une nouvelle URL. La valeur par défaut est <c>yes</c>.  
  
 <c>menubar</c> : Indique s’il faut afficher les menus dans la nouvelle fenêtre. La valeur par défaut est <c>yes</c>.  
  
 <c>resizable</c> : Indique si la fenêtre peut être redimensionnée par l’utilisateur. La valeur par défaut est <c>yes</c>.  
  
 <c>scrollbars</c> : Indique si la fenêtre a des barres de défilement horizontale et verticale. La valeur par défaut est <c>yes</c>.  
  
 <c>status</c> : Indique si la fenêtre a une barre d’état en bas. La valeur par défaut est <c>yes</c>.  
  
 <c>titlebar</c> : Indique si le titre de la page active est affiché. L’affectation de la valeur <c>no</c> à cette option n’a aucun effet dans une application managée ; la barre de titre apparaîtra toujours.  
  
 <c>toolbar</c> : Indique si les boutons de barre d’outils tels que **Précédente**, **Suivante** et **Arrêter** sont visibles. La valeur par défaut est <c>yes</c>.  
  
 <c>top</c> : Position gauche (coordonnée y) de la fenêtre, relative au coin supérieur gauche de l’écran de l’utilisateur, en pixels. Doit être un entier positif.  
  
 <c>width</c> : Largeur en pixels de la zone cliente de la fenêtre. Le minimum est 100 ; toute tentative d'ouverture d'une fenêtre plus petite provoque l'ouverture de la fenêtre en fonction des paramètres par défaut d'Internet Explorer.</param>
        <param name="replaceEntry">Indique si <paramref name="urlString" /> remplace l'URL de la fenêtre active dans l'historique de navigation. Cela aura un effet sur l'opération de méthodes sur la classe <see cref="T:System.Windows.Forms.HtmlHistory" />.</param>
        <summary>Affiche un fichier dans la fenêtre nommée.</summary>
        <returns>Un <see cref="T:System.Windows.Forms.HtmlWindow" /> qui représente la nouvelle fenêtre ou la fenêtre créée précédemment nommée par le paramètre <paramref name="target" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `target` paramètre peut nommer une fenêtre qui a été créée à la suite d’un appel précédent à <xref:System.Windows.Forms.HtmlWindow.Open%2A>. Le paramètre peut également pointer vers une fenêtre ouverte en cliquant sur un lien hypertexte (`A` élément) ou un `FORM` élément qui utilise le `TARGET` attribut pour ouvrir son URL dans une nouvelle fenêtre. Le code HTML suivant ouvre une nouvelle fenêtre nommée `orderWindow` lorsque l’utilisateur clique dessus :  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 Si vous fournissez des options pour le `windowOptions` paramètre, toute option non incluse est automatiquement désactivé. En d’autres termes, si vous spécifiez uniquement par l’intermédiaire de `windowOptions` que vous souhaitez une barre d’état, puis la barre de menus barre d’outils, titre, les barres de défilement et ainsi de suite s’affichera pas, sauf si vous les activez explicitement par l’intermédiaire de `windowOptions`.  
  
 Si le fichier référencé par `url` est un fichier HTML, fichier texte ou autre type de fichier qui peut être hébergé dans Internet Explorer, il s’affichera dans la fenêtre nommée. Si le fichier ne peut pas être affiché à l’intérieur d’Internet Explorer et la fenêtre nommée par cible n’existe pas déjà, la fenêtre s’ouvre uniquement depuis suffisamment longtemps pour Internet Explorer télécharger la ressource ; Il va s’arrêter immédiatement par la suite.  
  
 Lorsque vous créez de nouvelles fenêtres à l’aide de <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>, elle force le modèle d’objet de Document HTML ouvrir une nouvelle instance d’Internet Explorer. Si vous n’appelez pas <xref:System.Windows.Forms.HtmlWindow.Close%2A> sur toutes les fenêtres que vous avez créé, cette instance d’Internet Explorer reste en cours d’exécution même après la fermeture de votre application.  
  
 Si vous utilisez <xref:System.Windows.Forms.HtmlWindow.Open%2A> pour charger une URL dans une fenêtre existante, `windowOptions` va être ignorée ; la fenêtre conservera les dimensions, l’apparence et emplacement d’affichage donné par l’appel initial à <xref:System.Windows.Forms.HtmlWindow.Open%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Open (Uri url, string target, string windowOptions, bool replaceEntry);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow Open(class System.Uri url, string target, string windowOptions, bool replaceEntry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Open(System.Uri,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Open (url As Uri, target As String, windowOptions As String, replaceEntry As Boolean) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ Open(Uri ^ url, System::String ^ target, System::String ^ windowOptions, bool replaceEntry);" />
      <MemberSignature Language="F#" Value="member this.Open : Uri * string * string * bool -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.Open (url, target, windowOptions, replaceEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
        <Parameter Name="replaceEntry" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">L'URL qui décrit l'emplacement du fichier à charger.</param>
        <param name="target">Nom de la fenêtre dans laquelle ouvrir la ressource. Ce peut être un nom fourni par le développeur ou l'une des valeurs spéciales suivantes : 
 <c>_blank</c> : Ouvre <paramref name="url" /> dans une nouvelle fenêtre. Fonctionne de la même manière qu'un appel à <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />.  
  
 <c>_media</c> : Ouvre <paramref name="url" /> dans la barre de médias.  
  
 <c>_parent</c> : Ouvre <paramref name="url" /> dans la fenêtre qui a créé la fenêtre active.  
  
 <c>_search</c> : Ouvre <paramref name="url" /> dans la barre de recherche.  
  
 <c>_self</c> : Ouvre <paramref name="url" /> dans la fenêtre active.  
  
 <c>_top</c> : En cas d’appel pour une fenêtre qui appartient à un élément <c>FRAME</c>, ouvre <paramref name="url" /> dans la fenêtre qui héberge son <c>FRAMESET</c>. Sinon, fonctionne de la même manière que <c>_self</c>.</param>
        <param name="windowOptions">Chaîne délimitée par des virgules qui se compose d’aucune ou de plusieurs des options suivantes sous la forme <c>name=value</c>. Hormis les options <c>left</c>, <c>top</c>, <c>height</c> et <c>width</c>, qui prennent des entiers arbitraires, chaque option accepte <c>yes</c> ou <see langword="1" /> et <c>no</c> ou <see langword="0" /> comme valeurs valides.  
  
 <c>channelmode</c> : Utilisé avec la technologie de canaux déconseillée d’Internet Explorer 4.0. La valeur par défaut est <c>no</c>.  
  
 <c>directories</c> : Indique si la fenêtre doit afficher des boutons de navigation de répertoire. La valeur par défaut est <c>yes</c>.  
  
 <c>height</c> : Hauteur en pixels de la zone cliente de la fenêtre. Le minimum est 100 ; toute tentative d'ouverture d'une fenêtre plus petite provoque l'ouverture de la fenêtre en fonction des paramètres par défaut d'Internet Explorer.  
  
 <c>left</c> : Position gauche (coordonnée x) de la fenêtre, relative au coin supérieur gauche de l’écran de l’utilisateur, en pixels. Doit être un entier positif.  
  
 <c>location</c> : Indique s’il faut afficher la barre d’adresses, qui permet aux utilisateurs de naviguer dans la fenêtre vers une nouvelle URL. La valeur par défaut est <c>yes</c>.  
  
 <c>menubar</c> : Indique s’il faut afficher les menus dans la nouvelle fenêtre. La valeur par défaut est <c>yes</c>.  
  
 <c>resizable</c> : Indique si la fenêtre peut être redimensionnée par l’utilisateur. La valeur par défaut est <c>yes</c>.  
  
 <c>scrollbars</c> : Indique si la fenêtre a des barres de défilement horizontale et verticale. La valeur par défaut est <c>yes</c>.  
  
 <c>status</c> : Indique si la fenêtre a une barre d’état en bas. La valeur par défaut est <c>yes</c>.  
  
 <c>titlebar</c> : Indique si le titre de la page active est affiché. L’affectation de la valeur <c>no</c> à cette option n’a aucun effet dans une application managée ; la barre de titre apparaîtra toujours.  
  
 <c>toolbar</c> : Indique si les boutons de barre d’outils tels que **Précédente**, **Suivante** et **Arrêter** sont visibles. La valeur par défaut est <c>yes</c>.  
  
 <c>top</c> : Position gauche (coordonnée y) de la fenêtre, relative au coin supérieur gauche de l’écran de l’utilisateur, en pixels. Doit être un entier positif.  
  
 <c>width</c> : Largeur en pixels de la zone cliente de la fenêtre. Le minimum est 100 ; toute tentative d'ouverture d'une fenêtre plus petite provoque l'ouverture de la fenêtre en fonction des paramètres par défaut d'Internet Explorer.</param>
        <param name="replaceEntry">Indique si <paramref name="url" /> remplace l'URL de la fenêtre active dans l'historique de navigation. Cela aura un effet sur l'opération de méthodes sur la classe <see cref="T:System.Windows.Forms.HtmlHistory" />.</param>
        <summary>Affiche un fichier dans la fenêtre nommée.</summary>
        <returns>Un <see cref="T:System.Windows.Forms.HtmlWindow" /> qui représente la nouvelle fenêtre ou la fenêtre créée précédemment nommée par le paramètre <paramref name="target" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `target` paramètre peut nommer une fenêtre qui a été créée à la suite d’un appel précédent à <xref:System.Windows.Forms.HtmlWindow.Open%2A>. Le paramètre peut également pointer vers une fenêtre ouverte en cliquant sur un lien hypertexte (`A` élément) ou un `FORM` élément qui utilise le `TARGET` attribut pour ouvrir son URL dans une nouvelle fenêtre. Le code HTML suivant ouvre une nouvelle fenêtre nommée `orderWindow` lorsque l’utilisateur clique dessus :  
  
 `<A HREF="/startOrder.aspx" TARGET="orderWindow">Click to Start Order</a>`  
  
 Si vous fournissez des options pour le `windowOptions` paramètre, toute option non incluse est automatiquement désactivé. En d’autres termes, si vous spécifiez uniquement par l’intermédiaire de `windowOptions` que vous souhaitez une barre d’état, puis la barre de menus barre d’outils, titre, les barres de défilement et ainsi de suite s’affichera pas, sauf si vous les activez explicitement par l’intermédiaire de `windowOptions`.  
  
 Si le fichier référencé par `url` est un fichier HTML, fichier texte ou autre type de fichier qui peut être hébergé dans Internet Explorer, il s’affichera dans la fenêtre nommée. Si le fichier ne peut pas être affiché à l’intérieur d’Internet Explorer et la fenêtre nommée par cible n’existe pas déjà, la fenêtre s’ouvre uniquement depuis suffisamment longtemps pour Internet Explorer télécharger la ressource ; Il va s’arrêter immédiatement par la suite.  
  
 Lorsque vous créez de nouvelles fenêtres à l’aide de <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>, elle force le modèle d’objet de Document HTML ouvrir une nouvelle instance d’Internet Explorer. Si vous n’appelez pas <xref:System.Windows.Forms.HtmlWindow.Close%2A> sur toutes les fenêtres que vous avez créé, cette instance d’Internet Explorer reste en cours d’exécution même après la fermeture de votre application.  
  
 Si vous utilisez <xref:System.Windows.Forms.HtmlWindow.Open%2A> pour charger une URL dans une fenêtre existante, `windowOptions` va être ignorée ; la fenêtre conservera les dimensions, l’apparence et emplacement d’affichage donné par l’appel initial à <xref:System.Windows.Forms.HtmlWindow.Open%2A> .  
  
   
  
## Examples  
 L’exemple de code suivant contient deux méthodes :  
  
-   La première ouvre une URL dans une fenêtre nommée `displayWindow`, qui est créée avec une barre d’état.  
  
-   La seconde ouvre une autre URL dans la même fenêtre, mais spécifie que seule la barre de l’emplacement doit être affichée.  
  
 Notez que les dimensions de la fenêtre et les contrôles qui sont affichés varie sur lequel URL est d’abord ouvertes. L’exemple de code requiert que votre formulaire contienne un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlWindow#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536651.aspx">Méthode Open</related>
      </Docs>
    </Member>
    <Member MemberName="Opener">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Opener { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Opener" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Opener" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Opener As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Opener { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Opener : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Opener" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence à la fenêtre qui a ouvert la fenêtre active.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlWindow" /> qui a été créé par un appel aux méthodes <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" /> ou <see cref="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />. Si la fenêtre n'a pas été créée à l'aide de l'une de ces méthodes, cette propriété retourne <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenNew">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affiche un fichier dans une nouvelle fenêtre.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (string urlString, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(string urlString, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (urlString As String, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(System::String ^ urlString, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : string * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (urlString, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="urlString" Type="System.String" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="urlString">L'URL qui décrit l'emplacement du fichier à charger.</param>
        <param name="windowOptions">Chaîne délimitée par des virgules qui se compose d’aucune ou de plusieurs des options suivantes sous la forme <c>name=value</c>. Consultez <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" /> pour une description complète des options valides.</param>
        <summary>Affiche un fichier dans une nouvelle fenêtre.</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlWindow" /> représentant la nouvelle fenêtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier référencé par `url` est un fichier HTML, fichier texte ou autre type de fichier qui peut être hébergé dans Internet Explorer, il s’affichera dans une nouvelle fenêtre. Si le fichier ne peut pas être affiché à l’intérieur d’Internet Explorer, la fenêtre s’ouvre uniquement depuis suffisamment longtemps pour Internet Explorer télécharger la ressource ; Il va s’arrêter immédiatement par la suite.  
  
 Lorsque vous créez de nouvelles fenêtres à l’aide de <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>, elle force le modèle d’objet de Document HTML ouvrir une nouvelle instance d’Internet Explorer. Si vous n’appelez pas <xref:System.Windows.Forms.HtmlWindow.Close%2A> sur toutes les fenêtres que vous avez créé, cette instance d’Internet Explorer reste en cours d’exécution même après la fermeture de votre application.  
  
 Si vous souhaitez charger un document dans une fenêtre précédemment ouverte, consultez le <xref:System.Windows.Forms.HtmlWindow.Open%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow OpenNew (Uri url, string windowOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlWindow OpenNew(class System.Uri url, string windowOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.OpenNew(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (url As Uri, windowOptions As String) As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlWindow ^ OpenNew(Uri ^ url, System::String ^ windowOptions);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : Uri * string -&gt; System.Windows.Forms.HtmlWindow" Usage="htmlWindow.OpenNew (url, windowOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.Uri" />
        <Parameter Name="windowOptions" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">L'URL qui décrit l'emplacement du fichier à charger.</param>
        <param name="windowOptions">Chaîne délimitée par des virgules qui se compose d’aucune ou de plusieurs des options suivantes sous la forme <c>name=value</c>. Consultez <see cref="M:System.Windows.Forms.HtmlWindow.Open(System.String,System.String,System.String,System.Boolean)" /> pour une description complète des options valides.</param>
        <summary>Affiche un fichier dans une nouvelle fenêtre.</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlWindow" /> représentant la nouvelle fenêtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le fichier référencé par `url` est un fichier HTML, fichier texte ou autre type de fichier qui peut être hébergé dans Internet Explorer, il s’affichera dans une nouvelle fenêtre. Si le fichier ne peut pas être affiché à l’intérieur d’Internet Explorer, la fenêtre s’ouvre uniquement depuis suffisamment longtemps pour Internet Explorer télécharger la ressource ; Il va s’arrêter immédiatement par la suite.  
  
 Lorsque vous créez de nouvelles fenêtres à l’aide de <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A>, elle force le modèle d’objet de Document HTML ouvrir une nouvelle instance d’Internet Explorer. Si vous n’appelez pas <xref:System.Windows.Forms.HtmlWindow.Close%2A> sur toutes les fenêtres que vous avez créé, cette instance d’Internet Explorer reste en cours d’exécution même après la fermeture de votre application.  
  
 Si vous souhaitez charger un document dans une fenêtre précédemment ouverte, consultez le <xref:System.Windows.Forms.HtmlWindow.Open%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536651.aspx">Méthode Open</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Parent { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlWindow.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la fenêtre qui réside au-dessus de la fenêtre actuelle dans une page qui contient des frames.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlWindow" /> qui possède la fenêtre active. Si la fenêtre active n’est pas un <c>FRAME</c>, ou n’est pas incorporé à l’intérieur d’un <c>FRAME</c>, elle retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans un document contenant des frames, chaque `FRAME` au sein d’un `FRAMESET` agit comme une fenêtre enfant distincte sur la page. Le parent de chaque `FRAME` est la `FRAMESET` qui contient la `FRAME`.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534326.aspx">Propriété parent</related>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Position { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Position" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Position { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point" Usage="System.Windows.Forms.HtmlWindow.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position de la zone client de la fenêtre sur l'écran.</summary>
        <value><see cref="T:System.Drawing.Point" /> qui décrit en pixels les coordonnées x et y du coin supérieur gauche de l'écran.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Control.Location%2A> propriété de la <xref:System.Windows.Forms.WebBrowser> contrôle retourne la position du contrôle par rapport à l’angle supérieur gauche du formulaire. En revanche, <xref:System.Windows.Forms.HtmlWindow.Position%2A> renvoie l’emplacement de la zone d’affichage du document par rapport à l’angle supérieur gauche du moniteur de l’utilisateur.  
  
   
  
## Examples  
 L’exemple de code suivant ouvre une nouvelle fenêtre directement sur le <xref:System.Windows.Forms.WebBrowser> contrôle sur le formulaire. L’exemple de code requiert que votre formulaire contienne une instance de la <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlWindow#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/cc06e61f-43b6-4408-a676-2542dcfcd96e">Coordonnées Windows Forms</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534389.aspx">Propriété screenLeft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534390.aspx">Propriété screenTop</related>
      </Docs>
    </Member>
    <Member MemberName="Prompt">
      <MemberSignature Language="C#" Value="public string Prompt (string message, string defaultInputValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Prompt(string message, string defaultInputValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.Prompt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Prompt (message As String, defaultInputValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Prompt(System::String ^ message, System::String ^ defaultInputValue);" />
      <MemberSignature Language="F#" Value="member this.Prompt : string * string -&gt; string" Usage="htmlWindow.Prompt (message, defaultInputValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="defaultInputValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message à afficher à l'intention de l'utilisateur.</param>
        <param name="defaultInputValue">La valeur par défaut affichée dans la zone de texte.</param>
        <summary>Présente une boîte de dialogue qui affiche un message et une zone de texte à l'utilisateur.</summary>
        <returns><see cref="T:System.String" /> représentant le texte entré par l'utilisateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.Prompt%2A> fournit un moyen rapide et facile pour obtenir une entrée de texte simple à partir de l’utilisateur.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536673.aspx">Méthode prompt</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlWindow.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le focus de la fenêtre active.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’elle est appelée sur un `FRAME` fenêtre dans un `FRAMESET`, <xref:System.Windows.Forms.HtmlWindow.RemoveFocus%2A> provoquera cette fenêtre perd le focus, mais il ne définit pas automatiquement le focus sur une autre fenêtre.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">Méthode blur</related>
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Resize : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur utilise la souris pour modifier les dimensions de la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.Resize> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.Resize> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#455](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#455)]
 [!code-vb[System.Windows.Forms.EventExamples#455](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#455)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536959.aspx">Événement onresize</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResizeTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Remplace la taille de la fenêtre par les dimensions spécifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (System.Drawing.Size size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(valuetype System.Drawing.Size size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Drawing.Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(System::Drawing::Size size);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : System.Drawing.Size -&gt; unit" Usage="htmlWindow.ResizeTo size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Drawing.Size" />
      </Parameters>
      <Docs>
        <param name="size"><see cref="T:System.Drawing.Size" /> décrivant, en pixels, la largeur et la hauteur souhaitées de la fenêtre. Doit mesurer au moins 100 pixels dans les deux dimensions.</param>
        <summary>Remplace la taille de la fenêtre par les dimensions spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant ouvre une nouvelle fenêtre et redimensionne pour remplir la zone d’écran disponible.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">La fenêtre que vous essayez de redimensionner se trouve dans un domaine différent de sa fenêtre parente. Cette restriction fait partie de la sécurité des scripts inter-frame ; pour plus d’informations, consultez [About Cross-Frame Scripting and Security](https://msdn.microsoft.com/library/ms533028.aspx) (À propos des scripts et de la sécurité inter-frame).</exception>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536723.aspx">Méthode resizeTo</related>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo">
      <MemberSignature Language="C#" Value="public void ResizeTo (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResizeTo(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ResizeTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResizeTo(int width, int height);" />
      <MemberSignature Language="F#" Value="member this.ResizeTo : int * int -&gt; unit" Usage="htmlWindow.ResizeTo (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Décrit, en pixels, la largeur souhaitée de la fenêtre. Doit mesurer au moins 100 pixels.</param>
        <param name="height">Décrit, en pixels, la hauteur souhaitée de la fenêtre. Doit mesurer au moins 100 pixels.</param>
        <summary>Remplace la taille de la fenêtre par les dimensions spécifiées.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UnauthorizedAccessException">La fenêtre que vous essayez de redimensionner se trouve dans un domaine différent de sa fenêtre parente. Cette restriction fait partie de la sécurité des scripts inter-frame ; pour plus d’informations, consultez [About Cross-Frame Scripting and Security](https://msdn.microsoft.com/library/ms533028.aspx) (À propos des scripts et de la sécurité inter-frame).</exception>
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Scroll : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur fait défiler la fenêtre pour consulter le texte hors écran.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.Scroll> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.Scroll> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#456](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#456)]
 [!code-vb[System.Windows.Forms.EventExamples#456](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#456)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536966.aspx">Événement onscroll</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ScrollTo">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fait défiler la fenêtre à la position désignée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : System.Drawing.Point -&gt; unit" Usage="htmlWindow.ScrollTo point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Les coordonnées x et y, relatives au coin supérieur gauche de la fenêtre active vers laquelle la page doit défiler.</param>
        <summary>Déplace la fenêtre aux coordonnées spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> entraîne le défilement document afin que la coordonnée spécifiée sur le document se trouve dans le coin supérieur gauche de la fenêtre du document. Si le document n’est pas long ou assez large pour ce faire, <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> fera défiler le document autant que possible dans la direction spécifiée.  
  
   
  
## Examples  
 L’exemple de code suivant fait défiler le document à la position des coordonnées sur lequel l’utilisateur a cliqué.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlWindow#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536731.aspx">Méthode scrollTo</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTo">
      <MemberSignature Language="C#" Value="public void ScrollTo (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollTo(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlWindow.ScrollTo(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollTo (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollTo(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.ScrollTo : int * int -&gt; unit" Usage="htmlWindow.ScrollTo (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">La coordonnée x, relative au coin supérieur gauche de la fenêtre active vers laquelle la page doit défiler.</param>
        <param name="y">La coordonnée y, relative au coin supérieur gauche de la fenêtre active vers laquelle la page doit défiler.</param>
        <summary>Fait défiler la fenêtre à la position désignée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> entraîne le défilement document afin que la coordonnée spécifiée sur le document se trouve dans le coin supérieur gauche de la fenêtre du document. Si le document n’est pas long ou assez large pour ce faire, <xref:System.Windows.Forms.HtmlWindow.ScrollTo%2A> fera défiler le document autant que possible dans la direction spécifiée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.HtmlWindow.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille de la fenêtre active.</summary>
        <value><see cref="T:System.Drawing.Size" /> décrivant, en pixels, la taille de la fenêtre.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StatusBarText">
      <MemberSignature Language="C#" Value="public string StatusBarText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusBarText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusBarText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusBarText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StatusBarText : string with get, set" Usage="System.Windows.Forms.HtmlWindow.StatusBarText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte affiché dans la barre d'état d'une fenêtre.</summary>
        <value><see cref="T:System.String" /> qui contient le texte d'état en cours.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.WebBrowser> contrôle n’affiche pas une barre d’état. Toute nouvelle fenêtre que vous ouvrez avec la <xref:System.Windows.Forms.HtmlWindow.Open%2A> ou <xref:System.Windows.Forms.HtmlWindow.OpenNew%2A> méthodes, cependant, affiche une barre d’état par défaut.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534648.aspx">Propriété Status</related>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlWindow.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unload As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Unload;" />
      <MemberSignature Language="F#" Value="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Unload : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la page active se décharge et une nouvelle page est sur le point de s'afficher.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlWindow.Unload> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlWindow> nommé `HtmlWindow1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlWindow.Unload> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#457](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#457)]
 [!code-vb[System.Windows.Forms.EventExamples#457](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#457)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536973.aspx">Événement onunload</related>
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlWindow.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URL qui correspond à l'élément actuellement affiché dans la fenêtre.</summary>
        <value><see cref="T:System.Uri" /> qui décrit l'URL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est en lecture seule. Pour naviguer dans la fenêtre vers un nouveau document, utilisez le <xref:System.Windows.Forms.HtmlWindow.Navigate%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowFrameElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement WindowFrameElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement WindowFrameElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WindowFrameElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ WindowFrameElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WindowFrameElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlWindow.WindowFrameElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément frame qui correspond à cette fenêtre.</summary>
        <value>Un <see cref="T:System.Windows.Forms.HtmlElement" /> correspondant à cette fenêtre <c>FRAME</c> élément. Si cette fenêtre n'est pas un frame, il retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous récupérez un `FRAME` élément à partir de la <xref:System.Windows.Forms.HtmlWindow.Frames%2A> collection, elle retourne un <xref:System.Windows.Forms.HtmlWindow>. Appelez <xref:System.Windows.Forms.HtmlWindow.WindowFrameElement%2A> sur cet objet si vous avez besoin d’accéder aux attributs de l’objet sous-jacent `FRAME` élément, tel que le `SRC` attribut.  
  
   
  
## Examples  
 Le code suivant exemple compare les `SRC` attribut d’images dans un `FRAMESET` à l’emplacement actuel. Si elles sont différentes, les frames sont réinitialisés à leurs URL d’origine.  
  
 [!code-csharp[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlWindow#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlWindow/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.UnauthorizedAccessException">Vous ne pouvez pas accéder à un <c>FRAME</c> éléments ou les <c>FRAME</c>du document si le <c>FRAME</c> est dans une zone différente de celle la <c>FRAMESET</c> qui contient Il. Pour obtenir une explication complète, consultez [About Cross-Frame Scripting and Security](https://msdn.microsoft.com/library/ms533028.aspx).</permission>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533771.aspx">Propriété frameElement</related>
      </Docs>
    </Member>
  </Members>
</Type>