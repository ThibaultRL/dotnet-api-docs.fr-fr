<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="86bf0bbbe4a522840b0389d8f113470093d05f6f" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56401768" /></Metadata><TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Cursor = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente l'image utilisée pour peindre le pointeur de souris.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un curseur est une petite image dont l’emplacement sur l’écran est contrôlé par un dispositif de pointage, par exemple une souris, un stylet ou un trackball. Lorsque l’utilisateur déplace le dispositif de pointage, le système d’exploitation déplace le curseur en conséquence.  
  
 Différentes formes de curseur sont utilisés pour informer l’utilisateur quelle opération aura de la souris. Par exemple, quand vous modifiez ou en sélectionnant du texte, un <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> curseur s’affiche généralement. Un curseur d’attente est couramment utilisé pour informer l’utilisateur qu’un processus est en cours d’exécution. Exemples de processus, vous pouvez avoir à l’utilisateur d’attendre ouvrez un fichier, l’enregistrement d’un fichier ou en remplissant un contrôle comme un <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> ou <xref:System.Windows.Forms.TreeView> avec une grande quantité de données.  
  
 Tous les contrôles qui dérivent de la <xref:System.Windows.Forms.Control> classe ont une <xref:System.Windows.Forms.Control.Cursor%2A> propriété. Pour modifier le curseur affiché par le pointeur de la souris lorsqu’il est dans les limites du contrôle, assignez un <xref:System.Windows.Forms.Cursor> à la <xref:System.Windows.Forms.Control.Cursor%2A> propriété du contrôle. Vous pouvez également afficher des curseurs au niveau de l’application en assignant un <xref:System.Windows.Forms.Cursor> à la <xref:System.Windows.Forms.Cursor.Current%2A> propriété. Par exemple, si l’objectif de votre application consiste à modifier un fichier texte, vous pouvez définir le <xref:System.Windows.Forms.Cursor.Current%2A> propriété <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> pour afficher un curseur d’attente sur l’application pendant que le fichier de charge et enregistre pour empêcher le traitement des événements de souris. Lorsque le processus est terminé, définissez le <xref:System.Windows.Forms.Cursor.Current%2A> propriété <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> pour l’application affiche le curseur approprié sur chaque type de contrôle.  
  
> [!NOTE]
>  Si vous appelez <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> avant de réinitialiser le <xref:System.Windows.Forms.Cursor.Current%2A> propriété revenir à la <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> curseur, l’application reprend à l’écoute des événements de souris et l’affichage approprié <xref:System.Windows.Forms.Cursor> pour chaque contrôle dans l’application.  
  
 Objets de curseur peuvent être créés à partir de plusieurs sources, telles que le handle d’un existant <xref:System.Windows.Forms.Cursor>, une norme <xref:System.Windows.Forms.Cursor> fichier, une ressource ou un flux de données.  
  
> [!NOTE]
>  Le <xref:System.Windows.Forms.Cursor> classe ne prend pas en charge les curseurs animés (fichiers .ani) ou les curseurs avec des couleurs autres que noir et blanc.  
  
 Si l’image que vous utilisez comme un curseur est trop petite, vous pouvez utiliser la <xref:System.Windows.Forms.Cursor.DrawStretched%2A> méthode pour forcer l’image pour remplir les limites du curseur. Vous pouvez masquer temporairement le curseur en appelant le <xref:System.Windows.Forms.Cursor.Hide%2A> (méthode) et la restaurer en appelant le <xref:System.Windows.Forms.Cursor.Show%2A> (méthode).  
  
 En commençant par le .NET Framework 4.5.2, la <xref:System.Windows.Forms.Cursor> sera redimensionné en fonction du paramètre de paramètre PPP système lorsque le fichier app.config contient l’entrée suivante :  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 L’exemple de code suivant affiche un formulaire qui illustre l’utilisation d’un curseur personnalisé. Personnalisé <xref:System.Windows.Forms.Cursor> est incorporé dans le fichier de ressources de l’application. L’exemple nécessite un curseur contenu dans un fichier curseur nommé `MyCursor.cur`. Pour compiler cet exemple à l’aide de la ligne de commande, ajoutez l’indicateur suivant : `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 L’exemple de code suivant affiche les informations client dans un <xref:System.Windows.Forms.TreeView> contrôle. Les nœuds d’arbre racine affichent les noms des clients et les nœuds d’arbre enfants affichent les numéros de commande affectés à chaque client. Dans cet exemple, 1 000 clients sont affichés avec 15 commandes. Le redessin du <xref:System.Windows.Forms.TreeView> est supprimée à l’aide de la <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> et <xref:System.Windows.Forms.TreeView.EndUpdate%2A> méthodes et une attente <xref:System.Windows.Forms.Cursor> s’affiche alors que le <xref:System.Windows.Forms.TreeView> crée et peint le <xref:System.Windows.Forms.TreeNode> objets. Cet exemple nécessite que vous avez un fichier curseur nommé `MyWait.cur` dans le répertoire de l’application. Elle requiert également un `Customer` objet qui peut contenir une collection de `Order` objets et que vous avez créé une instance d’un <xref:System.Windows.Forms.TreeView> control sur un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Cursor" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : nativeint -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><see cref="T:System.IntPtr" /> qui représente le handle Windows du curseur à créer.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Cursor" /> à partir du handle Windows spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez libérer le handle de curseur lorsque vous avez terminé avec lui. Pour plus d’informations sur la suppression de ressources, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un curseur à partir du <xref:System.Windows.Forms.Cursor.Current%2A> du curseur <xref:System.Windows.Forms.Cursor.Handle%2A>, modifie sa position et le rectangle de découpage. Le résultat est le curseur vers le haut et vers la gauche de 50 pixels là où il est quand le code est exécuté. En outre, le rectangle de découpage du curseur est modifié pour les limites du formulaire (par défaut il est tout écran de l’utilisateur). Cet exemple nécessite que vous avez un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Button> pour appeler ce code lorsque vous cliquez dessus.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" /> est <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : System.IO.Stream -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Flux de données à partir duquel <see cref="T:System.Windows.Forms.Cursor" /> doit être chargé.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Cursor" /> à partir du flux de données spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le flux de données spécifié par `stream` doit contenir un fichier curseur (.cur).  
  
> [!NOTE]
>  Curseurs animés (fichiers .ani) ne sont pas pris en charge par le <xref:System.Windows.Forms.Cursor> classe.  
  
   
  
## Examples  
 L’exemple de code suivant charge un curseur à partir une <xref:System.IO.Stream> créé par le <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A> méthode d’un <xref:System.Windows.Forms.OpenFileDialog>. Lorsque la méthode est appelée, un <xref:System.Windows.Forms.OpenFileDialog> est affiché à l’utilisateur et à quel moment un. Fichier CUR est sélectionné et la boîte de dialogue fermée, le fichier est ouvert et le <xref:System.IO.Stream> retourné est utilisé pour créer un <xref:System.Windows.Forms.Cursor>.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Fichier curseur à charger.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Cursor" /> à partir du fichier spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `fileName` paramètre doit référencer un fichier curseur (.cur) standard.  
  
> [!NOTE]
>  Curseurs animés (fichiers .ani) ne sont pas pris en charge par le <xref:System.Windows.Forms.Cursor> classe.  
  
   
  
## Examples  
 L’exemple de code suivant affiche les informations client dans un <xref:System.Windows.Forms.TreeView> contrôle. Les nœuds d’arbre racine affichent les noms des clients et les nœuds d’arbre enfants affichent les numéros de commande affectés à chaque client. Dans cet exemple, 1 000 clients sont affichés avec 15 commandes. Le redessin du <xref:System.Windows.Forms.TreeView> est supprimée à l’aide de la <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> et <xref:System.Windows.Forms.TreeView.EndUpdate%2A> méthodes et une attente <xref:System.Windows.Forms.Cursor> s’affiche alors que le <xref:System.Windows.Forms.TreeView> crée et peint le <xref:System.Windows.Forms.TreeNode> objets. Cet exemple nécessite que vous avez un `Customer` objet qui peut contenir une collection de `Order` objets. Il requiert également que vous avez créé une instance d’un <xref:System.Windows.Forms.TreeView> control sur un <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : Type * string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor (type, resource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><see cref="T:System.Type" /> de la ressource</param>
        <param name="resource">Nom de la ressource.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Forms.Cursor" /> à partir de la ressource spécifiée avec le type de ressource spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Voici un exemple montrant comment incorporer un curseur en tant que ressource dans votre application. Pour incorporer la ressource, référencer le nom de ressource suivi par une virgule, puis son chemin d’accès complet de l’assembly. Consultez la section exemple pour apprendre à charger le curseur à partir de la ressource incorporée.  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  La référence de ressource lors de la compilation, ainsi que lors de référencement dans le code, respecte la casse pour à la fois les compilateurs C# et Visual Basic.  
  
   
  
## Examples  
 L’exemple de code suivant affiche un formulaire qui illustre l’utilisation d’un curseur personnalisé à l’aide de la <xref:System.Windows.Forms.Cursor.%23ctor%2A> constructeur. Personnalisé <xref:System.Windows.Forms.Cursor> est incorporé dans le fichier de ressources de l’application. L’exemple nécessite que vous disposez d’un curseur contenu dans un fichier curseur nommé `MyCursor.cur`. Pour compiler cet exemple à l’aide de la ligne de commande, ajoutez l’indicateur suivant : `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Cursor.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les limites qui représentent le rectangle de découpage du curseur.</summary>
        <value><see cref="T:System.Drawing.Rectangle" /> représentant le rectangle de découpage pour <see cref="T:System.Windows.Forms.Cursor" />, en coordonnées d'écran.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un curseur découpé est autorisé à déplacer uniquement dans son rectangle de découpage. En règle générale, le système autorise uniquement si la souris est actuellement capturée. Si le curseur n’est pas actuellement découpé, le rectangle résultant contient les dimensions de l’écran entier.  
  
   
  
## Examples  
 L’exemple de code suivant crée un curseur à partir du <xref:System.Windows.Forms.Cursor.Current%2A> du curseur <xref:System.Windows.Forms.Cursor.Handle%2A>, modifie sa position et le rectangle de découpage. Le résultat est le curseur vers le haut et vers la gauche de 50 pixels là où il est quand le code est exécuté. En outre, le rectangle de découpage du curseur est modifié pour les limites du formulaire (par défaut il est tout écran de l’utilisateur). Cet exemple nécessite que vous avez un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Button> pour appeler ce code lorsque vous cliquez dessus.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour toutes les fenêtres définir cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberSignature Language="F#" Value="member this.CopyHandle : unit -&gt; nativeint" Usage="cursor.CopyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie le handle de ce <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns><see cref="T:System.IntPtr" /> qui représente le handle du curseur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le descripteur créé après l’appel à cette méthode doit être supprimé lorsque vous avez terminé avec lui, car elle ne sera pas supprimée de par le garbage collector.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Cursor.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet curseur qui représente le curseur de souris.</summary>
        <value><see cref="T:System.Windows.Forms.Cursor" /> représentant le curseur de souris. La valeur par défaut est <see langword="null" /> si le curseur de souris n'est pas visible.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de la <xref:System.Windows.Forms.Cursor.Current%2A> propriété modifie le curseur actuellement affiché. L’application peut ou ne peut pas continuer à écouter les événements de souris. Pour signaler que l’application ne doit pas répondre aux événements de souris pendant une opération longue, utilisez le <xref:System.Windows.Forms.Application.UseWaitCursor%2A> propriété. Dans la plupart des cas, toutefois, il est préférable d’utiliser un thread d’arrière-plan pour gérer une opération longue et laisser votre interface utilisateur accessible à l’utilisateur. Pour plus d’informations sur l’implémentation facilement une tâche en arrière-plan, consultez <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour les sous-fenêtres définir cette propriété. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cursor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Windows.Forms.Cursor.Dispose%2A> une fois que vous avez terminé d'utiliser <xref:System.Windows.Forms.Cursor>. La méthode `Dispose` rend le <xref:System.Windows.Forms.Cursor> inutilisable. Après avoir appelé <xref:System.Windows.Forms.Cursor.Dispose%2A>, vous devez libérer toutes les références à la <xref:System.Windows.Forms.Cursor> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Windows.Forms.Cursor> occupée. Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours <xref:System.Windows.Forms.Cursor.Dispose%2A> avant de libérer votre dernière référence à <xref:System.Windows.Forms.Cursor>. Sinon, les ressources qu’il utilise ne seront pas libérées jusqu'à ce que le garbage collector libère.  
  
   
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.Draw (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Surface <see cref="T:System.Drawing.Graphics" /> sur laquelle dessiner <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" /> représentant les limites du <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Dessine le curseur sur la surface spécifiée dans les limites spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La commande de dessin est initiée sur la surface graphique représentée par le `g` paramètre, mais un <xref:System.Drawing.Graphics> ne contient pas d’informations sur le rendu d’une image donnée, afin qu’il passe l’appel à la <xref:System.Windows.Forms.Cursor>. Le <xref:System.Windows.Forms.Cursor.Draw%2A> méthode rogne l’image aux dimensions spécifiées et vous permet de spécifier un <xref:System.Drawing.Rectangle> au sein duquel dessiner le <xref:System.Windows.Forms.Cursor>. Cette méthode est généralement utilisée pour dessiner le curseur sur une surface du graphique. Par exemple, vous pouvez avoir une boîte de dialogue qui permet à l’utilisateur de sélectionner des curseurs à partir d’un <xref:System.Windows.Forms.ListBox> contrôle ou un groupe de <xref:System.Windows.Forms.RadioButton> contrôles.  
  
   
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite que vous avez un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> objet à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawStretched : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.DrawStretched (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Surface <see cref="T:System.Drawing.Graphics" /> sur laquelle dessiner <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" /> représentant les limites du <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Dessine le curseur dans un format agrandi sur la surface spécifiée dans les limites spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La commande de dessin est initiée sur la surface graphique représentée par le `g` paramètre, mais un <xref:System.Drawing.Graphics> objet ne contient pas d’informations sur le rendu d’une image donnée, afin qu’il passe l’appel à la <xref:System.Windows.Forms.Cursor> objet. Le <xref:System.Windows.Forms.Cursor.DrawStretched%2A> méthode étire l’image pour remplir spécifié <xref:System.Drawing.Rectangle> lorsque le curseur est dessiné.  
  
   
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite que vous avez un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> objet à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cursor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
  <see cref="T:System.Windows.Forms.Cursor" /> à comparer.</param>
        <summary>Retourne une valeur indiquant si le curseur est égal au <see cref="T:System.Windows.Forms.Cursor" /> spécifié.</summary>
        <returns><see langword="true" /> si le curseur est égal au <see cref="T:System.Windows.Forms.Cursor" /> spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant crée un curseur à partir du <xref:System.Windows.Forms.Cursor.Current%2A> du curseur <xref:System.Windows.Forms.Cursor.Handle%2A>, modifie sa position et le rectangle de découpage. Le résultat est le curseur vers le haut et vers la gauche de 50 pixels là où il est quand le code est exécuté. En outre, le rectangle de découpage du curseur est modifié pour les limites du formulaire (par défaut il est tout écran de l’utilisateur). Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Button> pour appeler ce code lorsque vous cliquez dessus.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="cursor.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Autorise un objet à tenter de libérer des ressources et à exécuter d'autres opérations de nettoyage avant qu'il ne soit récupéré par une opération garbage collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cursor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère le code de hachage pour le <see cref="T:System.Windows.Forms.Cursor" /> actuel.</summary>
        <returns>Code de hachage du <see cref="T:System.Windows.Forms.Cursor" /> actuel.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Cursor.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle du curseur.</summary>
        <value><see cref="T:System.IntPtr" /> qui représente le handle du curseur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce n’est pas une copie du handle ; ne pas supprimer de celui-ci.  
  
   
  
## Examples  
 L’exemple de code suivant crée un curseur à partir du <xref:System.Windows.Forms.Cursor.Current%2A> du curseur <xref:System.Windows.Forms.Cursor.Handle%2A>, modifie sa position et le rectangle de découpage. Le résultat est le curseur vers le haut et vers la gauche de 50 pixels là où il est quand le code est exécuté. En outre, le rectangle de découpage du curseur est modifié pour les limites du formulaire (par défaut il est tout écran de l’utilisateur). Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Button> pour appeler ce code lorsque vous cliquez dessus.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">La valeur du handle est <see cref="F:System.IntPtr.Zero" />.</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberSignature Language="F#" Value="static member Hide : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Masque le curseur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Cursor.Show%2A> et <xref:System.Windows.Forms.Cursor.Hide%2A> les appels de méthode doivent être équilibrées. Pour chaque appel à la <xref:System.Windows.Forms.Cursor.Hide%2A> méthode qu’il doit y avoir un appel correspondant à la <xref:System.Windows.Forms.Cursor.Show%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant masque le curseur lorsque le pointeur de la souris entre dans la zone du bouton client. De même, lorsque le pointeur de la souris quitte la zone cliente du bouton, le curseur s’affiche à nouveau. Cet exemple nécessite un <xref:System.Windows.Forms.Form> avec un <xref:System.Windows.Forms.Button> nommé `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour toutes les fenêtres, appelez cette méthode. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.HotSpot : System.Drawing.Point" Usage="System.Windows.Forms.Cursor.HotSpot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la zone réactive du curseur.</summary>
        <value><see cref="T:System.Drawing.Point" /> représentant la zone réactive du curseur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Cursor.HotSpot%2A> est le <xref:System.Drawing.Point> dans le curseur qui interagit avec d’autres éléments sur l’écran.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Windows.Forms.Cursor" /> à comparer.</param>
        <param name="right"><see cref="T:System.Windows.Forms.Cursor" /> à comparer.</param>
        <summary>Retourne une valeur indiquant si deux instances de la classe <see cref="T:System.Windows.Forms.Cursor" /> sont égales.</summary>
        <returns><see langword="true" /> si deux instances de la classe <see cref="T:System.Windows.Forms.Cursor" /> sont égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> objet à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="System.Windows.Forms.Cursor.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left"><see cref="T:System.Windows.Forms.Cursor" /> à comparer.</param>
        <param name="right"><see cref="T:System.Windows.Forms.Cursor" /> à comparer.</param>
        <summary>Retourne une valeur indiquant si deux instances de la classe <see cref="T:System.Windows.Forms.Cursor" /> ne sont pas égales.</summary>
        <returns><see langword="true" /> si deux instances de la classe <see cref="T:System.Windows.Forms.Cursor" /> ne sont pas égales ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Cursor.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du curseur.</summary>
        <value><see cref="T:System.Drawing.Point" /> représentant la position du curseur en coordonnées d'écran.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Cursor.Position%2A> propriété est identique à la <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant crée un curseur à partir du <xref:System.Windows.Forms.Cursor.Current%2A> du curseur <xref:System.Windows.Forms.Cursor.Handle%2A>, modifie sa position et le rectangle de découpage. Le résultat est le curseur vers le haut et vers la gauche de 50 pixels là où il est quand le code est exécuté. En outre, le rectangle de découpage du curseur est modifié pour les limites du formulaire (par défaut il est tout écran de l’utilisateur). Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Button> pour appeler ce code lorsque vous cliquez dessus.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberSignature Language="F#" Value="static member Show : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Affiche le curseur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.Cursor.Show%2A> et <xref:System.Windows.Forms.Cursor.Hide%2A> les appels de méthode doivent être équilibrées. Pour chaque appel à la <xref:System.Windows.Forms.Cursor.Hide%2A> méthode qu’il doit y avoir un appel correspondant à la <xref:System.Windows.Forms.Cursor.Show%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant masque le curseur lorsque le pointeur de la souris entre dans la zone du bouton client. De même, lorsque le pointeur de la souris quitte la zone cliente du bouton, le curseur s’affiche à nouveau. Cet exemple nécessite un <xref:System.Windows.Forms.Form> avec un <xref:System.Windows.Forms.Button> nommé `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Windows.Forms.Cursor.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille de l'objet curseur.</summary>
        <value><see cref="T:System.Drawing.Size" /> qui représente la largeur et la hauteur de <see cref="T:System.Windows.Forms.Cursor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant dessine le curseur spécifié sur le formulaire dans sa taille normale et en mode étendu, deux fois sa taille. Cet exemple nécessite un <xref:System.Windows.Forms.Form> et un <xref:System.Windows.Forms.Cursor> objet à passer à la méthode lorsqu’elle est appelée.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Classe <see cref="T:System.Runtime.Serialization.SerializationInfo" />.</param>
        <param name="context">Classe <see cref="T:System.Runtime.Serialization.StreamingContext" />.</param>
        <summary>Sérialise l'objet.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Cursor.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet qui contient les données relatives au <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <value><see cref="T:System.Object" /> qui contient les données relatives à <see cref="T:System.Windows.Forms.Cursor" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cursor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère une chaîne lisible par l'utilisateur représentant ce <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns><see cref="T:System.String" /> qui représente ce <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>