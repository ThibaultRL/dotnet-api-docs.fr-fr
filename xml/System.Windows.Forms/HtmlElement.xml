<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="87902a8466b3330ae39cf52a81c1f24b67dd60ed" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39941084" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente un élément HTML dans une page web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> correspond à n’importe quel type d’élément dans un document HTML, possible comme `BODY`, `TABLE`, et `FORM`, entre autres. La classe expose les propriétés les plus courantes que vous pouvez vous attendre à trouver sur tous les éléments.  
  
 La plupart des éléments peuvent avoir *éléments enfants*: autres éléments HTML qui sont situés juste en dessous. Utilisez le <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> propriété pour déterminer si un élément donné a des enfants et le <xref:System.Windows.Forms.HtmlElement.Children%2A> collection à itérer au sein de leur. Le <xref:System.Windows.Forms.HtmlElement.Parent%2A> propriété retourne le <xref:System.Windows.Forms.HtmlElement> dans lequel l’élément actuel est imbriqué.  
  
 Vous devez souvent accéder à des attributs, des propriétés et des méthodes sur l’élément sous-jacent qui ne sont pas directement exposées par <xref:System.Windows.Forms.HtmlElement>, telles que la `SRC` attribut sur une `IMG` élément ou le `Submit` méthode sur un `FORM`. Le <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> et <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> méthodes permettent de récupérer et de modifier tout attribut ou propriété sur un élément spécifique, tandis que <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> fournit l’accès à toute méthode non exposée dans le managé modèle DOM (Document Object). Si votre application a l’autorisation de code non managé, vous pouvez également accéder non exposés des propriétés et méthodes avec les <xref:System.Windows.Forms.HtmlElement.DomElement%2A> attribut.  
  
 Utilisez le <xref:System.Windows.Forms.HtmlElement.TagName%2A> propriété pour tester si un élément est d’un type spécifique.  
  
 N’importe quel document HTML peut être modifié au moment de l’exécution. Vous pouvez créer de nouveaux <xref:System.Windows.Forms.HtmlElement> objets avec le <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> méthode de <xref:System.Windows.Forms.HtmlDocument>et les ajouter à un autre élément à l’aide du <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> ou <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> méthodes. Vous pouvez également créer les éléments comme des balises HTML et les affecter à un élément existant <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment examiner un document HTML arbitraire et dériver une chaîne décrivant les éléments HTML, avec mise en retrait et numéros de niveau utilisés pour indiquer le niveau d’imbrication des éléments se trouvent dans le document. Cet exemple de code requiert que votre application héberge un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Windows.Forms.HtmlElementCollection" /> de tous les éléments situés sous l'élément actuel.</summary>
        <value>Collection de tous les éléments qui sont des enfants directs ou indirects de l'élément actuel. Si l’élément actuel est un <c>TABLE</c>, par exemple, <see cref="P:System.Windows.Forms.HtmlElement.All" /> retournera chaque <c>TH</c>, <c>TR</c>, et <c>TD</c> élément dans la table, ainsi que tout autre élément, tel que <c>DIV</c> et <c>étendue</c> éléments, contenus dans les cellules.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour accéder uniquement les éléments qui ont l’élément actuel en tant que parent direct, utilisez le <xref:System.Windows.Forms.HtmlElement.Children%2A> collection à la place.  
  
 Éléments dans cette collection ne seront pas nécessairement retournés dans l’ordre de la source.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">
          <see cref="T:System.Windows.Forms.HtmlElement" /> à ajouter à cet emplacement dans l'arborescence.</param>
        <summary>Ajoute un élément au sous-arbre d'un autre élément.</summary>
        <returns>L’élément qui le suit a été ajouté à l’arborescence.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Document objet Model (DOM) vous permet de modifier le contenu de l’exécution d’un fichier HTML de plusieurs façons. Utilisez <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> pour ajouter de nouveaux éléments à un document existant, ou pour déplacer un élément sur la page.  
  
 Si un élément a déjà été apparenté, ajoutant un élément à un autre élément supprimera automatiquement cet élément de son parent précédent.  
  
 Les ajouts apportés à un document au moment de l’exécution à l’aide <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> ne seront pas conservées lorsque vous appelez le <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> méthode sur le <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
   
  
## Examples  
 L’exemple de code suivant crée un lien hypertexte en utilisant le <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> (méthode) et l’ajoute à la fin d’une page à l’aide `AppendChild` sur la `BODY` élément. L’exemple requiert que votre application contient un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez gérer.</param>
        <param name="eventHandler">Code managé qui gère l'événement.</param>
        <summary>Ajoute un gestionnaire d'événements pour un événement nommé sur le modèle DOM HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Managed modèle DOM (Document Object) expose uniquement un nombre limité d’événements. La plupart des événements non exposés est uniquement définis pour des types spécifiques d’éléments ; comme le `submit` événement, qui est valide uniquement sur `FORM` éléments. Utilisez <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> pour ajouter un gestionnaire d’événements à ces événements non exposés.  
  
 Vous ne devez pas attacher un événement au document ou à un de ses objets jusqu'à ce que le chargement est terminé dans le document. Est le plus ancien que vous devez appeler cette méthode dans le <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> événements de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
 Pour plus d’informations sur les événements non gérés disponibles, consultez [l’accès à des membres non exposés sur le modèle objet de Document géré du HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) et les interfaces IHTMLElement : [IHTMLElement](http://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](http://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](http://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](http://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si cet élément peut avoir des éléments enfants.</summary>
        <value>
          <see langword="true" /> si l'élément peut avoir des éléments enfants ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains éléments, tels que `IMG` et `SCRIPT`, ne peut pas avoir d’enfants. Utilisez cette propriété avant d’appeler <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> ou <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> sur un élément arbitraire.  
  
   
  
## Examples  
 Le code suivant exemple gère le <xref:System.Windows.Forms.HtmlElement.Click> événement sur <xref:System.Windows.Forms.HtmlDocument>. Si un élément n’était pas précédent sélectionné à l’aide d’un clic de souris, le code assigne l’élément à une variable de classe privée nommée `MoveElement`. Si un élément a été sélectionné, le code tente d’ajouter à l’élément qui a été cliqué simplement. Cet exemple de code requiert que votre application héberge un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`, et que vous avez déjà ajouté un gestionnaire d’événements pour le <xref:System.Windows.Forms.HtmlElement.Click> événement sur <xref:System.Windows.Forms.HtmlDocument>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Windows.Forms.HtmlElementCollection" /> de tous les enfants de l'élément actuel.</summary>
        <value>Collection de tous les objets <see cref="T:System.Windows.Forms.HtmlElement" /> qui ont pour parent l'élément actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De nombreux éléments à l’intérieur d’un fichier HTML peuvent avoir d’autres éléments HTML juste en dessous. Le <xref:System.Windows.Forms.HtmlElement.Children%2A> collection fournit un mécanisme simple pour Explorer la structure arborescente d’un document.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> expose uniquement les éléments dont le parent direct est l’élément actuel. Si vous avez un <xref:System.Windows.Forms.HtmlElement> pour un `TABLE` élément, <xref:System.Windows.Forms.HtmlElement.Children%2A> accordera à tous les le `TR` éléments (ligne) à l’intérieur de la `TABLE`. Pour récupérer le `TD` éléments (cellule) contenus à l’intérieur de la `TR` éléments, vous devez utiliser soit le <xref:System.Windows.Forms.HtmlElement.Children%2A> collection sur chaque `TR` élément, ou utilisez le <xref:System.Windows.Forms.HtmlElement.All%2A> collection sur <xref:System.Windows.Forms.HtmlElement>.  
  
 Éléments de cette collection ne sont pas garantis pour être dans l’ordre de la source.  
  
 Si <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> est `false`, `Children` sera toujours vide.  
  
   
  
## Examples  
 L’exemple de code suivant examine un document HTML arbitraire et dériver une chaîne décrivant les éléments, avec mise en retrait et les numéros de niveau utilisés pour indiquer le niveau d’imbrication des éléments se trouvent dans le document. Pour ce faire, il recherche le `Children` collection de tous les éléments de manière récursive, en commençant par l’élément HTML en haut du document. Cet exemple de code requiert que votre application possède un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique sur l'élément avec le bouton gauche de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.Click> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.Click> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Si l’utilisateur clique sur un élément qui ne pas actuellement le focus, le <xref:System.Windows.Forms.HtmlElement.Click> événement se produit après la <xref:System.Windows.Forms.HtmlElement.Focusing> événement, mais avant que le <xref:System.Windows.Forms.HtmlElement.LostFocus> événement pour cet élément.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.Click> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.Click> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les limites de la zone client de l'élément dans le document HTML.</summary>
        <value>Zone client occupée par l'élément, moins toute zone occupée par les bordures et les barres de défilement. Pour obtenir la position et les dimensions de l'élément avec ses motifs, utilisez <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> à la place.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> Retourne les données de position uniquement pour les éléments qui ont été affectées à une hauteur explicite et une largeur ou des éléments qui utilisent le positionnement absolu. Un document est positionné de façon absolue si son style de position est définie sur `absolute`, après laquelle il peut être positionné sur les coordonnées dans la page HTML.  
  
   
  
## Examples  
 Supposons que vous avez chargé la page HTML suivante dans une instance hébergée de la <xref:System.Windows.Forms.WebBrowser> contrôle.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 L’exemple de code suivant illustre la récupération de cet élément et le développement de ses dimensions si la zone cliente est inférieure à 400 pixels de large sur 50 pixels en hauteur et définit également la `DIV` à la `contentEditable` afin que l’utilisateur peut entrer du texte d’état.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement que vous souhaitez gérer.</param>
        <param name="eventHandler">Code managé qui gère l'événement.</param>
        <summary>Supprime un gestionnaire d'événements d'un événement nommé sur le modèle DOM HTML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Windows.Forms.HtmlDocument" /> auquel cet élément appartient.</summary>
        <value>Document parent de cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines pages HTML peuvent héberger des frames à l’aide de la `FRAMESET` balises. Dans ce cas, chaque personne `FRAME` élément contient sa propre instance de <xref:System.Windows.Forms.HtmlDocument>. Cette propriété est particulièrement utile lorsque vous avez reçu une référence à un élément dans un gestionnaire d’événements à partir de la <xref:System.Windows.Forms.HtmlElementEventArgs>et vous avez besoin d’effectuer une action sur le document dans lequel réside l’élément.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un pointeur d'interface non managée pour cet élément.</summary>
        <value>Le modèle COM <c>IUnknown</c> interfaces de pointeur pour l’élément, vous pouvez effectuer un cast à un de l’élément HTML, telles que <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> est un wrapper pour l’Internet Explorer modèle DOM (Document Object), qui est écrit à l’aide de l’objet COM (Component Model). Si vous avez besoin d’accéder à des propriétés non exposées ou méthodes sur les interfaces COM sous-jacentes, telles que `IHTMLElement`, vous pouvez utiliser cet objet à interroger pour eux.  
  
 Pour pouvoir utiliser les interfaces non managées, vous devez importer la bibliothèque MSHTML (mshtml.dll) dans votre application. Toutefois, vous pouvez également exécuter des propriétés non exposées et les méthodes à l’aide de la `Invoke` (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant utilise les interfaces non managées pour prendre le texte actuellement sélectionné et le convertir en lien hypertexte, avec l’URL choisie par l’utilisateur. Ce code a été écrit en supposant que votre formulaire contient un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`, et que vous avez ajouté la bibliothèque MSHTML non managée en tant que référence à votre projet.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur clique deux fois de suite avec le bouton gauche de la souris sur un élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un double-clic est déterminé par les paramètres de la souris du système d’exploitation de l’utilisateur. L'utilisateur peut définir le délai qui détermine si les clics effectués sur un bouton de souris sont considérés comme un double-clic ou comme deux clics.  
  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.DoubleClick> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.DoubleClick> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.DoubleClick> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.DoubleClick> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur fait glisser le texte vers plusieurs emplacements.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement se produit lorsque le texte est déplacé vers les emplacements suivants :  
  
-   Dans ou entre des pages HTML hébergées dans le <xref:System.Windows.Forms.WebBrowser> contrôle ou Internet Explorer  
  
-   À une autre application  
  
-   Sur le bureau Windows  
  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.Drag> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.Drag> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.Drag> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.Drag> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un utilisateur termine une opération glisser.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.DragEnd> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.DragEnd> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.DragEnd> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.DragEnd> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur ne fait plus glisser un élément sur cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.DragLeave> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.DragLeave> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur fait glisser du texte sur l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.DragOver> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.DragOver> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.DragOver> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.DragOver> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit si l'utilisateur peut entrer des données dans cet élément.</summary>
        <value>
          <see langword="true" /> si l'élément autorise l'entrée d'utilisateur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour `FORM` éléments tels que les zones de texte et cases d’option, paramètre <xref:System.Windows.Forms.HtmlElement.Enabled%2A> à `false` empêchera l’utilisateur à l’aide de ces champs de formulaire. Pour les autres éléments, tels que `DIV` ou `SPAN`, la définition <xref:System.Windows.Forms.HtmlElement.Enabled%2A> à `false` tout le texte dans l’élément ombrée ; Toutefois, le texte sera toujours sélectionnable. Pour annuler la sélection, ajouter un gestionnaire d’événements pour le non exposés `onselectstart` à l’aide de l’événement le <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet dont la similitude doit être testée.</param>
        <summary>Teste si l'objet fourni est égal à l'élément actuel.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> est un <see cref="T:System.Windows.Forms.HtmlElement" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’élément suivant situé au-dessous de cet élément dans l’arborescence du document.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> représentant le premier élément contenu sous l'élément actuel, dans l'ordre de la source.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> conjointement avec <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> pour parcourir l’arborescence de document pour un document HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Met le focus d'entrée d'utilisateur sur l'élément actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définir le focus sur un élément à la fois donne le focus à cet élément et rend l’élément actif ; par exemple, l’élément qui a le focus est retourné par la <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> propriété du <xref:System.Windows.Forms.HtmlDocument>.  
  
 N’importe quel de touches entrée par un utilisateur après <xref:System.Windows.Forms.HtmlElement.Focus%2A> a été appelée va être envoyée à cet élément.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'élément reçoit pour la première fois le focus d'entrée utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un élément qui avait le focus avant que l’utilisateur bascule vers une autre application à l’aide de la barre des tâches ou les touches ALT + TAB recevra le <xref:System.Windows.Forms.HtmlElement.Focusing> et <xref:System.Windows.Forms.HtmlElement.GotFocus> événements à nouveau lorsque l’utilisateur bascule vers votre application.  
  
 Vous ne pouvez pas annuler le comportement par défaut de cet événement. Pour supprimer le focus à partir d’un élément, appelez <xref:System.Windows.Forms.HtmlElement.Focus%2A> sur un autre élément depuis le <xref:System.Windows.Forms.HtmlElement.GotFocus> événement.  
  
 Un <xref:System.Windows.Forms.HtmlElement.Focusing> événement sur un élément se produit également sur ses parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.Focusing> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.Focusing> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nom de l'attribut. Cet argument ne respecte pas la casse.</param>
        <summary>Récupère la valeur de l'attribut nommé sur l'élément.</summary>
        <returns>Valeur de cet attribut sur l'élément, de type <see cref="T:System.String" />. Si l'attribut spécifié n'existe pas sur cet élément, retourne une chaîne vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un attribut au format HTML est une paire nom/valeur valide pour cet élément. <xref:System.Windows.Forms.HtmlElement> expose uniquement les attributs qui sont communes à tous les éléments, en laissant ceux qui s’appliquent uniquement à certains types d’éléments ; `SRC` est un attribut prédéfini pour le `IMG` de balise, par exemple, mais pas pour le `DIV` balise. Utilisez <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> et <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> pour manipuler des attributs non exposés sur le managé modèle DOM (Document Object).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> et <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> respectent la casse.  
  
   
  
## Examples  
 L’exemple de code suivant récupère tous les `META` balises dans HTML de documents, à l’aide de <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> pour rechercher le `META` balise portant le nom `Description`. L’exemple exige que votre application ait un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nom de la balise dont vous souhaitez récupérer les objets <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Récupère une collection d’éléments représentée en HTML par l’étiquette <c>HTML</c> spécifiée.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> qui contient tous les éléments dont le nom de la balise <c>HTML</c> est identique à <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sert de fonction de hachage pour un type particulier.</summary>
        <returns>Code de hachage du <see cref="T:System.Object" /> actuel.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'élément a reçu le focus d'entrée d'utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler le comportement par défaut de cet événement, ni l’empêcher de se propager. Pour supprimer le focus à partir d’un élément, appelez <xref:System.Windows.Forms.HtmlElement.Focus%2A> sur un autre élément depuis le <xref:System.Windows.Forms.HtmlElement.GotFocus> événement.  
  
   
  
## Examples  
 Enregistrez le code HTML suivant dans un fichier et charger le fichier dans un <xref:System.Windows.Forms.WebBrowser> contrôle dans un projet Windows Forms.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 L’exemple de code suivant empêche la prochaine `INPUT` élément dans l’ordre de tabulation de recevoir le focus d’entrée d’utilisateur si l’élément précédent contient moins de cinq caractères. L’exemple requiert que le fichier HTML mentionné précédemment est chargé dans une instance de la <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une étiquette qui sert à identifier l'élément.</summary>
        <value>Identificateur unique pour l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> doit être unique ; Vous ne pouvez avoir deux éléments qui portent le même <xref:System.Windows.Forms.HtmlElement.Id%2A> à l’intérieur du même document. Utilisez le <xref:System.Windows.Forms.HtmlElement.Name%2A> propriété afin de donner le même identificateur à un groupe d’éléments liés logiquement entre eux.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le balisage HTML sous cet élément.</summary>
        <value>Balisage HTML qui définit les éléments enfants de l'élément actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe plusieurs façons d’ajouter de nouveaux éléments à une page HTML existante, telles que la <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> et <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> méthodes. À l’aide de <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> est souvent le moyen le plus rapide pour ajouter un nouveau contenu lorsque vous devez définir de nombreux attributs ou styles sur vos nouveaux éléments.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> diffère <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> dans la mesure <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> n’inclut pas le HTML qui représente l’objet que vous appelez. Consultez <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> pour plus d’informations sur la différence entre ces deux propriétés.  
  
 Paramètre <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> détruit tout enfant ajouté précédemment à l’élément. Si vous récupérez un élément du DOM et ensuite affecter le nouveau code HTML à ses parents <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété, votre référence à cet élément est inutile et son comportement lorsqu’il appelle ses propriétés et méthodes n’est pas défini.  
  
 Pour certains éléments, en définissant <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> n’est pas une opération valide. Certaines balises HTML n’ont aucune balise de fermeture, comme le `IMG` balise et par conséquent ne peut pas contenir d’éléments imbriqués. Certaines balises, telles que la `SCRIPT` balise, peut contenir uniquement du texte contenu ; paramètre <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> entraîne une erreur. Pour les deux types de balises, le <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> propriété retournera `false`. Vous ne pouvez pas attribuer <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> sur `TABLE` et `TR` éléments, en tant qu’assigner du HTML incorrect à ces éléments peut endommager le rendu du document. Utilisez <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> ou `insertRow` et `insertCell` méthodes sur non managé `IHTMLTable` interface pour ajouter des lignes et des cellules à un `TABLE`.  
  
 Si vous devez uniquement affecter un texte à un élément et le pas le balisage HTML, utilisez le <xref:System.Windows.Forms.HtmlElement.InnerText%2A> propriété à la place.  
  
 Affectez une valeur à <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> détruira les valeurs de texte précédemment attribuées à l’aide <xref:System.Windows.Forms.HtmlElement.InnerText%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La création d’éléments enfants sur cet élément n’est pas autorisée.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte assigné à l'élément.</summary>
        <value>Texte de l'élément, sans le balisage HTML. Si l'élément contient des éléments enfants, seul le texte de ces éléments enfants est conservé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous essayez d’assigner du HTML à un élément avec <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, le code HTML s’affiche en tant que littéraux dans le document, comme si vous visualisiez du HTML dans un fichier texte. Si vous assignez du HTML à un élément avec la <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété, <xref:System.Windows.Forms.HtmlElement.InnerText%2A> renvoie tout le texte dans la mesure HTML avec le balisage est supprimé.  
  
 Affectez une valeur à <xref:System.Windows.Forms.HtmlElement.InnerText%2A> détruira les éléments enfants qui appartiennent à l’élément.  
  
   
  
## Examples  
 Le code suivant crée un lien hypertexte en utilisant <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>et assigne le texte au lien en utilisant le <xref:System.Windows.Forms.HtmlElement.InnerText%2A> propriété.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">L’élément spécifié ne peut pas contenir de texte (par exemple, un élément <c>IMG</c>).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Emplacement où insérer cet élément par rapport à l'élément actuel.</param>
        <param name="newElement">Nouvel élément à insérer.</param>
        <summary>Insère un nouvel élément dans le modèle DOM.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElement" /> qui vient d'être inséré. En cas d'échec de l'insertion, retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’appelez pas cette méthode avant que le <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> événement sur le <xref:System.Windows.Forms.WebBrowser> contrôle s’est produite. Appel de cette méthode avant cette date peut entraîner une exception, comme le document n’a pas fini le chargement.  
  
 Si une valeur de <xref:System.Windows.Forms.HtmlElementInsertionOrientation> est valide varient selon le type de l’élément. Par exemple, <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> est valide si l’élément est un `DIV`, mais s’il s’agit une `SCRIPT` ou `IMG` élément, qui ne peut contenir des éléments enfants.  
  
   
  
## Examples  
 Le code suivant exemple montre comment insérer un `DIV` élément en haut de chaque page qui permet d’afficher les utilisateurs en dehors du serveur ADatum.com. L’exemple requiert que votre formulaire contienne un <xref:System.Windows.Forms.WebBrowser> contrôle nommé `WebBrowser1`. Votre exemple doit également importer l’espace de noms <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute une méthode spécifique à l'élément actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nom de la propriété ou de la méthode à appeler.</param>
        <summary>Exécute une méthode non exposée dans l'élément DOM sous-jacent de cet élément.</summary>
        <returns>Élément retourné par cette méthode, représenté sous la forme d'un <see cref="T:System.Object" />. Si ce <see cref="T:System.Object" /> est un autre élément HTML et si vous avez ajouté une référence à la bibliothèque MSHTML non managée à votre projet, vous pouvez effectuer un cast de celle-ci en son interface non managée appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour appeler des méthodes à partir du modèle DOM (Document Object) qui n’ont pas d’équivalents dans le code managé. Utilisez cette version de <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> pour exécuter des méthodes non exposées qui n’acceptent aucun argument. Pour obtenir un exemple, consultez <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Nom de la propriété ou de la méthode à appeler.</param>
        <param name="parameter">Liste de paramètres à passer.</param>
        <summary>Exécute une fonction définie dans la page HTML actuelle par un langage de script.</summary>
        <returns>Élément retourné par la fonction, représentée comme <see cref="T:System.Object" />. Si ce <see cref="T:System.Object" /> est un autre élément HTML et si vous avez ajouté une référence à la bibliothèque MSHTML non managée à votre projet, vous pouvez effectuer un cast de celle-ci en son interface non managée appropriée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour appeler des méthodes à partir du modèle DOM (Document Object) qui n’ont pas d’équivalents dans le code managé. Tous les arguments fournis à <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> seront converties en Win32 `VARIANT` types de données avant d’être passés à la fonction de script nommée.  
  
   
  
## Examples  
 Le code suivant exemple obtient un `TABLE` appelé `dataTable` et utilise le non exposés `moveRow` méthode pour déplacer une ligne à partir de la fin de la table vers le début.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur appuie sur une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> se produit avant <xref:System.Windows.Forms.HtmlElement.KeyPress>, ce qui réduit se produit avant <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.KeyDown> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.KeyDown> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.KeyDown> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.KeyDown> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’utilisateur appuie sur une touche du clavier et la relâche.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> se produit après <xref:System.Windows.Forms.HtmlElement.KeyDown> et avant <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.KeyPress> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.KeyPress> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.KeyPress> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.KeyPress> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’utilisateur relâche une touche du clavier.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> se produit après <xref:System.Windows.Forms.HtmlElement.KeyPress>, ce qui se produit après <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Vous ne pouvez pas annuler cet événement.  
  
 Un <xref:System.Windows.Forms.HtmlElement.KeyUp> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.KeyUp> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.KeyUp> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'élément perd le focus d'entrée utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.LosingFocus> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.LosingFocus> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'élément a perdu le focus d'entrée utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un élément ne recevra plus les événements de séquence de touches après <xref:System.Windows.Forms.HtmlElement.LostFocus> se produit jusqu'à ce qu’il reçoit le focus à nouveau, par l’utilisateur en le sélectionnant dans la page ou par l’application qui appelle le <xref:System.Windows.Forms.HtmlElement.Focus%2A> méthode sur cet élément.  
  
 Vous ne pouvez pas annuler cet événement.  
  
 Un <xref:System.Windows.Forms.HtmlElement.LostFocus> événement sur un élément se produit également sur ses parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.LostFocus> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.LostFocus> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur appuie sur un bouton de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.MouseDown> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.MouseDown> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseDown> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseDown> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur déplace pour la première fois le curseur de la souris sur l'élément actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseEnter> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseEnter> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l'utilisateur retire le curseur de la souris de l'élément actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseLeave> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseLeave> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'utilisateur déplace le curseur de la souris sur l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas annuler cet événement.  
  
 Un <xref:System.Windows.Forms.HtmlElement.MouseMove> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseMove> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseMove> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le curseur de souris passe les limites de l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.MouseOver> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.MouseOver> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseOver> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseOver> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’utilisateur relâche un bouton de la souris.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez annuler l’action par défaut pour un <xref:System.Windows.Forms.HtmlElement.MouseUp> événement sur un élément en définissant le <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
 Un <xref:System.Windows.Forms.HtmlElement.MouseUp> événement sur un élément se produit également sur ses éléments parents et sur la <xref:System.Windows.Forms.HtmlDocument> classe proprement dite, sauf si vous définissez la <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> propriété de la <xref:System.Windows.Forms.HtmlElementEventArgs> classe `true`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de ce membre. Dans l’exemple, un gestionnaire d’événements des rapports sur l’occurrence de la <xref:System.Windows.Forms.HtmlElement.MouseUp> événement. Ce rapport vous aide à savoir quand l’événement se produit et peut vous aider à déboguer. Pour générer un rapport sur plusieurs événements ou sur les événements qui se produisent fréquemment, envisagez de remplacer <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> avec <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou ajouter le message à un multiligne <xref:System.Windows.Forms.TextBox>.  
  
 Pour exécuter l’exemple de code, collez-le dans un projet qui contient une instance du type <xref:System.Windows.Forms.HtmlElement> nommé `HtmlElement1`. Puis vous assurer que le Gestionnaire d’événements est associé à la <xref:System.Windows.Forms.HtmlElement.MouseUp> événement.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'élément.</summary>
        <value>
          <see cref="T:System.String" /> représentant le nom de l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Windows.Forms.HtmlElement.Name%2A> propriété à récupérer des éléments à partir d’un document à l’aide la <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> méthode sur le <xref:System.Windows.Forms.HtmlElement.All%2A> propriété de <xref:System.Windows.Forms.HtmlDocument>.  
  
 Lorsqu’il est appliqué à `INPUT` éléments, <xref:System.Windows.Forms.HtmlElement.Name%2A> définit le nom de variable pour les données de cet élément lorsque son formulaire est envoyé au serveur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’élément suivant situé au même niveau que cet élément dans l’arborescence du document.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> représentant l'élément à droite de l'élément actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> conjointement avec <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> pour parcourir l’arborescence de document d’un élément HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément à partir duquel <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> est calculé.</summary>
        <value>Élément à partir duquel les décalages sont calculés.  
  
Si le parent d'un élément ou un autre élément dans la hiérarchie de l'élément utilise le positionnement relatif ou absolu, <see langword="OffsetParent" /> est le premier élément positionné de façon relative ou absolue dans lequel l'élément actuel est imbriqué. Si aucun des éléments situés au-dessus de l’élément actuel n’est positionné de façon relative ou absolue, <see langword="OffsetParent" /> sera le <c>corps</c> balise du document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments peuvent être positionnés sur une page HTML de trois manières : par défaut le positionnement du flux ; positionnement relatif, dans lequel l’élément est compensée par une quantité fixe par rapport à son parent ; et le positionnement absolu, dans lequel l’élément est donné fixe coordonner la position par rapport à l’angle supérieur gauche du document.  
  
 Lorsque les éléments d’un document utilisent le positionnement relatif ou absolu, vous pouvez utiliser `OffsetParent` pour calculer la position des coordonnées d’un élément dans la zone cliente.  
  
 Pour plus d’informations sur l’élément de positionnement en HTML, consultez [sur positionnement d’un élément](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> et <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> diffèrent pour `span1`, `span2` et `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'emplacement d'un élément par rapport à son parent.</summary>
        <value>Positions des coordonnées x et y de l'élément, ainsi que sa largeur et sa hauteur, par rapport à son parent.  
  
Si le parent d'un élément est positionné de façon relative ou absolue, <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> retourne le décalage de l'élément parent. Si l'élément lui-même est positionné de façon relative par rapport à son parent, <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> retourne le décalage à partir de son parent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments peuvent être positionnés sur une page HTML de trois manières :  
  
-   Positionnement de flux par défaut.  
  
-   Positionnement relatif, dans lequel l’élément est compensée par une quantité fixe par rapport à son parent.  
  
-   Le positionnement absolu, dans lequel l’élément est donné fixe coordonner la position par rapport à l’angle supérieur gauche du document.  
  
 Pour plus d’informations sur l’élément de positionnement en HTML, consultez [sur positionnement d’un élément](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> et <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> diffèrent pour `span1`, `span2` et `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Première <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Deuxième <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Compare deux éléments pour déterminer s'ils sont égaux.</summary>
        <returns>
          <see langword="true" /> si les deux paramètres sont <see langword="null" /> ou si les deux éléments ont la même interface COM sous-jacente ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’opérateur d’égalité teste le `IUnknown` pointeurs des objets COM sous-jacent encapsulés par fourni <xref:System.Windows.Forms.HtmlElement> classes.  
  
 La méthode équivalente pour cet opérateur est <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Première <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Deuxième <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Compare deux objets <see cref="T:System.Windows.Forms.HtmlElement" /> pour déterminer s'ils sont différents.</summary>
        <returns>
          <see langword="true" /> si un seul élément est <see langword="null" /> ou si les deux objets ne sont pas égaux ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[La méthode équivalente pour cet opérateur est la négation du <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le code HTML de l'élément actuel.</summary>
        <value>Code HTML pour l'élément actuel et ses enfants.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tandis que <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> retourne tout le HTML contenu dans l’élément actuel à l’exclusion des balises entourent l’élément actuel, <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> inclut la balise de l’élément actuel, ainsi que le code HTML qui contient des balises, par exemple :  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 Dans cet exemple, l’appel <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> sur `div2` renvoie :  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 L’appel <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> retourne :  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Si vous attribuez une nouvelle valeur à <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, la référence d’élément actuel devient non valide ; il ne reflète pas le nom, contenu de propriétés et les enfants du code HTML que vous avez juste affecté.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le texte de l'élément actuel.</summary>
        <value>Texte contenu dans l'élément actuel et dans les enfants de l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous essayez d’assigner du HTML à un élément avec <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, le code HTML s’affiche en tant que littéraux dans le document, comme si vous visualisiez du HTML dans un fichier texte. Si vous assignez du HTML à un élément avec la <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> propriété, <xref:System.Windows.Forms.HtmlElement.OuterText%2A> renvoie tout le texte dans la mesure HTML avec le balisage est supprimé.  
  
 Affectez une valeur à <xref:System.Windows.Forms.HtmlElement.OuterText%2A> détruira les éléments enfants qui appartiennent à l’élément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Vous ne pouvez pas définir du texte en dehors de cet élément.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'élément parent de l'élément actuel.</summary>
        <value>Élément situé au-dessus de l'élément actuel dans la hiérarchie du document HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Forms.HtmlElement.Parent%2A> propriété permet la découverte du contexte d’un élément. Il est très utile dans les gestionnaires d’événements tels que <xref:System.Windows.Forms.HtmlElement.Click>, qui peut être activé pour n’importe quel élément n’importe où dans la hiérarchie du document objet.  
  
 Le <xref:System.Windows.Forms.HtmlElement.Parent%2A> propriété de l’élément HTML (en haut d’un document HTML) pointe vers lui-même. Si vous appelez <xref:System.Windows.Forms.HtmlElement.Parent%2A> à l’intérieur d’une boucle, vérifiez que la condition d’arrêt de la boucle compare le type de l’élément actuel et le type de la `Parent` propriété, sans quoi votre code peut s’exécuter une boucle infinie.  
  
   
  
## Examples  
 L’exemple de code suivant recherche tous les `IMG` dans un document et utilise le <xref:System.Windows.Forms.HtmlElement.Parent%2A> propriété pour tester si le `IMG` contient un lien hypertexte vers une autre page ; le code assigne l’URL à la `ALT` attribut de la `IMG`marquer, afin que les utilisateurs peuvent la souris sur l’image pour voir où il mène.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Nom de l'événement à déclencher.</param>
        <summary>Provoque l'appel de tous les gestionnaires d'événements enregistrés par l'événement nommé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est utilisée pour accéder aux événements du modèle DOM (Document objet Model) HTML. Elle appelle directement la [IHTMLElement3::fireEvent](http://go.microsoft.com/fwlink/?LinkId=103189) (méthode). Pour plus d’informations sur l’utilisation du modèle DOM via le <xref:System.Windows.Forms.HtmlElement> de classe, consultez [l’accès à des membres non exposés sur le modèle objet de Document géré du HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime le focus de l'élément actuel, si cet élément a le focus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’appel à cette méthode déclenche la <xref:System.Windows.Forms.HtmlElement.LostFocus> événement pour l’élément.  
  
 Lorsque le focus est désactivé à partir d’un élément à l’aide de cette méthode, il est donné au document contenant l’élément, pas à l’élément suivant dans l’ordre de tabulation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Si <see langword="true" />, le haut de l'objet est affiché en haut de la fenêtre. Si <see langword="false" />, le bas de l'objet est affiché en bas de la fenêtre.</param>
        <summary>Fait défiler le document qui contient cet élément jusqu'à ce que le bord supérieur ou inférieur de cet élément soit aligné avec la fenêtre du document.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant recherche un élément par nom et fait défiler la page afin que le haut de l’élément est aligné avec le bord supérieur de la page visible.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la distance entre le bord de l'élément et le bord gauche de son contenu.</summary>
        <value>Distance, en pixels, entre le bord gauche de l'élément et le bord gauche de son contenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les dimensions complètes de la zone de défilement sont disponibles à l’aide <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` et <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> sont exposées indépendamment, car ce sont les seuls deux propriétés de la zone de défilement que les développeurs peuvent définir.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les dimensions de la région défilante d'un élément.</summary>
        <value>La taille et l'emplacement de coordonnée de la zone défilante d'un élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un élément aura une région défilante si son contenu dépasse la taille de ses dimensions, à moins que le style de dépassement de capacité sur l’élément interdit les barres de défilement de rendu.  
  
 Vous ne pouvez pas modifier directement la taille de la zone de défilement, mais vous pouvez modifier la distance entre les bords de la zone de défilement et les bords de l’élément. Utilisez le <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> et <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> propriétés pour y parvenir.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la distance entre le bord de l'élément et le bord supérieur de son contenu.</summary>
        <value>Distance, en pixels, entre le bord supérieur de l'élément et le bord supérieur de son contenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les dimensions complètes de la zone de défilement sont disponibles à l’aide <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> et `ScrollTop` sont exposées indépendamment, car ce sont les seuls deux propriétés de la zone de défilement que les développeurs peuvent définir.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nom de l'attribut à définir.</param>
        <param name="value">Nouvelle valeur de cet attribut.</param>
        <summary>Définit la valeur de l'attribut nommé sur l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un attribut au format HTML est une paire nom-valeur valide pour cet élément. <xref:System.Windows.Forms.HtmlElement> expose uniquement les attributs qui sont communes à tous les éléments, en laissant ceux qui s’appliquent uniquement à certains types d’éléments ; `SRC` est un attribut prédéfini pour le `IMG` de balise, par exemple, mais pas pour le `DIV` balise. Utilisez <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> et <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> pour manipuler des attributs non exposés sur le managé modèle DOM (Document Object).  
  
 Si `attributeName` n’est pas un attribut défini sur un élément, <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> définit sur l’élément en tant qu’un nouvel attribut.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> et <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> respectent la casse.  
  
 Pour définir le `class` attribut sur une <xref:System.Windows.Forms.HtmlElement> , vous devez faire référence à l’attribut en tant que `className` lorsque vous spécifiez le premier argument de <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 L’exemple de code suivant ajoute un nouveau `IMG` élément actuel de documents, à l’aide de <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> pour définir le `SRC` attribut pour l’image.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une liste délimitée par des virgules de styles pour l'élément actuel.</summary>
        <value>Chaîne constituée de tous les styles de l'élément</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le Document objet Model (DOM) utilise des styles tel que défini dans la spécification du World Wide Web Consortiums Cascading Style Sheets pour contrôler l’affichage d’un élément. Définit le style de la <xref:System.Windows.Forms.HtmlElement.Style%2A> propriété prennent la forme de paires nom-valeur délimitée par des deux-points, chaque paire étant séparés par un point-virgule, comme suit :  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Pour définir la police pour un `DIV` élément à 14 points Times New Roman gras, vous serez par exemple, affectez la chaîne suivante :  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Pour obtenir une liste complète de tous les styles disponibles dans le DOM HTML, consultez [attribut de STYLE](http://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'emplacement de cet élément dans l'ordre de tabulation.</summary>
        <value>Index numérique de l'élément dans l'ordre de tabulation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> détermine quel élément dans un document HTML reçoit ensuite le focus lorsque l’utilisateur appuie sur la touche TAB. Par défaut, les seuls éléments inclus dans l’ordre de tabulation sont `INPUT` éléments, le `SELECT` contrôle et n’importe quel élément dont `contentEditable` propriété est définie sur `true`. Vous pouvez inclure n’importe quel élément HTML dans l’ordre de tabulation, comme un `DIV`, en lui assignant explicite <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>.  
  
 Les valeurs valides pour <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> comprises entre-32767 et 32767.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de l’étiquette HTML.</summary>
        <value>Nom utilisé pour créer cet élément à l'aide du balisage HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nombre d’éléments dans le modèle d’objet de Document HTML ont des attributs, propriétés et méthodes qui sont uniques à ces éléments ; comme le `HREF` d’attribut sur le `A` élément, ou le `Submit` méthode sur `FORM`. Utilisez <xref:System.Windows.Forms.HtmlElement.TagName%2A> lorsque vous avez un élément d’un type potentiellement arbitraire et que vous avez besoin effectuer une opération spécifique au type.  
  
   
  
## Examples  
 L’exemple de code suivant recherche tous les `IMG` dans un document et utilise le `TagName` propriété pour tester si le `IMG` contient un lien hypertexte vers une autre page ; le code assigne l’URL à la `ALT` attribut de la `IMG`marquer, afin que les utilisateurs peuvent la souris sur l’image pour voir où il mène.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>