<Type Name="ReservationCollection" FullName="System.IO.Log.ReservationCollection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0538791316db2eba28cb8bcfa09bf2da24805dea" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064886" /></Metadata><TypeSignature Language="C#" Value="public abstract class ReservationCollection : System.Collections.Generic.ICollection&lt;long&gt;, System.Collections.Generic.IEnumerable&lt;long&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ReservationCollection extends System.Object implements class System.Collections.Generic.ICollection`1&lt;int64&gt;, class System.Collections.Generic.IEnumerable`1&lt;int64&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Log.ReservationCollection" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ReservationCollection&#xA;Implements ICollection(Of Long), IEnumerable(Of Long)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReservationCollection abstract : System::Collections::Generic::ICollection&lt;long&gt;, System::Collections::Generic::IEnumerable&lt;long&gt;" />
  <TypeSignature Language="F#" Value="type ReservationCollection = class&#xA;    interface ICollection&lt;int64&gt;&#xA;    interface seq&lt;int64&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Log</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Gère la collection de réservations d'espace faites dans une séquence d'enregistrement.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La classe représente un jeu des zones de réservation établies dans une séquence d'enregistrements. L'ajout d'éléments à la collection alloue de nouvelles réservations. La suppression d’éléments de la collection libère ces réservations.  
  
 Une application réserve l'espace dans le journal lorsqu'elle possède des données à écrire ultérieurement dans le journal, mais ne peut pas les écrire immédiatement. Les réservations offrent la garantie que les données pourront être écrites dans le journal lorsqu'elles seront disponibles pour être écrites. Lorsque vous utilisez des journaux, les applications réservent souvent un ou plusieurs enregistrements de journal dans une zone de marshaling. Vous devez réserver des enregistrements avant de les ajouter.  
  
 Les réservations peuvent être utilisées pour garantir qu’une opération peut être effectuée avant que les données soient validées ; si tel n’est pas le cas, les modifications sont restaurées. Elles peuvent servir à enregistrer une « opération d'annulation » dans le journal. Pendant une opération de restauration, un gestionnaire de ressources de transaction (RM) doit être capable de restaurer son état en cas d’interruption du RM pendant l’opération de restauration. En se servant d'une zone de réservation, un RM peut réserver de l'espace dans un journal avant qu'il soit utilisé.  
  
 La méthode <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> peut réserver l'espace, ajouter des données, ou les deux, suivant les paramètres spécifiés au moment de l'appel. À mesure que le travail progresse dans une transaction, une application peut ajouter les informations d'annulation et réserver l'espace pour les enregistrements de compensation. Pendant une opération de restauration, les enregistrements de compensation qui sont créés indiquent ce qui a été annulé sur le disque. Les enregistrements sont ajoutés à l'aide de l'espace préalablement réservé. Ce système garantit qu'un RM ne manque pas d'espace de journal, ce qui équivaut à une condition fatale, en cours d'opération de restauration. Si un journal se remplit complètement pendant une transaction, une application peut restaurer sans risque une transaction sans endommager de données durables.  
  
 CLFS est un système de journalisation de type ARIES, conçu pour la journalisation WAL (write-ahead log). Dans la journalisation WAL, une application inscrit une opération d'annulation avant de la réaliser, réservant l'espace qu'elle occupe dans le journal pour inscrire un enregistrement de compensation, qui peut servir lors d'une restauration. L'espace réservé est ensuite utilisé lorsque l'enregistrement de compensation est effectivement écrit.  
  
 Les applications peuvent soit réserver, soit accéder à, un espace conséquent à tout moment (ces opérations sont mutuellement exclusives). Lorsqu’un enregistrement de validation est écrit dans le journal, une application peut libérer les réservations faites pour les enregistrements de compensation. Cette action peut se faire en appelant la méthode <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> ou <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>. Appeler la méthode <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A> garantit que l'opération est atomique, ce que ne fait pas la méthode <xref:System.IO.Log.ReservationCollection.FreeReservation%2A>.  
  
 Lorsque vous libérez des enregistrements, vous devez libérer les mêmes enregistrements que vous avez réservés ensemble dans un appel précédent à la méthode <xref:System.IO.Log.IRecordSequence.ReserveAndAppend%2A>.  
  
> [!NOTE]
>  Votre implémentation de <xref:System.IO.Log.IRecordSequence> doit implémenter les méthodes <xref:System.IO.Log.ReservationCollection.MakeReservation%2A> et <xref:System.IO.Log.ReservationCollection.FreeReservation%2A> pour effectuer l'allocation et la désallocation effectives des réservations. De plus, votre implémentation doit également appeler <xref:System.IO.Log.ReservationCollection.ReservationFreed%2A> lorsqu'un enregistrement est écrit dans un espace réservé.  
  
   
  
## Examples  
 Les réservations peuvent être exécutées de deux manières, comme le montrent les exemples suivants. Vous pouvez adopter ces pratiques dans les exemples pour un traitement fiable. Notez que cette tâche ne peut être effectuée que lors de l’utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.  
  
```  
//Using the ReserveAndAppend Method  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
long[] lengthOfUndoRecords = new long[] { 1000 };  
recordSequence.ReserveAndAppend(recordData,  
                                                     userSqn,  
                                                     previousSqn,  
                                                     RecordSequenceAppendOptions.None,  
                                                     reservations,  
                                                     lengthOfUndoRecords);  
recordSequence.Append(undoRecordData,    // If necessary …  
                                    userSqn,  
                                    previousSqn,  
                                    RecordSequenceAppendOptions.ForceFlush,  
                                    reservations);  
  
// Using the Manual Approach  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ReservationCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.IO.Log.ReservationCollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Add(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(long size);" />
      <MemberSignature Language="F#" Value="abstract member Add : int64 -&gt; unit&#xA;override this.Add : int64 -&gt; unit" Usage="reservationCollection.Add size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille, en octets, de la réservation demandée.</param>
        <summary>Alloue une réservation et l’ajoute à la collection. Cette méthode ne peut pas être héritée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant décrit la procédure de réservation manuelle. Notez que cette tâche ne peut être effectuée que lors de l’utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="archiveTail" /> n'est pas compris entre le numéro de base et le dernier numéro de la séquence.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="size" /> n'est pas valide ou dépasse la taille de réservation maximale.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="reservationCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les réservations dans la collection. Cette méthode ne peut pas être héritée.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="size" /> n'est pas valide ou dépasse la taille de réservation maximale.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Contains(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (size As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(long size);" />
      <MemberSignature Language="F#" Value="abstract member Contains : int64 -&gt; bool&#xA;override this.Contains : int64 -&gt; bool" Usage="reservationCollection.Contains size" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille à localiser dans la collection.</param>
        <summary>Détermine si une réservation de la taille spécifiée a été faite. Cette méthode ne peut pas être héritée.</summary>
        <returns><see langword="true" /> si au moins une réservation de la taille spécifiée a été faite ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (long[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(int64[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.CopyTo(System.Int64[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As Long(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;long&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : int64[] * int -&gt; unit&#xA;override this.CopyTo : int64[] * int -&gt; unit" Usage="reservationCollection.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Int64[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau de destination de la copie.</param>
        <param name="arrayIndex">Index de base zéro dans le tableau au niveau duquel commencer la copie.</param>
        <summary>Copie l’ensemble de la collection dans un tableau à une dimension, en démarrant à l’index spécifié du tableau cible. Cette méthode ne peut pas être héritée.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> ou <paramref name="arrayIndex" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> est inférieur à zéro, ou supérieur ou égal à la longueur de <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">Il n'y a pas suffisamment d'espace dans le tableau spécifié pour copier les données.  
  
ou 
 <paramref name="array" /> n'est pas un tableau unidimensionnel, qui est le seul type de tableau pris en charge pour l'action demandée.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.IO.Log.ReservationCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de réservations dans la collection.</summary>
        <value>Nombre de réservations dans la collection.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReservationCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReservationCollection ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="reservationCollection.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet au <see cref="T:System.IO.Log.ReservationCollection" /> de libérer des ressources avant d’être détruit par le garbage collector.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeReservation">
      <MemberSignature Language="C#" Value="protected abstract void FreeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FreeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.FreeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub FreeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void FreeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member FreeReservation : int64 -&gt; unit" Usage="reservationCollection.FreeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille de la réservation à libérer.</param>
        <summary>En cas de substitution dans une classe dérivée, libère une réservation de la taille spécifiée.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de <see cref="T:System.IO.Log.ReservationCollection" />, vous devez implémenter cette méthode pour libérer effectivement l’espace dans la séquence d’enregistrement. Vous ne devez pas appeler <see cref="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" /> à la fin de la méthode ; cette logique est prise en charge pour vous.  
  
Lorsque vous libérez des enregistrements, vous devez libérer les mêmes enregistrements que vous avez réservés ensemble dans un appel précédent à la méthode <see cref="Overload:System.IO.Log.IRecordSequence.ReserveAndAppend" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetBestMatchingReservation">
      <MemberSignature Language="C#" Value="protected long GetBestMatchingReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int64 GetBestMatchingReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetBestMatchingReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetBestMatchingReservation (size As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; long GetBestMatchingReservation(long size);" />
      <MemberSignature Language="F#" Value="member this.GetBestMatchingReservation : int64 -&gt; int64" Usage="reservationCollection.GetBestMatchingReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille de la réservation qui doit être accommodée.</param>
        <summary>En cas de substitution dans une classe dérivée, reçoit la meilleure réservation correspondante pour une taille donnée.</summary>
        <returns>Une réservation de la collection qui est supérieure ou égale à la taille spécifiée, ou -1 si aucune réservation de ce type n’existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est généralement appelée lors de l'ajout d'un enregistrement d'un espace réservé à une séquence d'enregistrement. À son retour, une réservation de la taille retournée a été supprimée de la collection. Si, pour quelque raison que ce soit, l'espace réservé n'est pas accédé, la méthode <xref:System.IO.Log.ReservationCollection.ReservationMade%2A> doit être appelée pour s'assurer que <xref:System.IO.Log.ReservationCollection> représente fidèlement l'espace réservé dans la séquence d'enregistrement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;long&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;int64&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerator&lt;long&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;&#xA;override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;int64&gt;" Usage="reservationCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur capable d'itérer au sein de <see cref="T:System.IO.Log.ReservationCollection" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Énumérateur capable d'itérer au sein de <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'opération n'est pas valide pour l'une des raisons suivantes : 
- L’énumération est terminée.  
  
- La collection a été modifiée.  
  
- L’énumération n’a pas encore  démarré. Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.IO.Log.ReservationCollection.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la collection est en lecture seule.</summary>
        <value>Cette propriété retourne toujours <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Log.ReservationCollection> n'est jamais en lecture seule.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReservation">
      <MemberSignature Language="C#" Value="protected abstract void MakeReservation (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void MakeReservation(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.MakeReservation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub MakeReservation (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void MakeReservation(long size);" />
      <MemberSignature Language="F#" Value="abstract member MakeReservation : int64 -&gt; unit" Usage="reservationCollection.MakeReservation size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille de la réservation à allouer.</param>
        <summary>En cas de substitution dans une classe dérivée, alloue une réservation de la taille spécifiée.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Lorsque vous héritez de <see cref="T:System.IO.Log.ReservationCollection" />, vous devez implémenter cette méthode pour réserver effectivement l'espace dans la séquence d'enregistrement. Vous ne devez pas appeler <see cref="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" /> à la fin de la méthode ; cette logique est prise en charge pour vous.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (long item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(int64 item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.Remove(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(long item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : int64 -&gt; bool&#xA;override this.Remove : int64 -&gt; bool" Usage="reservationCollection.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="item">Taille de la réservation à libérer.</param>
        <summary>Libère une réservation de la taille spécifiée, s’il en existe. Cette méthode ne peut pas être héritée.</summary>
        <returns><see langword="true" /> si une réservation de la taille spécifiée a été trouvée et supprimée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant décrit la procédure de réservation manuelle. Notez que cette tâche ne peut être effectuée que lors de l’utilisation de la classe <xref:System.IO.Log.LogRecordSequence> basée sur un système CLFS.  
  
```  
ReservationCollection reservations = recordSequence.CreateReservationCollection();  
reservations.Add(lengthOfUndoRecord);  
try  
{  
   recordSequence.Append(recordData, userSqn, previousSqn, RecordAppendOptions.None);  
}  
catch (Exception)  
{  
   reservations.Remove(lengthOfUndoRecord);  
   throw;  
}  
  
recordSequence.Append(undoRecordData, userSqn, previousSqn, RecordAppendOptions.ForceFlush, reservations);  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Aucune réservation de taille suffisante pour accommoder l’enregistrement fourni ne se trouve dans la collection de réservations spécifiée.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S se produit lors de la création de l'instantané de l'archive.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.IO.Log.SequenceFullException">La séquence d'enregistrement est complète.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReservationFreed">
      <MemberSignature Language="C#" Value="protected void ReservationFreed (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationFreed(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationFreed(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationFreed (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationFreed(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationFreed : int64 -&gt; unit" Usage="reservationCollection.ReservationFreed size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille de la réservation qui a été libérée.</param>
        <summary>En cas de substitution dans une classe dérivée, indique qu’une réservation a été libérée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous héritez de <xref:System.IO.Log.ReservationCollection>, vous devez appeler cette méthode lorsqu'une réservation est libérée pour une raison autre que sa suppression de la collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReservationMade">
      <MemberSignature Language="C#" Value="protected void ReservationMade (long size);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReservationMade(int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.ReservationMade(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReservationMade (size As Long)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReservationMade(long size);" />
      <MemberSignature Language="F#" Value="member this.ReservationMade : int64 -&gt; unit" Usage="reservationCollection.ReservationMade size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="size">Taille de la réservation qui a été faite.</param>
        <summary>En cas de substitution dans une classe dérivée, indique qu'une réservation a été faite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous héritez de <xref:System.IO.Log.ReservationCollection>, vous devez appeler cette méthode si une réservation s'effectue sans appel à <xref:System.IO.Log.ReservationCollection.Add%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Log.ReservationCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IO.Log</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur capable d'itérer au sein de <see cref="T:System.IO.Log.ReservationCollection" />. Cette méthode ne peut pas être héritée.</summary>
        <returns>Énumérateur capable d'itérer au sein de <see cref="T:System.IO.Log.ReservationCollection" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">L'opération n'est pas valide pour l'une des raisons suivantes : 
- L’énumération est terminée.  
  
- La collection a été modifiée.  
  
- L’énumération n’a pas encore  démarré. Un appel à <see cref="M:System.Collections.IEnumerator.MoveNext" /> doit être fait.</exception>
        <exception cref="T:System.ObjectDisposedException">La méthode a été appelée après la suppression de la séquence.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire disponible n'est pas suffisante pour continuer l'exécution du programme.</exception>
        <exception cref="T:System.UnauthorizedAccessException">L'accès pour le magasin de journaux spécifié est refusé par le système d'exploitation.</exception>
      </Docs>
    </Member>
  </Members>
</Type>