<Type Name="XamlType" FullName="System.Xaml.XamlType">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5f660970c55af6a8e8be700e1df5ac2c266d1596" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52254546" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlType : IEquatable&lt;System.Xaml.XamlType&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlType extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlType&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlType" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlType&#xA;Implements IEquatable(Of XamlType)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlType : IEquatable&lt;System::Xaml::XamlType ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlType = class&#xA;    interface IEquatable&lt;XamlType&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlType&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Signale les informations relatives aux types XAML dans le cadre du système XAML général implémenté dans les services XAML .NET Framework.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De nombreuses API dans le <xref:System.Xaml.XamlType> classe fournissent des informations sur les types XAML, où le concept signalé est semblable aux sections particulières de la spécification XAML [MS-XAML].  
  
 <xref:System.Xaml.XamlType> est largement utilisé dans l’API de Services XAML .NET Framework pour les informations de rapport sur un type XAML. <xref:System.Xaml.XamlType> signale les informations que vous devrez peut-être savoir sur un type XAML pour pouvoir fonctionner avec une instance ou pour accéder à ses membres à partir d’un flux de nœud XAML, ou une représentation XAML semblable. Sa création de rapport est similaire à la façon dont le <xref:System.Type> dans le CLR système de type, ainsi que des classes de réflexion comme <xref:System.Reflection.MemberInfo>, fournissent des informations sur un type CLR et de son utilisation.  
  
 Pour étendre le système de type XAML, vous pouvez dériver de <xref:System.Xaml.XamlType>. Pour effectuer cette opération efficacement, vous devrez peut-être également implémenter un <xref:System.Xaml.Schema.XamlTypeInvoker>. Le <xref:System.Xaml.Schema.XamlTypeInvoker> permet au système de type XAML généralisé travailler avec le système de type stockage que vous spécifiez en tant que partie du comportement d’appel. Personnalisé spécifique <xref:System.Xaml.Schema.XamlTypeInvoker> offre un moyen de réduire les dépendances sur le système de type CLR, qui sont utilisés par la valeur par défaut <xref:System.Xaml.XamlType> comportement.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlType" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="underlyingType">
          <see cref="T:System.Type" /> CLR sous-jacent pour le type XAML à construire.</param>
        <param name="schemaContext">Contexte de schéma XAML pour les lecteurs XAML ou les writers XAML.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlType" /> en fonction des informations de type CLR sous-jacentes.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs <paramref name="underlyingType" /> ou <paramref name="schemaContext" /> sont <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XamlType (string typeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string typeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (typeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XamlType(System::String ^ typeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (typeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type à créer.</param>
        <param name="typeArguments">Arguments de type pour un <see cref="T:System.Xaml.XamlType" /> qui représente un type générique. Peut être (et est souvent) <see langword="null" />, ce qui indique que le type représenté n'est pas un type générique.</param>
        <param name="schemaContext">Contexte de schéma XAML pour les lecteurs XAML et les writers XAML.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlType" /> basée sur un nom de chaîne pour le type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s'agit d'un constructeur protégé. Aucune classe dérivée publique actuelle n’existe qui utilisent ce chemin d’accès particulier pour la construction. En tant que consommateur existants <xref:System.Xaml.XamlType>, vous devez utiliser les autres signatures de constructeur (<xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%2CSystem.Xaml.Schema.XamlTypeInvoker%29>, <xref:System.Xaml.XamlType.%23ctor%28System.Type%2CSystem.Xaml.XamlSchemaContext%29>, ou <xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29>) pour initialiser un <xref:System.Xaml.XamlType> objet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs <paramref name="typeName" /> ou <paramref name="schemaContext" /> sont <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (Type underlyingType, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlTypeInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type underlyingType, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlTypeInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.Type,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlTypeInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (underlyingType As Type, schemaContext As XamlSchemaContext, invoker As XamlTypeInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(Type ^ underlyingType, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlTypeInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : Type * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlTypeInvoker -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (underlyingType, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="underlyingType" Type="System.Type" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlTypeInvoker" />
      </Parameters>
      <Docs>
        <param name="underlyingType">Type CLR sous-jacent pour le type XAML à construire.</param>
        <param name="schemaContext">Contexte de schéma XAML pour le lecteur XAML.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlType" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlType" /> basée sur les informations de type sous-jacentes, ainsi qu'une implémentation de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs <paramref name="underlyingType" /> ou <paramref name="schemaContext" /> sont <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlType (string unknownTypeNamespace, string unknownTypeName, System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; typeArguments, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string unknownTypeNamespace, string unknownTypeName, class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; typeArguments, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.#ctor(System.String,System.String,System.Collections.Generic.IList{System.Xaml.XamlType},System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (unknownTypeNamespace As String, unknownTypeName As String, typeArguments As IList(Of XamlType), schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlType(System::String ^ unknownTypeNamespace, System::String ^ unknownTypeName, System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ typeArguments, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlType : string * string * System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlType" Usage="new System.Xaml.XamlType (unknownTypeNamespace, unknownTypeName, typeArguments, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="unknownTypeNamespace" Type="System.String" />
        <Parameter Name="unknownTypeName" Type="System.String" />
        <Parameter Name="typeArguments" Type="System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="unknownTypeNamespace">Espace de noms XAML du type, sous forme de chaîne.</param>
        <param name="unknownTypeName">Nom du type dans l'espace de noms XAML <paramref name="unknownTypeNamespace" /> fourni.</param>
        <param name="typeArguments">Arguments de type pour un <see cref="T:System.Xaml.XamlType" /> qui représente un type générique. Peut être (et est souvent) <see langword="null" />, ce qui indique que le type représenté n'est pas un type générique.</param>
        <param name="schemaContext">Contexte de schéma XAML pour les lecteurs XAML ou les writers XAML.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlType" /> basée sur l'espace de noms XAML et un nom de chaîne pour le type. Ce constructeur est exclusivement destiné à des fins d'analyse et d'enregistrement de nœuds XAML de types réputés pour ne pas avoir de stockage dans le système de type et le contexte de schéma XAML de prise en charge.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur uniquement pour les types « inconnus », où un type XAML qui mappe à un système de type sous-jacent n’est pas disponible. Ce constructeur ne peut pas produire de résultat où <xref:System.Xaml.XamlType.IsUnknown%2A?displayProperty=nameWithType> est `true`. Au lieu de cela, la logique de réflecteur par défaut signale le type sous-jacent que <xref:System.Xaml.XamlLanguage.Object%2A?displayProperty=nameWithType>. Toutefois, ce comportement peut changer raison de la <xref:System.Xaml.XamlType.LookupIsUnknown%2A> remplacer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Un ou plusieurs <paramref name="unknownTypeNamespace" />, <paramref name="unknownTypeName" /> ou <paramref name="schemaContext" /> sont <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowedContentTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; AllowedContentTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; AllowedContentTypes" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.AllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllowedContentTypes As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ AllowedContentTypes { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowedContentTypes : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.AllowedContentTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection en lecture seule des types utilisables comme valeur <see cref="P:System.Xaml.XamlType.ContentProperty" /> pour ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Collection en lecture seule des types de contenu possibles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Types qui peuvent être assignés un type de contenu spécifique (par exemple un type de base qui est un type de contenu autorisé) ne sont pas considérés comme plusieurs types à des fins de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupAllowedContentTypes%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ BaseType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type de base immédiat de ce type XAML. La détermination de cette valeur dépend du type sous-jacent de ce <see cref="T:System.Xaml.XamlType" /> et du contexte de schéma.</summary>
        <value>
          <see cref="T:System.Xaml.XamlType" /> du type de base immédiat de ce type XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupBaseType%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupBaseType%2A> sur ce type. Par défaut, <xref:System.Xaml.XamlType.BaseType%2A> retourne une constante interne qui représente un <xref:System.Object> si <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les informations de type signalées concernant un type XAML afin qu’il ne s’aligne plus comme prévu avec les informations de système de type de son type CLR sous-jacent. Pour les vérifications critiques de sécurité des opérations d’assignation et l’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanAssignTo">
      <MemberSignature Language="C#" Value="public virtual bool CanAssignTo (System.Xaml.XamlType xamlType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanAssignTo(class System.Xaml.XamlType xamlType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.CanAssignTo(System.Xaml.XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanAssignTo(System::Xaml::XamlType ^ xamlType);" />
      <MemberSignature Language="F#" Value="abstract member CanAssignTo : System.Xaml.XamlType -&gt; bool&#xA;override this.CanAssignTo : System.Xaml.XamlType -&gt; bool" Usage="xamlType.CanAssignTo xamlType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType">Type avec lequel comparer le <see cref="T:System.Xaml.XamlType" /> actuel.</param>
        <summary>Retourne une valeur qui indique si une instance de ce <see cref="T:System.Xaml.XamlType" /> a le <see cref="T:System.Xaml.XamlType" /> spécifié dans sa liste de types assignables.</summary>
        <returns>
          <see langword="true" /> si <paramref name="xamlType" /> figure dans la liste des types assignables ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le type peut être assigné n’a pas de toutes les fonctionnalités du type référence, vous pouvez l’utiliser pour l’attribution. Par exemple, vous pouvez utiliser l’attribution pour établir des correspondances de type pour les valeurs d’une propriété. Le concept de types assignables dans XAML est similaire au concept de cast ascendant dans le système de type CLR. Par exemple, sous un système de type CLR, chaque type a un <xref:System.Object> dans sa liste des types assignables.  
  
 Si l’un des deux <xref:System.Xaml.XamlType> aux instances qui sont utilisées pour la comparaison a <xref:System.Xaml.XamlType.IsUnknown%2A> égal à `true`, cette méthode a un mode inconnu qui retourne `true` si les deux <xref:System.Xaml.XamlType> instances sont équivalentes.  
  
 L’implémentation par défaut utilise le CLR <xref:System.Type> de <xref:System.Xaml.XamlType.UnderlyingType%2A> pour ce <xref:System.Xaml.XamlType> et l’entrée <xref:System.Xaml.XamlType>et les appels <xref:System.Type.IsAssignableFrom%2A>. Substituez cette méthode si vous souhaitez une détermination différente des types assignables.  
  
 En passant une valeur null `xamlType` ne lève pas d’exception et retourne toujours `false`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.CanAssignTo%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier la possibilité d’assignation d’un type XAML afin qu’il ne s’aligne plus comme prévu avec le comportement de conversion de type de son type CLR sous-jacent. Pour les vérifications critiques de sécurité des opérations d’assignation et l’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="public bool ConstructionRequiresArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ConstructionRequiresArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConstructionRequiresArguments As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ConstructionRequiresArguments { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ConstructionRequiresArguments : bool" Usage="System.Xaml.XamlType.ConstructionRequiresArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> doit avoir des arguments (contraintes génériques par <see langword="x:TypeArguments" />, texte d'initialisation ou d'autres techniques XAML) pour construire une instance valide du type.</summary>
        <value>
          <see langword="true" /> si la construction d'une instance requiert une valeur d'argument ; sinon,  <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupConstructionRequiresArguments%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember ContentProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlMember ContentProperty" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentProperty As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlMember ^ ContentProperty { System::Xaml::XamlMember ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentProperty : System.Xaml.XamlMember" Usage="System.Xaml.XamlType.ContentProperty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les informations <see cref="T:System.Xaml.XamlMember" /> de la propriété de contenu de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Informations <see cref="T:System.Xaml.XamlMember" /> de la propriété de contenu de ce <see cref="T:System.Xaml.XamlType" />. Peut être <see langword="null" /> en l'absence de propriété de contenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand à l’aide de la liaison ou du stockage du système de type CLR, la propriété de contenu XAML peut être spécifiée sur un type en appliquant <xref:System.Windows.Markup.ContentPropertyAttribute> à la définition de type.  
  
 Cette propriété s’aligne sur le `[content property]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupContentProperty%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupContentProperty%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentWrappers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; ContentWrappers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; ContentWrappers" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContentWrappers As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ ContentWrappers { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ContentWrappers : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.ContentWrappers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les types utilisés pour inclure dans un wrapper le contenu d'une propriété de contenu en l'absence de correspondance de type stricte, telle que les chaînes dans un <see langword="Collection&lt;T&gt;" />fortement typé.</summary>
        <value>Collection en lecture seule des types de wrapper de contenu possibles ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 S’il n’y a pas de wrappers pour prendre en compte la correspondance de type assouplissant, cette propriété est `null`.  
  
 Les types qui sont évalués en <xref:System.Xaml.XamlType.CanAssignTo%2A> pour un type de contenu spécifique ne sont pas considérés comme plusieurs types à des fins de <xref:System.Xaml.XamlType.ContentWrappers%2A>.  
  
 Dans la liaison de CLR pour <xref:System.Xaml> et <xref:System.Xaml.XamlType>, le type de wrapper de contenu XAML peut être spécifié sur un type comme un <xref:System.Windows.Markup.ContentWrapperAttribute>.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupContentWrappers%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupContentWrappers%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlType.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui représente le comportement de conversion de chargement différé pour ce type.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> qui représente le comportement de conversion de chargement différé pour ce type.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comportement de modèle XAML dans WPF est un exemple de comportement de chargement différé.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupDeferringLoader%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlType.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
        <returns>
          <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="obj" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlType other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlType other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.Equals(System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlType ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlType -&gt; bool" Usage="xamlType.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
        <returns>
          <see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAliasedProperty">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="member this.GetAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Directive pour laquelle rechercher le membre ajouté en alias.</param>
        <summary>Retourne le membre XAML ajouté en alias à une directive XAML par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Membre ajouté en alias, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupAliasedProperty%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllAttachableMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllAttachableMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllAttachableMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection qui contient toutes les propriétés pouvant être attachées exposées par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Collection qui contient zéro ou plusieurs valeurs <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque <xref:System.Xaml.XamlMember> dans la collection retournée doit contenir des valeurs qui prennent en charge le concept qui le <xref:System.Xaml.XamlMember> est un membre pouvant être attaché. Par exemple, les membres doivent retourner `true` pour <xref:System.Xaml.XamlMember.IsAttachable%2A>, un type pour <xref:System.Xaml.XamlMember.TargetType%2A>, et ainsi de suite.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMembers">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt; GetAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class System.Xaml.XamlMember&gt; GetAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAllMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMembers () As ICollection(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;System::Xaml::XamlMember ^&gt; ^ GetAllMembers();" />
      <MemberSignature Language="F#" Value="member this.GetAllMembers : unit -&gt; System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.GetAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une collection qui contient tous les membres exposés par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Collection qui contient zéro ou plusieurs valeurs <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupAllMembers%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttachableMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre pouvant être attaché à obtenir, dans le formulaire <c>ownerTypeName.MemberName</c>.</param>
        <summary>Retourne un objet <see cref="T:System.Xaml.XamlMember" /> représentant un membre spécifiquement nommé pouvant être attaché de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Un objet <see cref="T:System.Xaml.XamlMember" /> pour le membre demandé pouvant être attaché ; sinon, <see langword="null" />, si aucun membre pouvant être attaché portant ce nom n’existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupAttachableMember%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les membres signalés d’un type XAML afin qu’ils n’alignent plus comme prévu avec le <xref:System.ComponentModel.TypeDescriptor> `Get*` plus d’informations sur le type CLR sous-jacent. Pour les vérifications critiques de sécurité du membre de création de rapports, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlType.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cet objet.</summary>
        <returns>Code de hachage entier.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlMember GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xaml.XamlMember GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xaml::XamlMember ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.GetMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre à obtenir (sous forme de chaîne).</param>
        <summary>Retourne un <see cref="T:System.Xaml.XamlMember" /> pour un membre nommé spécifique de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.XamlMember" /> du membre, si un membre de ce type a été trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de `name` est censée être non qualifié. Noms de type qualifié qui indiquent un membre attaché doivent être soumis à <xref:System.Xaml.XamlType.GetAttachableMember%2A> à la place. Le préfixe membre noms ne doivent pas être utilisées ; aucun préfixe n’est pas dépend d’une utilisation et le système de type XAML ne peut pas connaître le contexte d’une telle utilisation et la façon dont le préfixe est mappé.  
  
 Les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupMember%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les membres signalés d’un type XAML afin qu’ils n’alignent plus comme prévu avec le <xref:System.ComponentModel.TypeDescriptor> `Get*` plus d’informations sur le type CLR sous-jacent. Pour les vérifications critiques de sécurité du membre de création de rapports, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionalParameters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; GetPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; GetPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ GetPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="member this.GetPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.GetPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Nombre (arité) de la syntaxe ou du mode constructeur spécifique pour lequel ou laquelle vous voulez obtenir des informations.</param>
        <summary>Pour les types d'extension de balisage, retourne les types des paramètres positionnels pris en charge dans une utilisation de l'extension de balisage spécifique à ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Liste de valeurs <see cref="T:System.Xaml.XamlType" />, où chaque <see cref="T:System.Xaml.XamlType" /> correspond au type de cette position dans la syntaxe. Vous devez spécifier les types dans le même ordre lorsque vous fournissez l'entrée de balisage pour l'extension de balisage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette API est uniquement pertinente si ce <xref:System.Xaml.XamlType> représente une extension de balisage (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> est `true`).  
  
 L’entrée `parameterCount` n’est pas de demander le type d’un paramètre positionnel spécifique. Il sert à spécifier l’arité d’une extension de balisage. Extension de balisage souvent possède plusieurs « signatures » et utilise le paramètre différentes arité (nombre) de paramètres positionnels pour différencier. Toutefois, vous pouvez configurer un contexte de schéma pour autoriser arités en double et utiliser des types de paramètres positionnels de différenciation. Pour plus d'informations, consultez <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Pour une arité (nombre) spécifique, les positions des paramètres et les types peuvent varier. Pour obtenir le type de position de l’extension de balisage d’une arité spécifique, vous appelez d’abord <xref:System.Xaml.XamlType.GetPositionalParameters%2A> en spécifiant le nombre d’arité. Obtenez ensuite l’élément à cette position à partir de la collection retournée.  
  
 Les appels à cette méthode peuvent appeler <xref:System.Xaml.XamlType.LookupPositionalParameters%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlType.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste d'identificateurs de chaîne pour les espaces de noms XAML dans lesquels le type est inclus.</summary>
        <returns>Liste de valeurs de chaînes où chaque chaîne est l'identificateur URI d'un espace de noms XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificateurs d’espace de noms XAML standard sont des chaînes au format URI.  
  
 L’implémentation par défaut vérifie la commande suivante, dans l’ordre : l’espace de noms XAML qui est fourni dans la construction (<xref:System.Xaml.XamlType.%23ctor%28System.String%2CSystem.String%2CSystem.Collections.Generic.IList%7BSystem.Xaml.XamlType%7D%2CSystem.Xaml.XamlSchemaContext%29> signature uniquement) ; et les espaces de noms qui sont disponibles à partir du contexte de schéma. S’ils sont chacun `null`, une nouvelle liste est générée qui contient une chaîne vide unique. Vous pouvez remplacer cette méthode pour modifier la méthodologie de recherche.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlTypeInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlTypeInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlTypeInvoker ^ Invoker { System::Xaml::Schema::XamlTypeInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlTypeInvoker" Usage="System.Xaml.XamlType.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'implémentation de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> associée à ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Implémentation de <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> associée à ce <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, l’appel <xref:System.Xaml.XamlType.Invoker%2A> pouvez appeler soit <xref:System.Xaml.XamlType.LookupInvoker%2A> ou une substitution spécifique de cette méthode. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupInvoker%2A> sur ce type.  
  
 Si un <xref:System.Xaml.XamlType.LookupInvoker%2A> remplacer retourne `null`, ou si l’implémentation par défaut retourne `null` en raison du manque de <xref:System.Xaml.XamlType.UnderlyingType%2A> pour ce <xref:System.Xaml.XamlType>, puis <xref:System.Xaml.XamlType.Invoker%2A> retourne <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlType.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type ambiant, suivant la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type ambiant ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsAmbient%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsAmbient%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Xaml.XamlType.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un tableau.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un tableau ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupCollectionKind%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupCollectionKind%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollection">
      <MemberSignature Language="C#" Value="public bool IsCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollection : bool" Usage="System.Xaml.XamlType.IsCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une collection.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une collection ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupCollectionKind%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupCollectionKind%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructible">
      <MemberSignature Language="C#" Value="public bool IsConstructible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructible" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsConstructible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructible : bool" Usage="System.Xaml.XamlType.IsConstructible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type constructible, selon la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type constructible ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’aligne sur le `[is default constructible]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsConstructible%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsConstructible%2A> sur ce type.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlType.ConstructionRequiresArguments" />
      </Docs>
    </Member>
    <Member MemberName="IsDictionary">
      <MemberSignature Language="C#" Value="public bool IsDictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDictionary" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsDictionary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDictionary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDictionary { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDictionary : bool" Usage="System.Xaml.XamlType.IsDictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un dictionnaire, selon la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un dictionnaire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’aligne sur le `[is dictionary]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupCollectionKind%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupCollectionKind%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGeneric">
      <MemberSignature Language="C#" Value="public bool IsGeneric { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGeneric" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsGeneric" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsGeneric As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsGeneric { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGeneric : bool" Usage="System.Xaml.XamlType.IsGeneric" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type générique.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est une propriété d’assistance qui recherche une valeur null de <xref:System.Xaml.XamlType.TypeArguments%2A>. Il n’existe aucun spécifiques `Lookup` méthode liées à <xref:System.Xaml.XamlType.IsGeneric%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarkupExtension">
      <MemberSignature Language="C#" Value="public bool IsMarkupExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarkupExtension" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarkupExtension As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarkupExtension { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarkupExtension : bool" Usage="System.Xaml.XamlType.IsMarkupExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une extension de balisage.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une extension de balisage ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En termes de spécification de XAML, ce type doit être assignable à `x:MarkupExtension` afin de retourner `true` pour <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsMarkupExtension%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameScope">
      <MemberSignature Language="C#" Value="public bool IsNameScope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameScope" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameScope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameScope As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameScope { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameScope : bool" Usage="System.Xaml.XamlType.IsNameScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une portée de nom XAML, selon la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une portée de nom XAML ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une portée de nom XAML applique l’unicité du nom de la propriété ou les propriétés utilisées pour `x:Name`  /  `[name property]`. Si <xref:System.Xaml.XamlType.IsNameScope%2A> est `true`, un mécanisme pour appliquer l’unicité doit exister et évaluer depuis la perspective de ce type possède une portée de nom XAML. La portée de nom XAML s’étend ensuite au contenu du type jusqu'à ce qu’un autre type de propriétaire de portée de nom XAML est rencontré.  
  
 Cette propriété s’aligne sur le `[is name scope]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsNameScope%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlType.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> est initialisé en utilisant une chaîne <see langword="xamlName" /> valide comme <see cref="P:System.Xaml.XamlType.Name" />.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> est initialisé en utilisant une chaîne <see langword="xamlName" /> valide ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullable">
      <MemberSignature Language="C#" Value="public bool IsNullable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNullable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsNullable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNullable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNullable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNullable : bool" Usage="System.Xaml.XamlType.IsNullable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type Nullable, selon la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type Nullable ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’aligne sur le `[is nullable]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsNullable%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Xaml.XamlType.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type public dans le système de type approprié.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type public ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsPublic%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les informations d’accès signalées concernant un type XAML afin qu’il ne s’aligne plus comme prévu avec les informations de type système et des accès de son type CLR sous-jacent. Pour les vérifications critiques de sécurité des opérations d’assignation et l’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlType.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type qui ne peut pas être résolu dans le système de type sous-jacent.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type qui ne peut pas être résolu ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsUnknown%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées.  
  
 Pour un chemin de chargement implique <xref:System.Xaml.XamlObjectWriter>, un <xref:System.Xaml.XamlType> qui a `true` pour <xref:System.Xaml.XamlType.IsUnknown%2A> ne peut pas être écrit dans un graphique d’objet. Sous les implémentations par défaut dans <xref:System.Xaml> , le <xref:System.Xaml.XamlObjectWriter.WriteStartObject%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque le pertinentes <xref:System.Xaml.XamlType> rapports `true` pour <xref:System.Xaml.XamlType.IsUnknown%2A>. Vous ne devez pas passer un <xref:System.Xaml.XamlType> qui a <xref:System.Xaml.XamlType.IsUnknown%2A> en tant que `true` sauf si vous êtes prêt à gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres façons d’ajuster le <xref:System.Xaml.XamlObjectWriter> comportement ou le flux de nœud XAML avant d’écrire l’objet graphique.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUsableDuringInitialization">
      <MemberSignature Language="C#" Value="public bool IsUsableDuringInitialization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUsableDuringInitialization" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUsableDuringInitialization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUsableDuringInitialization { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUsableDuringInitialization : bool" Usage="System.Xaml.XamlType.IsUsableDuringInitialization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> est développé de haut en bas pendant l'initialisation XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> est développé de haut en bas pendant l'initialisation XAML ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Haut-bas est une métaphore qui est une approximation du comportement du processeur XAML lors de la création du graphique d’objet. Un type généré de haut en bas est instancié, attaché à la page parente, et puis ses propriétés sont définies. Construction de haut en bas évite d’appeler des gestionnaires à propriétés modifiées plusieurs fois. Une telle gestion onduler le graphique d’objets et par conséquent, élimine les appels du gestionnaire plusieurs et fournit une optimisation des performances pour le démarrage du graphique d’objets.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupUsableDuringInitialization%2A> sur ce type.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
        <altmember cref="P:System.Windows.FrameworkElement.IsInitialized" />
      </Docs>
    </Member>
    <Member MemberName="IsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="public bool IsWhitespaceSignificantCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWhitespaceSignificantCollection" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWhitespaceSignificantCollection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWhitespaceSignificantCollection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWhitespaceSignificantCollection : bool" Usage="System.Xaml.XamlType.IsWhitespaceSignificantCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une collection d'espaces blancs significative, selon la définition XML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une collection d'espaces blancs significative ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsXData">
      <MemberSignature Language="C#" Value="public bool IsXData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsXData" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.IsXData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsXData As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsXData { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsXData : bool" Usage="System.Xaml.XamlType.IsXData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un <see langword="XDATA" /> XML, selon la définition XAML.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente <see langword="XDATA" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété s’aligne sur le `[is xdata]` élément d’information dans la spécification [MS-XAML].  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsXData%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsXData%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType ItemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType ItemType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ItemType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ ItemType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.ItemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui fournit les informations de type pour la propriété <see langword="Items" /> de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Objet <see cref="T:System.Xaml.XamlType" /> pour le type des éléments de la collection ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas une collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est uniquement pertinente si ce <xref:System.Xaml.XamlType> représente une collection (<xref:System.Xaml.XamlType.IsCollection%2A> est `true`). Le `Items` propriété est n’importe quelle propriété conserve des éléments de ce type de collection ou un tableau.  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupItemType%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupItemType%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType KeyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType KeyType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.KeyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ KeyType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.KeyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui fournit les informations de type pour la propriété de clé de ce <see cref="T:System.Xaml.XamlType" />, si le <see cref="T:System.Xaml.XamlType" /> représente un dictionnaire.</summary>
        <value>Objet <see cref="T:System.Xaml.XamlType" /> pour le type de la clé pour l'utilisation de dictionnaire ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas un dictionnaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est uniquement pertinente si ce <xref:System.Xaml.XamlType> représente un dictionnaire (<xref:System.Xaml.XamlType.IsDictionary%2A> est `true`).  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupKeyType%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupKeyType%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAliasedProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAliasedProperty (System.Xaml.XamlDirective directive);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAliasedProperty(class System.Xaml.XamlDirective directive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAliasedProperty(System.Xaml.XamlDirective)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAliasedProperty (directive As XamlDirective) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAliasedProperty(System::Xaml::XamlDirective ^ directive);" />
      <MemberSignature Language="F#" Value="abstract member LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember&#xA;override this.LookupAliasedProperty : System.Xaml.XamlDirective -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAliasedProperty directive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directive" Type="System.Xaml.XamlDirective" />
      </Parameters>
      <Docs>
        <param name="directive">Directive pour laquelle rechercher le membre ajouté en alias.</param>
        <summary>Retourne le membre XAML ajouté en alias à une directive XAML par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Membre ajouté en alias, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.GetAliasedProperty%2A>.  
  
 L’implémentation par défaut peut retourner des résultats pour les directives XAML suivantes : `Key`; `Name`; `Uid`; et `xml:lang`. Valeurs pour ces dépendent de la réflexion sous-jacente et peuvent encore retourner `null` si aucune propriété d’un alias est trouvée.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou les informations de schéma d’un type.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xaml.XamlDirective" />
        <altmember cref="T:System.Xaml.XamlLanguage" />
      </Docs>
    </Member>
    <Member MemberName="LookupAllAttachableMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllAttachableMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllAttachableMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllAttachableMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllAttachableMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllAttachableMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllAttachableMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllAttachableMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un jeu énumérable qui contient toutes les propriétés pouvant être attachées exposées par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Jeu énumérable qui contient zéro, une ou plusieurs valeurs <see cref="T:System.Xaml.XamlMember" /> ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A>.  
  
 Bien que <xref:System.Xaml.XamlType.GetAllAttachableMembers%2A> retourne une collection générique, cela `Lookup` méthode retourne un jeu énumérable générique.  
  
 L’implémentation par défaut utilise la réflexion CLR interne. Lorsque <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`, l’implémentation par défaut peut utiliser <xref:System.Xaml.XamlType.BaseType%2A>, s’il est disponible. Ce comportement appelle <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> récursivement pour tenter de trouver un type de base valid et retourne `null` si aucun type de base valide n’existe.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type. Un retour null doit être réservé pour les cas où les informations ne peut pas être déterminées en raison du manque de prise en charge système ou de la réflexion de type. Si un type est valide et la réflexion ou autres techniques sont disponibles, mais un type n’a pas de membres pouvant être attachés, vous devez retourner à la place de vide <xref:System.Collections.Generic.IEnumerable%601> définie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllMembers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt; LookupAllMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xaml.XamlMember&gt; LookupAllMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllMembers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllMembers () As IEnumerable(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IEnumerable&lt;System::Xaml::XamlMember ^&gt; ^ LookupAllMembers();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupAllMembers : unit -&gt; seq&lt;System.Xaml.XamlMember&gt;" Usage="xamlType.LookupAllMembers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un jeu énumérable qui contient tous les membres exposés par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Jeu énumérable qui contient zéro ou plusieurs valeurs <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.GetAllMembers%2A>.  
  
 Bien que <xref:System.Xaml.XamlType.GetAllMembers%2A> retourne une collection générique, cela `Lookup` méthode retourne un jeu énumérable générique.  
  
 L’implémentation par défaut utilise la réflexion CLR interne. Pour les cas où <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`, l’implémentation par défaut peut utiliser <xref:System.Xaml.XamlType.BaseType%2A>, s’il est disponible. Ce comportement appelle <xref:System.Xaml.XamlType.LookupAllMembers%2A> récursivement pour tenter de trouver un type de base valid et retourne `null` si aucun type de base valide n’existe.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type. Un retour null doit être réservé pour les cas où les informations ne peut pas être déterminées en raison du manque de prise en charge système ou de la réflexion de type. Si un type est valide, la réflexion ou autres techniques sont disponibles ; Si un type n’a pas de membres, vous devez retourner à la place de vide <xref:System.Collections.Generic.IEnumerable%601> définie.  
  
 Valeurs de retour pour <xref:System.Xaml.XamlType.LookupAllMembers%2A> et <xref:System.Xaml.XamlType.LookupAllAttachableMembers%2A> s’excluent mutuellement. Si vous avez une situation où une propriété de système de type de sauvegarde peut prendre en charge une utilisation de l’instance standard ainsi que d’une utilisation pouvant être attachée, ce membre doit être signalé comme deux <xref:System.Xaml.XamlMember> valeurs, avec une valeur qui apparaissent dans la liste pouvant être attachée et l’autre dans le liste des membres standard.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAllowedContentTypes">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupAllowedContentTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupAllowedContentTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAllowedContentTypes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAllowedContentTypes () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupAllowedContentTypes();" />
      <MemberSignature Language="F#" Value="abstract member LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupAllowedContentTypes : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupAllowedContentTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste des types utilisables comme valeur <see cref="P:System.Xaml.XamlType.ContentProperty" /> pour ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Liste des types de contenu possibles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 Les types qui sont évalués en <xref:System.Xaml.XamlType.CanAssignTo%2A> pour un type de contenu spécifique ne sont pas considérés comme plusieurs types à des fins de <xref:System.Xaml.XamlType.AllowedContentTypes%2A>.  
  
 L’implémentation par défaut peut utiliser d’autres propriétés de <xref:System.Xaml.XamlType> (<xref:System.Xaml.XamlType.ContentWrappers%2A>, <xref:System.Xaml.XamlType.ContentProperty%2A>, ou <xref:System.Xaml.XamlType.ItemType%2A>) pour obtenir un résultat. Le `Lookup` les remplacements pour la liste de propriétés précédente peut également être appelée dans cette détermination.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupAttachableMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupAttachableMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupAttachableMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupAttachableMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupAttachableMember (name As String) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupAttachableMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member LookupAttachableMember : string -&gt; System.Xaml.XamlMember&#xA;override this.LookupAttachableMember : string -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupAttachableMember name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre pouvant être attaché à obtenir, dans le formulaire <c>ownerTypeName.MemberName</c>.</param>
        <summary>Retourne un <see cref="T:System.Xaml.XamlMember" /> pour une valeur spécifique nommée pouvant être attachée à partir de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Un objet <see cref="T:System.Xaml.XamlMember" /> pour le membre demandé pouvant être attaché ; sinon, <see langword="null" />, si aucun membre pouvant être attaché portant ce nom n’existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.GetAttachableMember%2A>.  
  
 L’implémentation par défaut utilise la réflexion CLR interne. Lorsque <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`, l’implémentation par défaut peut utiliser <xref:System.Xaml.XamlType.BaseType%2A>, s’il est disponible. Ce comportement appelle <xref:System.Xaml.XamlType.LookupAttachableMember%2A> récursivement pour tenter de trouver un type de base valid et retourne `null` si aucun type de base valide n’existe.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupAttachableMember%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les membres signalés d’un type XAML afin qu’ils n’alignent plus comme prévu avec le <xref:System.ComponentModel.TypeDescriptor> `Get*` plus d’informations sur le type CLR sous-jacent. Pour les vérifications critiques de sécurité du membre de création de rapports, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupBaseType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupBaseType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupBaseType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupBaseType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupBaseType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupBaseType();" />
      <MemberSignature Language="F#" Value="abstract member LookupBaseType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupBaseType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupBaseType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Xaml.XamlType" /> du type de base immédiat de ce type XAML. La détermination de cette valeur dépend du type sous-jacent de ce <see cref="T:System.Xaml.XamlType" /> et du contexte de schéma.</summary>
        <returns>
          <see cref="T:System.Xaml.XamlType" /> du type de base immédiat de ce type XAML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.BaseType%2A>.  
  
 L’implémentation par défaut peut retourner une constante interne qui représente le <xref:System.Object> si <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupBaseType%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les informations de type signalées concernant un type XAML afin qu’il ne s’aligne plus comme prévu avec les informations de système de type de son type CLR sous-jacent. Pour les vérifications critiques de sécurité des opérations d’assignation et l’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCollectionKind">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlCollectionKind LookupCollectionKind ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Xaml.Schema.XamlCollectionKind LookupCollectionKind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCollectionKind" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCollectionKind () As XamlCollectionKind" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlCollectionKind LookupCollectionKind();" />
      <MemberSignature Language="F#" Value="abstract member LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind&#xA;override this.LookupCollectionKind : unit -&gt; System.Xaml.Schema.XamlCollectionKind" Usage="xamlType.LookupCollectionKind " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlCollectionKind</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur de l'énumération <see cref="T:System.Xaml.Schema.XamlCollectionKind" /> qui déclare le type de collection spécifique utilisé par ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Valeur de l'énumération <see cref="T:System.Xaml.Schema.XamlCollectionKind" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par une méthode privée interne (sans adresse `CollectionKind` ou `GetCollectionKind` API existe sur <xref:System.Xaml.XamlType>).  
  
 L’implémentation par défaut utilise la réflexion CLR interne. Pour les cas où <xref:System.Xaml.XamlType.UnderlyingType%2A> est `null`, l’implémentation par défaut peut utiliser <xref:System.Xaml.XamlType.BaseType%2A>, s’il est disponible. Ce comportement appelle indirectement <xref:System.Xaml.XamlType.LookupCollectionKind%2A> récursive tente de trouver un type de base valide ; elle retourne <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> si aucun type de base valide n’existe. En règle générale, l’implémentation par défaut tente de trouver le `Add` méthode du type sous-jacent par réflexion. Si trouvée, le <xref:System.Reflection.MethodInfo> de la `Add` méthode est suffisamment d’informations pour déterminer quelle <xref:System.Xaml.Schema.XamlCollectionKind> valeur doit être retournée. Sinon, il retourne <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType>.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupConstructionRequiresArguments">
      <MemberSignature Language="C#" Value="protected virtual bool LookupConstructionRequiresArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupConstructionRequiresArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupConstructionRequiresArguments" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupConstructionRequiresArguments () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupConstructionRequiresArguments();" />
      <MemberSignature Language="F#" Value="abstract member LookupConstructionRequiresArguments : unit -&gt; bool&#xA;override this.LookupConstructionRequiresArguments : unit -&gt; bool" Usage="xamlType.LookupConstructionRequiresArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> doit avoir des arguments (contraintes génériques par <see langword="x:TypeArguments" />, texte d'initialisation ou d'autres techniques XAML) pour construire une instance valide du type.</summary>
        <returns>
          <see langword="true" /> si la construction d'une instance requiert une valeur d'argument ; sinon, false</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>.  
  
 L’implémentation par défaut retourne `false` système de type pour les types valeur considérés dans le CLR. Dans les autres types de valeur, réflexion CLR <xref:System.Reflection.ConstructorInfo> est utilisé pour déterminer si un constructeur par défaut existe.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentProperty">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupContentProperty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupContentProperty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentProperty () As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupContentProperty();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentProperty : unit -&gt; System.Xaml.XamlMember&#xA;override this.LookupContentProperty : unit -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupContentProperty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les informations <see cref="T:System.Xaml.XamlMember" /> de la propriété de contenu de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.XamlMember" /> de la propriété de contenu de ce <see cref="T:System.Xaml.XamlType" />. Peut avoir la valeur <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.ContentProperty%2A>.  
  
 L’implémentation par défaut recherche <xref:System.Windows.Markup.ContentPropertyAttribute> sur la définition de type. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si ces contrôles ne découvrent pas un type de contenu, l’implémentation par défaut retourne `null`.  
  
 Substituez cette méthode si vous ne comptez pas sur la réflexion CLR interne par défaut et sont à l’aide de métadonnées ou autres techniques de création de rapports les informations de système de type XAML ou des informations de schéma d’un type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupContentWrappers">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupContentWrappers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupContentWrappers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupContentWrappers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupContentWrappers () As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupContentWrappers();" />
      <MemberSignature Language="F#" Value="abstract member LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupContentWrappers : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupContentWrappers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une liste de valeurs <see cref="T:System.Xaml.XamlType" /> qui représentent les wrappers de contenu pour ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Liste de valeurs <see cref="T:System.Xaml.XamlType" /> qui représentent les wrappers de contenu pour ce <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wrapper de contenu est une classe qui représente le type de collection de contenu lorsque les types qui sont utilisés dans cette collection ne sont pas contigus au système de type. Les types d’éléments de collecte pour le wrapper de contenu sont censés être limités d’une certaine façon au-delà <xref:System.Object> ou l’équivalent d’un objet neutre. Toutefois, cette limitation est appliquée uniquement par la conception ou l’objectif des propriétés qui utilisent ce type et non par le système de type. Plus d’un wrapper de contenu peut exister sur un type.  
  
 Pour un exemple de classe et le scénario de l’implémentation WPF XAML, consultez <xref:System.Windows.Documents.InlineCollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlType.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas d'implémentation dans une classe dérivée, retourne une implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode pour fournir la réflexion interne avec une autre manière d’obtenir les valeurs d’attribut CLR. En l’absence d’une substitution, le réflecteur interne utilise la logique de réflexion CLR typique.  
  
 L'implémentation par défaut retourne la valeur `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlType.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> utilisé pour le chargement différé des objets déclarés par XAML.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui a une contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> sur le générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlType.DeferringLoader%2A>. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.DeferringLoader%2A> pour retourner une valeur différente qu’est activée par la réflexion interne par défaut et fournit également personnalisé <xref:System.Xaml.Schema.XamlTypeInvoker> plus d’informations.  
  
 L’implémentation par défaut retourne un objet basé sur la lecture <xref:System.Windows.Markup.XamlDeferLoadAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur est indisponible, cette méthode retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlTypeInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlTypeInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlTypeInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlTypeInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlTypeInvoker" Usage="xamlType.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlTypeInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> associé à ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.Schema.XamlTypeInvoker" /> pour ce <see cref="T:System.Xaml.XamlType" /> ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.Invoker%2A>.  
  
 L’implémentation par défaut n’exige pas un <xref:System.Xaml.XamlType> être construite à l’aide d’un des constructeurs qui passent un initial <xref:System.Xaml.Schema.XamlTypeInvoker>. Toutefois, un <xref:System.Xaml.XamlType.UnderlyingType%2A> valeur doit exister pour le <xref:System.Xaml.XamlType>; sinon, retourne l’implémentation par défaut `null`.  
  
 Substituez cette méthode si vous créez également une classe dérivée de <xref:System.Xaml.Schema.XamlTypeInvoker> et souhaitez retourner la classe dérivée. Si vous retournez `null`, <xref:System.Xaml.XamlType.Invoker%2A> retourne <xref:System.Xaml.Schema.XamlTypeInvoker.UnknownInvoker%2A?displayProperty=nameWithType> aux appelants.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlType.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type ambiant, selon la définition XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type ambiant ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsAmbient%2A>.  
  
 L’implémentation par défaut utilise la réflexion CLR sur le <xref:System.Xaml.XamlType.UnderlyingType%2A> et vous pouvez vérifier les types de base. Cette implémentation vérifie la <xref:System.Windows.Markup.AmbientAttribute> qui est appliqué à la définition du type approprié au niveau de la classe et retourne `true` dans ce cas. Retournent tous les autres cas `false`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsAmbient%2A> pour retourner une valeur différente de celle activée par la réflexion interne par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsConstructible">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsConstructible ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsConstructible() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsConstructible" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsConstructible () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsConstructible();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsConstructible : unit -&gt; bool&#xA;override this.LookupIsConstructible : unit -&gt; bool" Usage="xamlType.LookupIsConstructible " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type constructible, selon la définition XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type constructible ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsConstructible%2A>.  
  
 L’implémentation par défaut utilise la réflexion CLR sur le <xref:System.Xaml.XamlType.UnderlyingType%2A>. Le type doit être concret, non imbriqué et fermé. L’implémentation par défaut vérifie si le type est un type valeur et le retour de <xref:System.Xaml.XamlType.ConstructionRequiresArguments%2A>. Pour une valeur null <xref:System.Xaml.XamlType.UnderlyingType%2A>, cette méthode retourne `true`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsConstructible%2A> pour retourner une valeur différente de celle activée par la réflexion interne par défaut.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsMarkupExtension">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsMarkupExtension ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsMarkupExtension() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsMarkupExtension" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsMarkupExtension () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsMarkupExtension();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsMarkupExtension : unit -&gt; bool&#xA;override this.LookupIsMarkupExtension : unit -&gt; bool" Usage="xamlType.LookupIsMarkupExtension " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une extension de balisage.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une extension de balisage ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 L’implémentation par défaut se compose uniquement de cet appel :  
  
 `return CanAssignTo(XamlLanguage.MarkupExtension);`  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsMarkupExtension%2A> à utiliser une logique différente.  
  
 En termes de spécification de XAML, ce type doit être assignable à `x:MarkupExtension` afin de retourner `true` pour <xref:System.Xaml.XamlType.IsMarkupExtension%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsNameScope">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNameScope ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNameScope() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNameScope" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNameScope () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNameScope();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNameScope : unit -&gt; bool&#xA;override this.LookupIsNameScope : unit -&gt; bool" Usage="xamlType.LookupIsNameScope " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une portée de nom XAML, selon la définition XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une portée de nom XAML ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsNameScope%2A>.  
  
 L’implémentation par défaut effectue une <xref:System.Xaml.XamlType.CanAssignTo%2A> appeler indirectement par rapport au type <xref:System.Windows.Markup.INameScope>. <xref:System.Windows.Markup.INameScope> est une interface qui est définie dans l’assembly WindowsBase.dll. Cette technique pour identifier la portée de nom XAML est utilisée à la fois par les implémentations de WPF et Windows Workflow Foundation de XAML.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsNameScope%2A> à utiliser une logique différente.  
  
 Une portée de nom XAML applique l’unicité du nom de l’ou les propriétés qui sont utilisées pour `x:Name`  /  `[name property]`. Si <xref:System.Xaml.XamlType.IsNameScope%2A> est `true`, puis un mécanisme pour appliquer l’unicité doit exister et évaluer depuis la perspective de ce type possède une portée de nom XAML. La portée de nom XAML s’étend ensuite au contenu du type jusqu'à ce qu’un autre type propriétaire de la portée de nom XAML est rencontré.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlObjectWriter.RootNameScope" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsNullable">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsNullable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsNullable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsNullable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsNullable () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsNullable();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsNullable : unit -&gt; bool&#xA;override this.LookupIsNullable : unit -&gt; bool" Usage="xamlType.LookupIsNullable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type Nullable, selon la définition XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type Nullable ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsNullable%2A>.  
  
 L’implémentation par défaut effectue une détermination selon le concept nullable de bibliothèque principale CLR, vérifié par rapport aux <xref:System.Xaml.XamlType.UnderlyingType%2A>. Pour une valeur null <xref:System.Xaml.XamlType.UnderlyingType%2A>, elle retourne `true`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsNullable%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsPublic : unit -&gt; bool&#xA;override this.LookupIsPublic : unit -&gt; bool" Usage="xamlType.LookupIsPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type public dans le système de type approprié.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type public ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsPublic%2A>.  
  
 L’implémentation par défaut utilise la réflexion CLR par rapport à une valeur non null <xref:System.Xaml.XamlType.UnderlyingType%2A>. Pour une valeur null <xref:System.Xaml.XamlType.UnderlyingType%2A>, elle retourne `true`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsPublic%2A> à utiliser une logique différente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupIsPublic%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les informations d’accès signalées concernant un type XAML afin qu’il ne s’aligne plus comme prévu avec les informations de type système ou d’accès de son type CLR sous-jacent. Pour les vérifications critiques de sécurité des opérations d’assignation et l’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlType.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un type qui ne peut pas être résolu dans le système de type sous-jacent.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type qui ne peut pas être résolu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsUnknown%2A>.  
  
 L’implémentation par défaut peut utiliser la réflexion CLR. Pour une valeur null <xref:System.Xaml.XamlType.UnderlyingType%2A>, elle retourne `true`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsUnknown%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsWhitespaceSignificantCollection">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWhitespaceSignificantCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWhitespaceSignificantCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWhitespaceSignificantCollection () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWhitespaceSignificantCollection();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWhitespaceSignificantCollection : unit -&gt; bool&#xA;override this.LookupIsWhitespaceSignificantCollection : unit -&gt; bool" Usage="xamlType.LookupIsWhitespaceSignificantCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente une collection d'espaces blancs significative, selon la définition XML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente une collection d'espaces blancs significative ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A>.  
  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.WhitespaceSignificantCollectionAttribute>. Il peut également vérifier le <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, elle retourne `false`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsWhitespaceSignificantCollection%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupIsXData">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsXData ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsXData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupIsXData" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsXData () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsXData();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsXData : unit -&gt; bool&#xA;override this.LookupIsXData : unit -&gt; bool" Usage="xamlType.LookupIsXData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> représente un <see langword="XDATA" /> XML, selon la définition XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente <see langword="XDATA" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsXData%2A>.  
  
 L’implémentation par défaut effectue une <xref:System.Xaml.XamlType.CanAssignTo%2A> appeler indirectement par rapport au type <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsXData%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupItemType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupItemType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupItemType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupItemType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupItemType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupItemType();" />
      <MemberSignature Language="F#" Value="abstract member LookupItemType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupItemType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupItemType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui fournit les informations de type pour la propriété <see langword="Items" /> de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Objet <see cref="T:System.Xaml.XamlType" /> pour le type des éléments de la collection ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas une collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.ItemType%2A>.  
  
 L’implémentation par défaut peut utiliser les concepts de réflexion CLR, tels que la vérification pour un `Add` méthode par <xref:System.Reflection.MethodInfo> et à l’aide de la <xref:System.Reflection.ParameterInfo>; vérification <xref:System.Xaml.XamlType.IsArray%2A>; et en vérifiant <xref:System.Xaml.XamlType.BaseType%2A> et essayez de la même logique.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.ItemType%2A> à utiliser une logique différente. Les cas où <xref:System.Xaml.XamlType.LookupCollectionKind%2A> retourne <xref:System.Xaml.Schema.XamlCollectionKind.None?displayProperty=nameWithType> doit retourner `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupKeyType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupKeyType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupKeyType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupKeyType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupKeyType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupKeyType();" />
      <MemberSignature Language="F#" Value="abstract member LookupKeyType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupKeyType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupKeyType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui fournit les informations de type pour la propriété de clé de ce <see cref="T:System.Xaml.XamlType" />, si le <see cref="T:System.Xaml.XamlType" /> représente un dictionnaire.</summary>
        <returns>Objet <see cref="T:System.Xaml.XamlType" /> pour le type de la clé pour l'utilisation de dictionnaire, ou <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas de dictionnaire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.KeyType%2A>.  
  
 L’implémentation par défaut peut utiliser les concepts de réflexion CLR, tels que la vérification pour un `Add` méthode par <xref:System.Reflection.MethodInfo> et à l’aide de la <xref:System.Reflection.ParameterInfo>; et en vérifiant <xref:System.Xaml.XamlType.BaseType%2A> et essayez de la même logique.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.KeyType%2A> à utiliser une logique différente. Les cas où <xref:System.Xaml.XamlType.LookupCollectionKind%2A> ne retourne pas <xref:System.Xaml.Schema.XamlCollectionKind.Dictionary?displayProperty=nameWithType> doit retourner `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupMarkupExtensionReturnType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupMarkupExtensionReturnType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionReturnType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupMarkupExtensionReturnType();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupMarkupExtensionReturnType : unit -&gt; System.Xaml.XamlType" Usage="xamlType.LookupMarkupExtensionReturnType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui fournit les informations de type pour le <see langword="ProvideValue" /> retourné de ce <see cref="T:System.Xaml.XamlType" />, s'il représente une extension de balisage.</summary>
        <returns>Objet <see cref="T:System.Xaml.XamlType" /> pour le type de retour pour l'utilisation d'une extension de balisage ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas une extension de balisage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A>.  
  
 L’implémentation par défaut retourne un <xref:System.Xaml.XamlType> basé sur la lecture <xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, elle retourne `null`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.MarkupExtensionReturnType%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupMember">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlMember LookupMember (string name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlMember LookupMember(string name, bool skipReadOnlyCheck) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupMember(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMember (name As String, skipReadOnlyCheck As Boolean) As XamlMember" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlMember ^ LookupMember(System::String ^ name, bool skipReadOnlyCheck);" />
      <MemberSignature Language="F#" Value="abstract member LookupMember : string * bool -&gt; System.Xaml.XamlMember&#xA;override this.LookupMember : string * bool -&gt; System.Xaml.XamlMember" Usage="xamlType.LookupMember (name, skipReadOnlyCheck)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlMember</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="skipReadOnlyCheck" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom du membre à obtenir (sous forme de chaîne).</param>
        <param name="skipReadOnlyCheck">
          <see langword="true" /> pour retourner un membre même si ce membre a une valeur <see langword="true" /> pour <see cref="P:System.Xaml.XamlMember.IsReadOnly" /> ; <see langword="false" /> pour ne pas retourner de membre <see cref="P:System.Xaml.XamlMember.IsReadOnly" />. La valeur par défaut est <see langword="false" />.</param>
        <summary>Retourne le <see cref="T:System.Xaml.XamlMember" /> pour un membre nommé spécifique de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.XamlMember" /> du membre, s'il a été trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.GetMember%2A>.  
  
 L’implémentation par défaut retourne un <xref:System.Xaml.XamlType> basé sur la réflexion CLR interne et d’évaluation par rapport au contexte de schéma.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.GetMember%2A> à utiliser une logique différente.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlType.LookupMember%2A> est virtuel et par conséquent, peut être substituée. La substitution a la possibilité (fins malveillantes ou autre) pour modifier les membres signalés d’un type XAML afin qu’ils n’alignent plus comme prévu avec le <xref:System.ComponentModel.TypeDescriptor> `Get*` plus d’informations sur le type CLR sous-jacent. Pour les vérifications critiques de sécurité du membre de création de rapports, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupPositionalParameters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; LookupPositionalParameters (int parameterCount);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; LookupPositionalParameters(int32 parameterCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupPositionalParameters(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupPositionalParameters (parameterCount As Integer) As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ LookupPositionalParameters(int parameterCount);" />
      <MemberSignature Language="F#" Value="abstract member LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;&#xA;override this.LookupPositionalParameters : int -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="xamlType.LookupPositionalParameters parameterCount" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameterCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parameterCount">Nombre (arité) de la syntaxe ou du mode constructeur spécifique pour lequel ou laquelle vous voulez obtenir des informations.</param>
        <summary>Pour les types d'extension de balisage, retourne les types des paramètres positionnels pris en charge dans une utilisation de l'extension de balisage spécifique à ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Liste de valeurs <see cref="T:System.Xaml.XamlType" /> où chaque <see cref="T:System.Xaml.XamlType" /> est le type de cette position dans la syntaxe. Vous devez spécifier ces types dans le même ordre lorsque vous fournissez l'entrée de balisage pour l'extension de balisage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.GetPositionalParameters%2A>.  
  
 L’implémentation par défaut utilise les informations de réflexion interne en fonction de recherche des constructeurs et en vérifiant l’arité. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.GetPositionalParameters%2A> à utiliser une logique différente.  
  
 Cette API est uniquement pertinente si ce <xref:System.Xaml.XamlType> représente une extension de balisage (<xref:System.Xaml.XamlType.IsMarkupExtension%2A> est `true`).  
  
 L’entrée `parameterCount` n’est pas de demander le type d’un paramètre positionnel spécifique. Il sert à spécifier l’arité d’une extension de balisage. Extension de balisage souvent a plusieurs signatures et utilise le paramètre différentes arité (nombre) de paramètres positionnels pour différencier. Toutefois, vous pouvez configurer un contexte de schéma pour autoriser arités en double et utiliser des types de paramètres positionnels de différenciation. Pour plus d'informations, consultez <xref:System.Xaml.XamlSchemaContext.SupportMarkupExtensionsWithDuplicateArity%2A>. Pour un nombre d’arité spécifique, les positions des paramètres et les types peuvent varier. Pour obtenir le type de position de l’extension de balisage d’une arité spécifique, vous appelez d’abord <xref:System.Xaml.XamlType.GetPositionalParameters%2A> avec le nombre d’arité. Obtenez ensuite l’élément à cette position à partir de la collection retournée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetMarkupExtensionHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt; LookupSetMarkupExtensionHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetMarkupExtensionHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetMarkupExtensionHandler () As EventHandler(Of XamlSetMarkupExtensionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetMarkupExtensionEventArgs ^&gt; ^ LookupSetMarkupExtensionHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;&#xA;override this.LookupSetMarkupExtensionHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;" Usage="xamlType.LookupSetMarkupExtensionHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetMarkupExtensionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un rappel du gestionnaire à utiliser pour les opérations ensemblistes d'extensions de balisage.</summary>
        <returns>Rappel du gestionnaire à utiliser pour les opérations ensemblistes d'extensions de balisage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.XamlSetMarkupExtensionAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupSetTypeConverterHandler">
      <MemberSignature Language="C#" Value="protected virtual EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.EventHandler`1&lt;class System.Windows.Markup.XamlSetTypeConverterEventArgs&gt; LookupSetTypeConverterHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupSetTypeConverterHandler" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupSetTypeConverterHandler () As EventHandler(Of XamlSetTypeConverterEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual EventHandler&lt;System::Windows::Markup::XamlSetTypeConverterEventArgs ^&gt; ^ LookupSetTypeConverterHandler();" />
      <MemberSignature Language="F#" Value="abstract member LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;&#xA;override this.LookupSetTypeConverterHandler : unit -&gt; EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;" Usage="xamlType.LookupSetTypeConverterHandler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Markup.XamlSetTypeConverterEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un gestionnaire à utiliser pour le paramétrage du convertisseur de type.</summary>
        <returns>Gestionnaire à utiliser pour le paramétrage du convertisseur de type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.XamlSetTypeConverterAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, retourne `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="protected virtual bool LookupTrimSurroundingWhitespace ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupTrimSurroundingWhitespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTrimSurroundingWhitespace () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupTrimSurroundingWhitespace();" />
      <MemberSignature Language="F#" Value="abstract member LookupTrimSurroundingWhitespace : unit -&gt; bool&#xA;override this.LookupTrimSurroundingWhitespace : unit -&gt; bool" Usage="xamlType.LookupTrimSurroundingWhitespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> doit être sérialisé en utilisant un mode qui tronque l’espace blanc l’entourant.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> doit être sérialisé en utilisant un mode qui tronque l'espace blanc autour ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.TrimSurroundingWhitespace%2A>.  
  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.TrimSurroundingWhitespaceAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, retourne `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlType.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui a une contrainte <see cref="T:System.ComponentModel.TypeConverter" />, laquelle représente le comportement de conversion de type pour les valeurs de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.ComponentModel.TypeConverter" /> qui représente le comportement de conversion de type pour les valeurs de ce <see cref="T:System.Xaml.XamlType" /> ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.TypeConverter%2A>.  
  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.ComponentModel.TypeConverterAttribute>. L’implémentation par défaut peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Il inclut également une logique spéciale pour la conversion de valeur par défaut des énumérations, des types valeur communs et des génériques. Si une valeur n’est pas disponible, retourne `null`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.TypeConverter%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingType">
      <MemberSignature Language="C#" Value="protected virtual Type LookupUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type LookupUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ LookupUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingType : unit -&gt; Type&#xA;override this.LookupUnderlyingType : unit -&gt; Type" Usage="xamlType.LookupUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Type" /> CLR sous-jacent de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Type" /> CLR sous-jacent de ce <see cref="T:System.Xaml.XamlType" /> ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.UnderlyingType%2A>.  
  
 L’implémentation par défaut retourne un champ interne. Ce champ est initialisé en général pendant la construction et sa valeur est basée sur le constructeur a été appelé et les informations que vous avez fourni.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.UnderlyingType%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUsableDuringInitialization">
      <MemberSignature Language="C#" Value="protected virtual bool LookupUsableDuringInitialization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupUsableDuringInitialization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupUsableDuringInitialization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUsableDuringInitialization () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupUsableDuringInitialization();" />
      <MemberSignature Language="F#" Value="abstract member LookupUsableDuringInitialization : unit -&gt; bool&#xA;override this.LookupUsableDuringInitialization : unit -&gt; bool" Usage="xamlType.LookupUsableDuringInitialization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> est développé de haut en bas pendant l'initialisation XAML.</summary>
        <returns>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> est développé de haut en bas pendant l'initialisation XAML ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Haut-bas est une métaphore qui est une approximation du comportement du processeur XAML lorsqu’il crée le graphique d’objet. Lors de la génération de haut en bas, un type est instancié, attaché à la page parente, et ses propriétés sont définies. Construction de haut en bas évite d’appeler des gestionnaires à propriétés modifiées plusieurs fois. Une telle gestion onduler le graphique d’objets et par conséquent, élimine les appels du gestionnaire plusieurs et fournit une optimisation des performances pour le démarrage du graphique d’objets.  
  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A>.  
  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.UsableDuringInitializationAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Si une valeur n’est pas disponible, retourne `false`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.IsUsableDuringInitialization%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlType.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui a une contrainte <see cref="T:System.Windows.Markup.ValueSerializer" />, laquelle représente le comportement de sérialisation pour les valeurs de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Windows.Markup.ValueSerializer" /> qui représente le comportement de sérialisation pour les valeurs de ce <see cref="T:System.Xaml.XamlType" /> ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée par les appels à <xref:System.Xaml.XamlType.ValueSerializer%2A>.  
  
 L’implémentation par défaut retourne une valeur basée sur la lecture <xref:System.Windows.Markup.ValueSerializerAttribute>. Il peut également vérifier <xref:System.Xaml.XamlType.BaseType%2A> pour l’attribut si aucun attribut n’est trouvé sur le type sous-jacent immédiat. Il inclut également une logique spéciale pour la sérialisation par défaut des énumérations, des types valeur communs ou génériques. Si une valeur n’est pas disponible, retourne `null`.  
  
 Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlType.ValueSerializer%2A> à utiliser une logique différente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionReturnType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType MarkupExtensionReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType MarkupExtensionReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionReturnType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ MarkupExtensionReturnType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionReturnType : System.Xaml.XamlType" Usage="System.Xaml.XamlType.MarkupExtensionReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui fournit les informations de type pour le <see langword="ProvideValue" /> retourné de ce <see cref="T:System.Xaml.XamlType" />, s'il représente une extension de balisage.</summary>
        <value>Objet <see cref="T:System.Xaml.XamlType" /> pour le type de retour pour l'utilisation d'une extension de balisage ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas une extension de balisage.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est uniquement pertinente si ce <xref:System.Xaml.XamlType> représente une extension de balisage (`x:MarkupExtension` figure dans la liste de types assignables).  
  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupMarkupExtensionReturnType%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlType.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de chaîne du type que ce <see cref="T:System.Xaml.XamlType" /> représente.</summary>
        <value>Nom de chaîne de ce type XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient généralement le nom de la construction de schéma (par le <xref:System.Xaml.XamlType.%23ctor%2A> signature), ou le nom de la <xref:System.Type>, s’il est construit à l’aide du constructeur pertinent du système de type CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Equality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="xamlType1 = xamlType2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlType" /> spécifiés ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="xamlType1" /> est égale à la valeur de <paramref name="xamlType2" /> ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlType xamlType1, System.Xaml.XamlType xamlType2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlType xamlType1, class System.Xaml.XamlType xamlType2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.op_Inequality(System.Xaml.XamlType,System.Xaml.XamlType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlType1 As XamlType, xamlType2 As XamlType) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlType ^ xamlType1, System::Xaml::XamlType ^ xamlType2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlType * System.Xaml.XamlType -&gt; bool" Usage="System.Xaml.XamlType.op_Inequality (xamlType1, xamlType2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlType1" Type="System.Xaml.XamlType" />
        <Parameter Name="xamlType2" Type="System.Xaml.XamlType" />
      </Parameters>
      <Docs>
        <param name="xamlType1">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <param name="xamlType2">
          <see cref="T:System.Xaml.XamlType" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlType" /> spécifiés ont des valeurs différentes.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="xamlType1" /> est différente de la valeur de <paramref name="xamlType2" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlType.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'espace de noms XAML unique qui est l'espace de noms XAML principal de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>Identificateur, sous forme de chaîne, de l'espace de noms XAML principal de ce type XAML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation fournit la même valeur que si vous appelez <xref:System.Xaml.XamlType.GetXamlNamespaces%2A> et l’obtention de la première chaîne de valeur à partir du jeu énumérable retourné.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaContext">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlSchemaContext SchemaContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlSchemaContext SchemaContext" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.SchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SchemaContext As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlSchemaContext ^ SchemaContext { System::Xaml::XamlSchemaContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaContext : System.Xaml.XamlSchemaContext" Usage="System.Xaml.XamlType.SchemaContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlSchemaContext" /> actif pour le traitement de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Xaml.XamlSchemaContext" /> actif pour le traitement de ce <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlSchemaContext> est une entrée de paramètre obligatoire lors de la construction d’un <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlType.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlType.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlType" />.</summary>
        <returns>Représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlType> implémentation de <xref:System.Object.ToString%2A> retourne le <xref:System.Xaml.XamlType.Name%2A> propriété de la <xref:System.Xaml.XamlType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimSurroundingWhitespace">
      <MemberSignature Language="C#" Value="public bool TrimSurroundingWhitespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrimSurroundingWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TrimSurroundingWhitespace As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrimSurroundingWhitespace { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.TrimSurroundingWhitespace : bool" Usage="System.Xaml.XamlType.TrimSurroundingWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlType" /> a un comportement de gestion des espaces blancs pour la sérialisation qui tronque l'espace blanc autour du contenu.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Xaml.XamlType" /> représente un type qui utilise la troncation des espaces blancs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupIsWhitespaceSignificantCollection%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeArguments">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt; TypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlType&gt; TypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeArguments As IList(Of XamlType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ TypeArguments { System::Collections::Generic::IList&lt;System::Xaml::XamlType ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeArguments : System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;" Usage="System.Xaml.XamlType.TypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlType&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'arguments de type dans les cas où ce <see cref="T:System.Xaml.XamlType" /> représente un générique.</summary>
        <value>Liste de types d'argument de type ; sinon, <see langword="null" /> si ce <see cref="T:System.Xaml.XamlType" /> ne représente pas un générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe certains scénarios pour un <xref:System.Xaml.XamlType> où l’appel du <xref:System.Xaml.XamlType.TypeArguments%2A> paramètre retourne une liste où les types sont encore ouverts. Dans ce cas, une ou plusieurs des retourné <xref:System.Xaml.XamlType> valeurs ont des valeurs d’espace réservé pour <xref:System.Xaml.XamlType.Name%2A?displayProperty=nameWithType>, tel que `T`, pour indiquer que le générique est toujours ouvert. Ce scénario peut se produire si vous obtenez un <xref:System.Xaml.XamlType> à partir d’un appel à <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A>, au lieu d’une implémentation de lecteur XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlType.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" /> qui représente le comportement de conversion de type pour les valeurs de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" /> qui représente le comportement de conversion de type pour les valeurs de ce <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupTypeConverter%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupTypeConverter%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingType">
      <MemberSignature Language="C#" Value="public Type UnderlyingType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.UnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ UnderlyingType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingType : Type" Usage="System.Xaml.XamlType.UnderlyingType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> CLR sous-jacent de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Type" /> CLR sous-jacent de ce <see cref="T:System.Xaml.XamlType" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlType.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlType.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.Windows.Markup.ValueSerializer" /> qui représente le comportement de sérialisation pour les valeurs de ce <see cref="T:System.Xaml.XamlType" />.</summary>
        <value>
          <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Windows.Markup.ValueSerializer" /> qui représente le comportement de sérialisation pour les valeurs de ce <see cref="T:System.Xaml.XamlType" /> ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous n’utilisez pas la technique de réflexion CLR interne par défaut pour un <xref:System.Xaml.XamlType>, les appels à cette propriété peuvent appeler <xref:System.Xaml.XamlType.LookupValueSerializer%2A> remplace sur <xref:System.Xaml.XamlType> classes dérivées. Pour plus d’informations sur les valeurs de retour et d’autres comportements, consultez la documentation pour <xref:System.Xaml.XamlType.LookupValueSerializer%2A> sur ce type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>