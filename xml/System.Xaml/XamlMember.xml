<Type Name="XamlMember" FullName="System.Xaml.XamlMember">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a5bf358cf5bbfc2549fa0d48319a913cdf514495" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51938067" /></Metadata><TypeSignature Language="C#" Value="public class XamlMember : IEquatable&lt;System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlMember extends System.Object implements class System.IEquatable`1&lt;class System.Xaml.XamlMember&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Xaml.XamlMember" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlMember&#xA;Implements IEquatable(Of XamlMember)" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlMember : IEquatable&lt;System::Xaml::XamlMember ^&gt;" />
  <TypeSignature Language="F#" Value="type XamlMember = class&#xA;    interface IEquatable&lt;XamlMember&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xaml.XamlMember&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fournit l'identificateur du système de type XAML pour les membres de types XAML. L'identificateur est utilisé par les lecteurs et les writers XAML lors du traitement des nœuds membres (lorsque le lecteur XAML est positionné sur un <see cref="F:System.Xaml.XamlNodeType.StartMember" />) de même que pour la logique du système de type XAML général.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xaml.XamlMember> peut utiliser trois méthodes pour retourner des informations relatives à un membre XAML : standard common language runtime (CLR) la réflexion ; une technique de réflexion de référence uniquement appel interne indicateurs de l’API que le bit utilisation optimisée ; ou appelant virtuel substitue de la `Lookup*` API fournie par possible <xref:System.Xaml.XamlMember> sous-classes. Pour la plupart des utilisations de l’API des Services XAML .NET Framework et le <xref:System.Xaml.XamlMember> API, vous utilisez le contexte de schéma XAML par défaut. Le contexte de schéma XAML par défaut pour les Services XAML .NET Framework utilise le stockage pour le système de type CLR. Cela permet des lecteurs XAML et les writers XAML travailler avec n’importe quel type ou membre qui est défini ou disponible pour, le CLR et ses techniques de réflexion.  
  
## <a name="lookup-apis-and-xamlmember-derived-classes"></a>XamlMember et API de recherche de Classes dérivées  
 <xref:System.Xaml.XamlMember> définit plusieurs membres virtuels que les classes dérivées peuvent remplacer. Ces membres ont des noms qui commencent toujours par la chaîne `Lookup`. Le reste de l’API nommer les références à la propriété qui a un impact sur la méthode virtuelle. Par exemple, un <xref:System.Xaml.XamlMember> une classe dérivée peut substituer <xref:System.Xaml.XamlMember.LookupTargetType%2A> pour influencer ce que la propriété définie à la base de <xref:System.Xaml.XamlMember.TargetType%2A> retourne dans une classe dérivée. Vous pouvez prévoir des valeurs de retour de ces propriétés dans <xref:System.Xaml.XamlMember> ou les classes dérivées existantes en lisant la documentation pour les données pertinentes `Lookup*` méthodes.  
  
 L’objectif de la `Lookup*` méthodes consiste à fournir une technique d’extension XAML type système qui incorpore le <xref:System.Xaml.XamlMember> classe de base. En dérivant de <xref:System.Xaml.XamlMember> et en remplaçant le `Lookup` membres virtuels, vous pouvez définir le concept d’un membre XAML pour un schéma XAML dans un système de type XAML sans être lié aux caractéristiques d’un système de type de stockage ou une technologie. Vous pouvez également utiliser un contexte de schéma XAML fourni sous ce schéma et toujours retourner les résultats souhaités.  
  
 Par exemple, considérez le <xref:System.Xaml.XamlMember> propriété <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Cette propriété informe les appelants que les opérations comme l’utilisation d’un <xref:System.Xaml.XamlWriter> pour la sérialisation peut écrire une valeur pour ce membre sur un objet cible. Dans l’implémentation par défaut, la détermination de si le membre est accessible en écriture s’effectue à l’aide de techniques de réflexion par rapport à CLR de sauvegarde <xref:System.Type> et ses membres (le <xref:System.Reflection.MemberInfo>). Par conséquent, par défaut, le système de type XAML dépend du système de type CLR. Toutefois, vous pouvez supprimer cette dépendance pour votre système de type XAML signalant de <xref:System.Xaml.XamlMember.IsWritePublic%2A> en substituant l’API <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A>. Au sein de votre remplacement, vous pouvez utiliser d’autres analyses, tels que les métadonnées qui est spécifique à votre technologie, une table de correspondance maître qui est optimisée pour un vocabulaire XAML fixe, ou une gamme d’autres stratégies pour déterminer si un membre XAML est accessible en écriture dans votre Vocabulaire XAML.  
  
## <a name="constructing-xamlmember-without-xaml-schema-context"></a>Construction de XamlMember sans contexte de schéma XAML  
 La plupart des constructeurs de <xref:System.Xaml.XamlMember> nécessitent un <xref:System.Xaml.XamlSchemaContext> dans le cadre de leur initialisation. Le <xref:System.Xaml.XamlSchemaContext> est également nécessaire pour la plupart interne <xref:System.Xaml.XamlSchemaContext> opérations, telles que l’obtention des informations qui sont transférées à partir du type de sauvegarde. Lorsque vous travaillez avec le <xref:System.Xaml.XamlMember> API, vous devez en général un <xref:System.Xaml.XamlSchemaContext> qui est disponible à partir d’une construction environnante comme un <xref:System.Xaml.XamlWriter>. Dans ce cas, vous pouvez passer le <xref:System.Xaml.XamlSchemaContext> font référence via tous les appels de système de type XAML qui requièrent un contexte de schéma XAML.  
  
 Un constructeur spécifique, <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29>, ne nécessite pas un <xref:System.Xaml.XamlSchemaContext>. Toutefois, un <xref:System.Xaml.XamlMember> qui est construit avec la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement implique <xref:System.Xaml.XamlObjectWriter>, ce membre ne peut pas être écrit dans un graphique d’objet. À l’aide de l’implémentation des services .NET Framework XAML, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque le pertinentes <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> qui a comme valeur `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres façons d’ajuster le <xref:System.Xaml.XamlObjectWriter> comportement. Par exemple, un ou plusieurs des éléments suivants peuvent être true de votre implémentation :  
  
-   Le contexte de schéma XAML est disponible plus tard.  
  
-   Vous utilisez un modèle de demandeur de membre.  
  
-   Vous substituez délibérément <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> dans un writer XAML personnalisé.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlType" />
    <altmember cref="T:System.Xaml.XamlDirective" />
    <altmember cref="T:System.Xaml.XamlObjectWriter" />
    <related type="Article" href="https://msdn.microsoft.com/library/7c11abec-1075-474c-9d9b-778e5dab21c3">Fonctionnement des concepts et structures du flux de nœud XAML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Système de type CLR <see cref="T:System.Reflection.EventInfo" /> qui représente le membre d'événement.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.EventInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un événement (propriété point de connexion de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> qui représente le membre de propriété.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente une propriété (et en particulier n’est pas une connexion de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.EventInfo eventInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.EventInfo eventInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.EventInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::EventInfo ^ eventInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.EventInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (eventInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventInfo" Type="System.Reflection.EventInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="eventInfo">Système de type CLR <see cref="T:System.Reflection.EventInfo" /> qui représente le membre d'événement.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec le système de type CLR <see cref="T:System.Reflection.EventInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un événement (ou une point de connexion de propriété de gestionnaire d’événements).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (System.Reflection.PropertyInfo propertyInfo, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Reflection.PropertyInfo propertyInfo, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.Reflection.PropertyInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::Reflection::PropertyInfo ^ propertyInfo, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : System.Reflection.PropertyInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (propertyInfo, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyInfo" Type="System.Reflection.PropertyInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="propertyInfo">Système de type CLR <see cref="T:System.Reflection.PropertyInfo" /> qui représente le membre de propriété.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> avec la réflexion <see cref="T:System.Reflection.PropertyInfo" /> et un <see cref="T:System.Xaml.XamlSchemaContext" />, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur uniquement si le membre représente une propriété et si elle n’est pas une connexion de gestionnaire d’événements.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nom sous forme de chaîne de l'événement pouvant être attaché.</param>
        <param name="adder"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour la méthode <see langword="Add" /> du gestionnaire de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente un événement pouvant être attaché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre d’événement pouvant être attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string name, System.Xaml.XamlType declaringType, bool isAttachable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Xaml.XamlType declaringType, bool isAttachable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, declaringType As XamlType, isAttachable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ name, System::Xaml::XamlType ^ declaringType, bool isAttachable);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Xaml.XamlType * bool -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (name, declaringType, isAttachable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="declaringType" Type="System.Xaml.XamlType" />
        <Parameter Name="isAttachable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nom sous forme de chaîne du membre.</param>
        <param name="declaringType">Informations <see cref="T:System.Xaml.XamlType" /> pour le type déclarant.</param>
        <param name="isAttachable"><see langword="true" /> pour indiquer que le membre peut être attaché ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" />, en utilisant un nom de chaîne et des informations sur le <see cref="T:System.Xaml.XamlType" /> déclarant. Un <see cref="T:System.Xaml.XamlMember" /> construit avec cette signature présente des limitations importantes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xaml.XamlMember> qui est construit avec la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement implique <xref:System.Xaml.XamlObjectWriter>, ce membre ne peut pas être écrit dans un graphique d’objet. À l’aide de l’implémentation de Services XAML du .NET Framework, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque le pertinentes <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> avec <xref:System.Xaml.XamlMember.IsUnknown%2A> `true` , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres façons d’ajuster le <xref:System.Xaml.XamlObjectWriter> comportement. Par exemple, un ou plusieurs des éléments suivants peuvent être true de votre implémentation :  
  
-   Le contexte de schéma XAML est disponible plus tard.  
  
-   Vous utilisez un modèle de demandeur de membre.  
  
-   Vous substituez délibérément <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> dans un writer XAML personnalisé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ou <paramref name="declaringType" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nom sous forme de chaîne de la propriété pouvant être attachée.</param>
        <param name="getter"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="get" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="setter"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="set" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente une propriété pouvant être jointe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente une propriété pouvant être attachée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachableEventName, System.Reflection.MethodInfo adder, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachableEventName, class System.Reflection.MethodInfo adder, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachableEventName As String, adder As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachableEventName, System::Reflection::MethodInfo ^ adder, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachableEventName, adder, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachableEventName" Type="System.String" />
        <Parameter Name="adder" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachableEventName">Nom sous forme de chaîne de l'événement pouvant être attaché.</param>
        <param name="adder"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour la méthode <see langword="Add" /> du gestionnaire de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente un événement pouvant être attaché, notamment des informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre d’événement pouvant être attaché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlMember (string attachablePropertyName, System.Reflection.MethodInfo getter, System.Reflection.MethodInfo setter, System.Xaml.XamlSchemaContext schemaContext, System.Xaml.Schema.XamlMemberInvoker invoker);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string attachablePropertyName, class System.Reflection.MethodInfo getter, class System.Reflection.MethodInfo setter, class System.Xaml.XamlSchemaContext schemaContext, class System.Xaml.Schema.XamlMemberInvoker invoker) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.#ctor(System.String,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Xaml.XamlSchemaContext,System.Xaml.Schema.XamlMemberInvoker)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (attachablePropertyName As String, getter As MethodInfo, setter As MethodInfo, schemaContext As XamlSchemaContext, invoker As XamlMemberInvoker)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlMember(System::String ^ attachablePropertyName, System::Reflection::MethodInfo ^ getter, System::Reflection::MethodInfo ^ setter, System::Xaml::XamlSchemaContext ^ schemaContext, System::Xaml::Schema::XamlMemberInvoker ^ invoker);" />
      <MemberSignature Language="F#" Value="new System.Xaml.XamlMember : string * System.Reflection.MethodInfo * System.Reflection.MethodInfo * System.Xaml.XamlSchemaContext * System.Xaml.Schema.XamlMemberInvoker -&gt; System.Xaml.XamlMember" Usage="new System.Xaml.XamlMember (attachablePropertyName, getter, setter, schemaContext, invoker)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="attachablePropertyName" Type="System.String" />
        <Parameter Name="getter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="setter" Type="System.Reflection.MethodInfo" />
        <Parameter Name="schemaContext" Type="System.Xaml.XamlSchemaContext" />
        <Parameter Name="invoker" Type="System.Xaml.Schema.XamlMemberInvoker" />
      </Parameters>
      <Docs>
        <param name="attachablePropertyName">Nom sous forme de chaîne de la propriété pouvant être attachée.</param>
        <param name="getter"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="get" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="setter"><see cref="T:System.Reflection.MethodInfo" /> du système de type CLR pour l'accesseur <see langword="set" /> de l'implémentation de stockage du membre pouvant être attaché.</param>
        <param name="schemaContext">Contexte <see cref="T:System.Xaml.XamlSchemaContext" /> qui qualifie le membre.</param>
        <param name="invoker">Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> qui gère les appels de réflexion au moment de l'exécution en fonction du <see cref="T:System.Xaml.XamlMember" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Xaml.XamlMember" /> pour un <see cref="T:System.Xaml.XamlMember" /> qui représente une propriété pouvant être jointe, notamment les informations sur <see cref="T:System.Xaml.Schema.XamlMemberInvoker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez ce constructeur si le membre représente un membre de propriété pouvant être attachée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeclaringType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ DeclaringType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type qui déclare le membre associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> du type qui déclare le membre associé à ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est généralement définie lors de l’initialisation et n’est généralement pas `null`.  
  
> [!IMPORTANT]
>  <xref:System.Xaml.XamlMember.DeclaringType%2A> informations peuvent être passées par les constructeurs pour l’initialisation. En appelant directement les constructeurs de base, l’initialisation pour <xref:System.Xaml.XamlMember> classes dérivées peuvent omettre certaines les vérifications de valeur qui sont effectuées dans la classe de base. Par conséquent, l’initialisation dérivée peut modifier les informations de relation de membre de type signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations de système de type de sa déclaration CLR sous-jacente. Pour les vérifications critiques de sécurité de la déclaration des informations de type, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeferringLoader">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; DeferringLoader { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; DeferringLoader" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeferringLoader As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ DeferringLoader { System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeferringLoader : System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="System.Xaml.XamlMember.DeferringLoader" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> utilisé pour le chargement différé des objets XAML déclarés.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.DeferringLoader%2A> appelle <xref:System.Xaml.XamlMember.LookupDeferringLoader%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les cas où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DependsOn">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; DependsOn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; DependsOn" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.DependsOn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependsOn As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ DependsOn { System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DependsOn : System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="System.Xaml.XamlMember.DependsOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une liste d'objets <see cref="T:System.Xaml.XamlMember" />. Cette liste répertorie les membres pour lesquels il existe des relations de dépendance pour l'ordre d'initialisation concernant ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Liste d'objets <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.DependsOn%2A> appelle <xref:System.Xaml.XamlMember.LookupDependsOn%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les cas où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Le `DependsOn` modèle peut être appliqué aux cas de modèle objet délibérément contredisent une règle XAML générale. La règle XAML générale est que les membres d’un type qui ne sont pas transmis en tant que texte d’initialisation (ou par une méthode de fabrique dans XAML 2009) doivent pouvoir être assigné dans n’importe quel ordre. En appliquant un `DependsOn` de modèle à un membre, vous pouvez indiquer les writers XAML à traiter toujours le membre référencé avant ce membre. Vous pouvez appliquer ce modèle dans les situations où la valeur du membre actuel requiert le contexte ou autres informations qui sont disponibles uniquement après que l’autre membre est défini.  
  
 Le `DependsOn` modèle doit être appliqué judicieusement et réservé pour les scénarios de propriété où il sert un but architectural. Grand nombre de dépendances est susceptibles de ralentir le traitement de XAML. En outre, il est possible de produire des dépendances circulaires, auquel cas le comportement de traitement XAML n’est pas défini.  
  
 Exemple `DependsOn` scénarios de WPF incluent certaines propriétés sur <xref:System.Windows.Controls.ControlTemplate> et <xref:System.Windows.DataTemplate>, dans <xref:System.Windows.Trigger>, puis, dans <xref:System.Windows.Setter>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.DependsOnAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xamlMember.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actif est égal à un autre objet.</summary>
        <returns><see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="obj" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Xaml.XamlMember other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Xaml.XamlMember other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.Equals(System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Xaml::XamlMember ^ other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Xaml.XamlMember -&gt; bool" Usage="xamlMember.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à cet objet.</param>
        <summary>Indique si l'objet actuel est égal à un autre objet du même type.</summary>
        <returns><see langword="true" /> si l'objet actuel est égal au paramètre <paramref name="other" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xamlMember.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cet objet.</summary>
        <returns>Code de hachage entier.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXamlNamespaces">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;string&gt; GetXamlNamespaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;string&gt; GetXamlNamespaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.GetXamlNamespaces" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetXamlNamespaces () As IList(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::String ^&gt; ^ GetXamlNamespaces();" />
      <MemberSignature Language="F#" Value="abstract member GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;&#xA;override this.GetXamlNamespaces : unit -&gt; System.Collections.Generic.IList&lt;string&gt;" Usage="xamlMember.GetXamlNamespaces " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste d'espaces de noms XAML dans lesquels ce membre XAML peut exister.</summary>
        <returns>Liste d'identificateurs d'espace de noms XAML sous forme de chaînes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne la <xref:System.Xaml.XamlType.GetXamlNamespaces%2A?displayProperty=nameWithType> résultat à partir de l’appel le <xref:System.Xaml.XamlMember.DeclaringType%2A> qui est associé à ce <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoker">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlMemberInvoker Invoker { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlMemberInvoker Invoker" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Invoker" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Invoker As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlMemberInvoker ^ Invoker { System::Xaml::Schema::XamlMemberInvoker ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Invoker : System.Xaml.Schema.XamlMemberInvoker" Usage="System.Xaml.XamlMember.Invoker" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Implémentation de <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associée à ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Invoker` modèle est une technique d’extension de système de type XAML avancée. Le `Invoker` modèle offre un moyen pour injecter le comportement de mappage de type de schéma différent, tout en utilisant les définitions de système de type XAML de Services XAML du .NET Framework.  
  
 Si un <xref:System.Xaml.XamlMember.LookupInvoker%2A> remplacer retourne `null`, ou si l’implémentation par défaut retourne `null` , car il lui manque le <xref:System.Xaml.XamlMember.UnderlyingMember%2A> pour ce <xref:System.Xaml.XamlMember>, le <xref:System.Xaml.XamlMember.Invoker%2A> retourne de la propriété <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType>.  
  
 <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> est la valeur par défaut. Cela est vrai pour la plupart des opérations qui utilisent les Services XAML .NET Framework et le contexte de schéma XAML par défaut, et où aucune spécifiques à substituer `Invoker` modèles sont passés pour la construction d’entités de système de type XAML.  
  
 Appel <xref:System.Xaml.XamlMember.Invoker%2A> appelle <xref:System.Xaml.XamlMember.LookupInvoker%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAmbient">
      <MemberSignature Language="C#" Value="public bool IsAmbient { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAmbient" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAmbient" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAmbient As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAmbient { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAmbient : bool" Usage="System.Xaml.XamlMember.IsAmbient" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.IsAmbient%2A> appelle <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit dans les implémentations où la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Recherche des propriétés ambiantes est sont généralement partie de la logique de traitement XAML pour vous assurer que les objets et valeurs qui reposent sur l’utilisation de qualification de type peuvent fonctionner correctement. Les API des Services XAML .NET Framework et le contexte de schéma XAML par défaut remplissent cette valeur selon attribution avec <xref:System.Windows.Markup.AmbientAttribute>. L’implémentation par défaut de <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> utilise cette existant <xref:System.Windows.Markup.AmbientAttribute> technique et elle retourne `true` si <xref:System.Windows.Markup.AmbientAttribute> existe sur une déclaration de membre.  
  
 <xref:System.Windows.Markup.AmbientAttribute> se trouve sur les membres de plusieurs types WPF, qui incluent <xref:System.Windows.Application>, <xref:System.Windows.Setter>, et <xref:System.Windows.Style>. Il se trouve également sur le <xref:System.Windows.ResourceDictionary> type, ce qui signifie que n’importe quel membre qui utilise <xref:System.Windows.ResourceDictionary> comme son type doit être considéré comme ambiant même si le membre n’est pas attribué spécifiquement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="IsAttachable">
      <MemberSignature Language="C#" Value="public bool IsAttachable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAttachable" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsAttachable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAttachable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAttachable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAttachable : bool" Usage="System.Xaml.XamlMember.IsAttachable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est un membre pouvant être attaché.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est un membre pouvant être attaché ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsAttachable%2A> valeur est initialisée selon le constructeur utilisé pour construire un <xref:System.Xaml.XamlMember>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirective">
      <MemberSignature Language="C#" Value="public bool IsDirective { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirective" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsDirective" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirective As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirective { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirective : bool" Usage="System.Xaml.XamlMember.IsDirective" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est une directive XAML.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est une directive XAML ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsDirective%2A> valeur est initialisée selon le constructeur utilisé pour construire un <xref:System.Xaml.XamlMember>. La base de <xref:System.Xaml.XamlMember> constructeurs initialisent afin que <xref:System.Xaml.XamlMember.IsDirective%2A> est `false`. Toutefois, le <xref:System.Xaml.XamlDirective> classe (une <xref:System.Xaml.XamlMember> classe dérivée) initialise afin que <xref:System.Xaml.XamlMember.IsDirective%2A> est `true`.  
  
 Si vous souhaitez signaler <xref:System.Xaml.XamlMember.IsDirective%2A> comme `true` aux appelants d’une classe de schéma XAML personnalisée pour les membres XAML, assurez-vous que vous dérivez de <xref:System.Xaml.XamlDirective> parce que c’est la seule façon d’activer ce comportement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvent">
      <MemberSignature Language="C#" Value="public bool IsEvent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEvent" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsEvent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEvent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEvent : bool" Usage="System.Xaml.XamlMember.IsEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre d'événement.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un événement ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.IsEvent%2A> appelle <xref:System.Xaml.XamlMember.LookupIsEvent%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNameValid">
      <MemberSignature Language="C#" Value="public bool IsNameValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNameValid" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsNameValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNameValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNameValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNameValid : bool" Usage="System.Xaml.XamlMember.IsNameValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> est initialisé avec une chaîne <see langword="xamlName" /> valide en tant que <see cref="P:System.Xaml.XamlMember.Name" />.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> est initialisé avec une chaîne <see langword="xamlName" /> valide ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Xaml.XamlMember.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en lecture seule.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en lecture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.IsReadOnly%2A> appelle <xref:System.Xaml.XamlMember.LookupIsReadOnly%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadPublic">
      <MemberSignature Language="C#" Value="public bool IsReadPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadPublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadPublic : bool" Usage="System.Xaml.XamlMember.IsReadPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre avec un accesseur <see langword="get" /> public pouvant être appelé.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un accesseur <see langword="get" /> public pouvant être appelé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsReadPublic%2A> valeur vérifie si le <xref:System.Xaml.XamlMember.DeclaringType%2A> est public. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> n’est pas public, le `get` l’accesseur n’est pas pouvant être appelé de manière pratique et <xref:System.Xaml.XamlMember.IsReadPublic%2A> retourne `false`.  
  
 Appel <xref:System.Xaml.XamlMember.IsReadPublic%2A> appelle <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> ou une substitution spécifique de cette méthode.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> méthode est virtuelle et par conséquent, peut être substituée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations d’accès de type système de sa déclaration CLR sous-jacente. Pour les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnknown">
      <MemberSignature Language="C#" Value="public bool IsUnknown { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnknown" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsUnknown" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnknown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnknown { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnknown : bool" Usage="System.Xaml.XamlMember.IsUnknown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le membre ne peut pas être résolu par le système de stockage utilisé pour la résolution du type et du membre.</summary>
        <value><see langword="true" /> si le membre ne peut pas être résolu ; <see langword="false" /> si le membre peut être résolu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Xaml.XamlMember> qui est construit avec la <xref:System.Xaml.XamlMember.%23ctor%28System.String%2CSystem.Xaml.XamlType%2CSystem.Boolean%29> signature retourne `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Pour un chemin de chargement implique <xref:System.Xaml.XamlObjectWriter>, un <xref:System.Xaml.XamlMember> avec `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> ne peut pas être écrit dans un graphique d’objet. Sous les implémentations par défaut dans les API des Services XAML .NET Framework, le <xref:System.Xaml.XamlObjectWriter.WriteStartMember%2A?displayProperty=nameWithType> appeler lève une <xref:System.Xaml.XamlObjectWriterException> lorsque le pertinentes <xref:System.Xaml.XamlMember> rapports `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A>.  
  
 Vous ne devez pas construire un <xref:System.Xaml.XamlMember> qui a comme valeur `true` pour <xref:System.Xaml.XamlMember.IsUnknown%2A> , sauf si votre implémentation peut gérer les exceptions de <xref:System.Xaml.XamlObjectWriter>, ou vous avez d’autres façons d’ajuster le <xref:System.Xaml.XamlObjectWriter> comportement.  
  
 Appel <xref:System.Xaml.XamlMember.IsUnknown%2A> appelle <xref:System.Xaml.XamlMember.LookupIsUnknown%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriteOnly">
      <MemberSignature Language="C#" Value="public bool IsWriteOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriteOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriteOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriteOnly : bool" Usage="System.Xaml.XamlMember.IsWriteOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.IsWriteOnly%2A> appelle <xref:System.Xaml.XamlMember.LookupIsWriteOnly%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWritePublic">
      <MemberSignature Language="C#" Value="public bool IsWritePublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWritePublic" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.IsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWritePublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWritePublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWritePublic : bool" Usage="System.Xaml.XamlMember.IsWritePublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public pouvant être appelé.</summary>
        <value><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un accesseur <see langword="set" /> public pouvant être appelé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.IsWritePublic%2A> valeur considère que si le <xref:System.Xaml.XamlMember.DeclaringType%2A> est public dans le cadre de la détermination. Si <xref:System.Xaml.XamlMember.DeclaringType%2A> n’est pas public, le `set` l’accesseur n’est pas pouvant être appelé de manière pratique et <xref:System.Xaml.XamlMember.IsWritePublic%2A> retourne `false`.  
  
 Appel <xref:System.Xaml.XamlMember.IsWritePublic%2A> appelle <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> ou une substitution spécifique de cette méthode.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> méthode est virtuelle et par conséquent, peut être substituée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations d’accès de type système de sa déclaration CLR sous-jacente. Pour les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupCustomAttributeProvider">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ICustomAttributeProvider LookupCustomAttributeProvider() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupCustomAttributeProvider" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupCustomAttributeProvider () As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::ICustomAttributeProvider ^ LookupCustomAttributeProvider();" />
      <MemberSignature Language="F#" Value="abstract member LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider&#xA;override this.LookupCustomAttributeProvider : unit -&gt; System.Reflection.ICustomAttributeProvider" Usage="xamlMember.LookupCustomAttributeProvider " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas d'implémentation dans une classe dérivée, retourne une implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" />.</summary>
        <returns>Implémentation de <see cref="T:System.Reflection.ICustomAttributeProvider" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituez cette méthode pour fournir la réflexion interne avec une autre manière d’obtenir les valeurs d’attribut CLR. En l’absence d’une substitution, le réflecteur interne utilise la logique de réflexion CLR typique comme les appels à <xref:System.Reflection.CustomAttributeData.GetCustomAttributes%2A>.  
  
 L'implémentation par défaut retourne la valeur `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupDeferringLoader">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Xaml.XamlDeferringLoader&gt; LookupDeferringLoader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDeferringLoader" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDeferringLoader () As XamlValueConverter(Of XamlDeferringLoader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Xaml::XamlDeferringLoader ^&gt; ^ LookupDeferringLoader();" />
      <MemberSignature Language="F#" Value="abstract member LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;&#xA;override this.LookupDeferringLoader : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;" Usage="xamlMember.LookupDeferringLoader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Xaml.XamlDeferringLoader&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, lequel est utilisé pour le chargement différé des objets XAML déclarés.</summary>
        <returns><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> qui a une contrainte <see cref="T:System.Xaml.XamlDeferringLoader" /> sur le générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur comprise entre le <xref:System.Xaml.XamlMember.DeferringLoader%2A> propriété. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.DeferringLoader%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 L’implémentation par défaut retourne un objet en lisant <xref:System.Windows.Markup.XamlDeferLoadAttribute> ou en utilisant un <xref:System.Xaml.XamlDeferringLoader> à partir du type déclarant. Si aucun objet n’est disponible, cette méthode peut retourner `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DeferringLoader" />
      </Docs>
    </Member>
    <Member MemberName="LookupDependsOn">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt; LookupDependsOn ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Xaml.XamlMember&gt; LookupDependsOn() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupDependsOn" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupDependsOn () As IList(Of XamlMember)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IList&lt;System::Xaml::XamlMember ^&gt; ^ LookupDependsOn();" />
      <MemberSignature Language="F#" Value="abstract member LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;&#xA;override this.LookupDependsOn : unit -&gt; System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;" Usage="xamlMember.LookupDependsOn " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Xaml.XamlMember&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une liste d'objets <see cref="T:System.Xaml.XamlMember" />. Cette liste répertorie les membres pour lesquels il existe des relations de dépendance pour l'ordre d'initialisation concernant ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Liste d'objets <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur comprise entre le <xref:System.Xaml.XamlMember.DependsOn%2A> propriété. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.DependsOn%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 Les implémentations de lecteur et writer WPF XAML ce cas l’attribut <xref:System.Windows.Markup.DependsOnAttribute>. L’implémentation par défaut utilise cette existant <xref:System.Windows.Markup.DependsOnAttribute> technique.  
  
 Substituez cette méthode si vous n’utilisez pas <xref:System.Windows.Markup.DependsOnAttribute> pour cet objectif et prévoyez de remplacer cette technique pour indiquer l’ordre de traitement de la propriété par votre propre technique. Si vous ne souhaitez pas prendre en charge un ordre de traitement de propriété, vous pouvez utiliser l’implémentation par défaut, car il ne retourne aucun résultat, ce qui convient.  
  
 La liste est en lecture seule.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
      </Docs>
    </Member>
    <Member MemberName="LookupInvoker">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlMemberInvoker LookupInvoker ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlMemberInvoker LookupInvoker() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupInvoker" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupInvoker () As XamlMemberInvoker" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlMemberInvoker ^ LookupInvoker();" />
      <MemberSignature Language="F#" Value="abstract member LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker&#xA;override this.LookupInvoker : unit -&gt; System.Xaml.Schema.XamlMemberInvoker" Usage="xamlMember.LookupInvoker " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlMemberInvoker</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Informations <see cref="T:System.Xaml.Schema.XamlMemberInvoker" /> pour ce <see cref="T:System.Xaml.XamlMember" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par les appels à <xref:System.Xaml.XamlMember.Invoker%2A>.  
  
 L’implémentation par défaut n’exige pas un <xref:System.Xaml.XamlMember> être construite à l’aide d’un des constructeurs qui passent un initial <xref:System.Xaml.Schema.XamlMemberInvoker>. Toutefois, un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> valeur doit exister pour le <xref:System.Xaml.XamlMember>; sinon, retourne l’implémentation par défaut `null`.  
  
 Substituez cette méthode si vous dérivez également de <xref:System.Xaml.Schema.XamlMemberInvoker> et souhaitez retourner la classe dérivée. Si vous retournez `null`, <xref:System.Xaml.XamlMember.Invoker%2A> retourne <xref:System.Xaml.Schema.XamlMemberInvoker.UnknownInvoker%2A?displayProperty=nameWithType> aux appelants.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Invoker" />
        <altmember cref="T:System.Xaml.Schema.XamlMemberInvoker" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsAmbient">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsAmbient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsAmbient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsAmbient" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsAmbient () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsAmbient();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsAmbient : unit -&gt; bool&#xA;override this.LookupIsAmbient : unit -&gt; bool" Usage="xamlMember.LookupIsAmbient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> est signalé comme étant une propriété ambiante.</summary>
        <returns><see langword="true" /> pour signaler ce <see cref="T:System.Xaml.XamlMember" /> comme une propriété ambiante ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par les appels internes qui vérifient les informations de propriété XAML ambiantes. Comportement de la propriété ambiante est comptabilisée dans le comportement de l’API publique de lecteurs XAML et les writers XAML. Les appels internes qui référencent <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> font généralement partie de la logique de traitement XAML pour vous assurer que les objets et valeurs qui reposent sur l’utilisation de qualification de type peuvent fonctionner correctement. L’implémentation de Services XAML du .NET Framework par défaut utilise l’attribution CLR pour obtenir ces informations à partir de la réflexion sur les types de stockage. Plus précisément, l’implémentation par défaut recherche <xref:System.Windows.Markup.AmbientAttribute> et retourne `true` pour <xref:System.Xaml.XamlMember.LookupIsAmbient%2A> si <xref:System.Windows.Markup.AmbientAttribute> existe sur une définition de membre.  
  
 Substituez cette méthode si vous n’utilisez pas <xref:System.Windows.Markup.AmbientAttribute> pour cet objectif et prévoyez de remplacer cette technique d’indication des propriétés XAML ambiantes par votre propre technique.  
  
 Exemples d’API de WPF cet attribut avec <xref:System.Windows.Markup.AmbientAttribute> sont <xref:System.Windows.Trigger.Property%2A?displayProperty=nameWithType> et <xref:System.Windows.Style.BasedOn%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.AmbientAttribute" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsEvent">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsEvent" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsEvent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsEvent();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsEvent : unit -&gt; bool&#xA;override this.LookupIsEvent : unit -&gt; bool" Usage="xamlMember.LookupIsEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un événement.</summary>
        <returns><see langword="true" /> pour signaler que ce <see cref="T:System.Xaml.XamlMember" /> représente un événement ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut vérifie si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> est de type <xref:System.Reflection.EventInfo>et si tel est le cas, renvoie `true`.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsEvent%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées qui peuvent être interprétée pour déterminer le XAML des représentations de système de types au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsEvent" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadOnly : unit -&gt; bool&#xA;override this.LookupIsReadOnly : unit -&gt; bool" Usage="xamlMember.LookupIsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété en lecture seule escomptée.</summary>
        <returns><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété prévue en lecture seule ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `true` si <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe, mais un public `set` accesseur n’existe pas, comme déterminé par réflexion interne.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsReadOnly%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées qui peuvent être interprétée pour déterminer le XAML des représentations de système de types au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsReadPublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsReadPublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsReadPublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsReadPublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsReadPublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsReadPublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsReadPublic : unit -&gt; bool&#xA;override this.LookupIsReadPublic : unit -&gt; bool" Usage="xamlMember.LookupIsReadPublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété qui a un accesseur <see langword="get" /> public.</summary>
        <returns><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente une propriété comportant un accesseur <see langword="get" /> public ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne des résultats basés sur une réflexion interne ou de la négation de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>, dans cet ordre.  
  
 <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> Retourne si le membre lui-même est public ; elle retourne `true` pour un membre public sur un nonpublic type déclarant. Utilisez <xref:System.Xaml.XamlMember.IsReadPublic%2A> au lieu de cela, si vous voulez également à prendre en compte la visibilité du type déclarant.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsReadPublic%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsReadPublic%2A> méthode est virtuelle et par conséquent, peut être substituée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations d’accès de type système de sa déclaration CLR sous-jacente. Pour les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsReadPublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsUnknown">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsUnknown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsUnknown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsUnknown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsUnknown () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsUnknown();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsUnknown : unit -&gt; bool&#xA;override this.LookupIsUnknown : unit -&gt; bool" Usage="xamlMember.LookupIsUnknown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre qui ne peut pas être résolu par le système de stockage utilisé pour la résolution du type et du membre.</summary>
        <returns><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre qui ne peut pas être résolu ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsUnknown%2A>. L’implémentation par défaut retourne des résultats qui sont basés sur la réflexion interne ou sur la recherche pour un `null` valeur <xref:System.Xaml.XamlMember.UnderlyingMember%2A>, dans cet ordre.  
  
 Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsUnknown" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWriteOnly">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWriteOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWriteOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWriteOnly" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWriteOnly () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWriteOnly();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWriteOnly : unit -&gt; bool&#xA;override this.LookupIsWriteOnly : unit -&gt; bool" Usage="xamlMember.LookupIsWriteOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public mais pas d'accesseur <see langword="get" /> public.</summary>
        <returns><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre en écriture seule ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne `true` si un <xref:System.Xaml.XamlMember.UnderlyingMember%2A> existe qui a un public `set` accesseur et un nonpublic `get` accesseur, tel que déterminé par la réflexion interne.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsWriteOnly%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWriteOnly" />
      </Docs>
    </Member>
    <Member MemberName="LookupIsWritePublic">
      <MemberSignature Language="C#" Value="protected virtual bool LookupIsWritePublic ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool LookupIsWritePublic() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupIsWritePublic" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupIsWritePublic () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool LookupIsWritePublic();" />
      <MemberSignature Language="F#" Value="abstract member LookupIsWritePublic : unit -&gt; bool&#xA;override this.LookupIsWritePublic : unit -&gt; bool" Usage="xamlMember.LookupIsWritePublic " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur indiquant si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre comportant un accesseur <see langword="set" /> public.</summary>
        <returns><see langword="true" /> si ce <see cref="T:System.Xaml.XamlMember" /> représente un membre accessible en écriture ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne des résultats basés sur la réflexion interne ou la négation de <xref:System.Xaml.XamlMember.IsReadOnly%2A>, dans cet ordre.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.IsWritePublic%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
> [!IMPORTANT]
>  Le <xref:System.Xaml.XamlMember.LookupIsWritePublic%2A> méthode est virtuelle et par conséquent, peut être substituée. La substitution a la possibilité de modifier (à des fins malveillantes ou autre) les informations d’accès signalées d’un membre XAML afin qu’il ne s’aligne plus comme prévu avec les informations d’accès de type système de sa déclaration CLR sous-jacente. Pour les vérifications critiques de sécurité des niveaux d’accès, utilisez à la place le type CLR sous-jacent.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.IsWritePublic" />
      </Docs>
    </Member>
    <Member MemberName="LookupMarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; LookupMarkupExtensionBracketCharacters ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; LookupMarkupExtensionBracketCharacters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupMarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupMarkupExtensionBracketCharacters () As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ LookupMarkupExtensionBracketCharacters();" />
      <MemberSignature Language="F#" Value="abstract member LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;&#xA;override this.LookupMarkupExtensionBracketCharacters : unit -&gt; System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="xamlMember.LookupMarkupExtensionBracketCharacters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le crochet ouvrant et le crochet fermant d’une extension de balisage.</summary>
        <returns>Collection contenant le crochet ouvrant et le crochet fermant.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupTargetType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupTargetType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupTargetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTargetType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTargetType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupTargetType();" />
      <MemberSignature Language="F#" Value="abstract member LookupTargetType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupTargetType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupTargetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Xaml.XamlType" /> du type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</summary>
        <returns>Type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut fait la distinction entre les membres pouvant être attachées et non pouvant être attachée. Pour les membres non pouvant être attachée, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne toujours <xref:System.Xaml.XamlMember.DeclaringType%2A>. Pour les membres pouvant être attachées, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne un résultat basé sur l’examen de la <xref:System.Xaml.XamlMember.UnderlyingMember%2A> type de paramètre d’accesseur et interprète ce type basé sur le contexte de schéma XAML.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.TargetType%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TargetType" />
      </Docs>
    </Member>
    <Member MemberName="LookupType">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.XamlType LookupType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.XamlType LookupType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupType () As XamlType" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::XamlType ^ LookupType();" />
      <MemberSignature Language="F#" Value="abstract member LookupType : unit -&gt; System.Xaml.XamlType&#xA;override this.LookupType : unit -&gt; System.Xaml.XamlType" Usage="xamlMember.LookupType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</summary>
        <returns><see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.Type%2A>. Substituez cette méthode si vous souhaitez <xref:System.Xaml.XamlMember.Type%2A> pour retourner une valeur différente de celle qui est activée par la réflexion interne par défaut, et si vous fournissez également personnalisé <xref:System.Xaml.Schema.XamlMemberInvoker> plus d’informations.  
  
 L’implémentation par défaut utilise différents chemins de code et concepts pour retourné <xref:System.Xaml.XamlType> qui est selon que cela <xref:System.Xaml.XamlMember> représente une propriété, une méthode ou un événement.  
  
-   Pour une propriété, retournée <xref:System.Xaml.XamlType> est le type qui définit la propriété ou qui est retourné par la propriété.  
  
-   Pour un événement, retourné <xref:System.Xaml.XamlType> est le type de gestionnaire d’événements requis (il s’agit d’un délégué dans une implémentation CLR).  
  
-   Pour une méthode, <xref:System.Xaml.XamlType> est le type de retour.  
  
 Dans chaque cas, le contexte de schéma XAML est utilisé pour évaluer le type XAML à partir du type de système sous-jacent.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.Type%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.Type" />
      </Docs>
    </Member>
    <Member MemberName="LookupTypeConverter">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; LookupTypeConverter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; LookupTypeConverter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupTypeConverter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupTypeConverter () As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ LookupTypeConverter();" />
      <MemberSignature Language="F#" Value="abstract member LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;&#xA;override this.LookupTypeConverter : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="xamlMember.LookupTypeConverter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une implémentation de convertisseur de type qui est associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instance de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut utilise la logique suivante et ordre de traitement :  
  
-   Si l’attribution existe au niveau du membre (<xref:System.ComponentModel.TypeConverterAttribute>), les informations d’attribut sont utilisées pour un appel à <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> par rapport au contexte de schéma XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> est valide, un convertisseur de type qui est associé au type est retourné.  
  
-   Si le membre est un événement, un convertisseur de type spécifique à l’événement est retourné.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.TypeConverter%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingGetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingGetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingGetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingGetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingGetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingGetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingGetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingGetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un accesseur <see langword="get" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> pour l'accesseur <see langword="get" /> associé , sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut interprète le <xref:System.Xaml.XamlMember.UnderlyingMember%2A> propriété en tant que <xref:System.Reflection.PropertyInfo> et retourne la valeur de <xref:System.Reflection.PropertyInfo.GetGetMethod%2A?displayProperty=nameWithType> (avec le paramètre défini sur `true`), ce qui signifie que la méthode retournée peut être non public. Ce comportement peut provoquer des `null` dans certains cas. y compris les cas où aucun accesseur associé n’existe ou le membre n’est pas une propriété.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de la <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingGetter%2A> propriété associé à un <xref:System.Xaml.Schema.XamlMemberInvoker>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin qu’elles retournent toutes résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingMember">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MemberInfo LookupUnderlyingMember ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MemberInfo LookupUnderlyingMember() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingMember () As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MemberInfo ^ LookupUnderlyingMember();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo&#xA;override this.LookupUnderlyingMember : unit -&gt; System.Reflection.MemberInfo" Usage="xamlMember.LookupUnderlyingMember " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un <see cref="T:System.Reflection.MemberInfo" /> de système de type CLR associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Objet <see cref="T:System.Reflection.MemberInfo" /> de système de type CLR associé à ce <see cref="T:System.Xaml.XamlMember" /> ; sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne les informations de membre sous-jacent, qui repose sur la construction. Si le <xref:System.Reflection.MemberInfo> objet est construit avec une signature qui ne fournit pas suffisamment d’informations pour définir le membre sous-jacent, cette méthode retourne `null`.  
  
 Si un membre sous-jacent a été défini pendant la construction, vous ne devez pas appeler cette méthode.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.UnderlyingMember%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin qu’elles retournent toutes résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.UnderlyingMember" />
      </Docs>
    </Member>
    <Member MemberName="LookupUnderlyingSetter">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo LookupUnderlyingSetter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo LookupUnderlyingSetter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupUnderlyingSetter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupUnderlyingSetter () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ LookupUnderlyingSetter();" />
      <MemberSignature Language="F#" Value="abstract member LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo&#xA;override this.LookupUnderlyingSetter : unit -&gt; System.Reflection.MethodInfo" Usage="xamlMember.LookupUnderlyingSetter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un accesseur <see langword="set" /> associé à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns><see cref="T:System.Reflection.MethodInfo" /> pour l'accesseur <see langword="set" /> associé , sinon <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut interprète <xref:System.Xaml.XamlMember.UnderlyingMember%2A> comme <xref:System.Reflection.PropertyInfo> et retourne la valeur de <xref:System.Reflection.PropertyInfo.GetSetMethod%2A?displayProperty=nameWithType> (avec le paramètre défini sur `true`), ce qui signifie que la méthode retournée peut être non public. Cela peut entraîner de `null` pour certains cas, y compris les cas où il n’existe pas d’accesseur, ou le membre n’est pas une propriété.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur comprise entre <xref:System.Xaml.Schema.XamlMemberInvoker.UnderlyingSetter%2A> sur associé à un <xref:System.Xaml.Schema.XamlMemberInvoker>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas. Veillez à implémenter <xref:System.Xaml.XamlMember.LookupUnderlyingGetter%2A>, <xref:System.Xaml.XamlMember.LookupUnderlyingSetter%2A>, et <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> afin qu’elles retournent toutes résultats mis en corrélation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LookupValueSerializer">
      <MemberSignature Language="C#" Value="protected virtual System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; LookupValueSerializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.LookupValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LookupValueSerializer () As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ LookupValueSerializer();" />
      <MemberSignature Language="F#" Value="abstract member LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;&#xA;override this.LookupValueSerializer : unit -&gt; System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="xamlMember.LookupValueSerializer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une implémentation du sérialiseur de valeur associée à ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Instance de <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.Windows.Markup.ValueSerializer" />, ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut utilise la logique suivante et ordre de traitement :  
  
-   Si l’attribution existe au niveau du membre (<xref:System.Windows.Markup.ValueSerializerAttribute>), les informations d’attribut sont utilisées pour un appel à <xref:System.Xaml.XamlSchemaContext.GetValueConverter%2A> par rapport au contexte de schéma XAML.  
  
-   Si <xref:System.Xaml.XamlMember.Type%2A> est valide, un convertisseur de valeur qui est associé au type est retourné.  
  
-   Si les conditions précédentes ne s’appliquent pas, `null` est retournée.  
  
 Cette méthode est appelée lorsqu’un appelant obtient une valeur à partir de <xref:System.Xaml.XamlMember.ValueSerializer%2A>. Substituez cette méthode si vous souhaitez signaler des résultats uniformes pour l’intégralité d’un <xref:System.Xaml.XamlMember> classe dérivée, ou si vous avez spécialisé des métadonnées disponibles pour le déterminer au cas par cas.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xaml.XamlMember.ValueSerializer" />
      </Docs>
    </Member>
    <Member MemberName="MarkupExtensionBracketCharacters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyDictionary&lt;char,char&gt; MarkupExtensionBracketCharacters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IReadOnlyDictionary`2&lt;char, char&gt; MarkupExtensionBracketCharacters" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MarkupExtensionBracketCharacters As IReadOnlyDictionary(Of Char, Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ MarkupExtensionBracketCharacters { System::Collections::Generic::IReadOnlyDictionary&lt;char, char&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MarkupExtensionBracketCharacters : System.Collections.Generic.IReadOnlyDictionary&lt;char, char&gt;" Usage="System.Xaml.XamlMember.MarkupExtensionBracketCharacters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyDictionary&lt;System.Char,System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Définit le crochet ouvrant et le crochet fermant d’une extension de balisage.</summary>
        <value>Collection contenant le crochet ouvrant et le crochet fermant.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xaml.XamlMember.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la chaîne de nom <see langword="xamlName" /> qui déclare ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Chaîne de nom <see langword="xamlName" /> qui déclare ce <see cref="T:System.Xaml.XamlMember" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette valeur est toujours définie pendant la construction. Les constructeurs sont implémentées par <xref:System.Xaml.XamlMember> généralement lève une exception si un nom initial n’est pas spécifié ; par conséquent, attendez-vous à cette propriété `null` ou une chaîne vide, si vous utilisez des Services de XAML par défaut .NET Framework implémentations.  
  
 [XamlName, grammaire](~/docs/framework/xaml-services/xamlname-grammar.md) et des règles d’affectation de noms pour le type CLR et les membres ne sont pas des intersections exactes. Il est possible de déclarer un nom de membre qui est valide sous le CLR mais pas valide sous d’affectation de noms XAML. Vous devez éviter cette situation si possible.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/11e4cada-41d2-494d-9531-0d3df4dfcbe3">XamlName</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Equality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="xamlMember1 = xamlMember2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlMember" /> spécifiés ont la même valeur.</summary>
        <returns><see langword="true" /> si la valeur de <paramref name="xamlMember1" /> est égale à la valeur de <paramref name="xamlMember2" /> ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xaml.XamlMember xamlMember1, System.Xaml.XamlMember xamlMember2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xaml.XamlMember xamlMember1, class System.Xaml.XamlMember xamlMember2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.op_Inequality(System.Xaml.XamlMember,System.Xaml.XamlMember)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (xamlMember1 As XamlMember, xamlMember2 As XamlMember) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xaml::XamlMember ^ xamlMember1, System::Xaml::XamlMember ^ xamlMember2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xaml.XamlMember * System.Xaml.XamlMember -&gt; bool" Usage="System.Xaml.XamlMember.op_Inequality (xamlMember1, xamlMember2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlMember1" Type="System.Xaml.XamlMember" />
        <Parameter Name="xamlMember2" Type="System.Xaml.XamlMember" />
      </Parameters>
      <Docs>
        <param name="xamlMember1"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <param name="xamlMember2"><see cref="T:System.Xaml.XamlMember" /> ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.Xaml.XamlMember" /> spécifiés ont des valeurs différentes.</summary>
        <returns><see langword="true" /> si la valeur de <paramref name="xamlMember1" /> est différente de la valeur de <paramref name="xamlMember2" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredXamlNamespace">
      <MemberSignature Language="C#" Value="public string PreferredXamlNamespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PreferredXamlNamespace" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredXamlNamespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PreferredXamlNamespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredXamlNamespace : string" Usage="System.Xaml.XamlMember.PreferredXamlNamespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'URI d'espace de noms XAML qui identifie l'espace de noms XAML principal de ce <see cref="T:System.Xaml.XamlMember" />.</summary>
        <value>Identificateur pour l'espace de noms XAML principal de ce <see cref="T:System.Xaml.XamlMember" />, sous forme de chaîne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Xaml.XamlMember.PreferredXamlNamespace%2A> propriété fournit la même valeur que si vous appelez <xref:System.Xaml.XamlMember.GetXamlNamespaces%2A> et l’obtention de la première chaîne de valeur dans la liste renvoyée. L’espace de noms XAML par défaut doit être utilisé lors de l’écriture du membre dans le texte ou autres représentations qui conservent les informations d’espace de noms XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SerializationVisibility">
      <MemberSignature Language="C#" Value="public System.ComponentModel.DesignerSerializationVisibility SerializationVisibility { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.DesignerSerializationVisibility SerializationVisibility" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.SerializationVisibility" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerializationVisibility As DesignerSerializationVisibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::DesignerSerializationVisibility SerializationVisibility { System::ComponentModel::DesignerSerializationVisibility get(); };" />
      <MemberSignature Language="F#" Value="member this.SerializationVisibility : System.ComponentModel.DesignerSerializationVisibility" Usage="System.Xaml.XamlMember.SerializationVisibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DesignerSerializationVisibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.ComponentModel.DesignerSerializationVisibility" /> qui indique comment un concepteur visuel doit traiter le membre.</summary>
        <value>Valeur de l'énumération <see cref="T:System.ComponentModel.DesignerSerializationVisibility" />. La valeur par défaut est <see cref="F:System.ComponentModel.DesignerSerializationVisibility.Visible" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType TargetType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TargetType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetType As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ TargetType { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetType : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</summary>
        <value>Type dans lequel le <see cref="T:System.Xaml.XamlMember" /> peut exister.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur retournée est différente pour les membres pouvant être attachées et non pouvant être attachée. Pour les membres non pouvant être attachée, <xref:System.Xaml.XamlMember.TargetType%2A> retourne <xref:System.Xaml.XamlMember.DeclaringType%2A>. Pour les membres pouvant être attachées, <xref:System.Xaml.XamlMember.LookupTargetType%2A> retourne un résultat qui est basé sur cette logique :  
  
-   Si la réflexion ne peut pas résoudre un stockage (<xref:System.Xaml.XamlMember.IsUnknown%2A> `true`), cette méthode retourne une constante interne qui représente un type d’objet générique.  
  
-   Si la condition précédente ne s’applique pas, <xref:System.Xaml.XamlMember.LookupTargetType%2A> est appelée. L’implémentation par défaut retourne un <xref:System.Xaml.XamlType> qui est basé sur l’examen des méthodes qui implémentent le `get` et `set` accesseurs. Une classe peut substituer <xref:System.Xaml.XamlMember.LookupTargetType%2A> à utiliser un comportement différent, comme les autres formes de métadonnées qui peut-être signaler des types de cibles pour les membres pouvant être attachés.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xaml.XamlMember.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xamlMember.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlMember" />.</summary>
        <returns>Représentation sous forme de chaîne de <see cref="T:System.Xaml.XamlMember" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation retourne <xref:System.Xaml.XamlMember.Name%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public System.Xaml.XamlType Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.XamlType Type" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As XamlType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::XamlType ^ Type { System::Xaml::XamlType ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Type : System.Xaml.XamlType" Usage="System.Xaml.XamlMember.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</summary>
        <value><see cref="T:System.Xaml.XamlType" /> du type qui est utilisé par le membre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.Type%2A> appelle <xref:System.Xaml.XamlMember.LookupType%2A> ou une substitution spécifique de cette méthode. Cela se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Le comportement par défaut (aucun <xref:System.Xaml.XamlMember.LookupType%2A> remplacer), retourné <xref:System.Xaml.XamlType> peut avoir des significations différentes conceptuelles. Signification varie selon que cela <xref:System.Xaml.XamlMember> représente une propriété, une méthode ou un événement, comme le montre la liste suivante :  
  
-   Pour une propriété, retournée <xref:System.Xaml.XamlType> est le type qui définit la propriété ou qui est retourné par la propriété.  
  
-   Pour un événement, retourné <xref:System.Xaml.XamlType> est le type de gestionnaire d’événements requis (il s’agit d’un délégué dans une implémentation CLR).  
  
-   Pour une méthode, <xref:System.Xaml.XamlType> est le type de retour de cette méthode, qui peut être `null`.  
  
 Dans chaque cas, le contexte de schéma XAML est utilisé pour évaluer le type XAML à partir du type de sauvegarde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeConverter">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt; TypeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.ComponentModel.TypeConverter&gt; TypeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.TypeConverter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeConverter As XamlValueConverter(Of TypeConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ TypeConverter { System::Xaml::Schema::XamlValueConverter&lt;System::ComponentModel::TypeConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeConverter : System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;" Usage="System.Xaml.XamlMember.TypeConverter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.ComponentModel.TypeConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" />, qui peut être utilisé pour la construction de conversion de type des objets XAML déclarés.</summary>
        <value>Valeur <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec une contrainte <see cref="T:System.ComponentModel.TypeConverter" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.TypeConverter%2A> appelle <xref:System.Xaml.XamlMember.LookupTypeConverter%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Valeur des implémentations qui retournent une propriété non null pour <xref:System.Xaml.XamlMember.TypeConverter%2A> ne sont pas nécessairement un <xref:System.ComponentModel.TypeConverter>. Voici une liste de valeurs de retour non null possibles pour <xref:System.Xaml.XamlMember.TypeConverter%2A> et ce que représentent les valeurs suivantes :  
  
-   La valeur de retour signale un convertisseur de type qui est attribué spécifiquement à ce membre ou plus généralement au type cible du convertisseur. Ce comportement est généralement quels la plupart des systèmes de type XAML et les processeurs XAML recherchent pour instancier un convertisseur de type et appeler ses méthodes.  
  
-   La valeur de retour signale un convertisseur de valeurs intégrées. Ces convertisseurs existent pour certaines opérations internes qui sont effectuées par un writer XAML. En particulier, ces convertisseurs intégrés convertir les valeurs de chaîne d’attribut brutes les primitives de langage XAML. Pour l’implémentation de Services XAML du .NET Framework, ces conversions de type intégré renvoient souvent à un convertisseur de type qui est défini dans l’assembly système. Par exemple, une conversion pour un <xref:System.Int32> valeur a une conversion, transférée intégrée et par conséquent, le <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterType%2A> valeur références <xref:System.ComponentModel.Int32Converter>.  
  
-   La valeur de retour signale le cas d’un modèle d’objet sans contrainte ; Autrement dit, le <xref:System.Xaml.XamlMember> a un <xref:System.Xaml.XamlMember.Type%2A> valeur <xref:System.Object>. Dans ce cas, le <xref:System.Xaml.Schema.XamlValueConverter%601> qui signale la <xref:System.Xaml.Schema.XamlValueConverter%601.Name%2A?displayProperty=nameWithType> est {`Object}`. Toutefois, <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A> est `null` , car aucun type ou une instance n’est disponible pour effectuer cette conversion. Au lieu de cela, le comportement du modèle objet ne peut pas être déterminé jusqu’au moment de l’exécution, lorsque le runtime de la technologie spécifique détermine la gestion de son graphique d’objet.  
  
 Si vous pouvez accéder à un travail <xref:System.ComponentModel.TypeConverter> de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>, vous pouvez appeler ses méthodes de conversion. Toutefois, de nombreuses méthodes de conversion s’appuient sur le contexte de service. Si vous n’avez pas le même contexte de service disponible que le convertisseur de type attend pour son rôle typique d’écriture d’objets pour les graphiques d’objets, les méthodes du convertisseur peuvent lever des exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo UnderlyingMember { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MemberInfo UnderlyingMember" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.UnderlyingMember" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnderlyingMember As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MemberInfo ^ UnderlyingMember { System::Reflection::MemberInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingMember : System.Reflection.MemberInfo" Usage="System.Xaml.XamlMember.UnderlyingMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Reflection.MemberInfo" /> du système de type CLR qui est disponible pour un membre construit par <see cref="T:System.Reflection.PropertyInfo" />, <see cref="T:System.Reflection.MethodInfo" /> ou <see cref="T:System.Reflection.EventInfo" />.</summary>
        <value>Informations <see cref="T:System.Reflection.MemberInfo" /> du système de type CLR utilisées pour le transtypage à partir des paramètres du constructeur initial. Un<see cref="T:System.Xaml.XamlMember" /> construit avec la signature <see cref="M:System.Xaml.XamlMember.#ctor(System.String,System.Xaml.XamlType,System.Boolean)" /> retourne <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.UnderlyingMember%2A> appelle <xref:System.Xaml.XamlMember.LookupUnderlyingMember%2A> ou une substitution spécifique de cette méthode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValueSerializer">
      <MemberSignature Language="C#" Value="public System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt; ValueSerializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xaml.Schema.XamlValueConverter`1&lt;class System.Windows.Markup.ValueSerializer&gt; ValueSerializer" />
      <MemberSignature Language="DocId" Value="P:System.Xaml.XamlMember.ValueSerializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValueSerializer As XamlValueConverter(Of ValueSerializer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ ValueSerializer { System::Xaml::Schema::XamlValueConverter&lt;System::Windows::Markup::ValueSerializer ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueSerializer : System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;" Usage="System.Xaml.XamlMember.ValueSerializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.Schema.XamlValueConverter&lt;System.Windows.Markup.ValueSerializer&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> utilisé pour la sérialisation de valeur des objets XAML déclarés.</summary>
        <value><see cref="T:System.Xaml.Schema.XamlValueConverter`1" /> avec la contrainte <see cref="T:System.Windows.Markup.ValueSerializer" /> sur le générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel <xref:System.Xaml.XamlMember.ValueSerializer%2A> appelle <xref:System.Xaml.XamlMember.LookupValueSerializer%2A> ou une substitution spécifique de cette méthode. Ce comportement se produit lorsque la logique de réflexion interne initiale n’a pas déjà défini les informations.  
  
 Valeur de pas tous les cas qui retournent une propriété non null pour <xref:System.Xaml.XamlMember.ValueSerializer%2A> sont nécessairement un <xref:System.Windows.Markup.ValueSerializer>. Consultez <xref:System.Xaml.XamlMember.TypeConverter%2A>; les mêmes considérations s’appliquent à <xref:System.Xaml.XamlMember.ValueSerializer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>