<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ea638a13be4ca721973134cc1fa8989636ffa7de" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51317461" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="5b797-101">
        <see cref="T:System.Windows.FrameworkContentElement" /> est l’implémentation et l’expansion de niveau infrastructure WPF de la classe de base <see cref="T:System.Windows.ContentElement" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="5b797-101">
          <see cref="T:System.Windows.FrameworkContentElement" /> is the WPF framework-level implementation and expansion of the <see cref="T:System.Windows.ContentElement" /> base class.</span>
      </span>
      <span data-ttu-id="5b797-102">
        <see cref="T:System.Windows.FrameworkContentElement" /> ajoute la prise en charge d’API d’entrée supplémentaires (notamment des info-bulles et des menus contextuels), des plans conceptuels, du contexte de données de la liaison de données, des styles et d’API d’assistance d’arborescence logique.</span>
      <span class="sxs-lookup">
        <span data-stu-id="5b797-102">
          <see cref="T:System.Windows.FrameworkContentElement" /> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-103"><xref:System.Windows.FrameworkContentElement> ne définit pas encore son propre comportement de rendu ; l’instanciation d’un <xref:System.Windows.FrameworkContentElement> instance de classe dans le code ou de balisage est possible mais n’affiche rien dans une [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5b797-103"><xref:System.Windows.FrameworkContentElement> does not yet define its own rendering behavior; instantiating an actual <xref:System.Windows.FrameworkContentElement> class instance in code or markup is possible but displays nothing in a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="5b797-104">Rendu de la logique doit être fourni par les classes qui prennent <xref:System.Windows.FrameworkContentElement> les éléments enfants dans le cadre de leur modèle de contenu, ou dans <xref:System.Windows.FrameworkContentElement> classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="5b797-104">Rendering logic must be provided by classes that take <xref:System.Windows.FrameworkContentElement> child elements as part of their content model, or in <xref:System.Windows.FrameworkContentElement> derived classes.</span></span>  
  
 <span data-ttu-id="5b797-105"><xref:System.Windows.FrameworkContentElement> délibérément en parallèle plusieurs du même [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] comme <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="5b797-105"><xref:System.Windows.FrameworkContentElement> deliberately parallels many of the same [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] as <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="5b797-106">Notez que certains [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] trouvé sur <xref:System.Windows.FrameworkElement> n’aura pas un <xref:System.Windows.FrameworkContentElement> équivalente.</span><span class="sxs-lookup"><span data-stu-id="5b797-106">Note that certain [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] found on <xref:System.Windows.FrameworkElement> will not have a <xref:System.Windows.FrameworkContentElement> equivalent.</span></span> <span data-ttu-id="5b797-107">Plusieurs de la <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] sont pour les fonctionnalités telles que la représentation sous forme de géométrie ou de mise en page, qui ne sont pas pertinentes pour un <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="5b797-107">Several of the <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] are for functionality such as geometry representation or layout, which are not relevant for a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 <span data-ttu-id="5b797-108">La majorité des existant <xref:System.Windows.FrameworkContentElement> classes dérivées seront trouve dans le <xref:System.Windows.Documents> espace de noms.</span><span class="sxs-lookup"><span data-stu-id="5b797-108">The majority of existing <xref:System.Windows.FrameworkContentElement> derived classes will be found in the <xref:System.Windows.Documents> namespace.</span></span> <span data-ttu-id="5b797-109">Beaucoup de ces classes dérivées implémentent des éléments pour le modèle de document de flux.</span><span class="sxs-lookup"><span data-stu-id="5b797-109">Many of these derived classes implement elements for the flow document model.</span></span> <span data-ttu-id="5b797-110">Certaines classes dérivées telles que <xref:System.Windows.Documents.Hyperlink> ont des fonctionnalités comme le contrôle, mais sont dérivées de <xref:System.Windows.FrameworkContentElement> telles que les éléments comme le contrôle peuvent toujours participer dans le modèle de document de flux.</span><span class="sxs-lookup"><span data-stu-id="5b797-110">Certain derived classes such as <xref:System.Windows.Documents.Hyperlink> have some control-like functionality, but are derived from <xref:System.Windows.FrameworkContentElement> such that the control-like elements can still participate in the flow document model.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-111">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-111">Initializes a new instance of the <see cref="T:System.Windows.FrameworkContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="5b797-112">Élément enfant à ajouter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-112">The child element to be added.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-113">Ajoute l’élément fourni comme enfant de cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-113">Adds the provided element as a child of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-114">Cette méthode peut lever une exception si elle est appelée à la fois lorsque l’arborescence logique est itérée par un autre processus.</span><span class="sxs-lookup"><span data-stu-id="5b797-114">This method can throw an exception if called at a time when the logical tree is being iterated by another process.</span></span>  
  
 <span data-ttu-id="5b797-115">La plupart des <xref:System.Windows.FrameworkContentElement> classes dérivées exposent des collections dédiées qui sont responsables de relation contenant-contenu (par exemple, <xref:System.Windows.Documents.Span.Inlines%2A> sur la <xref:System.Windows.Documents.Span> classe ; <xref:System.Windows.Documents.Section.Blocks%2A> sur la <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="5b797-115">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="5b797-116">Vous pouvez généralement éviter tout besoin de manipuler l’arborescence logique directement si vous dérivez à partir de ces classes.</span><span class="sxs-lookup"><span data-stu-id="5b797-116">You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</span></span> <span data-ttu-id="5b797-117">Utilisation de l’arborescence logique pour les éléments de contenu est un scénario avancé qui peut nécessiter un analyseur spécialisé ou spécialisé <xref:System.Windows.FrameworkElement> qui agit en tant que l’élément de rendu parent (hôte de contenu).</span><span class="sxs-lookup"><span data-stu-id="5b797-117">Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <xref:System.Windows.FrameworkElement> that acts as the parent rendering element (content host).</span></span>  
  
 <span data-ttu-id="5b797-118">Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-118">For more information about how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-119">Appelé avant qu’un élément soit initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-119">Called before an element is initialized.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="5b797-120">Substituez cette méthode pour fournir une gestion spéciale qui doit se produire avant que votre élément est initialisé pendant le processus de chargement de l’élément.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-120">Override this method to provide special handling that should occur before your element is initialized during the element loading process.</span>
            </span>
            <span data-ttu-id="5b797-121">Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-121">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span>
            </span>
            <span data-ttu-id="5b797-122">L’implémentation de base lève une exception si <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> est appelée plusieurs fois sur le même élément avant d’atteindre <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-122">The base implementation will throw an exception if <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> is called more than one time on the same element prior to reaching <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-123">Commence la séquence d'actions contenues dans la table de montage séquentiel fournie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-123">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5b797-124">Table de montage séquentiel à lancer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-124">The storyboard to begin.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-125">Commence la séquence d'actions contenues dans la table de montage séquentiel fournie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-125">Begins the sequence of actions that are contained in the provided storyboard.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-126">Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ».</span><span class="sxs-lookup"><span data-stu-id="5b797-126">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5b797-127">Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois.</span><span class="sxs-lookup"><span data-stu-id="5b797-127">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5b797-128">Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-128">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5b797-129">Table de montage séquentiel à lancer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-129">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="5b797-130">Valeur de l'énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-130">A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-131">Commence la séquence d'actions contenues dans la table de montage séquentiel fournie, avec les options spécifiées pour ce qui doit se produire si la propriété est déjà animée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-131">Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-132">Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ».</span><span class="sxs-lookup"><span data-stu-id="5b797-132">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5b797-133">Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois.</span><span class="sxs-lookup"><span data-stu-id="5b797-133">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5b797-134">Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-134">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="5b797-135">À l’aide de la composition HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="5b797-135">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="5b797-136">Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas les horloges automatiquement.</span><span class="sxs-lookup"><span data-stu-id="5b797-136">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</span></span>  
  
 <span data-ttu-id="5b797-137">Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé.</span><span class="sxs-lookup"><span data-stu-id="5b797-137">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="5b797-138">Il existe plusieurs façons de supprimer une horloge :</span><span class="sxs-lookup"><span data-stu-id="5b797-138">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="5b797-139">Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé.</span><span class="sxs-lookup"><span data-stu-id="5b797-139">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="5b797-140">Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde.</span><span class="sxs-lookup"><span data-stu-id="5b797-140">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="5b797-141">Cette opération supprime toutes les horloges d’animation à partir de la propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-141">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="5b797-142">Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="5b797-142">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="5b797-143">Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge.</span><span class="sxs-lookup"><span data-stu-id="5b797-143">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="5b797-144">Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="5b797-144">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="5b797-145">Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.</span><span class="sxs-lookup"><span data-stu-id="5b797-145">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="5b797-146">Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-146">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="5b797-147">Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.</span><span class="sxs-lookup"><span data-stu-id="5b797-147">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="5b797-148">Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.</span><span class="sxs-lookup"><span data-stu-id="5b797-148">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="5b797-149">Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-149">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">
          <span data-ttu-id="5b797-150">Table de montage séquentiel à lancer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-150">The storyboard to begin.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="5b797-151">Valeur de l’énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-151">A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</span>
          </span>
        </param>
        <param name="isControllable">
          <span data-ttu-id="5b797-152">Déclare si l'animation est contrôlable (peut être suspendue) après avoir démarré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-152">Declares whether the animation is controllable (can be paused) after it is started.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-153">Commence la séquence d'actions contenues dans la table de montage séquentiel fournie, avec l'état spécifié pour le contrôle de l'animation après qu'elle ait démarré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-153">Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-154">Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ».</span><span class="sxs-lookup"><span data-stu-id="5b797-154">For the signatures that do not use the `isControllable`, parameter, or when that parameter is specified `false`, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</span></span> <span data-ttu-id="5b797-155">Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois.</span><span class="sxs-lookup"><span data-stu-id="5b797-155">Therefore the animation cannot be restarted after being run once.</span></span> <span data-ttu-id="5b797-156">Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-156">Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</span></span>  
  
## <a name="using-the-compose-handoffbehavior"></a><span data-ttu-id="5b797-157">À l’aide de la composition HandoffBehavior</span><span class="sxs-lookup"><span data-stu-id="5b797-157">Using the Compose HandoffBehavior</span></span>  
 <span data-ttu-id="5b797-158">Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas ces horloges automatiquement.</span><span class="sxs-lookup"><span data-stu-id="5b797-158">When you apply a <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, or <xref:System.Windows.Media.Animation.AnimationClock> to a property by using the <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, any <xref:System.Windows.Media.Animation.Clock> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</span></span>  
  
 <span data-ttu-id="5b797-159">Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé.</span><span class="sxs-lookup"><span data-stu-id="5b797-159">To avoid performance issues when you apply a large number of clocks by using <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, you should remove composing clocks from the animated property after they complete.</span></span> <span data-ttu-id="5b797-160">Il existe plusieurs façons de supprimer une horloge :</span><span class="sxs-lookup"><span data-stu-id="5b797-160">There are several ways to remove a clock:</span></span>  
  
-   <span data-ttu-id="5b797-161">Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé.</span><span class="sxs-lookup"><span data-stu-id="5b797-161">To remove all clocks from a property, use the <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> or <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> method of the animated object.</span></span> <span data-ttu-id="5b797-162">Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde.</span><span class="sxs-lookup"><span data-stu-id="5b797-162">Specify the property being animated as the first parameter, and `null` as the second.</span></span> <span data-ttu-id="5b797-163">Cette opération supprime toutes les horloges d’animation à partir de la propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-163">This removes all animation clocks from the property.</span></span>  
  
-   <span data-ttu-id="5b797-164">Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>.</span><span class="sxs-lookup"><span data-stu-id="5b797-164">To remove a specific <xref:System.Windows.Media.Animation.AnimationClock> from a list of clocks, use the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of the <xref:System.Windows.Media.Animation.AnimationClock> to retrieve a <xref:System.Windows.Media.Animation.ClockController>, then call the <xref:System.Windows.Media.Animation.ClockController.Remove%2A> method of the <xref:System.Windows.Media.Animation.ClockController>.</span></span> <span data-ttu-id="5b797-165">Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge.</span><span class="sxs-lookup"><span data-stu-id="5b797-165">This is typically done in the <xref:System.Windows.Media.Animation.Clock.Completed> event handler for a clock.</span></span> <span data-ttu-id="5b797-166">Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`.</span><span class="sxs-lookup"><span data-stu-id="5b797-166">Note that only root clocks can be controlled by a <xref:System.Windows.Media.Animation.ClockController>; the <xref:System.Windows.Media.Animation.Clock.Controller%2A> property of a child clock returns `null`.</span></span> <span data-ttu-id="5b797-167">Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.</span><span class="sxs-lookup"><span data-stu-id="5b797-167">Note also that the <xref:System.Windows.Media.Animation.Clock.Completed> event is not raised if the effective duration of the clock is forever.</span></span>  <span data-ttu-id="5b797-168">Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-168">In that case, the user must determine when to call <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.</span></span>  
  
 <span data-ttu-id="5b797-169">Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.</span><span class="sxs-lookup"><span data-stu-id="5b797-169">This is primarily an issue for animations on objects that have a long lifetime.</span></span>  <span data-ttu-id="5b797-170">Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.</span><span class="sxs-lookup"><span data-stu-id="5b797-170">When an object is garbage collected, its clocks are also disconnected and garbage collected.</span></span>  
  
 <span data-ttu-id="5b797-171">Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-171">For more information about clock objects, see [Animation and Timing System Overview](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-172">Obtient ou définit le <see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-172">Gets or sets the <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-173">
            <see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-173">The <see cref="T:System.Windows.Data.BindingGroup" /> that is used for the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-174">Un <xref:System.Windows.Data.BindingGroup> peut être utilisé pour valider les valeurs de plusieurs propriétés d’un objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-174">A <xref:System.Windows.Data.BindingGroup> can be used to validate the values of multiple properties of an object.</span></span> <span data-ttu-id="5b797-175">Par exemple, supposons qu’une application invite l’utilisateur à entrer une adresse et remplit ensuite un objet de type `Address`, qui a les propriétés `Street`, `City`, `ZipCode`, et `Country`, avec les valeurs que l’utilisateur fourni.</span><span class="sxs-lookup"><span data-stu-id="5b797-175">For example, suppose that an application prompts the user to enter an address and then populates an object of type `Address`, which has the properties `Street`, `City`, `ZipCode`, and `Country`, with the values that the user provided.</span></span> <span data-ttu-id="5b797-176">L’application a un panneau qui contient quatre <xref:System.Windows.Controls.TextBox> contrôles, chacun d’eux est lié à une des propriétés de l’objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-176">The application has a panel that contains four <xref:System.Windows.Controls.TextBox> controls, each of which is bound to one of the object’s properties.</span></span> <span data-ttu-id="5b797-177">Vous pouvez utiliser un <xref:System.Windows.Controls.ValidationRule> dans un <xref:System.Windows.Data.BindingGroup> pour valider le `Address` objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-177">You can use a <xref:System.Windows.Controls.ValidationRule> in a <xref:System.Windows.Data.BindingGroup> to validate the `Address` object.</span></span> <span data-ttu-id="5b797-178">Par exemple, le <xref:System.Windows.Controls.ValidationRule> pouvez vous assurer que le code postal est valide pour le pays de l’adresse.</span><span class="sxs-lookup"><span data-stu-id="5b797-178">For example, the <xref:System.Windows.Controls.ValidationRule> can ensure that the zip code is valid for the country of the address.</span></span>  
  
 <span data-ttu-id="5b797-179">Les éléments enfants héritent le <xref:System.Windows.Data.BindingGroup> à partir de leurs éléments parents, tout comme avec toute autre propriété pouvant être héritées.</span><span class="sxs-lookup"><span data-stu-id="5b797-179">Child elements inherit the <xref:System.Windows.Data.BindingGroup> from their parent elements, just as with any other inheritable property.</span></span>  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-180">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-180">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-181">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-181">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|<span data-ttu-id="5b797-182">La valeur des propriétés de métadonnées **true**</span><span class="sxs-lookup"><span data-stu-id="5b797-182">Metadata properties set to **true**</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-183">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-183">Identifies the <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-184">Essaie de mettre cet élément en vue, dans toutes régions déroulantes dans lesquelles il est contenu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-184">Attempts to bring this element into view, within any scrollable regions it is contained within.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-185">En appelant cette méthode, vous appellerez efficacement <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> sur toute zone défilante parente qui contient l’élément (le parent peut très bien être un <xref:System.Windows.FrameworkElement>, et non un <xref:System.Windows.FrameworkContentElement>).</span><span class="sxs-lookup"><span data-stu-id="5b797-185">By calling this method, you effectively will call <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> on any parent scrollable area that contains the element (the parent may very well be a <xref:System.Windows.FrameworkElement>, not a <xref:System.Windows.FrameworkContentElement>).</span></span> <span data-ttu-id="5b797-186">Si cet élément n’est pas contenu dans une zone avec défilement, l’événement est déclenché, mais il n’y aura aucun effet.</span><span class="sxs-lookup"><span data-stu-id="5b797-186">If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">
          <span data-ttu-id="5b797-187">Comment : créer un ScrollViewer</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-187">How to: Create a ScrollViewer</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-188">Obtient ou définit l'élément de menu contextuel qui doit apparaître à chaque fois que le menu contextuel est demandé via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] à partir de cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-188">Gets or sets the context menu element that should appear whenever the context menu is requested via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] from within this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-189">Le menu contextuel que cet élément utilise.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-189">The context menu that this element uses.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-190">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-190">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-191">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-191">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|<span data-ttu-id="5b797-192">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-192">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-193">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-193">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-194">L’exemple suivant place un <xref:System.Windows.Controls.ContextMenu> sur un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="5b797-194">The following example places a <xref:System.Windows.Controls.ContextMenu> on a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-195">Se produit juste avant qu'un menu contextuel sur l'élément ne soit fermé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-195">Occurs just before any context menu on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-196">Pour supprimer la fermeture menus contextuels, les gestionnaires de l’événement doivent marquer comme géré.</span><span class="sxs-lookup"><span data-stu-id="5b797-196">To suppress closing context menus, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="5b797-197">Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer l’identificateur d’événement de service sous-jacent :</span><span class="sxs-lookup"><span data-stu-id="5b797-197">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 <span data-ttu-id="5b797-198">(Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkContentElement> qu’expose l’événement de service sous-jacent ne mappe pas correctement le <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificateur pour une utilisation dans les déclencheurs).</span><span class="sxs-lookup"><span data-stu-id="5b797-198">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-199">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-199">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-200">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-200">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|<span data-ttu-id="5b797-201">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-201">Routing strategy</span></span>|<span data-ttu-id="5b797-202">Propagation</span><span class="sxs-lookup"><span data-stu-id="5b797-202">Bubbling</span></span>|  
|<span data-ttu-id="5b797-203">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-203">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-204">L’exemple suivant implémente un gestionnaire qui modifie le curseur sur une région nommée `DisplayArea` (non illustré).</span><span class="sxs-lookup"><span data-stu-id="5b797-204">The following example implements a handler that changes the cursor over a named region `DisplayArea` (not shown).</span></span> <span data-ttu-id="5b797-205">Les commentaires indiquent un <xref:System.Windows.UIElement> l’utilisation, mais en fait, cet exemple serait identique si `DisplayArea` ont été une <xref:System.Windows.FrameworkContentElement>.</span><span class="sxs-lookup"><span data-stu-id="5b797-205">The comment hints at a <xref:System.Windows.UIElement> usage, but in fact this sample would be identical if `DisplayArea` were a <xref:System.Windows.FrameworkContentElement>.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-206">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-206">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-207">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-207">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-208">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-208">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-209">Se produit lorsqu'un menu contextuel sur l'élément est ouvert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-209">Occurs when any context menu on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-210">Pour ouvrir manuellement des menus contextuels, gestionnaires des événements doivent marquer l’événement comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="5b797-210">To manually open context menus, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="5b797-211">Sinon, la valeur existante de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriété sera utilisée pour ouvrir automatiquement un menu contextuel.</span><span class="sxs-lookup"><span data-stu-id="5b797-211">Otherwise, the existing value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="5b797-212">Marquage de l’événement géré annule effectivement l’action par défaut et peut être une opportunité pour réinitialiser la valeur de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriété, puis ouvrez le nouveau <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="5b797-212">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="5b797-213">Toutefois, il existe un problème de synchronisation que vous devez connaître.</span><span class="sxs-lookup"><span data-stu-id="5b797-213">However, there is a timing issue you should be aware of.</span></span> <span data-ttu-id="5b797-214">Pour remplacer complètement le menu contextuel via un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> gestionnaire, le menu contextuel initial ne doit pas être null / vide.</span><span class="sxs-lookup"><span data-stu-id="5b797-214">In order to completely replace the context menu through a <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> handler, the initial context menu must not be null / empty.</span></span> <span data-ttu-id="5b797-215">Ou bien, vous devrez peut-être gérer l’événement et ouvrez manuellement un nouveau menu contextuel.</span><span class="sxs-lookup"><span data-stu-id="5b797-215">Alternatively, you might need to handle the event and then manually open a new context menu.</span></span> <span data-ttu-id="5b797-216">Pour plus d’informations, consultez [Comment : gérer l’événement ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-216">For details, see [How to: Handle the ContextMenuOpening Event](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).</span></span>  
  
 <span data-ttu-id="5b797-217">Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer l’identificateur d’événement de service sous-jacent :</span><span class="sxs-lookup"><span data-stu-id="5b797-217">To use this event as an <xref:System.Windows.EventTrigger> in a style, you must reference the underlying service event identifier:</span></span>  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 <span data-ttu-id="5b797-218">(Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkContentElement> qu’expose l’événement de service sous-jacent ne mappe pas correctement le <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificateur pour une utilisation dans les déclencheurs).</span><span class="sxs-lookup"><span data-stu-id="5b797-218">(This usage is required because the event implementation on <xref:System.Windows.FrameworkContentElement> that exposes the underlying service event does not correctly map the <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identifier for use in triggers).</span></span>  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-219">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-219">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-220">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-220">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|<span data-ttu-id="5b797-221">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-221">Routing strategy</span></span>|<span data-ttu-id="5b797-222">Propagation</span><span class="sxs-lookup"><span data-stu-id="5b797-222">Bubbling</span></span>|  
|<span data-ttu-id="5b797-223">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-223">Delegate</span></span>|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-224">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-224">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-225">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-225">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-226">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-226">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-227">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-227">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-228">Obtient ou définit le curseur qui s'affiche lorsque le pointeur de la souris est sur cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-228">Gets or sets the cursor that displays when the mouse pointer is over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-229">Curseur à afficher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-229">The cursor to display.</span>
          </span>
          <span data-ttu-id="5b797-230">La valeur par défaut est <see langword="null" /> conformément à cette propriété de dépendance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-230">The default value is defined as <see langword="null" /> per this dependency property.</span>
          </span>
          <span data-ttu-id="5b797-231">Toutefois, la valeur pratique par défaut au moment de l’exécution provient de divers facteurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-231">However, the practical default at run time will come from a variety of factors.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-232">Lorsque vous définissez cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processeur s’appuie sur la conversion de type pour la <xref:System.Windows.Input.Cursor> classe pour évaluer la chaîne.</span><span class="sxs-lookup"><span data-stu-id="5b797-232">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processor relies on type conversion for the <xref:System.Windows.Input.Cursor> class to evaluate the string.</span></span> <span data-ttu-id="5b797-233">La chaîne fournie doit être évaluée en une <xref:System.Windows.Input.CursorType> valeur.</span><span class="sxs-lookup"><span data-stu-id="5b797-233">The provided string should evaluate to a <xref:System.Windows.Input.CursorType> value.</span></span> <span data-ttu-id="5b797-234">Pour plus d'informations, consultez <xref:System.Windows.Input.Cursor>.</span><span class="sxs-lookup"><span data-stu-id="5b797-234">See <xref:System.Windows.Input.Cursor> for details.</span></span>  
  
 <span data-ttu-id="5b797-235">Si le curseur établi par cette propriété ou n’affiche pas lorsque le pointeur de la souris est au-dessus de cet élément est également dépendant de la valeur de la <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-235">Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> property.</span></span> <span data-ttu-id="5b797-236">En outre, liées aux événements de considérations telles qu’un glisser active, capture de la souris, les modes dans des contrôles et ainsi de suite, d’édition de texte affecte également le curseur avec une priorité plus élevée que la valeur que vous spécifiez dans cette propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-236">Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</span></span>  
  
 <span data-ttu-id="5b797-237">Pour rétablir le comportement de la définition de cette propriété sur la valeur par défaut éventuelle, affectez-lui la valeur `null` à nouveau.</span><span class="sxs-lookup"><span data-stu-id="5b797-237">To revert the behavior of setting this property to the eventual default, set it to `null` again.</span></span>  
  
 <span data-ttu-id="5b797-238">Le `null` par défaut signifie en réalité que la détermination de la valeur de curseur pratique est différée ici et doit être obtenue à partir d’un autre emplacement.</span><span class="sxs-lookup"><span data-stu-id="5b797-238">The `null` default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</span></span> <span data-ttu-id="5b797-239">Si présentés sans valeurs par programmation à partir de n’importe quelle source, le curseur par défaut sur un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application sera une flèche.</span><span class="sxs-lookup"><span data-stu-id="5b797-239">If presented with no programmatic values from any source, the default cursor over a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application will be an arrow.</span></span>  
  
 <span data-ttu-id="5b797-240">Chaque mouvement de la souris sur un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application déclenche une <xref:System.Windows.ContentElement.QueryCursor> événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-240">Each movement of the mouse over a [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application raises a <xref:System.Windows.ContentElement.QueryCursor> event.</span></span> <span data-ttu-id="5b797-241">L’événement se propage et tout élément le long de l’itinéraire a la possibilité de gérer l’événement et définir la valeur du curseur via les arguments de cet événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-241">The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</span></span> <span data-ttu-id="5b797-242">Si cela se produit, le fait que l’événement est géré et qu’il a une valeur modifiée dans les arguments est prioritaire sur la valeur de la <xref:System.Windows.FrameworkContentElement.Cursor%2A> propriété à n’importe quel niveau, sauf si <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> est défini.</span><span class="sxs-lookup"><span data-stu-id="5b797-242">If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <xref:System.Windows.FrameworkContentElement.Cursor%2A> property at any level, unless <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> is set.</span></span>  
  
 <span data-ttu-id="5b797-243">Si vous ne créez un curseur personnalisé, en général, vous définissez cette propriété sur une valeur de propriété statique de la <xref:System.Windows.Input.Cursors> classe.</span><span class="sxs-lookup"><span data-stu-id="5b797-243">If not creating a custom cursor, typically you set this property to a static property value of the <xref:System.Windows.Input.Cursors> class.</span></span>  
  
 <span data-ttu-id="5b797-244">Définition de la <xref:System.Windows.Input.Cursor> sur une valeur personnalisée n’est pas activé en mode de confiance partielle.</span><span class="sxs-lookup"><span data-stu-id="5b797-244">Setting the <xref:System.Windows.Input.Cursor> to a custom value is not enabled in partial trust.</span></span> <span data-ttu-id="5b797-245">Pour plus d’informations sur les curseurs personnalisés, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-245">For more information on custom cursors, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-246">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-246">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-247">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-247">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|<span data-ttu-id="5b797-248">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-248">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-249">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-249">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-250">L’exemple suivant définit le curseur sur une valeur personnalisée.</span><span class="sxs-lookup"><span data-stu-id="5b797-250">The following example sets the cursor to a custom value.</span></span>  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-251">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-251">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-252">Obtient ou définit le contexte de données d’un élément quand il participe à la liaison de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-252">Gets or sets the data context for an element when it participates in data binding.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-253">Objet à utiliser comme contexte de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-253">The object to use as data context.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-254">*Contexte de données* est un concept qui permet aux éléments d’hériter des informations de leurs éléments parents sur la source de liaison qui est utilisé pour la liaison, ainsi que d’autres caractéristiques de la liaison telles que le chemin d’accès.</span><span class="sxs-lookup"><span data-stu-id="5b797-254">*Data context* is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</span></span>  
  
 <span data-ttu-id="5b797-255">Contexte de données peut être défini directement à un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objet, avec les liaisons qui évaluent aux propriétés de cet objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-255">Data context can be set directly to a [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] object, with the bindings evaluating to properties of that object.</span></span> <span data-ttu-id="5b797-256">Vous pouvez également définir le contexte de données un <xref:System.Windows.Data.DataSourceProvider> objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-256">Alternatively, you can set the data context to a <xref:System.Windows.Data.DataSourceProvider> object.</span></span>  
  
 <span data-ttu-id="5b797-257">Cette propriété de dépendance hérite des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-257">This dependency property inherits property values.</span></span> <span data-ttu-id="5b797-258">S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkContentElement.DataContext%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkContentElement.DataContext%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.</span><span class="sxs-lookup"><span data-stu-id="5b797-258">If there are child elements with no other value for <xref:System.Windows.FrameworkContentElement.DataContext%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkContentElement.DataContext%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="5b797-259">Vous pouvez également utiliser une des propriétés suivantes de la <xref:System.Windows.Data.Binding> classe pour spécifier explicitement de la source de liaison : <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, ou <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-259">Alternatively, you can use one of the following properties of the <xref:System.Windows.Data.Binding> class to specify the binding source explicitly: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, or <xref:System.Windows.Data.Binding.RelativeSource%2A>.</span></span> <span data-ttu-id="5b797-260">Pour plus d’informations, consultez [Comment : spécifier la Source de liaison](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-260">For more information, see [How to: Specify the Binding Source](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).</span></span>  
  
 <span data-ttu-id="5b797-261">Dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> est le plus couramment défini comme un <xref:System.Windows.Data.Binding> déclaration.</span><span class="sxs-lookup"><span data-stu-id="5b797-261">In [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> is most commonly set to as a <xref:System.Windows.Data.Binding> declaration.</span></span> <span data-ttu-id="5b797-262">Vous pouvez utiliser la syntaxe d’élément de propriété ou de syntaxe d’attribut.</span><span class="sxs-lookup"><span data-stu-id="5b797-262">You can use either property element syntax or attribute syntax.</span></span> <span data-ttu-id="5b797-263">Syntaxe d’attribut est indiquée dans l’exemple de cette page.</span><span class="sxs-lookup"><span data-stu-id="5b797-263">Attribute syntax is shown in the example on this page.</span></span> <span data-ttu-id="5b797-264">Vous pouvez également définir <xref:System.Windows.FrameworkContentElement.DataContext%2A> dans le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-264">You can also set <xref:System.Windows.FrameworkContentElement.DataContext%2A> in code.</span></span>  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5b797-265">Utilisation des éléments de propriété XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-265">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-266">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-266">XAML Attribute Usage</span></span>  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-267">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-267">XAML Values</span></span>  
 <span data-ttu-id="5b797-268">*dataContextObject*</span><span class="sxs-lookup"><span data-stu-id="5b797-268">*dataContextObject*</span></span>  
 <span data-ttu-id="5b797-269">Un objet incorporé directement qui sert de contexte de données pour toutes les liaisons dans l’élément parent.</span><span class="sxs-lookup"><span data-stu-id="5b797-269">A directly embedded object that serves as data context for any bindings within the parent element.</span></span> <span data-ttu-id="5b797-270">En règle générale, cet objet est un <xref:System.Windows.Data.Binding> ou un autre <xref:System.Windows.Data.BindingBase> sous-classe.</span><span class="sxs-lookup"><span data-stu-id="5b797-270">Typically, this object is a <xref:System.Windows.Data.Binding> or another <xref:System.Windows.Data.BindingBase> subclass.</span></span> <span data-ttu-id="5b797-271">Vous pouvez également les données brutes de n’importe quel [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] destiné à la liaison peut être placée ici, avec les liaisons réelles définies ultérieurement de type d’objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-271">Alternatively, raw data of any [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] object type intended for binding may be placed here, with the actual bindings defined later.</span></span>  
  
 <span data-ttu-id="5b797-272">*bindingUsage*</span><span class="sxs-lookup"><span data-stu-id="5b797-272">*bindingUsage*</span></span>  
 <span data-ttu-id="5b797-273">Utilisation de liaison qui prend la valeur à un contexte de données approprié.</span><span class="sxs-lookup"><span data-stu-id="5b797-273">A binding usage that evaluates to an appropriate data context.</span></span> <span data-ttu-id="5b797-274">Pour plus d’informations, consultez [Binding, extension de balisage](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-274">For details, see [Binding Markup Extension](~/docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
 <span data-ttu-id="5b797-275">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5b797-275">*resourceExtension*</span></span>  
 <span data-ttu-id="5b797-276">Une des opérations suivantes : `StaticResource`, ou `DynamicResource`.</span><span class="sxs-lookup"><span data-stu-id="5b797-276">One of the following: `StaticResource`, or `DynamicResource`.</span></span> <span data-ttu-id="5b797-277">Cette utilisation est utilisée lorsque vous faites référence aux données brutes définies en tant qu’objet dans les ressources.</span><span class="sxs-lookup"><span data-stu-id="5b797-277">This usage is used when referring to raw data defined as an object in resources.</span></span> <span data-ttu-id="5b797-278">Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-278">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5b797-279">*contextResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5b797-279">*contextResourceKey*</span></span>  
 <span data-ttu-id="5b797-280">L’identificateur de clé pour l’objet qui est demandé à partir d’un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-280">The key identifier for the object being requested from within a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-281">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-281">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-282">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-282">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|<span data-ttu-id="5b797-283">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-283">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-284">L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouvel objet de données personnalisées, l’établissement de cet objet en tant que <xref:System.Windows.FrameworkContentElement.DataContext%2A>et en définissant le chemin de liaison à une propriété qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="5b797-284">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-285">Se produit lorsque le contexte des données de cet élément change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-285">Occurs when this element's data context changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-286">Pour obtenir une explication des contextes de données et la liaison de données, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-286">For an explanation of data contexts and data binding, see [Data Binding Overview](~/docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="5b797-287">Lors d’un élément <xref:System.Windows.FrameworkContentElement.DataContext%2A> modifications, toutes les propriétés liées aux données sur cet élément susceptibles d’être affectées.</span><span class="sxs-lookup"><span data-stu-id="5b797-287">When an element's <xref:System.Windows.FrameworkContentElement.DataContext%2A> changes, all data-bound properties on this element are potentially affected.</span></span> <span data-ttu-id="5b797-288">Cela s’applique à tous les éléments qui sont des éléments descendants de l’élément actuel, qui héritent du contexte de données, ainsi que l’élément actuel lui-même.</span><span class="sxs-lookup"><span data-stu-id="5b797-288">This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</span></span> <span data-ttu-id="5b797-289">Toutes ces liaisons nouveau interprètent la nouvelle <xref:System.Windows.FrameworkContentElement.DataContext%2A> afin de refléter la nouvelle valeur dans les liaisons.</span><span class="sxs-lookup"><span data-stu-id="5b797-289">All such bindings re-interpret the new <xref:System.Windows.FrameworkContentElement.DataContext%2A> to reflect the new value in bindings.</span></span> <span data-ttu-id="5b797-290">Il n’existe aucune garantie concernant l’ordre de ces modifications au déclenchement de la <xref:System.Windows.FrameworkContentElement.DataContextChanged> événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-290">There is no guarantee made about the order of these changes relative to the raising of the <xref:System.Windows.FrameworkContentElement.DataContextChanged> event.</span></span>  <span data-ttu-id="5b797-291">Les modifications peuvent se produire avant l’événement, après l’événement, ou dans toute combinaison.</span><span class="sxs-lookup"><span data-stu-id="5b797-291">The changes can occur before the event, after the event, or in any mixture.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-292">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-292">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DataContext" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-293">Obtient ou définit la clé à utiliser pour rechercher le modèle de style pour ce contrôle dans les thèmes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-293">Gets or sets the key to use to find the style template for this control in themes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-294">Clé du style.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-294">The style key.</span>
          </span>
          <span data-ttu-id="5b797-295">Pour fonctionner correctement dans le cadre de la recherche du style du thème, cette valeur est supposée être le <see cref="T:System.Type" /> de l'élément qui est appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-295">To work correctly as part of theme style lookup, this value is expected to be the <see cref="T:System.Type" /> of the element being styled.</span>
          </span>
          <span data-ttu-id="5b797-296">
            <see langword="null" /> est une valeur acceptée dans un certain cas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-296">
              <see langword="null" /> is an accepted value for a certain case.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-297">Cette propriété n’est pas généralement définie via une de ses accesseurs Set directs.</span><span class="sxs-lookup"><span data-stu-id="5b797-297">This property is typically not set through any of its direct setters.</span></span> <span data-ttu-id="5b797-298">Au lieu de cela, vous substituez les métadonnées spécifiques au type de cette propriété de dépendance chaque fois que vous créez une sous-classe.</span><span class="sxs-lookup"><span data-stu-id="5b797-298">Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</span></span> <span data-ttu-id="5b797-299">Lorsque vous créez une sous-classe, appelez le <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> méthode par rapport à la <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificateur, dans le constructeur statique de la sous-classe de contrôle.</span><span class="sxs-lookup"><span data-stu-id="5b797-299">When you subclass, call the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method against the <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identifier, within the static constructor of the control subclass.</span></span>  
  
 <span data-ttu-id="5b797-300">Par exemple, une classe inline comme <xref:System.Windows.Documents.Bold> a en fait une implémentation très peu au-delà de la substitution de la <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> métadonnées dans son constructeur statique et l’exposition de plusieurs constructeurs d’instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-300">For instance, an inline class such as <xref:System.Windows.Documents.Bold> actually has very little implementation beyond overriding the <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> metadata in its static constructor, and exposing several instance constructors.</span></span> <span data-ttu-id="5b797-301">Le fait que les éléments entourés par le <xref:System.Windows.Documents.Bold> balise gain un <xref:System.Windows.Documents.TextElement.FontWeight%2A> propriété du <xref:System.Windows.FontWeights.Bold%2A> est implémenté dans le style de thème qui a été référencé en définissant la valeur par défaut <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> à `typeof(Bold)`.</span><span class="sxs-lookup"><span data-stu-id="5b797-301">The fact that elements surrounded by the <xref:System.Windows.Documents.Bold> tag gain a <xref:System.Windows.Documents.TextElement.FontWeight%2A> property of <xref:System.Windows.FontWeights.Bold%2A> is implemented within the theme style that was referenced by setting the default value of <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> to `typeof(Bold)`.</span></span>  
  
 <span data-ttu-id="5b797-302">Si vous souhaitez que votre élément ou un contrôle de délibérément ne pas utiliser les styles de thème, définissez le <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> propriété `true`.</span><span class="sxs-lookup"><span data-stu-id="5b797-302">If you want your element or control to deliberately not use theme styles, set the <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> property to `true`.</span></span>  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-303">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-303">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-304">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-304">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|<span data-ttu-id="5b797-305">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-305">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-306">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-306">Identifies the <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-307">Appelé immédiatement après l’initialisation d’un élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-307">Called immediately after an element is initialized.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-308">Implémentez cette méthode pour fournir une gestion spéciale qui doit se produire lorsque votre élément est initialisé pendant le processus de chargement de l’élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-308">Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</span></span>  
  
 <span data-ttu-id="5b797-309">Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation.</span><span class="sxs-lookup"><span data-stu-id="5b797-309">Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</span></span>  
  
 <span data-ttu-id="5b797-310">Si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> a été appelé précédemment, la base de mise en œuvre déclenchera le <xref:System.Windows.FrameworkContentElement.Initialized> événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-310">If <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was previously called, the base implementation will raise the <xref:System.Windows.FrameworkContentElement.Initialized> event.</span></span> <span data-ttu-id="5b797-311">Sinon, si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> n’a pas été appelé ou qu’il ne peut pas être déterminé si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> a été appelée, l’événement n’est pas déclenché.</span><span class="sxs-lookup"><span data-stu-id="5b797-311">Otherwise, if <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was not called or it could not be determined whether <xref:System.Windows.FrameworkContentElement.BeginInit%2A> was called, the event is not raised.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5b797-312">Nom de l'élément à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-312">Name of the element to search for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-313">Recherche un élément qui a le nom de l’identificateur fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-313">Finds an element that has the provided identifier name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-314">Élément demandé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-314">The requested element.</span>
          </span>
          <span data-ttu-id="5b797-315">Peut avoir la valeur <see langword="null" /> si aucun élément correspondant n'est trouvé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-315">May be <see langword="null" /> if no matching element was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-316">Si cet élément possède des éléments enfants, ces éléments enfants sont tous recherchés de manière récursive pour l’élément nommé demandé.</span><span class="sxs-lookup"><span data-stu-id="5b797-316">If this element has child elements, these child elements are all searched recursively for the requested named element.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-317">L’exemple suivant définit une propriété sur un élément recherché par nom dans un référencé <xref:System.Windows.Documents.FlowDocument> sur une page.</span><span class="sxs-lookup"><span data-stu-id="5b797-317">The following example sets a property on an element found by name within a referenced <xref:System.Windows.Documents.FlowDocument> on a page.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="5b797-318">Identificateur de clé de la ressource à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-318">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-319">Recherche une ressource avec la clé spécifiée et lève une exception si la ressource demandée est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-319">Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-320">Ressource trouvée, ou <see langword="null" /> si aucune ressource correspondante n’a été trouvée (mais lève également une exception si <see langword="null" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-320">The found resource, or <see langword="null" /> if no matching resource was found (but will also throw an exception if <see langword="null" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="5b797-321">Si vous appelez cette méthode pour une clé qui est introuvable, une exception est levée.</span><span class="sxs-lookup"><span data-stu-id="5b797-321">If you call this method for a key that cannot be found, an exception is thrown.</span></span> <span data-ttu-id="5b797-322">Si vous ne souhaitez pas gérer les exceptions pour ce cas, vous devez plutôt appeler <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-322">If you do not want to handle exceptions for this case, you should instead call <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>.</span></span> <span data-ttu-id="5b797-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Retourne `null` quand aucune ressource n’est trouvée et ne lève pas d’exception.</span><span class="sxs-lookup"><span data-stu-id="5b797-323"><xref:System.Windows.FrameworkContentElement.TryFindResource%2A> returns `null` when no resource is found, and does not throw an exception.</span></span>  
  
 <span data-ttu-id="5b797-324">Si la ressource est introuvable sur l’élément appelant, l’arborescence parente est recherchée à l’aide de l’arborescence logique, de la même façon que l’arborescence serait recherchée si une ressource était demandée par clé au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5b797-324">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="5b797-325">En règle générale, vous castez immédiatement la valeur de retour vers le type de la propriété que vous essayez de définir avec la valeur de la ressource retournée.</span><span class="sxs-lookup"><span data-stu-id="5b797-325">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-326">L’exemple suivant recherche une ressource, tel que défini dans le balisage et s’applique à une certaine propriété d’un élément en réponse à un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-326">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <span data-ttu-id="5b797-327">La clé de ressource demandée est introuvable.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-327">The requested resource key was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="5b797-328">
            <paramref name="resourceKey" /> a la valeur <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-328">
              <paramref name="resourceKey" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-329">Obtient ou définit un objet qui active la personnalisation de l’apparence, les effets ou d’autres caractéristiques de style qui s’appliquent à cet élément lorsqu’il capture le focus clavier.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-329">Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-330">Style souhaité à appliquer sur le focus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-330">The desired style to apply on focus.</span>
          </span>
          <span data-ttu-id="5b797-331">La valeur par défaut déclarée dans la propriété de dépendance est un <see cref="T:System.Windows.Style" /> statique vide.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-331">The default value as declared in the dependency property is an empty static <see cref="T:System.Windows.Style" />.</span>
          </span>
          <span data-ttu-id="5b797-332">Toutefois, la valeur effective au moment de l’exécution est souvent (mais pas toujours) un style tel qu’il est fourni par la prise en charge du thème pour les contrôles.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-332">However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-333">Lorsque vous définissez cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles sont presque toujours définis comme une ressource, plutôt qu’inline comme un élément et que la ressource est généralement référencé comme un <xref:System.Windows.StaticResourceExtension>.</span><span class="sxs-lookup"><span data-stu-id="5b797-333">When setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <xref:System.Windows.StaticResourceExtension>.</span></span>  
  
 <span data-ttu-id="5b797-334">Notez que cette propriété affecte l’apparence visuelle mais ne signale pas ainsi dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5b797-334">Note that this property affects visual appearance but does not report so in metadata.</span></span> <span data-ttu-id="5b797-335">Il s’agit, car la modification de l’apparence visuelle est pilotée par événements et ne peut-être pas s’appliquer à tout moment et par conséquent, ne doit pas généralement signaler toute information visual ou une disposition dans les métadonnées.</span><span class="sxs-lookup"><span data-stu-id="5b797-335">This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</span></span>  
  
 <span data-ttu-id="5b797-336">Sur le plan conceptuel, le comportement visuel de focus appliqué à un contrôle doit être cohérent à partir d’un élément à l’élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-336">Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</span></span> <span data-ttu-id="5b797-337">La méthode la plus sensible pour appliquer la cohérence consiste à modifier uniquement le style de focus visuel si vous composez un thème entier.</span><span class="sxs-lookup"><span data-stu-id="5b797-337">The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</span></span> <span data-ttu-id="5b797-338">Définition de cette propriété sur les styles individuels et non comme faisant partie d’un thème n’est pas l’utilisation prévue de cette propriété, car elle peut entraîner une expérience utilisateur ambiguë concernant le focus clavier.</span><span class="sxs-lookup"><span data-stu-id="5b797-338">Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</span></span> <span data-ttu-id="5b797-339">Si vous prévoyez un comportement spécifique à l’élément qui est délibérément pas cohérent à travers un thème, une approche bien meilleure consiste à utiliser des déclencheurs dans les styles pour les propriétés de l’état d’entrées individuelles, telles que <xref:System.Windows.UIElement.IsFocused%2A> ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>et à le faire d’une façon qui ne pas visuellement, interférer avec n’importe quel style de focus visuel existant.</span><span class="sxs-lookup"><span data-stu-id="5b797-339">If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <xref:System.Windows.UIElement.IsFocused%2A> or <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>, and to do so in a way that does not visually interfere with any existing focus visual style.</span></span> <span data-ttu-id="5b797-340">Pour plus d’informations sur l’intention de conception de <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> et d’autres propriétés du focus, consultez [focus dans les contrôles et FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-340">For more information on the design intention of <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> and alternative focus properties, see [Styling for Focus in Controls, and FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).</span></span>  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-341">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-341">XAML Attribute Usage</span></span>  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5b797-342">Utilisation des éléments de propriété XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-342">XAML Property Element Usage</span></span>  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-343">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-343">XAML Values</span></span>  
 <span data-ttu-id="5b797-344">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5b797-344">*resourceExtension*</span></span>  
 <span data-ttu-id="5b797-345">Une des opérations suivantes :, ou.</span><span class="sxs-lookup"><span data-stu-id="5b797-345">One of the following: , or .</span></span> <span data-ttu-id="5b797-346">Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-346">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5b797-347">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5b797-347">*styleResourceKey*</span></span>  
 <span data-ttu-id="5b797-348">La clé qui identifie le style demandé.</span><span class="sxs-lookup"><span data-stu-id="5b797-348">The key that identifies the style being requested.</span></span> <span data-ttu-id="5b797-349">La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-349">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5b797-350">Syntaxe d’élément de propriété est techniquement possible, mais non recommandée.</span><span class="sxs-lookup"><span data-stu-id="5b797-350">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="5b797-351">Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-351">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="5b797-352">Une référence de liaison à l’aide ou <xref:System.Windows.Data.Binding> est également possible, mais rare.</span><span class="sxs-lookup"><span data-stu-id="5b797-352">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-353">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-353">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-354">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-354">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|<span data-ttu-id="5b797-355">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-355">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-356">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-356">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-357">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-357">Identifies the <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-358">Obtient ou définit une valeur qui indique si ce <see cref="T:System.Windows.FrameworkContentElement" /> doit forcer le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] pour restituer le curseur comme déclaré par la propriété <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> de cette instance.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-358">Gets or sets a value indicating whether this <see cref="T:System.Windows.FrameworkContentElement" /> should force the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] to render the cursor as declared by this instance's <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> property.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-359">
            <see langword="true" /> pour forcer la présentation de curseur lorsqu'il se trouve sur cet élément pour utiliser ce paramètre d'instance pour le curseur (y compris sur tous les éléments enfants) ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-359">
              <see langword="true" /> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="5b797-360">La valeur par défaut est <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-360">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-361">Si cette propriété `true` remplacera les préférences de curseur établies par les éléments enfants.</span><span class="sxs-lookup"><span data-stu-id="5b797-361">Setting this property to `true` will override the cursor preferences established by child elements.</span></span> <span data-ttu-id="5b797-362">Par conséquent, en général application sous peine [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] peut prêter à confusion pour l’utilisateur, en particulier si les éléments enfants essaient de spécifier des curseurs.</span><span class="sxs-lookup"><span data-stu-id="5b797-362">Doing so in general application [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] might be confusing for the user, particularly if child elements are attempting to specify cursors.</span></span> <span data-ttu-id="5b797-363">Paramètre <xref:System.Windows.FrameworkElement.ForceCursor%2A> est plus appropriée dans les scénarios de sous-classement ou de composition de contrôle.</span><span class="sxs-lookup"><span data-stu-id="5b797-363">Setting <xref:System.Windows.FrameworkElement.ForceCursor%2A> is more appropriate in control subclassing or compositing scenarios.</span></span>  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-364">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-364">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-365">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-365">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|<span data-ttu-id="5b797-366">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-366">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-367">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-367">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-368">L’exemple suivant force le curseur au-dessus de l’élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-368">The following example forces the cursor while over the element.</span></span>  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-369">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-369">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5b797-370">Le <see cref="T:System.Windows.DependencyProperty" /> cible à partir duquel obtenir la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-370">The target <see cref="T:System.Windows.DependencyProperty" /> from which to get the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-371">Reçoit le <see cref="T:System.Windows.Data.BindingExpression" /> pour la liaison de propriété spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-371">Gets the <see cref="T:System.Windows.Data.BindingExpression" /> for the specified property's binding.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-372">Retourne un <see cref="T:System.Windows.Data.BindingExpression" /> si la cible est liée aux données ; sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-372">Returns a <see cref="T:System.Windows.Data.BindingExpression" /> if the target is data bound; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="5b797-373">L’exemple suivant récupère une liaison en interrogeant une propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-373">The following example retrieves a binding by querying a property.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-374">Retourne un parent logique alternatif pour cet élément s’il n’existe aucun parent visuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-374">Returns an alternative logical parent for this element if there is no visual parent.</span>
          </span>
          <span data-ttu-id="5b797-375">Dans ce cas, un parent <see cref="T:System.Windows.FrameworkContentElement" /> a toujours la même valeur que la propriété <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-375">In this case, a <see cref="T:System.Windows.FrameworkContentElement" /> parent is always the same value as the <see cref="P:System.Windows.FrameworkContentElement.Parent" /> property.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-376">Retourne une valeur autre que <see langword="null" /> quand une implémentation de niveau infrastructure WPF de cette méthode a une connexion de parent non visuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-376">Returns something other than <see langword="null" /> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-377">L’implémentation par défaut retourne le parent visuel unique attendu.</span><span class="sxs-lookup"><span data-stu-id="5b797-377">The default implementation returns the expected single visual parent.</span></span> <span data-ttu-id="5b797-378">Des implémentations personnalisées peuvent retourner d’autres relations parentes.</span><span class="sxs-lookup"><span data-stu-id="5b797-378">Custom implementations might return alternate parent relationships.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-379">Se produit lorsque <see cref="T:System.Windows.FrameworkContentElement" /> est initialisé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-379">Occurs when this <see cref="T:System.Windows.FrameworkContentElement" /> is initialized.</span>
          </span>
          <span data-ttu-id="5b797-380">Cela coïncide avec les cas où la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> se transforme de <see langword="false" /> (ou indéfini) en <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-380">This coincides with cases where the value of the <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> property changes from <see langword="false" /> (or undefined) to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-381">Cet événement est déclenché chaque fois que le <xref:System.Windows.FrameworkContentElement.EndInit%2A> ou <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> méthodes sont appelées.</span><span class="sxs-lookup"><span data-stu-id="5b797-381">This event will be raised whenever the <xref:System.Windows.FrameworkContentElement.EndInit%2A> or <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> methods are called.</span></span> <span data-ttu-id="5b797-382">Appels à ces méthodes peuvent ont été apportées par un code délibéré, ou par le [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] processus de chargement.</span><span class="sxs-lookup"><span data-stu-id="5b797-382">Calls to these methods could have been made by deliberate code, or by the [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] loading process.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-383">Obtient ou définit le contexte pour l’entrée utilisée par ce <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-383">Gets or sets the context for input used by this <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-384">Portée d’entrée, qui modifie la façon dont l’entrée provenant d’autres méthodes d’entrée est interprétée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-384">The input scope, which modifies how input from alternative input methods is interpreted.</span>
          </span>
          <span data-ttu-id="5b797-385">La valeur par défaut est <see langword="null" /> (ce qui entraîne une gestion par défaut des commandes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-385">The default value is <see langword="null" /> (which results in a default handling of commands).</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-386">Cette propriété de dépendance hérite des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-386">This dependency property inherits property values.</span></span> <span data-ttu-id="5b797-387">S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkElement.InputScope%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.InputScope%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.</span><span class="sxs-lookup"><span data-stu-id="5b797-387">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.InputScope%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.InputScope%2A> value of the nearest parent element with this value assigned.</span></span>  
  
 <span data-ttu-id="5b797-388">Bien qu’un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilisation de la syntaxe est répertoriée et est autorisée syntaxiquement, la définition de cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] n’est pas courante.</span><span class="sxs-lookup"><span data-stu-id="5b797-388">Although a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax usage is listed and is syntactically allowed, setting this property in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] is not common.</span></span>  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-389">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-389">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-390">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-390">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|<span data-ttu-id="5b797-391">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-391">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-392">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-392">Identifies the <see cref="P:System.Windows.FrameworkContentElement.InputScope" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-393">Obtient une valeur qui indique si cet élément a été initialisé, en étant chargé comme [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], ou en ayant explicitement sa méthode <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> appelée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-393">Gets a value indicating whether this element has been initialized, either by being loaded as [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], or by explicitly having its <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> method called.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-394">
            <see langword="true" /> si l'élément est initialisé par le chargement susmentionné ou les appels de méthode ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-394">
              <see langword="true" /> if the element is initialized per the aforementioned loading or method calls; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-395">Cette propriété peut également être `true` si cet élément a été déplacé au sein de l’arborescence d’éléments tel qu’il a un nouvel élément parent et par conséquent soit rechargé.</span><span class="sxs-lookup"><span data-stu-id="5b797-395">This property may also be `true` if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-396">Obtient une valeur qui indique si cet élément a été chargé pour la présentation.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-396">Gets a value indicating whether this element has been loaded for presentation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-397">
            <see langword="true" /> si l'élément actuel est attaché à une arborescence d'éléments et a été restitué ; <see langword="false" /> si l'élément n'a jamais été attaché à une arborescence d'éléments chargée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-397">
              <see langword="true" /> if the current element is attached to an element tree and has been rendered; <see langword="false" /> if the element has never been attached to a loaded element tree.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-398">À partir d’une instance nouvellement construite, cette propriété fait commence `false`et reste `true` une fois qu’il est défini sur `true`, même si par la suite supprimé par le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-398">From a newly constructed instance, this property starts off `false`, and remains `true` once it is set to `true`, even if subsequently removed by  code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-399">L’exemple de code suivant utilise <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> comme un contrôle conditionnel pour s’assurer qu’une fonction `displayData` (non illustré) sont des éléments valides chargés dans la page de travailler sur, dans le cadre d’un gestionnaire à la demande.</span><span class="sxs-lookup"><span data-stu-id="5b797-399">The following example code uses <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> as a conditional check to assure that a function `displayData` (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</span></span> <span data-ttu-id="5b797-400">Que la même logique est exécutée comme un gestionnaire d’événements <xref:System.Windows.FrameworkContentElement.Loaded>.</span><span class="sxs-lookup"><span data-stu-id="5b797-400">That same logic is run as an event handler for <xref:System.Windows.FrameworkContentElement.Loaded>.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-401">Obtient ou définit les informations de langue de localisation/globalisation qui s’appliquent à un élément spécifique.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-401">Gets or sets localization/globalization language information that applies to an individual element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-402">Informations de culture pour cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-402">The culture information for this element.</span>
          </span>
          <span data-ttu-id="5b797-403">La valeur par défaut est une instance de <see cref="T:System.Windows.Markup.XmlLanguage" /> avec la chaîne “en-US” comme valeur <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-403">The default value is an <see cref="T:System.Windows.Markup.XmlLanguage" /> instance with its <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> value set to the string "en-US".</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-404">Les formats de chaîne respectent la norme RFC 3066.</span><span class="sxs-lookup"><span data-stu-id="5b797-404">The string formats follow the RFC 3066 standard.</span></span> <span data-ttu-id="5b797-405">Par exemple, aux États-Unis L’anglais est « en-US ».</span><span class="sxs-lookup"><span data-stu-id="5b797-405">For example, U.S. English is "en-US".</span></span> <span data-ttu-id="5b797-406">Consultez <xref:System.Windows.Markup.XmlLanguage> pour plus d’informations sur les valeurs et le format.</span><span class="sxs-lookup"><span data-stu-id="5b797-406">See <xref:System.Windows.Markup.XmlLanguage> for more information on the values and format.</span></span>  
  
 <span data-ttu-id="5b797-407">Cette propriété de dépendance hérite des valeurs de propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-407">This dependency property inherits property values.</span></span> <span data-ttu-id="5b797-408">S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkElement.Language%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.Language%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.</span><span class="sxs-lookup"><span data-stu-id="5b797-408">If there are child elements with no other value for <xref:System.Windows.FrameworkElement.Language%2A> established through local values or styles, the property system will set the value to be the <xref:System.Windows.FrameworkElement.Language%2A> value of the nearest parent element with this value assigned.</span></span>  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-409">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-409">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-410">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-410">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|<span data-ttu-id="5b797-411">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-411">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-412">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Language" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-412">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Language" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-413">Se produit quand l’élément est disposé, rendu et prêt pour l’interaction.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-413">Occurs when the element is laid out, rendered, and ready for interaction.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-414">Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="5b797-414">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="5b797-415">Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.</span><span class="sxs-lookup"><span data-stu-id="5b797-415">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-416">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-417">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-417">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|<span data-ttu-id="5b797-418">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-418">Routing strategy</span></span>|<span data-ttu-id="5b797-419">Direct</span><span class="sxs-lookup"><span data-stu-id="5b797-419">Direct</span></span>|  
|<span data-ttu-id="5b797-420">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-420">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-421">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-421">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-422">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-422">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-423">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-423">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-424">Obtient un énumérateur pour les éléments enfants logiques de cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-424">Gets an enumerator for the logical child elements of this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-425">Un énumérateur pour les éléments enfants logiques de cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-425">An enumerator for logical child elements of this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-426">Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-426">For more information on how to use <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> and <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, see [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="5b797-427">La direction sur laquelle le focus doit être déplacé, comme une valeur de l'énumération.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-427">The direction that focus is to be moved, as a value of the enumeration.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-428">Déplace le focus clavier de cet élément sur un autre élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-428">Moves the keyboard focus from this element to another element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-429">Retourne la valeur <see langword="true" /> si le focus est déplacé avec succès ; <see langword="false" /> si l'élément cible dans la direction spécifiée n'existe pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-429">Returns <see langword="true" /> if focus is moved successfully; <see langword="false" /> if the target element in direction as specified does not exist.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-430">Obtient ou définit le nom d’identification de l’élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-430">Gets or sets the identifying name of the element.</span>
          </span>
          <span data-ttu-id="5b797-431">Le nom fournit une référence d’instance pour permettre à du code-behind programmatique, tel que le code d’un gestionnaire d’événements, de faire référence à un élément une fois qu’il est construit pendant l’analyse de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-431">The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-432">Nom de l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-432">The name of the element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-433">L’utilisation la plus courante de cette propriété est lorsque vous spécifiez un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nom de l’élément dans le balisage.</span><span class="sxs-lookup"><span data-stu-id="5b797-433">The most common usage of this property is when specifying a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] element name in markup.</span></span>  
  
 <span data-ttu-id="5b797-434">Cette propriété fournit essentiellement une propriété de commodité de niveau infrastructure WPF pour définir le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-434">This property essentially provides a WPF framework-level convenience property to set the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [x:Name Directive](~/docs/framework/xaml-services/x-name-directive.md).</span></span>  
  
 <span data-ttu-id="5b797-435">Obtenir un <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code n’est pas courante, car si vous avez déjà la référence appropriée dans le code, vous pouvez simplement appeler des méthodes et propriétés sur l’élément de référence et n’avez généralement pas besoin du <xref:System.Windows.FrameworkContentElement.Name%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-435">Getting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <xref:System.Windows.FrameworkContentElement.Name%2A>.</span></span> <span data-ttu-id="5b797-436">Une exception est si la chaîne a une signification surchargée, par exemple s’il est utile d’afficher ce nom dans [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5b797-436">An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="5b797-437">Définissant un <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code si la version d’origine <xref:System.Windows.FrameworkContentElement.Name%2A> a été ensemble à partir du balisage est également pas recommandée, et modification de la propriété ne changera pas la référence d’objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-437">Setting a <xref:System.Windows.FrameworkContentElement.Name%2A> from code if the original <xref:System.Windows.FrameworkContentElement.Name%2A> was set from markup is also not recommended, and changing the property will not change the object reference.</span></span> <span data-ttu-id="5b797-438">Ces références d’objet sont créés uniquement lorsque les portées de nom sous-jacentes sont créées explicitement pendant [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] le chargement.</span><span class="sxs-lookup"><span data-stu-id="5b797-438">Such object references are created only when the underlying namescopes are explicitly created during [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] loading.</span></span>  
  
 <span data-ttu-id="5b797-439">Vous devez appeler spécifiquement <xref:System.Windows.FrameworkContentElement.RegisterName%2A> pour apporter une modification effective sur le <xref:System.Windows.FrameworkContentElement.Name%2A> propriété d’un élément déjà chargé.</span><span class="sxs-lookup"><span data-stu-id="5b797-439">You must specifically call <xref:System.Windows.FrameworkContentElement.RegisterName%2A> to make an effective change on the <xref:System.Windows.FrameworkContentElement.Name%2A> property of an already loaded element.</span></span>  
  
 <span data-ttu-id="5b797-440">Un notable cas où le paramètre <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code est important est pour exécutent des éléments d’affectation de noms que les tables de montage séquentiel.</span><span class="sxs-lookup"><span data-stu-id="5b797-440">One notable case where setting <xref:System.Windows.FrameworkContentElement.Name%2A> from  code is important is for naming elements that storyboards will run against.</span></span> <span data-ttu-id="5b797-441">Avant vous pouvez inscrire un nom, vous devez également instancier et attribuer une <xref:System.Windows.NameScope> instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-441">Before you can register a name, might also need to instantiate and assign a <xref:System.Windows.NameScope> instance.</span></span> <span data-ttu-id="5b797-442">Consultez la section exemple, ou [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-442">See the Example section, or [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="5b797-443">Paramètre <xref:System.Windows.FrameworkContentElement.Name%2A> à partir de code a des applications limitées, mais la recherche d’un élément par nom est plus courante, en particulier si vous employez un modèle de navigation où rechargent les pages dans l’application et le code d’exécution n’est pas nécessairement le code-behind de qui page respectif.</span><span class="sxs-lookup"><span data-stu-id="5b797-443">Setting <xref:System.Windows.FrameworkContentElement.Name%2A> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</span></span> <span data-ttu-id="5b797-444">La méthode utilitaire <xref:System.Windows.FrameworkContentElement.FindName%2A>, qui est disponible à partir d’un <xref:System.Windows.FrameworkContentElement>, peut rechercher n’importe quel élément par <xref:System.Windows.FrameworkContentElement.Name%2A> de manière récursive d’arborescence logique de cet élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-444">The utility method <xref:System.Windows.FrameworkContentElement.FindName%2A>, which is available from any <xref:System.Windows.FrameworkContentElement>, can find any element by <xref:System.Windows.FrameworkContentElement.Name%2A> in that element's logical tree recursively.</span></span> <span data-ttu-id="5b797-445">Ou vous pouvez utiliser la <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> méthode statique de <xref:System.Windows.LogicalTreeHelper>, qui prend également la <xref:System.Windows.FrameworkContentElement.Name%2A> chaîne en tant qu’argument.</span><span class="sxs-lookup"><span data-stu-id="5b797-445">Or you can use the <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> static method of <xref:System.Windows.LogicalTreeHelper>, which also takes the <xref:System.Windows.FrameworkContentElement.Name%2A> string as an argument.</span></span>  
  
 <span data-ttu-id="5b797-446">Éléments racine couramment utilisés (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> par exemple) implémentent l’interface <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="5b797-446">Commonly used root elements (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> for example) implement the interface <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="5b797-447">Les implémentations de cette interface sont supposées renforcer les noms d’être non équivoque dans leur étendue.</span><span class="sxs-lookup"><span data-stu-id="5b797-447">Implementations of this interface are expected to enforce that names be unambiguous within their scope.</span></span>  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-448">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-448">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-449">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-449">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|<span data-ttu-id="5b797-450">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-450">Metadata properties set to `true`</span></span>|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-451">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Name" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-451">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Name" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-452">Fournit des données sur l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-452">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-453">Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> rencontre cette classe sur son itinéraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-453">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5b797-454">Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-454">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-455">Cette méthode n’a pas d’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="5b797-455">This method has no default implementation.</span></span> <span data-ttu-id="5b797-456">Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.</span><span class="sxs-lookup"><span data-stu-id="5b797-456">You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5b797-457">L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur \* méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-457">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5b797-458">Dans ce cas, l’événement correspondant est un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-458">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5b797-459">Le modèle d’implémentation des méthodes On \* est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires.</span><span class="sxs-lookup"><span data-stu-id="5b797-459">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="5b797-460">Par conséquent, votre implémentation doit prendre des propriétés de source des arguments de l’événement en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas).</span><span class="sxs-lookup"><span data-stu-id="5b797-460">Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5b797-461">Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-461">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5b797-462">Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-462">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-463">Données d'événement de l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-463">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-464">Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> rencontre cette classe sur son itinéraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-464">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5b797-465">Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-465">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-466">Cette méthode n’a pas d’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="5b797-466">This method has no default implementation.</span></span> <span data-ttu-id="5b797-467">Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.</span><span class="sxs-lookup"><span data-stu-id="5b797-467">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5b797-468">L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur \* méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-468">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5b797-469">Dans ce cas, l’événement correspondant est un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-469">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5b797-470">Le modèle d’implémentation des méthodes On \* est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas).</span><span class="sxs-lookup"><span data-stu-id="5b797-470">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5b797-471">Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-471">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5b797-472">Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-472">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-473">Données d'événement de l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-473">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-474">Gestionnaire de classe pour l'événement <see cref="E:System.Windows.ContentElement.GotFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-474">Class handler for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-475">Ce gestionnaire de classe définit le comportement approprié du focus sur cet élément si l’événement provient de cet élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-475">This class handler sets appropriate focus behavior on this element if the event originated from this element.</span></span> <span data-ttu-id="5b797-476">Si la source de l’événement était un autre élément dans l’arborescence, le gestionnaire ne fait rien.</span><span class="sxs-lookup"><span data-stu-id="5b797-476">If the event's source was another element in the tree, the handler does nothing.</span></span>  
  
 <span data-ttu-id="5b797-477">Substituez cette méthode afin de modifier ces par défaut sur votre élément de comportement de convergence.</span><span class="sxs-lookup"><span data-stu-id="5b797-477">Override this method in order to change these default focusing behavior on your element.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-478">Données d'événement de l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-478">Event data for the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-479">Déclenche l'événement <see cref="E:System.Windows.FrameworkContentElement.Initialized" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-479">Raises the <see cref="E:System.Windows.FrameworkContentElement.Initialized" /> event.</span>
          </span>
          <span data-ttu-id="5b797-480">Cette méthode est appelée toutes les fois que <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> a la valeur <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-480">This method is invoked whenever <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> is set to <see langword="true" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-481">L’implémentation par défaut de cette méthode virtuelle déclenche l’événement comme décrit précédemment dans cette rubrique.</span><span class="sxs-lookup"><span data-stu-id="5b797-481">The default implementation of this virtual method raises the event as described earlier in this topic.</span></span> <span data-ttu-id="5b797-482">Les substitutions doivent appeler base () pour conserver ce comportement.</span><span class="sxs-lookup"><span data-stu-id="5b797-482">Overrides should call base() to preserve this behavior.</span></span>  
  
 <span data-ttu-id="5b797-483">Notez que le <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> propriété est en lecture seule.</span><span class="sxs-lookup"><span data-stu-id="5b797-483">Note that the <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> property is read-only.</span></span> <span data-ttu-id="5b797-484">Par conséquent, vous ne pouvez pas définir pour forcer le comportement de l’initialisation de cette façon.</span><span class="sxs-lookup"><span data-stu-id="5b797-484">Therefore, you cannot set it to force initialization behavior that way.</span></span> <span data-ttu-id="5b797-485">Paramètre d’initialisation est conçu pour être utilisé uniquement par le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span><span class="sxs-lookup"><span data-stu-id="5b797-485">Initialization setting is intended to be done only by the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-486">Données d’événement qui décrivent la propriété ayant changé, dont les anciennes et nouvelles valeurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-486">The event data that describes the property that changed, including the old and new values.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-487">Méthode appelée chaque fois que la valeur effective d’une propriété de dépendance de ce <see cref="T:System.Windows.FrameworkContentElement" /> est mise à jour.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-487">Invoked whenever the effective value of any dependency property on this <see cref="T:System.Windows.FrameworkContentElement" /> has been updated.</span>
          </span>
          <span data-ttu-id="5b797-488">La propriété de dépendance spécifique qui a changé est indiquée dans le paramètre d’arguments.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-488">The specific dependency property that changed is reported in the arguments parameter.</span>
          </span>
          <span data-ttu-id="5b797-489">Substitue <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-489">Overrides <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-490">Cette méthode n’est pas destinée à généralement détecter les modifications apportées aux propriétés ou les invalidations.</span><span class="sxs-lookup"><span data-stu-id="5b797-490">This method is not intended to generally detect property changes or invalidations.</span></span> <span data-ttu-id="5b797-491">Il est destiné à la place les modifications du modèle d’invalidation général si certaines informations sont connues de larges classifications de propriétés.</span><span class="sxs-lookup"><span data-stu-id="5b797-491">It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</span></span>  
  
 <span data-ttu-id="5b797-492">Cette méthode est appelée potentiellement plusieurs fois pendant la durée de vie d’un objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-492">This method is potentially invoked many times during the life of an object.</span></span> <span data-ttu-id="5b797-493">Par conséquent, vous pouvez obtenir de meilleures performances si vous substituez les métadonnées de propriétés spécifiques puis attachez <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> fonctions pour les propriétés individuelles.</span><span class="sxs-lookup"><span data-stu-id="5b797-493">Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <xref:System.Windows.CoerceValueCallback> or <xref:System.Windows.PropertyChangedCallback> functions for individual properties.</span></span> <span data-ttu-id="5b797-494">Toutefois, vous utiliseriez cette méthode si un <xref:System.Windows.FrameworkContentElement> inclut un nombre important de propriétés de dépendance mises en corrélation par valeur, ou si elle inclut la logique comme comportement de rendu qui doit être réexécuté pour plusieurs cas d’invalidations de propriétés connexes.</span><span class="sxs-lookup"><span data-stu-id="5b797-494">However, you would use this method if a <xref:System.Windows.FrameworkContentElement> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</span></span>  
  
 <span data-ttu-id="5b797-495">Notez qu’il existe une portant le même nom `OnPropertyChanged` méthode avec une signature différente (le type de paramètre est <xref:System.ComponentModel.PropertyChangedEventArgs>) qui peuvent apparaître sur un nombre de classes.</span><span class="sxs-lookup"><span data-stu-id="5b797-495">Note that there is an identically named `OnPropertyChanged` method with a different signature (the parameter type is <xref:System.ComponentModel.PropertyChangedEventArgs>) that can appear on a number of classes.</span></span> <span data-ttu-id="5b797-496">Que `OnPropertyChanged` est utilisé pour les notifications d’objet de données, et fait partie du contrat pour <xref:System.ComponentModel.INotifyPropertyChanged>.</span><span class="sxs-lookup"><span data-stu-id="5b797-496">That `OnPropertyChanged` is used for data object notifications, and is part of the contract for <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="5b797-497">Appelez toujours l’implémentation de base, comme première opération dans votre implémentation.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-497">Always call the base implementation, as the first operation in your implementation.</span>
            </span>
            <span data-ttu-id="5b797-498">Entier sera considérablement désactivé dans le cas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés, ce qui entraîne le signalement de valeurs incorrectes.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-498">Failure to do this will significantly disable the entire [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system, which causes incorrect values to be reported.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">
          <span data-ttu-id="5b797-499">L'ancien style.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-499">The old style.</span>
          </span>
        </param>
        <param name="newStyle">
          <span data-ttu-id="5b797-500">Le nouveau style.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-500">The new style.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-501">Appelé lorsque le style qui est utilisé sur cet élément change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-501">Invoked when the style that is in use on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-502">Cette méthode présente une implémentation par défaut qui définit un indicateur interne, en notant la condition de style modifié.</span><span class="sxs-lookup"><span data-stu-id="5b797-502">This method has a default implementation that sets an internal flag noting the style changed condition.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="5b797-503">Toujours appeler l’implémentation de base, sinon les styles ne peut pas être appliqués.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-503">Always call the base implementation, otherwise styles cannot be applied.</span>
            </span>
            <span data-ttu-id="5b797-504">Scénarios pour la substitution de cette méthode peuvent inclure si votre classe dérivée possède un sélecteur de style spécialisé, ou met en cache les valeurs de style.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-504">Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</span>
            </span>
            <span data-ttu-id="5b797-505">Modifications de thème potentiellement appelle cette méthode.</span>
            <span class="sxs-lookup">
              <span data-stu-id="5b797-505">Theme changes will potentially invoke this method.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-506">Fournit des données sur l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-506">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-507">Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> rencontre cette classe sur son itinéraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-507">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5b797-508">Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-508">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-509">Cette méthode n’a pas d’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="5b797-509">This method has no default implementation.</span></span> <span data-ttu-id="5b797-510">Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.</span><span class="sxs-lookup"><span data-stu-id="5b797-510">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5b797-511">L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur \* méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-511">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5b797-512">Dans ce cas, l’événement correspondant est un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-512">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5b797-513">Le modèle d’implémentation des méthodes On \* est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas).</span><span class="sxs-lookup"><span data-stu-id="5b797-513">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5b797-514">Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-514">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5b797-515">Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-515">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="5b797-516">Fournit des données sur l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-516">Provides data about the event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-517">Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> rencontre cette classe sur son itinéraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-517">Invoked whenever the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> routed event reaches this class in its route.</span>
          </span>
          <span data-ttu-id="5b797-518">Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-518">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-519">Cette méthode n’a pas d’implémentation par défaut.</span><span class="sxs-lookup"><span data-stu-id="5b797-519">This method has no default implementation.</span></span> <span data-ttu-id="5b797-520">Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.</span><span class="sxs-lookup"><span data-stu-id="5b797-520">You should still call base() in case an intermediate class in the inheritance has implemented this method.</span></span>  
  
 <span data-ttu-id="5b797-521">L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur \* méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance.</span><span class="sxs-lookup"><span data-stu-id="5b797-521">The purpose of this method is somewhat similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</span></span> <span data-ttu-id="5b797-522">Dans ce cas, l’événement correspondant est un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="5b797-523">Le modèle d’implémentation des méthodes On \* est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas).</span><span class="sxs-lookup"><span data-stu-id="5b797-523">The implementation pattern of the On\* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</span></span> <span data-ttu-id="5b797-524">Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-524">Subclasses of <xref:System.Windows.FrameworkContentElement> could choose to call private class handler methods when the event is received along the route.</span></span> <span data-ttu-id="5b797-525">Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.</span><span class="sxs-lookup"><span data-stu-id="5b797-525">One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-526">Obtient ou définit une valeur qui indique si cet élément incorpore des propriétés de style de styles de thème.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-526">Gets or sets a value indicating whether this element incorporates style properties from theme styles.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-527">
            <see langword="true" /> si cet élément n'utilise pas de propriétés du style de thème ; toutes les propriétés qui proviennent du style proviennent de styles d'application locaux, et les propriétés du style de thème ne s'appliquent pas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-527">
              <see langword="true" /> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</span>
          </span>
          <span data-ttu-id="5b797-528">
            <see langword="false" /> si les styles d'application s'appliquent en premier, puis que les styles de thème s'appliquent aux propriétés qui n'ont pas été spécifiquement définies dans les styles d'application.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-528">
              <see langword="false" /> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-529">L’utilisation la plus courante de cette propriété est une utilisation indirecte dans l’accesseur Set d’un style qui fournit un style à thème.</span><span class="sxs-lookup"><span data-stu-id="5b797-529">The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</span></span>  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-530">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-531">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-531">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|<span data-ttu-id="5b797-532">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-532">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-533">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-533">Identifies the <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-534">Obtient le parent de l’arborescence logique pour cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-534">Gets the parent in the logical tree for this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-535">Parent logique pour cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-535">The logical parent for this element.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-536">Notez que le parent logique d’un élément peut éventuellement changer selon les fonctionnalités de votre application, et en conservant la valeur de cette propriété ne reflétera pas cette modification.</span><span class="sxs-lookup"><span data-stu-id="5b797-536">Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</span></span> <span data-ttu-id="5b797-537">Vous devez généralement obtenir la valeur juste avant que vous en avez besoin.</span><span class="sxs-lookup"><span data-stu-id="5b797-537">You typically should get the value immediately before you need it.</span></span>  
  
 <span data-ttu-id="5b797-538">Consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) pour plus d’informations sur le parcours des arborescences logiques et les scénarios où il est appropriée de cette approche vers la découverte de l’élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-538">See [Trees in WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</span></span>  
  
 <span data-ttu-id="5b797-539">Le système de propriétés recalculera potentiellement toutes les valeurs de propriété d’un élément lorsqu’il est apparenté à nouveau, car certaines propriétés héritent des valeurs dans l’arborescence logique.</span><span class="sxs-lookup"><span data-stu-id="5b797-539">The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</span></span> <span data-ttu-id="5b797-540">Le <xref:System.Windows.FrameworkContentElement.DataContext%2A> qui s’applique pour les liaisons peut également changer lorsque les éléments sont apparentés à nouveau.</span><span class="sxs-lookup"><span data-stu-id="5b797-540">The <xref:System.Windows.FrameworkContentElement.DataContext%2A> that applies for bindings can also change when elements are reparented.</span></span>  
  
 <span data-ttu-id="5b797-541">Modification du parent d’un élément est généralement uniquement effectuée via la manipulation de collections, à l’aide de dédié méthodes add ou remove, ou via la définition des propriétés de contenu d’éléments.</span><span class="sxs-lookup"><span data-stu-id="5b797-541">Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</span></span>  
  
 <span data-ttu-id="5b797-542">Le scénario le plus courant pour l’utilisation de la <xref:System.Windows.FrameworkContentElement.Parent%2A> propriété consiste à obtenir une référence, puis d’obtenir différentes <xref:System.Windows.FrameworkContentElement> les valeurs de propriété à partir du parent.</span><span class="sxs-lookup"><span data-stu-id="5b797-542">The most typical scenario for using the <xref:System.Windows.FrameworkContentElement.Parent%2A> property is to obtain a reference and then get various <xref:System.Windows.FrameworkContentElement> property values from the parent.</span></span> <span data-ttu-id="5b797-543">Pour les modèles, les <xref:System.Windows.FrameworkContentElement.Parent%2A> du modèle à long terme sera `null`.</span><span class="sxs-lookup"><span data-stu-id="5b797-543">For templates, the <xref:System.Windows.FrameworkContentElement.Parent%2A> of the template eventually will be `null`.</span></span> <span data-ttu-id="5b797-544">Pour franchir ce point et développer l’arborescence logique où le modèle est réellement appliqué, utilisez <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-544">To get past this point and extend into the logical tree where the template is actually applied, use <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-545">L’exemple suivant vérifie si le <xref:System.Windows.FrameworkContentElement.Parent%2A> d’un <xref:System.Windows.Documents.TextPointer> est d’un type particulier.</span><span class="sxs-lookup"><span data-stu-id="5b797-545">The following example checks to see whether the <xref:System.Windows.FrameworkContentElement.Parent%2A> of a <xref:System.Windows.Documents.TextPointer> is of a particular type.</span></span>  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="5b797-546">La direction pour laquelle une future modification de focus doit être déterminée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-546">The direction for which a prospective focus change should be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-547">Détermine l'élément suivant qui recevrait le focus relatif à cet élément pour une direction du déplacement du focus fournie, mais ne déplace pas réellement le focus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-547">Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</span>
          </span>
          <span data-ttu-id="5b797-548">Cette méthode est sealed et ne peut pas être substituée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-548">This method is sealed and cannot be overridden.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-549">L'élément suivant sur lequel se déplacerait le focus si le focus était parcouru réellement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-549">The next element that focus would move to if focus were actually traversed.</span>
          </span>
          <span data-ttu-id="5b797-550">Peut retourner <see langword="null" /> si le focus ne peut pas être déplacé par rapport à cet élément pour la direction fournie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-550">May return <see langword="null" /> if focus cannot be moved relative to this element for the provided direction.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> est la méthode connexe qui déplace effectivement le focus.</span><span class="sxs-lookup"><span data-stu-id="5b797-551"><xref:System.Windows.FrameworkContentElement.MoveFocus%2A> is the related method that actually does move focus.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="5b797-552">Spécifié l'une des directions suivantes dans le <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-552">Specified one of the following directions in the <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />.</span>
          </span>
          <span data-ttu-id="5b797-553">Ces sens ne sont pas légaux pour <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (mais le sont pour <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-553">These directions are not legal for <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (but they are legal for <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5b797-554">Nom à utiliser pour le mappage nom-objet spécifié.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-554">Name to use for the specified name-object mapping.</span>
          </span>
        </param>
        <param name="scopedElement">
          <span data-ttu-id="5b797-555">Objet pour le mappage.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-555">Object for the mapping.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-556">Fournit un accesseur qui simplifie l'accès à la méthode d'inscription <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-556">Provides an accessor that simplifies access to the <see cref="T:System.Windows.NameScope" /> registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-557">Cette méthode est une méthode pratique pour appeler <xref:System.Windows.NameScope.RegisterName%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-557">This method is a convenience method for calling <xref:System.Windows.NameScope.RegisterName%2A>.</span></span> <span data-ttu-id="5b797-558">L’implémentation vérifie les éléments parents successifs jusqu'à ce qu’il trouve applicable <xref:System.Windows.NameScope> implémentation, ce qui se trouve en recherchant un élément qui implémente <xref:System.Windows.Markup.INameScope>.</span><span class="sxs-lookup"><span data-stu-id="5b797-558">The implementation will check successive parent elements until it finds the applicable <xref:System.Windows.NameScope> implementation, which is found by finding an element that implements <xref:System.Windows.Markup.INameScope>.</span></span> <span data-ttu-id="5b797-559">Pour plus d’informations sur les portées de nom, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-559">For more information about namescopes, see [WPF XAML Namescopes](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>  
  
 <span data-ttu-id="5b797-560">Appel <xref:System.Windows.FrameworkContentElement.RegisterName%2A> est nécessaire pour raccorder correctement des tables de montage séquentiel pour les applications lors de la création dans le code.</span><span class="sxs-lookup"><span data-stu-id="5b797-560">Calling <xref:System.Windows.FrameworkContentElement.RegisterName%2A> is necessary in order to correctly hook up animation storyboards for applications when created in code.</span></span> <span data-ttu-id="5b797-561">Il s’agit, car un de la clé d’animation de propriétés, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utilise une recherche de nom de l’exécution au lieu d’être en mesure de prendre une référence à un élément cible.</span><span class="sxs-lookup"><span data-stu-id="5b797-561">This is because one of the key storyboard properties, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, uses a run-time name lookup instead of being able to take a reference to a target element.</span></span> <span data-ttu-id="5b797-562">Cela est vrai même si cet élément est accessible par référence à partir du code.</span><span class="sxs-lookup"><span data-stu-id="5b797-562">This is true even if that element is accessible by reference from the code.</span></span> <span data-ttu-id="5b797-563">Pour plus d’informations sur la nécessité d’inscrire les noms pour les cibles de la table de montage séquentiel, consultez [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-563">For more information on why you need to register names for storyboard targets, see [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).</span></span> <span data-ttu-id="5b797-564">Animations pour les éléments de contenu sont moins fréquentes que les animations sur les contrôles, le [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) se concentre sur les scénarios de contrôle.</span><span class="sxs-lookup"><span data-stu-id="5b797-564">Animations for content elements are less common than animations on controls, the [Storyboards Overview](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) concentrates on control scenarios.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">
          <span data-ttu-id="5b797-565">Élément à supprimer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-565">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-566">Supprime l’élément spécifié de l’arborescence logique pour cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-566">Removes the specified element from the logical tree for this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-567">Cela [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] est principalement utile pour la classe qui dérive des scénarios, lors de l’ajout de prise en charge des collections enfants.</span><span class="sxs-lookup"><span data-stu-id="5b797-567">This [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is mainly relevant for class deriving scenarios, when adding support for child collections.</span></span>  
  
 <span data-ttu-id="5b797-568">La plupart des <xref:System.Windows.FrameworkContentElement> classes dérivées exposent des collections dédiées qui sont responsables de relation contenant-contenu (par exemple, <xref:System.Windows.Documents.Span.Inlines%2A> sur la <xref:System.Windows.Documents.Span> classe ; <xref:System.Windows.Documents.Section.Blocks%2A> sur la <xref:System.Windows.Documents.Section> classe).</span><span class="sxs-lookup"><span data-stu-id="5b797-568">Most <xref:System.Windows.FrameworkContentElement> derived classes expose dedicated collections that are responsible for containment (for example, <xref:System.Windows.Documents.Span.Inlines%2A> on the <xref:System.Windows.Documents.Span> class; <xref:System.Windows.Documents.Section.Blocks%2A> on the <xref:System.Windows.Documents.Section> class).</span></span> <span data-ttu-id="5b797-569">Dériver de telles classes généralement peut éviter tout besoin de manipuler l’arborescence logique directement.</span><span class="sxs-lookup"><span data-stu-id="5b797-569">Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-570">Obtient ou définit le dictionnaire de ressources actuel défini localement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-570">Gets or sets the current locally-defined resource dictionary.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-571">Les ressources actuelles définies localement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-571">The current locally-defined resources.</span>
          </span>
          <span data-ttu-id="5b797-572">Il s'agit d'un dictionnaire de ressources, où les ressources dans le dictionnaire sont accédées par clé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-572">This is a dictionary of resources, where resources within the dictionary are accessed by key.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-573">Les dictionnaires de ressources qui peuvent être définis complètement ou partiellement en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] sont généralement créés comme élément de propriété et sont généralement sur l’élément racine pour n’importe quelle page individuel ou pour l’application.</span><span class="sxs-lookup"><span data-stu-id="5b797-573">Resource dictionaries that can be defined completely or partially in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] are typically created as a property element, and are typically on the root element for any individual page or for the application.</span></span> <span data-ttu-id="5b797-574">Placer le dictionnaire de ressources à ce niveau facilite la recherche d’éléments enfants individuels dans la page (ou à partir de n’importe quelle page, dans le cas d’application).</span><span class="sxs-lookup"><span data-stu-id="5b797-574">Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</span></span> <span data-ttu-id="5b797-575">Dans la plupart des scénarios d’application, nous recommandons que les styles être définis en tant qu’éléments objet dans un dictionnaire de ressources, ou être définis comme des ressources externes afin que la ressource de style entière peut être autonome (cette approche permet de concepteur distinct responsabilités du développeur en séparant les fichiers physiques qui doivent être modifiées).</span><span class="sxs-lookup"><span data-stu-id="5b797-575">In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</span></span>  
  
 <span data-ttu-id="5b797-576">Notez que cette propriété retourne uniquement le dictionnaire de ressources déclaré directement dans cet élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-576">Note that this property returns only the resource dictionary declared directly within that element.</span></span> <span data-ttu-id="5b797-577">Cela est différent de celui du processus de recherche de ressource réelle, où un élément enfant peut accéder à toutes les ressources définies dans chaque élément parent, la recherche de manière récursive vers le haut.</span><span class="sxs-lookup"><span data-stu-id="5b797-577">This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</span></span>  
  
 <span data-ttu-id="5b797-578">Peut également être référencées par le code à partir de la collection de ressources, mais n’oubliez pas que les ressources créées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sans aucun doute ne seront plus accessibles jusqu’après <xref:System.Windows.FrameworkContentElement.Loaded> est déclenché par l’élément qui déclare le dictionnaire.</span><span class="sxs-lookup"><span data-stu-id="5b797-578">Resources can also be referenced by code from within the collection, but be aware that resources created in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] will definitely not be accessible until after <xref:System.Windows.FrameworkContentElement.Loaded> is raised by the element that declares the dictionary.</span></span> <span data-ttu-id="5b797-579">En fait, les ressources sont analysées de façon asynchrone et pas même le <xref:System.Windows.FrameworkContentElement.Loaded> événement est l’assurance que vous pouvez référencer un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] défini de ressources.</span><span class="sxs-lookup"><span data-stu-id="5b797-579">In fact, resources are parsed asynchronously, and not even the <xref:System.Windows.FrameworkContentElement.Loaded> event is an assurance that you can reference a [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resource.</span></span> <span data-ttu-id="5b797-580">C’est pourquoi vous devez généralement accéder uniquement aux [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] définies des ressources dans le cadre du code au moment de l’exécution, ou par le biais des autres [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques telles que les styles ou les références d’extension de ressource pour les valeurs d’attribut.</span><span class="sxs-lookup"><span data-stu-id="5b797-580">For this reason you should generally only access [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] defined resources as part of run-time code, or through other [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques such as styles or resource extension references for attribute values.</span></span> <span data-ttu-id="5b797-581">Lorsque vous accédez aux ressources via le code, il est fondamentalement équivalent à une référence effectuée depuis [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5b797-581">When you access resources through code, it is essentially equivalent to a  reference made from [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="5b797-582">Sous-jacent <xref:System.Windows.ResourceDictionary> prend en charge les méthodes requises pour ajouter, supprimer ou interroger les ressources à partir de la collection à l’aide de code.</span><span class="sxs-lookup"><span data-stu-id="5b797-582">The underlying <xref:System.Windows.ResourceDictionary> supports the methods required to add, remove, or query resources from within the collection by using code.</span></span> <span data-ttu-id="5b797-583">Le <xref:System.Windows.FrameworkContentElement.Resources%2A> propriété peut être définie pour prendre en charge le scénario du remplacement complet de la collection de ressources d’un élément à nouveau ou différent <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-583">The <xref:System.Windows.FrameworkContentElement.Resources%2A> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="5b797-584">Notez que le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe indiquée n’inclut pas un élément pour le <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-584">Notice that the [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntax shown does not include an element for the <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="5b797-585">Il s’agit d’un exemple de syntaxe de collection implicite ; une balise qui représente l’élément de collection peut être omise.</span><span class="sxs-lookup"><span data-stu-id="5b797-585">This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</span></span> <span data-ttu-id="5b797-586">Les éléments qui sont ajoutés en tant qu’éléments à la collection sont spécifiés à la place.</span><span class="sxs-lookup"><span data-stu-id="5b797-586">The elements that are added as items to the collection are specified instead.</span></span> <span data-ttu-id="5b797-587">Pour plus d’informations sur les collections implicites et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consultez [syntaxe de XAML en détail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-587">For more information about implicit collections and [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], see [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="5b797-588">Un cas où un <xref:System.Windows.ResourceDictionary> est encore spécifié explicitement comme un élément est si vous introduisez un dictionnaire fusionné, auquel cas il n’existe généralement aucun élément enfant pour qui <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-588">One case where a <xref:System.Windows.ResourceDictionary> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <xref:System.Windows.ResourceDictionary>.</span></span> <span data-ttu-id="5b797-589">Pour plus d’informations, consultez [dictionnaires de ressources fusionnés](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-589">For details, see [Merged Resource Dictionaries](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).</span></span>  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5b797-590">Utilisation des éléments de propriété XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-590">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-591">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-591">XAML Values</span></span>  
 <span data-ttu-id="5b797-592">*oneOrMoreResourceElements*</span><span class="sxs-lookup"><span data-stu-id="5b797-592">*oneOrMoreResourceElements*</span></span>  
 <span data-ttu-id="5b797-593">Un ou plusieurs éléments objet, chacun d’eux définit une ressource.</span><span class="sxs-lookup"><span data-stu-id="5b797-593">One or more object elements, each of which defines a resource.</span></span> <span data-ttu-id="5b797-594">Chaque élément de propriété de ressource au sein de chaque <xref:System.Windows.ResourceDictionary> doit avoir une valeur unique pour le [Directive x : Key](~/docs/framework/xaml-services/x-key-directive.md), qui sert de clé unique lorsque les valeurs sont récupérées à partir de la <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-594">Each resource property element within each <xref:System.Windows.ResourceDictionary> must have a unique value for the [x:Key Directive](~/docs/framework/xaml-services/x-key-directive.md), which serves as the unique key when values are retrieved from the <xref:System.Windows.ResourceDictionary>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-595">L’exemple suivant établit une <xref:System.Windows.FrameworkContentElement.Resources%2A> collection sur un <xref:System.Windows.Documents.FlowDocument> élément racine.</span><span class="sxs-lookup"><span data-stu-id="5b797-595">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element.</span></span> <span data-ttu-id="5b797-596"><xref:System.Windows.Documents.FlowDocument> est un choix par défaut, car il est un des rares <xref:System.Windows.FrameworkContentElement> classes pertinentes comme un élément racine et les ressources sont généralement stockés à la racine de page ou à des niveaux supérieurs de même, comme illustré dans l’application.</span><span class="sxs-lookup"><span data-stu-id="5b797-596"><xref:System.Windows.Documents.FlowDocument> is a typical choice because it is one of the few <xref:System.Windows.FrameworkContentElement> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-597">Attache une liaison à cet élément pour la propriété de dépendance spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-597">Attaches a binding to this element for the specified dependency property.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5b797-598">Identifie la propriété liée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-598">Identifies the bound property.</span>
          </span>
        </param>
        <param name="path">
          <span data-ttu-id="5b797-599">Le nom de propriété source ou le chemin d'accès à la propriété utilisée pour la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-599">The source property name or the path to the property used for the binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-600">Rattache une liaison à cet élément, selon le nom de propriété source fourni comme une qualification de chemin d'accès à la source de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-600">Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-601">Enregistre les conditions de la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-601">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="5b797-602">Cette valeur de retour peut être utile pour la vérification des erreurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-602">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-603">Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>et crée un nouveau <xref:System.Windows.Data.Binding> selon fourni `path` paramètre.</span><span class="sxs-lookup"><span data-stu-id="5b797-603">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>, and creates a new <xref:System.Windows.Data.Binding> based on the provided `path` parameter.</span></span> <span data-ttu-id="5b797-604">Cette signature est plus commode si vous établissez une liaison simple par défaut.</span><span class="sxs-lookup"><span data-stu-id="5b797-604">This signature is more convenient if you are establishing a simple default binding.</span></span> <span data-ttu-id="5b797-605">Si vous avez besoin spécifier des propriétés de liaison à des conditions non définis par défaut, ou souhaitez utiliser un <xref:System.Windows.Data.MultiBinding> ou <xref:System.Windows.Data.PriorityBinding>, vous devez utiliser le <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span><span class="sxs-lookup"><span data-stu-id="5b797-605">If you need to specify any binding properties to non-default conditions, or want to use a <xref:System.Windows.Data.MultiBinding> or <xref:System.Windows.Data.PriorityBinding>,you should use the <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-606">L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouvel objet de données personnalisées, l’établissement de cet objet en tant que <xref:System.Windows.FrameworkContentElement.DataContext%2A>et en définissant le chemin de liaison à une propriété qu’il contient.</span><span class="sxs-lookup"><span data-stu-id="5b797-606">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new custom data object, establishing that object as <xref:System.Windows.FrameworkContentElement.DataContext%2A>, and setting the binding path to a property within it.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5b797-607">Identifie la propriété liée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-607">Identifies the bound property.</span>
          </span>
        </param>
        <param name="binding">
          <span data-ttu-id="5b797-608">Représente une liaison de données.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-608">Represents a data binding.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-609">Attache une liaison à cet élément selon l’objet de liaison fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-609">Attaches a binding to this element, based on the provided binding object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-610">Enregistre les conditions de la liaison.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-610">Records the conditions of the binding.</span>
          </span>
          <span data-ttu-id="5b797-611">Cette valeur de retour peut être utile pour la vérification des erreurs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-611">This return value can be useful for error checking.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-612">Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="5b797-612">This method is a convenience method for calling <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, which passes the current instance as the <xref:System.Windows.DependencyObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-613">L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouveau <xref:System.Windows.Data.Binding> et en définissant la source sur nouvellement généré `DateTime` objet.</span><span class="sxs-lookup"><span data-stu-id="5b797-613">The following example sets a binding on a <xref:System.Windows.Documents.Paragraph> element, by creating a new <xref:System.Windows.Data.Binding> and setting the source to a newly built `DateTime` object.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="5b797-614">Propriété à laquelle la ressource est liée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-614">The property to which the resource is bound.</span>
          </span>
        </param>
        <param name="name">
          <span data-ttu-id="5b797-615">Nom de la ressource.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-615">The name of the resource.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-616">Recherche une ressource avec le nom spécifié et lui paramètre une référence à une ressource pour la propriété spécifiée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-616">Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-617">Une référence de ressource est similaire à l’utilisation d’un [Extension de balisage DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) dans le balisage.</span><span class="sxs-lookup"><span data-stu-id="5b797-617">A resource reference is similar to the use of a [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) in markup.</span></span> <span data-ttu-id="5b797-618">La référence de ressource crée une expression interne qui fournit la valeur de la propriété spécifiée sur une base différée d’exécution.</span><span class="sxs-lookup"><span data-stu-id="5b797-618">The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</span></span> <span data-ttu-id="5b797-619">L’expression sera réévaluée chaque fois que le dictionnaire de ressources indique une valeur modifiée par le biais des événements internes, ou chaque fois que l’élément actuel est apparenté à nouveau (une modification du parent modifierait le chemin de recherche du dictionnaire).</span><span class="sxs-lookup"><span data-stu-id="5b797-619">The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-620">Indique si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkContentElement.Resources" /> sur les instances de cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-620">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-621">
            <see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.Resources" /> doit être sérialisée ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-621">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Resources" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-622">Ceci renverra `true` afin qu’il existe au moins une ressource de clé local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-622">This will return `true` so long as there is at least one keyed resource in the local <xref:System.Windows.FrameworkContentElement.Resources%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-623">Indique si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkContentElement.Style" /> sur les instances de cette classe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-623">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-624">
            <see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.Style" /> doit être sérialisée ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-624">
              <see langword="true" /> if the <see cref="P:System.Windows.FrameworkContentElement.Style" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-625">Ceci renverra `true` si la <xref:System.Windows.Style> est définie localement.</span><span class="sxs-lookup"><span data-stu-id="5b797-625">This will return `true` if the <xref:System.Windows.Style> is locally set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-626">Se produit lorsque toute source de données associée participant à une liaison sur cet élément change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-626">Occurs when any associated data source participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-627">Cet événement survole le <xref:System.Windows.Data.Binding.SourceUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-627">This event surfaces the <xref:System.Windows.Data.Binding.SourceUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span>  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-628">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-628">XAML Attribute Usage</span></span>  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-629">Obtient ou définit le style à utiliser par cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-629">Gets or sets the style to be used by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-630">Style appliqué, non défini par défaut de l’élément, le cas échéant.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-630">The applied, nondefault style for the element, if present.</span>
          </span>
          <span data-ttu-id="5b797-631">Sinon, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-631">Otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="5b797-632">La valeur par défaut d’un <see cref="T:System.Windows.FrameworkContentElement" /> construit par défaut est <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-632">The default for a default-constructed <see cref="T:System.Windows.FrameworkContentElement" /> is <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-633">Le style actuel est souvent fourni par un style par défaut de thèmes, ou à partir de styles généralement appliquées aux objets de ce type par les ressources au niveau page ou application (un style implicite).</span><span class="sxs-lookup"><span data-stu-id="5b797-633">The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</span></span> <span data-ttu-id="5b797-634">Cette propriété ne pas définie ou retour par défaut les styles (thème), mais il retourne le style implicit ou un style explicite.</span><span class="sxs-lookup"><span data-stu-id="5b797-634">This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</span></span> <span data-ttu-id="5b797-635">Dans le cas de styles implicites ou explicites, peu importe si le style est accessible en tant que ressource ou défini localement.</span><span class="sxs-lookup"><span data-stu-id="5b797-635">In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</span></span>  
  
 <span data-ttu-id="5b797-636">Définition des styles comporte certaines restrictions.</span><span class="sxs-lookup"><span data-stu-id="5b797-636">Setting the styles has some restrictions.</span></span> <span data-ttu-id="5b797-637">Vous pouvez réinitialiser l’ensemble <xref:System.Windows.FrameworkContentElement.Style%2A> propriété vers un nouveau <xref:System.Windows.Style> à tout moment, ce qui force une recomposition de disposition.</span><span class="sxs-lookup"><span data-stu-id="5b797-637">You can reset the entire <xref:System.Windows.FrameworkContentElement.Style%2A> property to a new <xref:System.Windows.Style> at any time, which will force a layout recomposition.</span></span> <span data-ttu-id="5b797-638">Toutefois, dès que ce style est placé en cours d’utilisation par un élément chargé, le <xref:System.Windows.Style> doit être considéré comme sealed.</span><span class="sxs-lookup"><span data-stu-id="5b797-638">However, as soon as that style is placed in use by a loaded element, the <xref:System.Windows.Style> should be considered sealed.</span></span> <span data-ttu-id="5b797-639">Essayez d’apporter une modification à n’importe quelle propriété individuelle d’un style en cours d’utilisation (tels que quoi que ce soit dans la collection de <xref:System.Windows.Style.Setters%2A>) provoque une exception levée.</span><span class="sxs-lookup"><span data-stu-id="5b797-639">Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <xref:System.Windows.Style.Setters%2A>) causes an exception to be thrown.</span></span> <span data-ttu-id="5b797-640">Un style qui est défini dans le balisage est considéré comme en cours d’utilisation dès qu’il est chargé à partir d’un dictionnaire de ressources (pour les ressources), ou la page, dans qu'il est contenu est chargée (pour les styles intraligne).</span><span class="sxs-lookup"><span data-stu-id="5b797-640">A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</span></span>  
  
 <span data-ttu-id="5b797-641"><xref:System.Windows.FrameworkContentElement.Style%2A> est une propriété de dépendance avec une priorité particulière.</span><span class="sxs-lookup"><span data-stu-id="5b797-641"><xref:System.Windows.FrameworkContentElement.Style%2A> is a dependency property with special precedence.</span></span> <span data-ttu-id="5b797-642">Définie localement style fonctionne généralement à la priorité la plus élevée dans le système de propriétés.</span><span class="sxs-lookup"><span data-stu-id="5b797-642">The locally set style generally operates at the highest precedence in the property system.</span></span> <span data-ttu-id="5b797-643">Si le <xref:System.Windows.FrameworkContentElement.Style%2A> a la valeur null à ce stade, pendant le chargement du système de propriétés vérifie styles implicites comme ressources définies qui spécifient ce type.</span><span class="sxs-lookup"><span data-stu-id="5b797-643">If the <xref:System.Windows.FrameworkContentElement.Style%2A> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</span></span> <span data-ttu-id="5b797-644">Si le style est toujours la valeur null après cette étape, puis le style provient le style par défaut (thème), mais le style par défaut n’est pas retourné dans la <xref:System.Windows.FrameworkContentElement.Style%2A> valeur de propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-644">If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <xref:System.Windows.FrameworkContentElement.Style%2A> property value.</span></span> <span data-ttu-id="5b797-645">Consultez [priorité de valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-645">See [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-646">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-646">XAML Attribute Usage</span></span>  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-647">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-647">XAML Values</span></span>  
 <span data-ttu-id="5b797-648">*resourceExtension*</span><span class="sxs-lookup"><span data-stu-id="5b797-648">*resourceExtension*</span></span>  
 <span data-ttu-id="5b797-649">Une des opérations suivantes :, ou.</span><span class="sxs-lookup"><span data-stu-id="5b797-649">One of the following: , or .</span></span> <span data-ttu-id="5b797-650">Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-650">See [XAML Resources](~/docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
 <span data-ttu-id="5b797-651">*styleResourceKey*</span><span class="sxs-lookup"><span data-stu-id="5b797-651">*styleResourceKey*</span></span>  
 <span data-ttu-id="5b797-652">La clé qui identifie le style demandé.</span><span class="sxs-lookup"><span data-stu-id="5b797-652">The key that identifies the style being requested.</span></span> <span data-ttu-id="5b797-653">La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.</span><span class="sxs-lookup"><span data-stu-id="5b797-653">The key refers to an existing resource in a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5b797-654">Syntaxe d’élément de propriété est techniquement possible, mais non recommandée.</span><span class="sxs-lookup"><span data-stu-id="5b797-654">Property element syntax is technically possible, but not recommended.</span></span> <span data-ttu-id="5b797-655">Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span><span class="sxs-lookup"><span data-stu-id="5b797-655">See [Inline Styles and Templates](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).</span></span>  <span data-ttu-id="5b797-656">Une référence de liaison à l’aide ou <xref:System.Windows.Data.Binding> est également possible, mais rare.</span><span class="sxs-lookup"><span data-stu-id="5b797-656">A binding reference using  or <xref:System.Windows.Data.Binding> is also possible, but uncommon.</span></span>  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-657">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-657">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-658">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-658">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|<span data-ttu-id="5b797-659">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-659">Metadata properties set to `true`</span></span>|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-660">L’exemple suivant établit une <xref:System.Windows.FrameworkContentElement.Resources%2A> collection sur un <xref:System.Windows.Documents.FlowDocument> élément racine et puis de la référence en tant que ressource comme un style spécifique pour un <xref:System.Windows.Documents.Paragraph>.</span><span class="sxs-lookup"><span data-stu-id="5b797-660">The following example establishes a <xref:System.Windows.FrameworkContentElement.Resources%2A> collection on a <xref:System.Windows.Documents.FlowDocument> root element and then references it as a resource as a specific style for a <xref:System.Windows.Documents.Paragraph>.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-661">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Style" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-661">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Style" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">
          <span data-ttu-id="5b797-662">Nom de la propriété ambiante demandée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-662">The name of the requested ambient property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-663">Pour obtenir une description de ce membre, consultez la méthode <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-663">For a description of this member, see the <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-664">
            <see langword="true" /> si <paramref name="propertyName" /> est disponible ; sinon, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-664">
              <see langword="true" /> if <paramref name="propertyName" /> is available; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-665">Ce membre est une implémentation d'un membre d'interface explicite.</span><span class="sxs-lookup"><span data-stu-id="5b797-665">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="5b797-666">Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.FrameworkContentElement> est castée en interface <xref:System.Windows.Markup.IQueryAmbient>.</span><span class="sxs-lookup"><span data-stu-id="5b797-666">It can be used only when the <xref:System.Windows.FrameworkContentElement> instance is cast to an <xref:System.Windows.Markup.IQueryAmbient> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-667">Obtient ou définit une valeur d’objet arbitraire utilisable pour stocker des informations personnalisées sur cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-667">Gets or sets an arbitrary object value that can be used to store custom information about this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-668">La valeur prévue.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-668">The intended value.</span>
          </span>
          <span data-ttu-id="5b797-669">Cette propriété n’a aucune valeur par défaut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-669">This property has no default value.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-670">Cette propriété est analogue aux propriétés de balise dans d’autres modèles de programmation de Microsoft, tel que Visual Basic pour Applications ou des Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="5b797-670">This property is analogous to Tag properties in other Microsoft programming models, such as Visual Basic for Applications or Windows Forms.</span></span> <span data-ttu-id="5b797-671">Il vise à fournir un emplacement existant pour stocker des informations personnalisées de base sur n’importe quel élément sans forcer les développeurs d’applications à la sous-classe.</span><span class="sxs-lookup"><span data-stu-id="5b797-671">It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</span></span>  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-672">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-672">XAML Values</span></span>  
 <span data-ttu-id="5b797-673">Étant donné que cette propriété prend un objet, vous devez utiliser l’utilisation d’élément de propriété afin de définir le <xref:System.Windows.FrameworkContentElement.Tag%2A> propriété dans XAML pour autre chose qu’un objet avec un convertisseur de type connu et intégrées, telles qu’une chaîne.</span><span class="sxs-lookup"><span data-stu-id="5b797-673">Because this property takes an object, you need to use the property element usage in order to set the <xref:System.Windows.FrameworkContentElement.Tag%2A> property in XAML to anything other than an object with a known and built-in type converter, such as a string.</span></span> <span data-ttu-id="5b797-674">Objets utilisés de cette façon sont généralement pas dans les espaces de noms WPF standard et peuvent donc avoir besoin de mappage d’espace de noms à l’espace de noms externe afin d’être introduite en tant qu’éléments XAML.</span><span class="sxs-lookup"><span data-stu-id="5b797-674">Objects used in this way are typically not within the standard WPF namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as XAML elements.</span></span>  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-675">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-675">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-676">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-676">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|<span data-ttu-id="5b797-677">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-677">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-678">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-678">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-679">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-679">Identifies the <see cref="P:System.Windows.FrameworkContentElement.Tag" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-680">Se produit quand une propriété cible associée qui participe à une liaison sur cet élément change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-680">Occurs when any associated target property participating in a binding on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-681">Cet événement survole le <xref:System.Windows.Data.Binding.TargetUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément.</span><span class="sxs-lookup"><span data-stu-id="5b797-681">This event surfaces the <xref:System.Windows.Data.Binding.TargetUpdated> event that is raised by any <xref:System.Windows.Data.Binding> associated with this element.</span></span> <span data-ttu-id="5b797-682">Cela signifie généralement que la liaison en question est une liaison bidirectionnelle, et que la propriété de dépendance liée affirme une invalidation de la valeur de propriété précédente par toute validation ou d’un modèle de mise en cache qui prend en charge de la propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-682">This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</span></span>  
  
 <span data-ttu-id="5b797-683">Les arguments d’événement de cet événement informe les propriété liée a été modifiées.</span><span class="sxs-lookup"><span data-stu-id="5b797-683">The event arguments of this event will inform you which bound property was changed.</span></span>  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-684">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-684">XAML Attribute Usage</span></span>  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-685">Obtient une référence au modèle parent de cet élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-685">Gets a reference to the template parent of this element.</span>
          </span>
          <span data-ttu-id="5b797-686">Cette propriété n’est pas pertinente si l’élément n’a pas été créé par l’intermédiaire d’un modèle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-686">This property is not relevant if the element was not created through a template.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-687">L’élément dont <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> a provoqué cet élément doit être créé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-687">The element whose <see cref="T:System.Windows.FrameworkTemplate" /><see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> caused this element to be created.</span>
          </span>
          <span data-ttu-id="5b797-688">Cette valeur est souvent <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-688">This value is frequently <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-689">Les modèles sont des objets en fait partagés où le contenu du modèle est créé une seule fois.</span><span class="sxs-lookup"><span data-stu-id="5b797-689">Templates are actually shared objects, where the contents of the template are created only once.</span></span> <span data-ttu-id="5b797-690">Par conséquent, si vous obtenez une référence d’objet à un élément qui provenance d’un modèle, vous trouverez que l’arborescence logique apparente n’atteint pas à la racine de la page.</span><span class="sxs-lookup"><span data-stu-id="5b797-690">Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</span></span> <span data-ttu-id="5b797-691">Pour connecter une référence de modèle à l’arborescence logique de la page, vous devez obtenir le <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valeur et continuer à parcourir cette arborescence d’éléments comme vous le souhaitez.</span><span class="sxs-lookup"><span data-stu-id="5b797-691">In order to connect such a template reference to the page's logical tree, you should get the <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> value and continue to navigate that element tree as desired.</span></span>  
  
 <span data-ttu-id="5b797-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> sera fréquemment `null` pour les objets communs, car si vous avez obtenu une référence d’objet d’une page dans votre application via des moyens typiques, cet élément n’a probablement pas créé à partir d’un modèle.</span><span class="sxs-lookup"><span data-stu-id="5b797-692"><xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> will frequently be `null` for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</span></span> <span data-ttu-id="5b797-693">Les cas où <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> peut ne pas être `null` peuvent inclure des opérations telles que le test de positionnement, les événements gestion de certains événements d’entrée de bas niveau, ou utiliser des énumérateurs, qui ont peuvent retourner des éléments provenant de modèles.</span><span class="sxs-lookup"><span data-stu-id="5b797-693">Cases where <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> might not be `null` would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-694">Obtient ou définit l'objet d'info-bulle affiché pour cet élément dans le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-694">Gets or sets the tool-tip object that is displayed for this element in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="5b797-695">L'objet d'info-bulle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-695">The tooltip object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-696">Si la valeur de cette propriété est de type <xref:System.Windows.Controls.ToolTip>, puis qui est l’info-bulle qui sera utilisé dans le [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="5b797-696">If the value of this property is of type <xref:System.Windows.Controls.ToolTip>, then that is the tool-tip that will be used in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  <span data-ttu-id="5b797-697">Si la valeur est d’un autre type, cette valeur sera utilisée comme le *contenu* pour un <xref:System.Windows.Controls.ToolTip> fourni (construit) par le système.</span><span class="sxs-lookup"><span data-stu-id="5b797-697">If the value is of any other type, then that value will be used as the *content* for a <xref:System.Windows.Controls.ToolTip> provided (constructed) by the system.</span></span> <span data-ttu-id="5b797-698">Pour plus d’informations, consultez <xref:System.Windows.Controls.ToolTipService>.</span><span class="sxs-lookup"><span data-stu-id="5b797-698">For more information see <xref:System.Windows.Controls.ToolTipService>.</span></span> <span data-ttu-id="5b797-699">La classe de service fournit des propriétés jointes qui peuvent être utilisées pour personnaliser davantage une info-bulle.</span><span class="sxs-lookup"><span data-stu-id="5b797-699">The service class provides attached properties that can be used to further customize a tool-tip.</span></span>  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a><span data-ttu-id="5b797-700">Utilisation d'attributs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-700">XAML Attribute Usage</span></span>  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="5b797-701">Utilisation des éléments de propriété XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-701">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a><span data-ttu-id="5b797-702">Valeurs XAML</span><span class="sxs-lookup"><span data-stu-id="5b797-702">XAML Values</span></span>  
 <span data-ttu-id="5b797-703">*toolTipContent*</span><span class="sxs-lookup"><span data-stu-id="5b797-703">*toolTipContent*</span></span>  
 <span data-ttu-id="5b797-704">Chaîne qui devient le texte affiché pour le <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span><span class="sxs-lookup"><span data-stu-id="5b797-704">A string that becomes the display text for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.</span></span>  
  
 <span data-ttu-id="5b797-705">*toolTipObjectContent*</span><span class="sxs-lookup"><span data-stu-id="5b797-705">*toolTipObjectContent*</span></span>  
 <span data-ttu-id="5b797-706">Objet fourni dans le formulaire d’élément objet, qui doit être utilisé comme contenu pour le <xref:System.Windows.FrameworkContentElement> .</span><span class="sxs-lookup"><span data-stu-id="5b797-706">Some object, provided in object element form, that should be used as the content for the <xref:System.Windows.FrameworkContentElement> .</span></span> <span data-ttu-id="5b797-707">En règle générale, ce serait un <xref:System.Windows.FrameworkElement> ou tout autre élément qui crée une composition de disposition pour le <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, contenant finalement le contenu de texte dans la composition.</span><span class="sxs-lookup"><span data-stu-id="5b797-707">Typically this would be a <xref:System.Windows.FrameworkElement> or some other element that creates layout compositing for the <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, eventually containing text content within the compositing.</span></span> <span data-ttu-id="5b797-708">Dans ce cas, le <xref:System.Windows.Controls.ToolTip> élément est créé implicitement à partir d’analysée [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]et le *toolTipObjectContent* contenu est défini en tant que son <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propriété.</span><span class="sxs-lookup"><span data-stu-id="5b797-708">In this usage, the <xref:System.Windows.Controls.ToolTip> element is created implicitly from the parsed [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], and the *toolTipObjectContent* content is set as its <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="5b797-709"><`ToolTip` .../></span><span class="sxs-lookup"><span data-stu-id="5b797-709"><`ToolTip` .../></span></span>  
 <span data-ttu-id="5b797-710">Consultez <xref:System.Windows.Controls.ToolTip>.</span><span class="sxs-lookup"><span data-stu-id="5b797-710">See <xref:System.Windows.Controls.ToolTip>.</span></span>  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="5b797-711">Informations sur les propriétés de dépendance</span><span class="sxs-lookup"><span data-stu-id="5b797-711">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-712">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-712">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|<span data-ttu-id="5b797-713">La valeur des propriétés de métadonnées `true`</span><span class="sxs-lookup"><span data-stu-id="5b797-713">Metadata properties set to `true`</span></span>|<span data-ttu-id="5b797-714">Aucun.</span><span class="sxs-lookup"><span data-stu-id="5b797-714">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="5b797-715">L’exemple suivant définit la valeur de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propriété directement dans une chaîne.</span><span class="sxs-lookup"><span data-stu-id="5b797-715">The following example sets the value of the <xref:System.Windows.FrameworkElement.ToolTip%2A> property directly to a string.</span></span>  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-716">Se produit juste avant la fermeture d'une info-bulle sur l'élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-716">Occurs just before any tooltip on the element is closed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-717">Pour supprimer la fermeture de l’info-bulle, les gestionnaires de l’événement doivent le marquer comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="5b797-717">To suppress closing the tooltip, handlers of the event should mark it as handled.</span></span>  
  
 <span data-ttu-id="5b797-718">Cet événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style.</span><span class="sxs-lookup"><span data-stu-id="5b797-718">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="5b797-719">Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas de méthodes d’ajout/suppression de l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-719">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-720">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-721">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-721">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|<span data-ttu-id="5b797-722">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-722">Routing strategy</span></span>|<span data-ttu-id="5b797-723">Direct</span><span class="sxs-lookup"><span data-stu-id="5b797-723">Direct</span></span>|  
|<span data-ttu-id="5b797-724">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-724">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-725">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-725">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-726">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-726">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-727">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-727">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-728">Se produit à l’ouverture d’une info-bulle sur l’élément.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-728">Occurs when any tooltip on the element is opened.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-729">Pour ouvrir manuellement les info-bulles, gestionnaires des événements doivent marquer l’événement comme étant géré.</span><span class="sxs-lookup"><span data-stu-id="5b797-729">To manually open tooltips, handlers of the events should mark the relevant event as handled.</span></span> <span data-ttu-id="5b797-730">Sinon, la valeur de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriété sera utilisée pour ouvrir automatiquement un menu contextuel.</span><span class="sxs-lookup"><span data-stu-id="5b797-730">Otherwise, the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property will be used to automatically open a context menu.</span></span> <span data-ttu-id="5b797-731">Marquage de l’événement géré annule effectivement l’action par défaut et peut être une opportunité pour réinitialiser la valeur de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriété, puis ouvrez le nouveau <xref:System.Windows.Controls.ContextMenu>.</span><span class="sxs-lookup"><span data-stu-id="5b797-731">Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <xref:System.Windows.FrameworkContentElement.ToolTip%2A> property and then open the new <xref:System.Windows.Controls.ContextMenu>.</span></span> <span data-ttu-id="5b797-732">Notez que cet événement ne sera pas déclenché si <xref:System.Windows.FrameworkContentElement.ToolTip%2A> est une référence null ou autrement pas définie.</span><span class="sxs-lookup"><span data-stu-id="5b797-732">Note that this event will not be raised if <xref:System.Windows.FrameworkContentElement.ToolTip%2A> is a null reference or otherwise unset.</span></span>  
  
 <span data-ttu-id="5b797-733">Cet événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style.</span><span class="sxs-lookup"><span data-stu-id="5b797-733">This event cannot be an <xref:System.Windows.EventTrigger> in a style.</span></span> <span data-ttu-id="5b797-734">Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas de méthodes d’ajout/suppression de l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-734">This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</span></span>  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-735">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-735">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-736">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-736">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|<span data-ttu-id="5b797-737">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-737">Routing strategy</span></span>|<span data-ttu-id="5b797-738">Direct</span><span class="sxs-lookup"><span data-stu-id="5b797-738">Direct</span></span>|  
|<span data-ttu-id="5b797-739">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-739">Delegate</span></span>|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-740">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-740">Identifies the <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-741">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-741">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-742">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-742">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-743">Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-743">Identifies the <see cref="P:System.Windows.FrameworkContentElement.ToolTip" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">
          <span data-ttu-id="5b797-744">Identificateur de clé de la ressource à rechercher.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-744">Key identifier of the resource to be found.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-745">Recherche une ressource avec la clé spécifiée et retourne cette ressource si elle est trouvée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-745">Searches for a resource with the specified key, and returns that resource if found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5b797-746">Ressource trouvée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-746">The found resource.</span>
          </span>
          <span data-ttu-id="5b797-747">Si aucune ressource n’a été trouvée, <see langword="null" /> est retourné.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-747">If no resource was found, <see langword="null" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-748">Si la ressource est introuvable sur l’élément appelant, l’arborescence parente est recherchée à l’aide de l’arborescence logique, de la même façon que l’arborescence serait recherchée si une référence de ressource dynamique était demandée par clé au moment de l’exécution.</span><span class="sxs-lookup"><span data-stu-id="5b797-748">If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</span></span>  
  
 <span data-ttu-id="5b797-749">En règle générale, vous castez immédiatement la valeur de retour vers le type de la propriété que vous essayez de définir avec la valeur de la ressource retournée.</span><span class="sxs-lookup"><span data-stu-id="5b797-749">Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</span></span>  
  
 <span data-ttu-id="5b797-750">Le <xref:System.Windows.FrameworkContentElement.FindResource%2A> méthode a un comportement similaire, sauf qu’il lève une exception dans le cas vous ne trouvez ne pas une ressource avec la clé fournie.</span><span class="sxs-lookup"><span data-stu-id="5b797-750">The <xref:System.Windows.FrameworkContentElement.FindResource%2A> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5b797-751">L’exemple suivant recherche une ressource, tel que défini dans le balisage et s’applique à une certaine propriété d’un élément en réponse à un événement routé.</span><span class="sxs-lookup"><span data-stu-id="5b797-751">The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-752">Se produit lorsque l'élément est supprimé d'une arborescence d'éléments chargés.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-752">Occurs when the element is removed from an element tree of loaded elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-753">Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés.</span><span class="sxs-lookup"><span data-stu-id="5b797-753">Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</span></span> <span data-ttu-id="5b797-754">Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.</span><span class="sxs-lookup"><span data-stu-id="5b797-754">Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <xref:System.Windows.EventTrigger> in a style.</span></span>  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="5b797-755">Informations sur les événements acheminés</span><span class="sxs-lookup"><span data-stu-id="5b797-755">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="5b797-756">Champ d’identificateur</span><span class="sxs-lookup"><span data-stu-id="5b797-756">Identifier field</span></span>|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|<span data-ttu-id="5b797-757">Stratégie de routage</span><span class="sxs-lookup"><span data-stu-id="5b797-757">Routing strategy</span></span>|<span data-ttu-id="5b797-758">Direct</span><span class="sxs-lookup"><span data-stu-id="5b797-758">Direct</span></span>|  
|<span data-ttu-id="5b797-759">délégué</span><span class="sxs-lookup"><span data-stu-id="5b797-759">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="5b797-760">Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-760">Identifies the <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-761">Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span><span class="sxs-lookup"><span data-stu-id="5b797-761">Event identifier objects are created when routed events are registered (see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) and can then be used to add class handlers (see <xref:System.Windows.EventManager.RegisterClassHandler%2A>).</span></span> <span data-ttu-id="5b797-762">Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.</span><span class="sxs-lookup"><span data-stu-id="5b797-762">Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="5b797-763">Nom de la paire nom-objet à supprimer de la portée actuelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-763">Name of the name-object pair to remove from the current scope.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5b797-764">Simplifie l'accès à la méthode de désinscription <see cref="T:System.Windows.NameScope" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-764">Simplifies access to the <see cref="T:System.Windows.NameScope" /> de-registration method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5b797-765">Vous devez seulement désinscrire les noms si vous avez l’intention de réinscrire un autre élément portant ce nom même.</span><span class="sxs-lookup"><span data-stu-id="5b797-765">You only need to un-register names if you intend to re-register another element with that same name.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="5b797-766">Réapplique le style par défaut au <see cref="T:System.Windows.FrameworkContentElement" /> actuel.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5b797-766">Reapplies the default style to the current <see cref="T:System.Windows.FrameworkContentElement" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>