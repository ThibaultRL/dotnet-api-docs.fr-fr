<Type Name="FrameworkContentElement" FullName="System.Windows.FrameworkContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="70bb637f8e0393750486d5d256c1653256d4e269" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008805" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkContentElement : System.Windows.ContentElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkContentElement extends System.Windows.ContentElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkContentElement&#xA;Inherits ContentElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkContentElement : System::Windows::ContentElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkContentElement = class&#xA;    inherit ContentElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.ContentElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.FrameworkContentElement" /> est l’implémentation et l’expansion de niveau infrastructure WPF de la classe de base <see cref="T:System.Windows.ContentElement" />. <see cref="T:System.Windows.FrameworkContentElement" /> ajoute la prise en charge d’API d’entrée supplémentaires (notamment des info-bulles et des menus contextuels), des plans conceptuels, du contexte de données de la liaison de données, des styles et d’API d’assistance d’arborescence logique.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement> ne définit pas encore son propre comportement de rendu ; l’instanciation d’un <xref:System.Windows.FrameworkContentElement> instance de classe dans le code ou de balisage est possible mais n’affiche rien dans une [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Rendu de la logique doit être fourni par les classes qui prennent <xref:System.Windows.FrameworkContentElement> les éléments enfants dans le cadre de leur modèle de contenu, ou dans <xref:System.Windows.FrameworkContentElement> classes dérivées.  
  
 <xref:System.Windows.FrameworkContentElement> délibérément en parallèle plusieurs du même [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] comme <xref:System.Windows.FrameworkElement>. Notez que certains [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] trouvé sur <xref:System.Windows.FrameworkElement> n’aura pas un <xref:System.Windows.FrameworkContentElement> équivalente. Plusieurs de la <xref:System.Windows.FrameworkElement> [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] sont pour les fonctionnalités telles que la représentation sous forme de géométrie ou de mise en page, qui ne sont pas pertinentes pour un <xref:System.Windows.FrameworkContentElement>.  
  
 La majorité des existant <xref:System.Windows.FrameworkContentElement> classes dérivées seront trouve dans le <xref:System.Windows.Documents> espace de noms. Beaucoup de ces classes dérivées implémentent des éléments pour le modèle de document de flux. Certaines classes dérivées telles que <xref:System.Windows.Documents.Hyperlink> ont des fonctionnalités comme le contrôle, mais sont dérivées de <xref:System.Windows.FrameworkContentElement> telles que les éléments comme le contrôle peuvent toujours participer dans le modèle de document de flux.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.FrameworkElement" />
    <altmember cref="T:System.Windows.ContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Élément enfant à ajouter.</param>
        <summary>Ajoute l’élément fourni comme enfant de cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut lever une exception si elle est appelée à la fois lorsque l’arborescence logique est itérée par un autre processus.  
  
 La plupart des <xref:System.Windows.FrameworkContentElement> classes dérivées exposent des collections dédiées qui sont responsables de relation contenant-contenu (par exemple, <xref:System.Windows.Documents.Span.Inlines%2A> sur la <xref:System.Windows.Documents.Span> classe ; <xref:System.Windows.Documents.Section.Blocks%2A> sur la <xref:System.Windows.Documents.Section> classe). Vous pouvez généralement éviter tout besoin de manipuler l’arborescence logique directement si vous dérivez à partir de ces classes. Utilisation de l’arborescence logique pour les éléments de contenu est un scénario avancé qui peut nécessiter un analyseur spécialisé ou spécialisé <xref:System.Windows.FrameworkElement> qui agit en tant que l’élément de rendu parent (hôte de contenu).  
  
 Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkContentElement.LogicalChildren" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkContentElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé avant qu’un élément soit initialisé.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Substituez cette méthode pour fournir une gestion spéciale qui doit se produire avant que votre élément est initialisé pendant le processus de chargement de l’élément.  
  
Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation.  
  
L’implémentation de base lève une exception si <see cref="M:System.Windows.FrameworkContentElement.BeginInit" /> est appelée plusieurs fois sur le même élément avant d’atteindre <see cref="M:System.Windows.FrameworkContentElement.EndInit" />.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Commence la séquence d'actions contenues dans la table de montage séquentiel fournie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkContentElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <summary>Commence la séquence d'actions contenues dans la table de montage séquentiel fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois. Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <param name="handoffBehavior">Valeur de l'énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</param>
        <summary>Commence la séquence d'actions contenues dans la table de montage séquentiel fournie, avec les options spécifiées pour ce qui doit se produire si la propriété est déjà animée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois. Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas les horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs façons de supprimer une horloge :  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkContentElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <param name="handoffBehavior">Valeur de l’énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</param>
        <param name="isControllable">Déclare si l'animation est contrôlable (peut être suspendue) après avoir démarré.</param>
        <summary>Commence la séquence d'actions contenues dans la table de montage séquentiel fournie, avec l'état spécifié pour le contrôle de l'animation après qu'elle ait démarré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les chronologies associées à l’animation sont supprimées dès qu’il atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir été exécutée une seule fois. Notez que contrôle d’une animation requiert également que la table de montage séquentiel soit nommée ou accessible en tant qu’instance dans le code.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas ces horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs façons de supprimer une horloge :  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkContentElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Data.BindingGroup> peut être utilisé pour valider les valeurs de plusieurs propriétés d’un objet. Par exemple, supposons qu’une application invite l’utilisateur à entrer une adresse et remplit ensuite un objet de type `Address`, qui a les propriétés `Street`, `City`, `ZipCode`, et `Country`, avec les valeurs que l’utilisateur fourni. L’application a un panneau qui contient quatre <xref:System.Windows.Controls.TextBox> contrôles, chacun d’eux est lié à une des propriétés de l’objet. Vous pouvez utiliser un <xref:System.Windows.Controls.ValidationRule> dans un <xref:System.Windows.Data.BindingGroup> pour valider le `Address` objet. Par exemple, le <xref:System.Windows.Controls.ValidationRule> pouvez vous assurer que le code postal est valide pour le pays de l’adresse.  
  
 Les éléments enfants héritent le <xref:System.Windows.Data.BindingGroup> à partir de leurs éléments parents, tout comme avec toute autre propriété pouvant être héritées.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.BindingGroupProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkContentElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Essaie de mettre cet élément en vue, dans toutes régions déroulantes dans lesquelles il est contenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En appelant cette méthode, vous appellerez efficacement <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> sur toute zone défilante parente qui contient l’élément (le parent peut très bien être un <xref:System.Windows.FrameworkElement>, et non un <xref:System.Windows.FrameworkContentElement>). Si cet élément n’est pas contenu dans une zone avec défilement, l’événement est déclenché, mais il n’y aura aucun effet.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms752352(v=vs.90)">Procédure : Créer un ScrollViewer</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkContentElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'élément de menu contextuel qui doit apparaître à chaque fois que le menu contextuel est demandé via [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] à partir de cet élément.</summary>
        <value>Le menu contextuel que cet élément utilise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ContextMenuProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant place un <xref:System.Windows.Controls.ContextMenu> sur un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#contextmenu)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant qu'un menu contextuel sur l'élément ne soit fermé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour supprimer la fermeture menus contextuels, les gestionnaires de l’événement doivent marquer comme géré.  
  
 Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer l’identificateur d’événement de service sous-jacent :  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkContentElement> qu’expose l’événement de service sous-jacent ne mappe pas correctement le <xref:System.Windows.FrameworkContentElement.ContextMenuClosing> identificateur pour une utilisation dans les déclencheurs).  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ContextMenuClosingEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire qui modifie le curseur sur une région nommée `DisplayArea` (non illustré). Les commentaires indiquent un <xref:System.Windows.UIElement> l’utilisation, mais en fait, cet exemple serait identique si `DisplayArea` ont été une <xref:System.Windows.FrameworkContentElement>.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un menu contextuel sur l'élément est ouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ouvrir manuellement des menus contextuels, gestionnaires des événements doivent marquer l’événement comme étant géré. Sinon, la valeur existante de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriété sera utilisée pour ouvrir automatiquement un menu contextuel. Marquage de l’événement géré annule effectivement l’action par défaut et peut être une opportunité pour réinitialiser la valeur de la <xref:System.Windows.FrameworkContentElement.ContextMenu%2A> propriété, puis ouvrez le nouveau <xref:System.Windows.Controls.ContextMenu>. Toutefois, il existe un problème de synchronisation que vous devez connaître. Pour remplacer complètement le menu contextuel via un <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> gestionnaire, le menu contextuel initial ne doit pas être null / vide. Ou bien, vous devrez peut-être gérer l’événement et ouvrez manuellement un nouveau menu contextuel. Pour plus d’informations, consultez [Guide pratique pour Gérer l’événement ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer l’identificateur d’événement de service sous-jacent :  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkContentElement> qu’expose l’événement de service sous-jacent ne mappe pas correctement le <xref:System.Windows.FrameworkContentElement.ContextMenuOpening> identificateur pour une utilisation dans les déclencheurs).  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkContentElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le curseur qui s'affiche lorsque le pointeur de la souris est sur cet élément.</summary>
        <value>Curseur à afficher. La valeur par défaut est <see langword="null" /> conformément à cette propriété de dépendance. Toutefois, la valeur pratique par défaut au moment de l’exécution provient de divers facteurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processeur s’appuie sur la conversion de type pour la <xref:System.Windows.Input.Cursor> classe pour évaluer la chaîne. La chaîne fournie doit être évaluée en une <xref:System.Windows.Input.CursorType> valeur. Pour plus d'informations, consultez <xref:System.Windows.Input.Cursor>.  
  
 Si le curseur établi par cette propriété ou n’affiche pas lorsque le pointeur de la souris est au-dessus de cet élément est également dépendant de la valeur de la <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> propriété. En outre, liées aux événements de considérations telles qu’un glisser active, capture de la souris, les modes dans des contrôles et ainsi de suite, d’édition de texte affecte également le curseur avec une priorité plus élevée que la valeur que vous spécifiez dans cette propriété.  
  
 Pour rétablir le comportement de la définition de cette propriété sur la valeur par défaut éventuelle, affectez-lui la valeur `null` à nouveau.  
  
 Le `null` par défaut signifie en réalité que la détermination de la valeur de curseur pratique est différée ici et doit être obtenue à partir d’un autre emplacement. Si présentés sans valeurs par programmation à partir de n’importe quelle source, le curseur par défaut sur un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application sera une flèche.  
  
 Chaque mouvement de la souris sur un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application déclenche une <xref:System.Windows.ContentElement.QueryCursor> événement. L’événement se propage et tout élément le long de l’itinéraire a la possibilité de gérer l’événement et définir la valeur du curseur via les arguments de cet événement. Si cela se produit, le fait que l’événement est géré et qu’il a une valeur modifiée dans les arguments est prioritaire sur la valeur de la <xref:System.Windows.FrameworkContentElement.Cursor%2A> propriété à n’importe quel niveau, sauf si <xref:System.Windows.FrameworkContentElement.ForceCursor%2A> est défini.  
  
 Si vous ne créez un curseur personnalisé, en général, vous définissez cette propriété sur une valeur de propriété statique de la <xref:System.Windows.Input.Cursors> classe.  
  
 Définition de la <xref:System.Windows.Input.Cursor> sur une valeur personnalisée n’est pas activé en mode de confiance partielle. Pour plus d’informations sur les curseurs personnalisés, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.CursorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant définit le curseur sur une valeur personnalisée.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkContentElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkContentElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte de données d’un élément quand il participe à la liaison de données.</summary>
        <value>Objet à utiliser comme contexte de données.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Contexte de données* est un concept qui permet aux éléments d’hériter des informations de leurs éléments parents sur la source de liaison qui est utilisé pour la liaison, ainsi que d’autres caractéristiques de la liaison telles que le chemin d’accès.  
  
 Contexte de données peut être défini directement à un [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objet, avec les liaisons qui évaluent aux propriétés de cet objet. Vous pouvez également définir le contexte de données un <xref:System.Windows.Data.DataSourceProvider> objet.  
  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkContentElement.DataContext%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkContentElement.DataContext%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.  
  
 Vous pouvez également utiliser une des propriétés suivantes de la <xref:System.Windows.Data.Binding> classe pour spécifier explicitement de la source de liaison : <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, ou <xref:System.Windows.Data.Binding.RelativeSource%2A>. Pour plus d'informations, voir [Procédure : Spécifiez la Source de liaison](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 Dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkContentElement.DataContext%2A> est le plus couramment défini comme un <xref:System.Windows.Data.Binding> déclaration. Vous pouvez utiliser la syntaxe d’élément de propriété ou de syntaxe d’attribut. Syntaxe d’attribut est indiquée dans l’exemple de cette page. Vous pouvez également définir <xref:System.Windows.FrameworkContentElement.DataContext%2A> dans le code.  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *dataContextObject*  
 Un objet incorporé directement qui sert de contexte de données pour toutes les liaisons dans l’élément parent. En règle générale, cet objet est un <xref:System.Windows.Data.Binding> ou un autre <xref:System.Windows.Data.BindingBase> sous-classe. Vous pouvez également les données brutes de n’importe quel [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] destiné à la liaison peut être placée ici, avec les liaisons réelles définies ultérieurement de type d’objet.  
  
 *bindingUsage*  
 Utilisation de liaison qui prend la valeur à un contexte de données approprié. Pour plus d’informations, consultez [Binding, extension de balisage](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Une des opérations suivantes : `StaticResource`, ou `DynamicResource`. Cette utilisation est utilisée lorsque vous faites référence aux données brutes définies en tant qu’objet dans les ressources. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 L’identificateur de clé pour l’objet qui est demandé à partir d’un <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.DataContextProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouvel objet de données personnalisées, l’établissement de cet objet en tant que <xref:System.Windows.FrameworkContentElement.DataContext%2A>et en définissant le chemin de liaison à une propriété qu’il contient.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contexte des données de cet élément change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir une explication des contextes de données et la liaison de données, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Lors d’un élément <xref:System.Windows.FrameworkContentElement.DataContext%2A> modifications, toutes les propriétés liées aux données sur cet élément susceptibles d’être affectées. Cela s’applique à tous les éléments qui sont des éléments descendants de l’élément actuel, qui héritent du contexte de données, ainsi que l’élément actuel lui-même. Toutes ces liaisons nouveau interprètent la nouvelle <xref:System.Windows.FrameworkContentElement.DataContext%2A> afin de refléter la nouvelle valeur dans les liaisons. Il n’existe aucune garantie concernant l’ordre de ces modifications au déclenchement de la <xref:System.Windows.FrameworkContentElement.DataContextChanged> événement.  Les modifications peuvent se produire avant l’événement, après l’événement, ou dans toute combinaison.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkContentElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la clé à utiliser pour rechercher le modèle de style pour ce contrôle dans les thèmes.</summary>
        <value>Clé du style. Pour fonctionner correctement dans le cadre de la recherche du style du thème, cette valeur est supposée être le <see cref="T:System.Type" /> de l'élément qui est appelé. <see langword="null" /> est une valeur acceptée dans un certain cas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété n’est pas généralement définie via une de ses accesseurs Set directs. Au lieu de cela, vous substituez les métadonnées spécifiques au type de cette propriété de dépendance chaque fois que vous créez une sous-classe. Lorsque vous créez une sous-classe, appelez le <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> méthode par rapport à la <xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty> identificateur, dans le constructeur statique de la sous-classe de contrôle.  
  
 Par exemple, une classe inline comme <xref:System.Windows.Documents.Bold> a en fait une implémentation très peu au-delà de la substitution de la <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> métadonnées dans son constructeur statique et l’exposition de plusieurs constructeurs d’instance. Le fait que les éléments entourés par le <xref:System.Windows.Documents.Bold> balise gain un <xref:System.Windows.Documents.TextElement.FontWeight%2A> propriété du <xref:System.Windows.FontWeights.Bold%2A> est implémenté dans le style de thème qui a été référencé en définissant la valeur par défaut <xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A> à `typeof(Bold)`.  
  
 Si vous souhaitez que votre élément ou un contrôle de délibérément ne pas utiliser les styles de thème, définissez le <xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A> propriété `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkContentElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé immédiatement après l’initialisation d’un élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implémentez cette méthode pour fournir une gestion spéciale qui doit se produire lorsque votre élément est initialisé pendant le processus de chargement de l’élément.  
  
 Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation.  
  
 Si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> a été appelé précédemment, la base de mise en œuvre déclenchera le <xref:System.Windows.FrameworkContentElement.Initialized> événement. Sinon, si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> n’a pas été appelé ou qu’il ne peut pas être déterminé si <xref:System.Windows.FrameworkContentElement.BeginInit%2A> a été appelée, l’événement n’est pas déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkContentElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l'élément à rechercher.</param>
        <summary>Recherche un élément qui a le nom de l’identificateur fourni.</summary>
        <returns>Élément demandé. Peut avoir la valeur <see langword="null" /> si aucun élément correspondant n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cet élément possède des éléments enfants, ces éléments enfants sont tous recherchés de manière récursive pour l’élément nommé demandé.  
  
   
  
## Examples  
 L’exemple suivant définit une propriété sur un élément recherché par nom dans un référencé <xref:System.Windows.Documents.FlowDocument> sur une page.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindName](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findname)]
 [!code-vb[ContentElementsSmorgasbord#FindName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findname)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkContentElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificateur de clé de la ressource à rechercher.</param>
        <summary>Recherche une ressource avec la clé spécifiée et lève une exception si la ressource demandée est introuvable.</summary>
        <returns>Ressource trouvée, ou <see langword="null" /> si aucune ressource correspondante n’a été trouvée (mais lève également une exception si <see langword="null" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Si vous appelez cette méthode pour une clé qui est introuvable, une exception est levée. Si vous ne souhaitez pas gérer les exceptions pour ce cas, vous devez plutôt appeler <xref:System.Windows.FrameworkContentElement.TryFindResource%2A>. <xref:System.Windows.FrameworkContentElement.TryFindResource%2A> Retourne `null` quand aucune ressource n’est trouvée et ne lève pas d’exception.  
  
 Si la ressource est introuvable sur l’élément appelant, l’arborescence parente est recherchée à l’aide de l’arborescence logique, de la même façon que l’arborescence serait recherchée si une ressource était demandée par clé au moment de l’exécution.  
  
 En règle générale, vous castez immédiatement la valeur de retour vers le type de la propriété que vous essayez de définir avec la valeur de la ressource retournée.  
  
   
  
## Examples  
 L’exemple suivant recherche une ressource, tel que défini dans le balisage et s’applique à une certaine propriété d’un élément en réponse à un événement routé.  
  
 [!code-csharp[ContentElementsSmorgasbord#FindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#findresource)]
 [!code-vb[ContentElementsSmorgasbord#FindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#findresource)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">La clé de ressource demandée est introuvable.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit un objet qui active la personnalisation de l’apparence, les effets ou d’autres caractéristiques de style qui s’appliquent à cet élément lorsqu’il capture le focus clavier.</summary>
        <value>Style souhaité à appliquer sur le focus. La valeur par défaut déclarée dans la propriété de dépendance est un <see cref="T:System.Windows.Style" /> statique vide. Toutefois, la valeur effective au moment de l’exécution est souvent (mais pas toujours) un style tel qu’il est fourni par la prise en charge du thème pour les contrôles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], styles sont presque toujours définis comme une ressource, plutôt qu’inline comme un élément et que la ressource est généralement référencé comme un <xref:System.Windows.StaticResourceExtension>.  
  
 Notez que cette propriété affecte l’apparence visuelle mais ne signale pas ainsi dans les métadonnées. Il s’agit, car la modification de l’apparence visuelle est pilotée par événements et ne peut-être pas s’appliquer à tout moment et par conséquent, ne doit pas généralement signaler toute information visual ou une disposition dans les métadonnées.  
  
 Sur le plan conceptuel, le comportement visuel de focus appliqué à un contrôle doit être cohérent à partir d’un élément à l’élément. La méthode la plus sensible pour appliquer la cohérence consiste à modifier uniquement le style de focus visuel si vous composez un thème entier. Définition de cette propriété sur les styles individuels et non comme faisant partie d’un thème n’est pas l’utilisation prévue de cette propriété, car elle peut entraîner une expérience utilisateur ambiguë concernant le focus clavier. Si vous prévoyez un comportement spécifique à l’élément qui est délibérément pas cohérent à travers un thème, une approche bien meilleure consiste à utiliser des déclencheurs dans les styles pour les propriétés de l’état d’entrées individuelles, telles que <xref:System.Windows.UIElement.IsFocused%2A> ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>et à le faire d’une façon qui ne pas visuellement, interférer avec n’importe quel style de focus visuel existant. Pour plus d’informations sur l’intention de conception de <xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A> et d’autres propriétés du focus, consultez [focus dans les contrôles et FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourceExtension*  
 Une des opérations suivantes :, ou. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clé qui identifie le style demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée. Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Une référence de liaison à l’aide [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) ou <xref:System.Windows.Data.Binding> est également possible, mais rare.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.FocusVisualStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkContentElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si ce <see cref="T:System.Windows.FrameworkContentElement" /> doit forcer le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] pour restituer le curseur comme déclaré par la propriété <see cref="P:System.Windows.FrameworkContentElement.Cursor" /> de cette instance.</summary>
        <value><see langword="true" /> pour forcer la présentation de curseur lorsqu'il se trouve sur cet élément pour utiliser ce paramètre d'instance pour le curseur (y compris sur tous les éléments enfants) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété `true` remplacera les préférences de curseur établies par les éléments enfants. Par conséquent, en général application sous peine [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] peut prêter à confusion pour l’utilisateur, en particulier si les éléments enfants essaient de spécifier des curseurs. Paramètre <xref:System.Windows.FrameworkElement.ForceCursor%2A> est plus appropriée dans les scénarios de sous-classement ou de composition de contrôle.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ForceCursorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant force le curseur au-dessus de l’élément.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Le <see cref="T:System.Windows.DependencyProperty" /> cible à partir duquel obtenir la liaison.</param>
        <summary>Reçoit le <see cref="T:System.Windows.Data.BindingExpression" /> pour la liaison de propriété spécifiée.</summary>
        <returns>Retourne un <see cref="T:System.Windows.Data.BindingExpression" /> si la cible est liée aux données ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant récupère une liaison en interrogeant une propriété.  
  
 [!code-csharp[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#getbindingexpression)]
 [!code-vb[ContentElementsSmorgasbord#GetBindingExpression](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#getbindingexpression)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un parent logique alternatif pour cet élément s’il n’existe aucun parent visuel. Dans ce cas, un parent <see cref="T:System.Windows.FrameworkContentElement" /> a toujours la même valeur que la propriété <see cref="P:System.Windows.FrameworkContentElement.Parent" />.</summary>
        <returns>Retourne une valeur autre que <see langword="null" /> quand une implémentation de niveau infrastructure WPF de cette méthode a une connexion de parent non visuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut retourne le parent visuel unique attendu. Des implémentations personnalisées peuvent retourner d’autres relations parentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="T:System.Windows.FrameworkContentElement" /> est initialisé. Cela coïncide avec les cas où la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> se transforme de <see langword="false" /> (ou indéfini) en <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché chaque fois que le <xref:System.Windows.FrameworkContentElement.EndInit%2A> ou <xref:System.Windows.FrameworkContentElement.OnInitialized%2A> méthodes sont appelées. Appels à ces méthodes peuvent ont été apportées par un code délibéré, ou par le [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] processus de chargement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkContentElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte pour l’entrée utilisée par ce <see cref="T:System.Windows.FrameworkContentElement" />.</summary>
        <value>Portée d’entrée, qui modifie la façon dont l’entrée provenant d’autres méthodes d’entrée est interprétée. La valeur par défaut est <see langword="null" /> (ce qui entraîne une gestion par défaut des commandes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkElement.InputScope%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.InputScope%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.  
  
 Bien qu’un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilisation de la syntaxe est répertoriée et est autorisée syntaxiquement, la définition de cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] n’est pas courante.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.InputScopeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkContentElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet élément a été initialisé, en étant chargé comme [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], ou en ayant explicitement sa méthode <see cref="M:System.Windows.FrameworkContentElement.EndInit" /> appelée.</summary>
        <value><see langword="true" /> si l'élément est initialisé par le chargement susmentionné ou les appels de méthode ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut également être `true` si cet élément a été déplacé au sein de l’arborescence d’éléments tel qu’il a un nouvel élément parent et par conséquent soit rechargé.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkContentElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet élément a été chargé pour la présentation.</summary>
        <value><see langword="true" /> si l'élément actuel est attaché à une arborescence d'éléments et a été restitué ; <see langword="false" /> si l'élément n'a jamais été attaché à une arborescence d'éléments chargée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À partir d’une instance nouvellement construite, cette propriété fait commence `false`et reste `true` une fois qu’il est défini sur `true`, même si par la suite supprimé par le code.  
  
   
  
## Examples  
 L’exemple de code suivant utilise <xref:System.Windows.FrameworkContentElement.IsLoaded%2A> comme un contrôle conditionnel pour s’assurer qu’une fonction `displayData` (non illustré) sont des éléments valides chargés dans la page de travailler sur, dans le cadre d’un gestionnaire à la demande. Que la même logique est exécutée comme un gestionnaire d’événements <xref:System.Windows.FrameworkContentElement.Loaded>.  
  
 [!code-csharp[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#isloaded)]
 [!code-vb[ContentElementsSmorgasbord#IsLoaded](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#isloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkContentElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkContentElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations de langue de localisation/globalisation qui s’appliquent à un élément spécifique.</summary>
        <value>Informations de culture pour cet élément. La valeur par défaut est une instance de <see cref="T:System.Windows.Markup.XmlLanguage" /> avec la chaîne “en-US” comme valeur <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les formats de chaîne respectent la norme RFC 3066. Par exemple, aux États-Unis L’anglais est « en-US ». Consultez <xref:System.Windows.Markup.XmlLanguage> pour plus d’informations sur les valeurs et le format.  
  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants avec aucune autre valeur pour <xref:System.Windows.FrameworkElement.Language%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.Language%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.LanguageProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l’élément est disposé, rendu et prêt pour l’interaction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés. Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.LoadedEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.Loaded" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkContentElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un énumérateur pour les éléments enfants logiques de cet élément.</summary>
        <value>Un énumérateur pour les éléments enfants logiques de cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkContentElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkContentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">La direction sur laquelle le focus doit être déplacé, comme une valeur de l'énumération.</param>
        <summary>Déplace le focus clavier de cet élément sur un autre élément.</summary>
        <returns>Retourne la valeur <see langword="true" /> si le focus est déplacé avec succès ; <see langword="false" /> si l'élément cible dans la direction spécifiée n'existe pas.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkContentElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom d’identification de l’élément. Le nom fournit une référence d’instance pour permettre à du code-behind programmatique, tel que le code d’un gestionnaire d’événements, de faire référence à un élément une fois qu’il est construit pendant l’analyse de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nom de l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation la plus courante de cette propriété est lorsque vous spécifiez un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nom de l’élément dans le balisage.  
  
 Cette propriété fournit essentiellement une propriété de commodité de niveau infrastructure WPF pour définir le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Obtenir un <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code n’est pas courante, car si vous avez déjà la référence appropriée dans le code, vous pouvez simplement appeler des méthodes et propriétés sur l’élément de référence et n’avez généralement pas besoin du <xref:System.Windows.FrameworkContentElement.Name%2A>. Une exception est si la chaîne a une signification surchargée, par exemple s’il est utile d’afficher ce nom dans [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Définissant un <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code si la version d’origine <xref:System.Windows.FrameworkContentElement.Name%2A> a été ensemble à partir du balisage est également pas recommandée, et modification de la propriété ne changera pas la référence d’objet. Ces références d’objet sont créés uniquement lorsque les portées de nom sous-jacentes sont créées explicitement pendant [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] le chargement.  
  
 Vous devez appeler spécifiquement <xref:System.Windows.FrameworkContentElement.RegisterName%2A> pour apporter une modification effective sur le <xref:System.Windows.FrameworkContentElement.Name%2A> propriété d’un élément déjà chargé.  
  
 Un notable cas où le paramètre <xref:System.Windows.FrameworkContentElement.Name%2A> à partir du code est important est pour exécutent des éléments d’affectation de noms que les tables de montage séquentiel. Avant vous pouvez inscrire un nom, vous devez également instancier et attribuer une <xref:System.Windows.NameScope> instance. Consultez la section exemple, ou [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Paramètre <xref:System.Windows.FrameworkContentElement.Name%2A> à partir de code a des applications limitées, mais la recherche d’un élément par nom est plus courante, en particulier si vous employez un modèle de navigation où rechargent les pages dans l’application et le code d’exécution n’est pas nécessairement le code-behind de qui page respectif. La méthode utilitaire <xref:System.Windows.FrameworkContentElement.FindName%2A>, qui est disponible à partir d’un <xref:System.Windows.FrameworkContentElement>, peut rechercher n’importe quel élément par <xref:System.Windows.FrameworkContentElement.Name%2A> de manière récursive d’arborescence logique de cet élément. Ou vous pouvez utiliser la <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> méthode statique de <xref:System.Windows.LogicalTreeHelper>, qui prend également la <xref:System.Windows.FrameworkContentElement.Name%2A> chaîne en tant qu’argument.  
  
 Éléments racine couramment utilisés (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> par exemple) implémentent l’interface <xref:System.Windows.Markup.INameScope>. Les implémentations de cette interface sont supposées renforcer les noms d’être non équivoque dans leur étendue.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.NameProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /> rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires. Par conséquent, votre implémentation doit prendre des propriétés de source des arguments de l’événement en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkContentElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement de l'événement.</param>
        <summary>Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /> rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkContentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement de l'événement.</param>
        <summary>Gestionnaire de classe pour l'événement <see cref="E:System.Windows.ContentElement.GotFocus" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce gestionnaire de classe définit le comportement approprié du focus sur cet élément si l’événement provient de cet élément. Si la source de l’événement était un autre élément dans l’arborescence, le gestionnaire ne fait rien.  
  
 Substituez cette méthode afin de modifier ces par défaut sur votre élément de comportement de convergence.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkContentElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d'événement de l'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.FrameworkContentElement.Initialized" />. Cette méthode est appelée toutes les fois que <see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /> a la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation par défaut de cette méthode virtuelle déclenche l’événement comme décrit précédemment dans cette rubrique. Les substitutions doivent appeler base () pour conserver ce comportement.  
  
 Notez que le <xref:System.Windows.FrameworkContentElement.IsInitialized%2A> propriété est en lecture seule. Par conséquent, vous ne pouvez pas définir pour forcer le comportement de l’initialisation de cette façon. Paramètre d’initialisation est conçu pour être utilisé uniquement par le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkContentElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d’événement qui décrivent la propriété ayant changé, dont les anciennes et nouvelles valeurs.</param>
        <summary>Méthode appelée chaque fois que la valeur effective d’une propriété de dépendance sur ce <see cref="T:System.Windows.FrameworkContentElement" /> a été mise à jour. La propriété de dépendance spécifique qui a changé est indiquée dans le paramètre d’arguments. Substitue <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas destinée à généralement détecter les modifications apportées aux propriétés ou les invalidations. Il est destiné à la place les modifications du modèle d’invalidation général si certaines informations sont connues de larges classifications de propriétés.  
  
 Cette méthode est appelée potentiellement plusieurs fois pendant la durée de vie d’un objet. Par conséquent, vous pouvez obtenir de meilleures performances si vous substituez les métadonnées de propriétés spécifiques puis attachez <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> fonctions pour les propriétés individuelles. Toutefois, vous utiliseriez cette méthode si un <xref:System.Windows.FrameworkContentElement> inclut un nombre important de propriétés de dépendance mises en corrélation par valeur, ou si elle inclut la logique comme comportement de rendu qui doit être réexécuté pour plusieurs cas d’invalidations de propriétés connexes.  
  
 Notez qu’il existe une portant le même nom `OnPropertyChanged` méthode avec une signature différente (le type de paramètre est <xref:System.ComponentModel.PropertyChangedEventArgs>) qui peuvent apparaître sur un nombre de classes. Que `OnPropertyChanged` est utilisé pour les notifications d’objet de données, et fait partie du contrat pour <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Appelez toujours l’implémentation de base, comme première opération dans votre implémentation. Entier sera considérablement désactivé dans le cas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés, ce qui entraîne le signalement de valeurs incorrectes.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkContentElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">L'ancien style.</param>
        <param name="newStyle">Le nouveau style.</param>
        <summary>Appelé lorsque le style qui est utilisé sur cet élément change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode présente une implémentation par défaut qui définit un indicateur interne, en notant la condition de style modifié.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Toujours appeler l’implémentation de base, sinon les styles ne peut pas être appliqués. Scénarios pour la substitution de cette méthode peuvent inclure si votre classe dérivée possède un sélecteur de style spécialisé, ou met en cache les valeurs de style. Modifications de thème potentiellement appelle cette méthode.</para></block>
        <altmember cref="P:System.Windows.FrameworkContentElement.Style" />
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkContentElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler implémenterait au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkContentElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si cet élément incorpore des propriétés de style de styles de thème.</summary>
        <value><see langword="true" /> si cet élément n'utilise pas de propriétés du style de thème ; toutes les propriétés qui proviennent du style proviennent de styles d'application locaux, et les propriétés du style de thème ne s'appliquent pas. <see langword="false" /> si les styles d'application s'appliquent en premier, puis que les styles de thème s'appliquent aux propriétés qui n'ont pas été spécifiquement définies dans les styles d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation la plus courante de cette propriété est une utilisation indirecte dans l’accesseur Set d’un style qui fournit un style à thème.  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le parent de l’arborescence logique pour cet élément.</summary>
        <value>Parent logique pour cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notez que le parent logique d’un élément peut éventuellement changer selon les fonctionnalités de votre application, et en conservant la valeur de cette propriété ne reflétera pas cette modification. Vous devez généralement obtenir la valeur juste avant que vous en avez besoin.  
  
 Consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) pour plus d’informations sur le parcours des arborescences logiques et les scénarios où il est appropriée de cette approche vers la découverte de l’élément.  
  
 Le système de propriétés recalculera potentiellement toutes les valeurs de propriété d’un élément lorsqu’il est apparenté à nouveau, car certaines propriétés héritent des valeurs dans l’arborescence logique. Le <xref:System.Windows.FrameworkContentElement.DataContext%2A> qui s’applique pour les liaisons peut également changer lorsque les éléments sont apparentés à nouveau.  
  
 Modification du parent d’un élément est généralement uniquement effectuée via la manipulation de collections, à l’aide de dédié méthodes add ou remove, ou via la définition des propriétés de contenu d’éléments.  
  
 Le scénario le plus courant pour l’utilisation de la <xref:System.Windows.FrameworkContentElement.Parent%2A> propriété consiste à obtenir une référence, puis d’obtenir différentes <xref:System.Windows.FrameworkContentElement> les valeurs de propriété à partir du parent. Pour les modèles, les <xref:System.Windows.FrameworkContentElement.Parent%2A> du modèle à long terme sera `null`. Pour franchir ce point et développer l’arborescence logique où le modèle est réellement appliqué, utilisez <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A>.  
  
   
  
## Examples  
 L’exemple suivant vérifie si le <xref:System.Windows.FrameworkContentElement.Parent%2A> d’un <xref:System.Windows.Documents.TextPointer> est d’un type particulier.  
  
 [!code-csharp[TextPointer_snippets#FCEParent](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#fceparent)]
 [!code-vb[TextPointer_snippets#FCEParent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#fceparent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkContentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">La direction pour laquelle une future modification de focus doit être déterminée.</param>
        <summary>Détermine l'élément suivant qui recevrait le focus relatif à cet élément pour une direction du déplacement du focus fournie, mais ne déplace pas réellement le focus. Cette méthode est sealed et ne peut pas être substituée.</summary>
        <returns>L'élément suivant sur lequel se déplacerait le focus si le focus était parcouru réellement. Peut retourner <see langword="null" /> si le focus ne peut pas être déplacé par rapport à cet élément pour la direction fournie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkContentElement.MoveFocus%2A> est la méthode connexe qui déplace effectivement le focus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Spécifié l'une des directions suivantes dans le <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Ces sens ne sont pas légaux pour <see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (mais le sont pour <see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkContentElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nom à utiliser pour le mappage nom-objet spécifié.</param>
        <param name="scopedElement">Objet pour le mappage.</param>
        <summary>Fournit un accesseur qui simplifie l'accès à la méthode d'inscription <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.NameScope.RegisterName%2A>. L’implémentation vérifie les éléments parents successifs jusqu'à ce qu’il trouve applicable <xref:System.Windows.NameScope> implémentation, ce qui se trouve en recherchant un élément qui implémente <xref:System.Windows.Markup.INameScope>. Pour plus d’informations sur les portées de nom, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Appel <xref:System.Windows.FrameworkContentElement.RegisterName%2A> est nécessaire pour raccorder correctement des tables de montage séquentiel pour les applications lors de la création dans le code. Il s’agit, car un de la clé d’animation de propriétés, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utilise une recherche de nom de l’exécution au lieu d’être en mesure de prendre une référence à un élément cible. Cela est vrai même si cet élément est accessible par référence à partir du code. Pour plus d’informations sur la nécessité d’inscrire les noms pour les cibles de la table de montage séquentiel, consultez [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md). Animations pour les éléments de contenu sont moins fréquentes que les animations sur les contrôles, le [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md) se concentre sur les scénarios de contrôle.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkContentElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Élément à supprimer.</param>
        <summary>Supprime l’élément spécifié de l’arborescence logique pour cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] est principalement utile pour la classe qui dérive des scénarios, lors de l’ajout de prise en charge des collections enfants.  
  
 La plupart des <xref:System.Windows.FrameworkContentElement> classes dérivées exposent des collections dédiées qui sont responsables de relation contenant-contenu (par exemple, <xref:System.Windows.Documents.Span.Inlines%2A> sur la <xref:System.Windows.Documents.Span> classe ; <xref:System.Windows.Documents.Section.Blocks%2A> sur la <xref:System.Windows.Documents.Section> classe). Dériver de telles classes généralement peut éviter tout besoin de manipuler l’arborescence logique directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkContentElement.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le dictionnaire de ressources actuel défini localement.</summary>
        <value>Les ressources actuelles définies localement. Il s'agit d'un dictionnaire de ressources, où les ressources dans le dictionnaire sont accédées par clé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les dictionnaires de ressources qui peuvent être définis complètement ou partiellement en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] sont généralement créés comme élément de propriété et sont généralement sur l’élément racine pour n’importe quelle page individuel ou pour l’application. Placer le dictionnaire de ressources à ce niveau facilite la recherche d’éléments enfants individuels dans la page (ou à partir de n’importe quelle page, dans le cas d’application). Dans la plupart des scénarios d’application, nous recommandons que les styles être définis en tant qu’éléments objet dans un dictionnaire de ressources, ou être définis comme des ressources externes afin que la ressource de style entière peut être autonome (cette approche permet de concepteur distinct responsabilités du développeur en séparant les fichiers physiques qui doivent être modifiées).  
  
 Notez que cette propriété retourne uniquement le dictionnaire de ressources déclaré directement dans cet élément. Cela est différent de celui du processus de recherche de ressource réelle, où un élément enfant peut accéder à toutes les ressources définies dans chaque élément parent, la recherche de manière récursive vers le haut.  
  
 Peut également être référencées par le code à partir de la collection de ressources, mais n’oubliez pas que les ressources créées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sans aucun doute ne seront plus accessibles jusqu’après <xref:System.Windows.FrameworkContentElement.Loaded> est déclenché par l’élément qui déclare le dictionnaire. En fait, les ressources sont analysées de façon asynchrone et pas même le <xref:System.Windows.FrameworkContentElement.Loaded> événement est l’assurance que vous pouvez référencer un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] défini de ressources. C’est pourquoi vous devez généralement accéder uniquement aux [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] définies des ressources dans le cadre du code au moment de l’exécution, ou par le biais des autres [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques telles que les styles ou les références d’extension de ressource pour les valeurs d’attribut. Lorsque vous accédez aux ressources via le code, il est fondamentalement équivalent à un [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) référence effectuée depuis [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Sous-jacent <xref:System.Windows.ResourceDictionary> prend en charge les méthodes requises pour ajouter, supprimer ou interroger les ressources à partir de la collection à l’aide de code. Le <xref:System.Windows.FrameworkContentElement.Resources%2A> propriété peut être définie pour prendre en charge le scénario du remplacement complet de la collection de ressources d’un élément à nouveau ou différent <xref:System.Windows.ResourceDictionary>.  
  
 Notez que le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe indiquée n’inclut pas un élément pour le <xref:System.Windows.ResourceDictionary>. Il s’agit d’un exemple de syntaxe de collection implicite ; une balise qui représente l’élément de collection peut être omise. Les éléments qui sont ajoutés en tant qu’éléments à la collection sont spécifiés à la place. Pour plus d’informations sur les collections implicites et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consultez [syntaxe de XAML en détail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Un cas où un <xref:System.Windows.ResourceDictionary> est encore spécifié explicitement comme un élément est si vous introduisez un dictionnaire fusionné, auquel cas il n’existe généralement aucun élément enfant pour qui <xref:System.Windows.ResourceDictionary>. Pour plus d’informations, consultez [dictionnaires de ressources fusionnés](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *oneOrMoreResourceElements*  
 Un ou plusieurs éléments objet, chacun d’eux définit une ressource. Chaque élément de propriété de ressource au sein de chaque <xref:System.Windows.ResourceDictionary> doit avoir une valeur unique pour le [Directive x : Key](~/docs/framework/xaml-services/x-key-directive.md), qui sert de clé unique lorsque les valeurs sont récupérées à partir de la <xref:System.Windows.ResourceDictionary>.  
  
   
  
## Examples  
 L’exemple suivant établit une <xref:System.Windows.FrameworkContentElement.Resources%2A> collection sur un <xref:System.Windows.Documents.FlowDocument> élément racine. <xref:System.Windows.Documents.FlowDocument> est un choix par défaut, car il est un des rares <xref:System.Windows.FrameworkContentElement> classes pertinentes comme un élément racine et les ressources sont généralement stockés à la racine de page ou à des niveaux supérieurs de même, comme illustré dans l’application.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attache une liaison à cet élément pour la propriété de dépendance spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkContentElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifie la propriété liée.</param>
        <param name="path">Le nom de propriété source ou le chemin d'accès à la propriété utilisée pour la liaison.</param>
        <summary>Rattache une liaison à cet élément, selon le nom de propriété source fourni comme une qualification de chemin d'accès à la source de données.</summary>
        <returns>Enregistre les conditions de la liaison. Cette valeur de retour peut être utile pour la vérification des erreurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>et crée un nouveau <xref:System.Windows.Data.Binding> selon fourni `path` paramètre. Cette signature est plus commode si vous établissez une liaison simple par défaut. Si vous avez besoin spécifier des propriétés de liaison à des conditions non définis par défaut, ou souhaitez utiliser un <xref:System.Windows.Data.MultiBinding> ou <xref:System.Windows.Data.PriorityBinding>, vous devez utiliser le <xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.  
  
   
  
## Examples  
 L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouvel objet de données personnalisées, l’établissement de cet objet en tant que <xref:System.Windows.FrameworkContentElement.DataContext%2A>et en définissant le chemin de liaison à une propriété qu’il contient.  
  
 [!code-csharp[ContentElementsSmorgasbord#DataContext](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#datacontext)]
 [!code-vb[ContentElementsSmorgasbord#DataContext](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#datacontext)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkContentElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identifie la propriété liée.</param>
        <param name="binding">Représente une liaison de données.</param>
        <summary>Attache une liaison à cet élément selon l’objet de liaison fourni.</summary>
        <returns>Enregistre les conditions de la liaison. Cette valeur de retour peut être utile pour la vérification des erreurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>.  
  
   
  
## Examples  
 L’exemple suivant définit une liaison sur un <xref:System.Windows.Documents.Paragraph> élément, en créant un nouveau <xref:System.Windows.Data.Binding> et en définissant la source sur nouvellement généré `DateTime` objet.  
  
 [!code-csharp[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#setbinding)]
 [!code-vb[ContentElementsSmorgasbord#SetBinding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#setbinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkContentElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété à laquelle la ressource est liée.</param>
        <param name="name">Nom de la ressource.</param>
        <summary>Recherche une ressource avec le nom spécifié et lui paramètre une référence à une ressource pour la propriété spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une référence de ressource est similaire à l’utilisation d’un [Extension de balisage DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) dans le balisage. La référence de ressource crée une expression interne qui fournit la valeur de la propriété spécifiée sur une base différée d’exécution. L’expression sera réévaluée chaque fois que le dictionnaire de ressources indique une valeur modifiée par le biais des événements internes, ou chaque fois que l’élément actuel est apparenté à nouveau (une modification du parent modifierait le chemin de recherche du dictionnaire).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkContentElement.Resources" /> sur les instances de cette classe.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.Resources" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ceci renverra `true` afin qu’il existe au moins une ressource de clé local <xref:System.Windows.FrameworkContentElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkContentElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkContentElement.Style" /> sur les instances de cette classe.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkContentElement.Style" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ceci renverra `true` si la <xref:System.Windows.Style> est définie localement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque toute source de données associée participant à une liaison sur cet élément change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement survole le <xref:System.Windows.Data.Binding.SourceUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object SourceUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkContentElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style à utiliser par cet élément.</summary>
        <value>Style appliqué, non défini par défaut de l’élément, le cas échéant. Sinon, <see langword="null" />. La valeur par défaut d’un <see cref="T:System.Windows.FrameworkContentElement" /> construit par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le style actuel est souvent fourni par un style par défaut de thèmes, ou à partir de styles généralement appliquées aux objets de ce type par les ressources au niveau page ou application (un style implicite). Cette propriété ne pas définie ou retour par défaut les styles (thème), mais il retourne le style implicit ou un style explicite. Dans le cas de styles implicites ou explicites, peu importe si le style est accessible en tant que ressource ou défini localement.  
  
 Définition des styles comporte certaines restrictions. Vous pouvez réinitialiser l’ensemble <xref:System.Windows.FrameworkContentElement.Style%2A> propriété vers un nouveau <xref:System.Windows.Style> à tout moment, ce qui force une recomposition de disposition. Toutefois, dès que ce style est placé en cours d’utilisation par un élément chargé, le <xref:System.Windows.Style> doit être considéré comme sealed. Essayez d’apporter une modification à n’importe quelle propriété individuelle d’un style en cours d’utilisation (tels que quoi que ce soit dans la collection de <xref:System.Windows.Style.Setters%2A>) provoque une exception levée. Un style qui est défini dans le balisage est considéré comme en cours d’utilisation dès qu’il est chargé à partir d’un dictionnaire de ressources (pour les ressources), ou la page, dans qu'il est contenu est chargée (pour les styles intraligne).  
  
 <xref:System.Windows.FrameworkContentElement.Style%2A> est une propriété de dépendance avec une priorité particulière. Définie localement style fonctionne généralement à la priorité la plus élevée dans le système de propriétés. Si le <xref:System.Windows.FrameworkContentElement.Style%2A> a la valeur null à ce stade, pendant le chargement du système de propriétés vérifie styles implicites comme ressources définies qui spécifient ce type. Si le style est toujours la valeur null après cette étape, puis le style provient le style par défaut (thème), mais le style par défaut n’est pas retourné dans la <xref:System.Windows.FrameworkContentElement.Style%2A> valeur de propriété. Consultez [priorité de valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Style="{resourceExtension StyleResourceKey}"/>  
```  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourceExtension*  
 Une des opérations suivantes :, ou. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clé qui identifie le style demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée. Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  Une référence de liaison à l’aide [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) ou <xref:System.Windows.Data.Binding> est également possible, mais rare.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.StyleProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant établit une <xref:System.Windows.FrameworkContentElement.Resources%2A> collection sur un <xref:System.Windows.Documents.FlowDocument> élément racine et puis de la référence en tant que ressource comme un style spécifique pour un <xref:System.Windows.Documents.Paragraph>.  
  
 [!code-xaml[ContentElementsSmorgasbord#FCEResources](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page2.xaml#fceresources)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété ambiante demandée.</param>
        <summary>Pour obtenir une description de ce membre, consultez la méthode <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns><see langword="true" /> si <paramref name="propertyName" /> est disponible ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.FrameworkContentElement> est castée en interface <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkContentElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur d’objet arbitraire utilisable pour stocker des informations personnalisées sur cet élément.</summary>
        <value>La valeur prévue. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est analogue aux propriétés de balise dans d’autres modèles de programmation de Microsoft, tel que Visual Basic pour Applications ou des Windows Forms. Il vise à fournir un emplacement existant pour stocker des informations personnalisées de base sur n’importe quel élément sans forcer les développeurs d’applications à la sous-classe.  
  
<a name="xamlValues_Tag"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 Étant donné que cette propriété prend un objet, vous devez utiliser l’utilisation d’élément de propriété afin de définir le <xref:System.Windows.FrameworkContentElement.Tag%2A> propriété dans XAML pour autre chose qu’un objet avec un convertisseur de type connu et intégrées, telles qu’une chaîne. Objets utilisés de cette façon sont généralement pas dans les espaces de noms WPF standard et peuvent donc avoir besoin de mappage d’espace de noms à l’espace de noms externe afin d’être introduite en tant qu’éléments XAML.  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.TagProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une propriété cible associée qui participe à une liaison sur cet élément change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement survole le <xref:System.Windows.Data.Binding.TargetUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément. Cela signifie généralement que la liaison en question est une liaison bidirectionnelle, et que la propriété de dépendance liée affirme une invalidation de la valeur de propriété précédente par toute validation ou d’un modèle de mise en cache qui prend en charge de la propriété.  
  
 Les arguments d’événement de cet événement informe les propriété liée a été modifiées.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object TargetUpdated="EventHandler"/>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkContentElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au modèle parent de cet élément. Cette propriété n’est pas pertinente si l’élément n’a pas été créé par l’intermédiaire d’un modèle.</summary>
        <value>L’élément dont <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> a provoqué cet élément doit être créé. Cette valeur est souvent <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les modèles sont des objets en fait partagés où le contenu du modèle est créé une seule fois. Par conséquent, si vous obtenez une référence d’objet à un élément qui provenance d’un modèle, vous trouverez que l’arborescence logique apparente n’atteint pas à la racine de la page. Pour connecter une référence de modèle à l’arborescence logique de la page, vous devez obtenir le <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> valeur et continuer à parcourir cette arborescence d’éléments comme vous le souhaitez.  
  
 <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> sera fréquemment `null` pour les objets communs, car si vous avez obtenu une référence d’objet d’une page dans votre application via des moyens typiques, cet élément n’a probablement pas créé à partir d’un modèle. Les cas où <xref:System.Windows.FrameworkContentElement.TemplatedParent%2A> peut ne pas être `null` peuvent inclure des opérations telles que le test de positionnement, les événements gestion de certains événements d’entrée de bas niveau, ou utiliser des énumérateurs, qui ont peuvent retourner des éléments provenant de modèles.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkContentElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkContentElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet d'info-bulle affiché pour cet élément dans le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>L'objet d'info-bulle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de cette propriété est de type <xref:System.Windows.Controls.ToolTip>, puis qui est l’info-bulle qui sera utilisé dans le [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Si la valeur est d’un autre type, cette valeur sera utilisée comme le *contenu* pour un <xref:System.Windows.Controls.ToolTip> fourni (construit) par le système. Pour plus d'informations, consultez <xref:System.Windows.Controls.ToolTipService>. La classe de service fournit des propriétés jointes qui peuvent être utilisées pour personnaliser davantage une info-bulle.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *toolTipContent*  
 Chaîne qui devient le texte affiché pour le <xref:System.Windows.FrameworkContentElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Objet fourni dans le formulaire d’élément objet, qui doit être utilisé comme contenu pour le <xref:System.Windows.FrameworkContentElement> . En règle générale, ce serait un <xref:System.Windows.FrameworkElement> ou tout autre élément qui crée une composition de disposition pour le <xref:System.Windows.FrameworkContentElement.ToolTip%2A>, contenant finalement le contenu de texte dans la composition. Dans ce cas, le <xref:System.Windows.Controls.ToolTip> élément est créé implicitement à partir d’analysée [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]et le *toolTipObjectContent* contenu est défini en tant que son <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propriété.  
  
 <`ToolTip` .../>  
 Consultez <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ToolTipProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant définit la valeur de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propriété directement dans une chaîne.  
  
 [!code-csharp[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/csharp/VS_Snippets_Wpf/TableSnippets2/CSharp/Window1.xaml.cs#_table_rowgroups_maniprows)]
 [!code-vb[TableSnippets2#_Table_RowGroups_ManipRows](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TableSnippets2/visualbasic/window1.xaml.vb#_table_rowgroups_maniprows)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant la fermeture d'une info-bulle sur l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour supprimer la fermeture de l’info-bulle, les gestionnaires de l’événement doivent le marquer comme étant géré.  
  
 Cet événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style. Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas de méthodes d’ajout/suppression de l’événement.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ToolTipClosingEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit à l’ouverture d’une info-bulle sur l’élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ouvrir manuellement les info-bulles, gestionnaires des événements doivent marquer l’événement comme étant géré. Sinon, la valeur de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriété sera utilisée pour ouvrir automatiquement un menu contextuel. Marquage de l’événement géré annule effectivement l’action par défaut et peut être une opportunité pour réinitialiser la valeur de la <xref:System.Windows.FrameworkContentElement.ToolTip%2A> propriété, puis ouvrez le nouveau <xref:System.Windows.Controls.ContextMenu>. Notez que cet événement ne sera pas déclenché si <xref:System.Windows.FrameworkContentElement.ToolTip%2A> est une référence null ou autrement pas définie.  
  
 Cet événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style. Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas de méthodes d’ajout/suppression de l’événement.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.ToolTipOpeningEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkContentElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkContentElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkContentElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificateur de clé de la ressource à rechercher.</param>
        <summary>Recherche une ressource avec la clé spécifiée et retourne cette ressource si elle est trouvée.</summary>
        <returns>Ressource trouvée. Si aucune ressource n’a été trouvée, <see langword="null" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ressource est introuvable sur l’élément appelant, l’arborescence parente est recherchée à l’aide de l’arborescence logique, de la même façon que l’arborescence serait recherchée si une référence de ressource dynamique était demandée par clé au moment de l’exécution.  
  
 En règle générale, vous castez immédiatement la valeur de retour vers le type de la propriété que vous essayez de définir avec la valeur de la ressource retournée.  
  
 Le <xref:System.Windows.FrameworkContentElement.FindResource%2A> méthode a un comportement similaire, sauf qu’il lève une exception dans le cas vous ne trouvez ne pas une ressource avec la clé fournie.  
  
   
  
## Examples  
 L’exemple suivant recherche une ressource, tel que défini dans le balisage et s’applique à une certaine propriété d’un élément en réponse à un événement routé.  
  
 [!code-csharp[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#tryfindresource)]
 [!code-vb[ContentElementsSmorgasbord#TryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#tryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkContentElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'élément est supprimé d'une arborescence d'éléments chargés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés. Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkContentElement.UnloadedEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkContentElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l’événement <see cref="E:System.Windows.FrameworkContentElement.Unloaded" /> [Vue d’ensemble des événements routés](~/docs/framework/wpf/advanced/routed-events-overview.md).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Objets identificateur d’événement sont créés lorsque des événements routés sont enregistrés (consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>) et peuvent ensuite être utilisées pour ajouter des gestionnaires de classe (voir <xref:System.Windows.EventManager.RegisterClassHandler%2A>). Objets de l’identificateur contient un nom identifiant le type de propriétaire, type de gestionnaire, stratégie de routage et une méthode utilitaire pour ajouter des propriétaires à l’événement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkContentElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la paire nom-objet à supprimer de la portée actuelle.</param>
        <summary>Simplifie l'accès à la méthode de désinscription <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez seulement désinscrire les noms si vous avez l’intention de réinscrire un autre élément portant ce nom même.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkContentElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réapplique le style par défaut au <see cref="T:System.Windows.FrameworkContentElement" /> actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>