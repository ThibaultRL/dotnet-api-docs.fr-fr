<Type Name="VisualStateManager" FullName="System.Windows.VisualStateManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="eaaf54ec86ecccd1fcac9d888cb6ecf44cd10fd6" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57939349" /></Metadata><TypeSignature Language="C#" Value="public class VisualStateManager : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit VisualStateManager extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.VisualStateManager" />
  <TypeSignature Language="VB.NET" Value="Public Class VisualStateManager&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class VisualStateManager : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type VisualStateManager = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gère les états et la logique de transition entre les états des contrôles.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.VisualStateManager> vous permet de spécifier des États pour un contrôle, l’apparence d’un contrôle lorsqu’il est dans un certain état, et lorsqu’un contrôle change d’état. Par exemple, un <xref:System.Windows.Controls.Button> peut avoir une apparence légèrement différente que l’utilisateur appuie ou il n’est pas enfoncée. Deux états définis par le <xref:System.Windows.Controls.Button> définit correspondent aux lorsqu’elle est activée (`"Pressed"`) et quand il n’est pas (`"Normal"`). L’apparence d’un contrôle lorsqu’il est dans un état est défini par un <xref:System.Windows.VisualState>. Un <xref:System.Windows.VisualState> contient une collection de <xref:System.Windows.Media.Animation.Storyboard> objets qui spécifient comment l’apparence du contrôle change lorsque le contrôle est dans cet état. Vous ajoutez des états visuels à un contrôle en définissant le `VisualStateManager.VisualStateGroups` propriété jointe sur le contrôle. Chaque <xref:System.Windows.VisualStateGroup> contient une collection de <xref:System.Windows.VisualState> les objets qui s’excluent mutuellement. Autrement dit, le contrôle est toujours exactement un état de chaque <xref:System.Windows.VisualStateGroup>.  
  
 Le <xref:System.Windows.VisualStateManager> vous permet également de spécifier quand un contrôle entre dans un état spécifique. La méthode que vous devez appeler pour modifier des États dépend de votre scénario. Si vous créez un contrôle qui utilise le <xref:System.Windows.VisualStateManager> dans son <xref:System.Windows.Controls.ControlTemplate>, appelez le <xref:System.Windows.VisualStateManager.GoToState%2A> (méthode). Pour plus d’informations sur la création de contrôles qui utilisent la <xref:System.Windows.VisualStateManager>, consultez [création d’un contrôle qui a une apparence personnalisable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md). Si vous utilisez le <xref:System.Windows.VisualStateManager> en dehors d’un <xref:System.Windows.Controls.ControlTemplate> (par exemple, si vous utilisez un <xref:System.Windows.VisualStateManager> dans un <xref:System.Windows.Controls.UserControl> ou dans un seul élément), appelez le <xref:System.Windows.VisualStateManager.GoToElementState%2A> (méthode). Dans les deux cas, le <xref:System.Windows.VisualStateManager> exécute la logique nécessaire pour démarrer et arrêter les plans conceptuels qui sont associés à l’état impliqué convenablement. Par exemple, supposez qu’un contrôle définit les États, `State1` et `State2`, dont chacune dispose d’une table de montage séquentiel associé. Si le contrôle est en `State1` et que vous passez `State2` à <xref:System.Windows.VisualStateManager.GoToState%2A> ou <xref:System.Windows.VisualStateManager.GoToElementState%2A>, le <xref:System.Windows.VisualStateManager> démarre l’animation dans `State2` et arrête le storyboard dans `State1`.  
  
 Les contrôles qui sont inclus avec [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] utiliser le <xref:System.Windows.VisualStateManager> pour modifier les états visuels. Lorsque vous créez un <xref:System.Windows.Controls.ControlTemplate> pour un contrôle qui est inclus avec [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], vous pouvez ajouter <xref:System.Windows.VisualState> objets pour le contrôle <xref:System.Windows.Controls.ControlTemplate> pour spécifier l’apparence du contrôle dans un état particulier. Pour rechercher les noms des états visuels pour les contrôles qui sont inclus avec [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], consultez [Styles et modèles Control](~/docs/framework/wpf/controls/control-styles-and-templates.md). Gère la logique du contrôle en cours de transition entre les États, donc il vous suffit de définir la <xref:System.Windows.VisualState> objets dans le nouveau <xref:System.Windows.Controls.ControlTemplate>. Pour plus d’informations sur la création de modèles de contrôle pour les contrôles existants, consultez [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
 Si vous souhaitez implémenter votre propre logique pour la transition entre les États, vous devez hériter <xref:System.Windows.VisualStateManager>, remplacer le <xref:System.Windows.VisualStateManager.GoToStateCore%2A> (méthode) et définissez le <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A?displayProperty=nameWithType> propriété jointe sur le contrôle qui utilise la logique personnalisée.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Shapes.Rectangle> et ajoute un <xref:System.Windows.VisualStateGroup> nommé `CommonStates` à la `VisualStateManager.VisualStatesGroups` propriété jointe. L’exemple définit le `MouseOver` et `Normal` <xref:System.Windows.VisualState> des objets dans le `CommonStates` <xref:System.Windows.VisualStateGroup>. Lorsque l’utilisateur déplace le pointeur de la souris sur le <xref:System.Windows.Shapes.Rectangle>, celui-ci passe du rouge au vert en une demi-seconde. Lorsque l’utilisateur déplace la souris du rectangle, le <xref:System.Windows.Controls.Grid> immédiatement les modifications au rouge. Notez que le `Normal` état ne définit pas un <xref:System.Windows.Media.Animation.Storyboard>. A <xref:System.Windows.Media.Animation.Storyboard> n’est pas nécessaire, car lorsque le <xref:System.Windows.Shapes.Rectangle> passe à partir de la `MouseOver` l’état le `Normal` état, le <xref:System.Windows.Media.Animation.Storyboard> pour `MouseOver` est arrêté et le <xref:System.Windows.Media.SolidColorBrush.Color%2A> propriété pour le <xref:System.Windows.Media.SolidColorBrush> retourne rouge.  
  
 [!code-xaml[VSMCustomControl#VSMNoTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml#vsmnotemplate)]  
  
 L’exemple suivant montre le Gestionnaire d’événements qui est défini dans l’exemple précédent et appelle le <xref:System.Windows.VisualStateManager.GoToElementState%2A> méthode pour effectuer la transition entre États. Si le rectangle dans l’exemple précédent faisait partie d’un <xref:System.Windows.Controls.ControlTemplate>, l’exemple aurait appeler le <xref:System.Windows.VisualStateManager.GoToState%2A> (méthode).  
  
 [!code-csharp[VSMCustomControl#GoToElementState](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/window1.xaml.cs#gotoelementstate)]
 [!code-vb[VSMCustomControl#GoToElementState](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/window1.xaml.vb#gotoelementstate)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public VisualStateManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; VisualStateManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.VisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManager">
      <MemberSignature Language="C#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="ILAsm" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.CustomVisualStateManager" />
      <MemberSignature Language="VB.NET" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberSignature Language="F#" Value="see GetCustomVisualStateManager, and SetCustomVisualStateManager" Usage="see GetCustomVisualStateManager, and SetCustomVisualStateManager" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient ou définit l'objet <see cref="T:System.Windows.VisualStateManager" /> qui effectue la transition entre les états d'un contrôle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> est `null`, le <xref:System.Windows.VisualStateManager> utilise sa propre logique pour la transition entre États. Si vous souhaitez implémenter votre propre logique pour la transition entre les États, créez une classe qui hérite de <xref:System.Windows.VisualStateManager> et remplacer le <xref:System.Windows.VisualStateManager.GoToStateCore%2A> (méthode). Pour utiliser la classe personnalisée, définissez le <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> propriété à un objet de votre type personnalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomVisualStateManagerProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomVisualStateManagerProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomVisualStateManagerProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomVisualStateManagerProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomVisualStateManagerProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomVisualStateManagerProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.CustomVisualStateManagerProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static System.Windows.VisualStateManager GetCustomVisualStateManager (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.VisualStateManager GetCustomVisualStateManager(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetCustomVisualStateManager(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCustomVisualStateManager (obj As FrameworkElement) As VisualStateManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::VisualStateManager ^ GetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetCustomVisualStateManager : System.Windows.FrameworkElement -&gt; System.Windows.VisualStateManager" Usage="System.Windows.VisualStateManager.GetCustomVisualStateManager obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VisualStateManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Élément à partir duquel obtenir la propriété jointe <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</param>
        <summary>Obtient la propriété jointe <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <returns>Gestionnaire d'état visuel qui effectue la transition entre les états d'un contrôle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualStateGroups">
      <MemberSignature Language="C#" Value="public static System.Collections.IList GetVisualStateGroups (System.Windows.FrameworkElement obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IList GetVisualStateGroups(class System.Windows.FrameworkElement obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GetVisualStateGroups(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetVisualStateGroups (obj As FrameworkElement) As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IList ^ GetVisualStateGroups(System::Windows::FrameworkElement ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetVisualStateGroups : System.Windows.FrameworkElement -&gt; System.Collections.IList" Usage="System.Windows.VisualStateManager.GetVisualStateGroups obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="obj">Élément à partir duquel obtenir la propriété jointe <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</param>
        <summary>Obtient la propriété jointe <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <returns>Collection d'objets <see cref="T:System.Windows.VisualStateGroup" /> associée à l'objet spécifié.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GoToElementState">
      <MemberSignature Language="C#" Value="public static bool GoToElementState (System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToElementState(class System.Windows.FrameworkElement stateGroupsRoot, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToElementState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToElementState (stateGroupsRoot As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToElementState(System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToElementState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToElementState (stateGroupsRoot, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stateGroupsRoot">Élément racine qui contient l'objet <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">État vers lequel effectuer la transition.</param>
        <param name="useTransitions"><see langword="true" /> pour utiliser un objet <see cref="T:System.Windows.VisualTransition" /> visant à effectuer une transition entre les états ; sinon, <see langword="false" />.</param>
        <summary>Assure la transition de l'élément entre deux états. Utilisez cette méthode pour le changement d'états défini par une application, plutôt qu'un contrôle.</summary>
        <returns><see langword="true" /> si le contrôle a basculé avec succès vers le nouvel état ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.VisualStateManager.GoToElementState%2A> méthode pour modifier les États sur un élément en dehors d’un <xref:System.Windows.Controls.ControlTemplate> (par exemple, si vous utilisez un <xref:System.Windows.VisualStateManager> dans un <xref:System.Windows.DataTemplate> ou <xref:System.Windows.Window>). Appelez le <xref:System.Windows.VisualStateManager.GoToState%2A> méthode si vous changez les États dans un contrôle qui utilise le <xref:System.Windows.VisualStateManager> dans son <xref:System.Windows.Controls.ControlTemplate>.  
  
   
  
## Examples  
 L’exemple suivant crée une application qui invite l’utilisateur à deviner un nombre compris entre 1 et 100.  Lorsque l’utilisateur entre un nombre, l’application indique si l’estimation est correcte, trop faible ou trop élevée.  Ce qui suit [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] crée l’interface utilisateur pour l’application et définit 4 états : `TooLow`, `TooHigh`, `Correct`, et `Guessing`. Lorsque l’application démarre, il est dans le `Guessing` état. .  
  
 [!code-xaml[VSMGoToElementState#GoToElementStateXaml](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml#gotoelementstatexaml)]  
  
 Le code suivant illustre la logique de l’application.  Lorsque l’utilisateur entre un nombre et clique sur le bouton, l’application appelle <xref:System.Windows.VisualStateManager.GoToElementState%2A> à passer à `TooHigh`, `TooLow`, ou `Correct` pour fournir des commentaires à l’utilisateur sur l’estimation.  Pour tester cet exemple, appelez le `GenerateNumber` méthode lorsque l’application commence.  
  
 [!code-csharp[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmgotoelementstate/csharp/mainwindow.xaml.cs#gotoelementstatecode)]
 [!code-vb[VSMGoToElementState#GoToElementStateCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmgotoelementstate/visualbasic/mainwindow.xaml.vb#gotoelementstatecode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="stateName" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToState">
      <MemberSignature Language="C#" Value="public static bool GoToState (System.Windows.FrameworkElement control, string stateName, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GoToState(class System.Windows.FrameworkElement control, string stateName, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToState(System.Windows.FrameworkElement,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GoToState (control As FrameworkElement, stateName As String, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool GoToState(System::Windows::FrameworkElement ^ control, System::String ^ stateName, bool useTransitions);" />
      <MemberSignature Language="F#" Value="static member GoToState : System.Windows.FrameworkElement * string * bool -&gt; bool" Usage="System.Windows.VisualStateManager.GoToState (control, stateName, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle à passer d'un état à l'autre.</param>
        <param name="stateName">État vers lequel effectuer la transition.</param>
        <param name="useTransitions"><see langword="true" /> pour utiliser un objet <see cref="T:System.Windows.VisualTransition" /> visant à effectuer une transition entre les états ; sinon, <see langword="false" />.</param>
        <summary>Fait passer le contrôle d'un état à un autre. Utilisez cette méthode pour le changement d'état sur un contrôle qui a un <see cref="T:System.Windows.Controls.ControlTemplate" />.</summary>
        <returns><see langword="true" /> si le contrôle a basculé avec succès vers le nouvel état ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez le <xref:System.Windows.VisualStateManager.GoToState%2A> méthode si vous changez les États dans un contrôle qui utilise le <xref:System.Windows.VisualStateManager> dans son <xref:System.Windows.Controls.ControlTemplate>. Appelez le <xref:System.Windows.VisualStateManager.GoToElementState%2A> méthode pour modifier les États sur un élément en dehors d’un <xref:System.Windows.Controls.ControlTemplate> (par exemple, si vous utilisez un <xref:System.Windows.VisualStateManager> dans un <xref:System.Windows.Controls.UserControl> ou dans un seul élément).  
  
   
  
## Examples  
 L’exemple suivant illustre un contrôle qui utilise le <xref:System.Windows.VisualStateManager.GoToState%2A> méthode pour effectuer la transition entre États. Pour l’exemple complet, consultez [création d’un contrôle qu’a une apparence personnalisable](~/docs/framework/wpf/controls/creating-a-control-that-has-a-customizable-appearance.md).  
  
 [!code-csharp[VSMCustomControl#UpdateStates](~/samples/snippets/csharp/VS_Snippets_Wpf/vsmcustomcontrol/csharp/numericupdown.cs#updatestates)]
 [!code-vb[VSMCustomControl#UpdateStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/vsmcustomcontrol/visualbasic/numericupdown.vb#updatestates)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="stateName" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GoToStateCore">
      <MemberSignature Language="C#" Value="protected virtual bool GoToStateCore (System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot, string stateName, System.Windows.VisualStateGroup group, System.Windows.VisualState state, bool useTransitions);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GoToStateCore(class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot, string stateName, class System.Windows.VisualStateGroup group, class System.Windows.VisualState state, bool useTransitions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.GoToStateCore(System.Windows.FrameworkElement,System.Windows.FrameworkElement,System.String,System.Windows.VisualStateGroup,System.Windows.VisualState,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GoToStateCore (control As FrameworkElement, stateGroupsRoot As FrameworkElement, stateName As String, group As VisualStateGroup, state As VisualState, useTransitions As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool GoToStateCore(System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot, System::String ^ stateName, System::Windows::VisualStateGroup ^ group, System::Windows::VisualState ^ state, bool useTransitions);" />
      <MemberSignature Language="F#" Value="abstract member GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool&#xA;override this.GoToStateCore : System.Windows.FrameworkElement * System.Windows.FrameworkElement * string * System.Windows.VisualStateGroup * System.Windows.VisualState * bool -&gt; bool" Usage="visualStateManager.GoToStateCore (control, stateGroupsRoot, stateName, group, state, useTransitions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateName" Type="System.String" />
        <Parameter Name="group" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="state" Type="System.Windows.VisualState" />
        <Parameter Name="useTransitions" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="control">Contrôle à passer d'un état à l'autre.</param>
        <param name="stateGroupsRoot">Élément racine qui contient l'objet <see cref="T:System.Windows.VisualStateManager" />.</param>
        <param name="stateName">Nom du nouvel état vers lequel effectuer la transition.</param>
        <param name="group"><see cref="T:System.Windows.VisualStateGroup" /> auquel appartient l'état.</param>
        <param name="state">La représentation de l'état vers lequel effectuer la transition.</param>
        <param name="useTransitions"><see langword="true" /> pour utiliser un objet <see cref="T:System.Windows.VisualTransition" /> visant à effectuer une transition entre les états ; sinon, <see langword="false" />.</param>
        <summary>Effectue la transition d'un contrôle entre états.</summary>
        <returns><see langword="true" /> si le contrôle a basculé avec succès vers le nouvel état ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.VisualStateManager.GoToStateCore%2A> méthode exécute la logique nécessaire pour démarrer et arrêter les plans conceptuels qui sont associés à une transition convenablement. Lorsqu’un contrôle appelle <xref:System.Windows.VisualStateManager.GoToState%2A> pour modifier son état, le <xref:System.Windows.VisualStateManager> effectue les opérations suivantes :  
  
-   Premier, si le <xref:System.Windows.VisualState> que le contrôle est en cours de transition a un <xref:System.Windows.Media.Animation.Storyboard>, l’animation commence. Ensuite, si le <xref:System.Windows.VisualState> que le contrôle provient a un <xref:System.Windows.Media.Animation.Storyboard>, les extrémités de la table de montage séquentiel.  
  
-   Si le contrôle se trouve déjà dans le `stateName` état, <xref:System.Windows.VisualStateManager.GoToState%2A> n’effectue aucune action et retourne `true`.  
  
-   Si `stateName` n’existe pas dans le <xref:System.Windows.Controls.ControlTemplate> de `control`, <xref:System.Windows.VisualStateManager.GoToState%2A> n’effectue aucune action et retourne `false`.  
  
 Vous pouvez implémenter votre propre <xref:System.Windows.VisualStateManager> pour fournir une logique différente pour la transition entre États. Par exemple, vous pouvez modifier la logique décrite précédemment, ou vous pouvez fournir la logique pour la transition entre les types d’animations personnalisées.  Pour implémenter un <xref:System.Windows.VisualStateManager>, créez une classe qui hérite de <xref:System.Windows.VisualStateManager> et remplacer le <xref:System.Windows.VisualStateManager.GoToStateCore%2A> (méthode). Pour utiliser la classe personnalisée, définissez le <xref:System.Windows.VisualStateManager.CustomVisualStateManager%2A> propriété à un objet de votre type personnalisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanged">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanged (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanged(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanged (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanged(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanged : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanged (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objet sur lequel s'est produit l'événement <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">État depuis lequel le contrôle effectue la transition.</param>
        <param name="newState">État vers lequel le contrôle effectue la transition.</param>
        <param name="control">Contrôle qui effectue la transition entre les états.</param>
        <param name="stateGroupsRoot">Élément racine qui contient l'objet <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> sur l'objet <see cref="T:System.Windows.VisualStateGroup" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.VisualStateGroup> est défini sur le <xref:System.Windows.Controls.ControlTemplate> d’un contrôle, le `control` paramètre est défini sur le contrôle auquel appartient <xref:System.Windows.Controls.ControlTemplate>.  Lorsque le <xref:System.Windows.VisualStateGroup> est définie sur une <xref:System.Windows.FrameworkElement>, `control` est `null` et vous devez utiliser le `stateGroupsRoot` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="newState" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanged(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="RaiseCurrentStateChanging">
      <MemberSignature Language="C#" Value="protected void RaiseCurrentStateChanging (System.Windows.VisualStateGroup stateGroup, System.Windows.VisualState oldState, System.Windows.VisualState newState, System.Windows.FrameworkElement control, System.Windows.FrameworkElement stateGroupsRoot);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseCurrentStateChanging(class System.Windows.VisualStateGroup stateGroup, class System.Windows.VisualState oldState, class System.Windows.VisualState newState, class System.Windows.FrameworkElement control, class System.Windows.FrameworkElement stateGroupsRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseCurrentStateChanging (stateGroup As VisualStateGroup, oldState As VisualState, newState As VisualState, control As FrameworkElement, stateGroupsRoot As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseCurrentStateChanging(System::Windows::VisualStateGroup ^ stateGroup, System::Windows::VisualState ^ oldState, System::Windows::VisualState ^ newState, System::Windows::FrameworkElement ^ control, System::Windows::FrameworkElement ^ stateGroupsRoot);" />
      <MemberSignature Language="F#" Value="member this.RaiseCurrentStateChanging : System.Windows.VisualStateGroup * System.Windows.VisualState * System.Windows.VisualState * System.Windows.FrameworkElement * System.Windows.FrameworkElement -&gt; unit" Usage="visualStateManager.RaiseCurrentStateChanging (stateGroup, oldState, newState, control, stateGroupsRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateGroup" Type="System.Windows.VisualStateGroup" />
        <Parameter Name="oldState" Type="System.Windows.VisualState" />
        <Parameter Name="newState" Type="System.Windows.VisualState" />
        <Parameter Name="control" Type="System.Windows.FrameworkElement" />
        <Parameter Name="stateGroupsRoot" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="stateGroup">Objet sur lequel s'est produit l'événement <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" />.</param>
        <param name="oldState">État depuis lequel le contrôle effectue la transition.</param>
        <param name="newState">État vers lequel le contrôle effectue la transition.</param>
        <param name="control">Contrôle qui effectue la transition entre les états.</param>
        <param name="stateGroupsRoot">Élément racine qui contient l'objet <see cref="T:System.Windows.VisualStateManager" />.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.VisualStateGroup.CurrentStateChanging" /> sur l'objet <see cref="T:System.Windows.VisualStateGroup" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.VisualStateGroup> est défini sur le <xref:System.Windows.Controls.ControlTemplate> d’un contrôle, le `control` paramètre est défini sur le contrôle auquel appartient <xref:System.Windows.Controls.ControlTemplate>.  Lorsque le <xref:System.Windows.VisualStateGroup> est définie sur une <xref:System.Windows.FrameworkElement>, `control` est `null` et vous devez utiliser le `stateGroupsRoot` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stateGroupsRoot" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="newState" /> est <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>Lors de la substitution <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> dans une classe dérivée, veillez à appeler la classe de base <see cref="M:System.Windows.VisualStateManager.RaiseCurrentStateChanging(System.Windows.VisualStateGroup,System.Windows.VisualState,System.Windows.VisualState,System.Windows.FrameworkElement,System.Windows.FrameworkElement)" /> méthode afin que les délégués inscrits reçoivent l’événement.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetCustomVisualStateManager">
      <MemberSignature Language="C#" Value="public static void SetCustomVisualStateManager (System.Windows.FrameworkElement obj, System.Windows.VisualStateManager value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCustomVisualStateManager(class System.Windows.FrameworkElement obj, class System.Windows.VisualStateManager value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.VisualStateManager.SetCustomVisualStateManager(System.Windows.FrameworkElement,System.Windows.VisualStateManager)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCustomVisualStateManager (obj As FrameworkElement, value As VisualStateManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCustomVisualStateManager(System::Windows::FrameworkElement ^ obj, System::Windows::VisualStateManager ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCustomVisualStateManager : System.Windows.FrameworkElement * System.Windows.VisualStateManager -&gt; unit" Usage="System.Windows.VisualStateManager.SetCustomVisualStateManager (obj, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Windows.FrameworkElement" />
        <Parameter Name="value" Type="System.Windows.VisualStateManager" />
      </Parameters>
      <Docs>
        <param name="obj">Objet sur lequel la propriété doit être définie.</param>
        <param name="value">Gestionnaire d'état visuel qui effectue la transition entre les états d'un contrôle.</param>
        <summary>Définit la propriété jointe <see cref="P:System.Windows.VisualStateManager.CustomVisualStateManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroups">
      <MemberSignature Language="C#" Value="see GetVisualStateGroups" />
      <MemberSignature Language="ILAsm" Value="see GetVisualStateGroups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.VisualStateManager.VisualStateGroups" />
      <MemberSignature Language="VB.NET" Value="see GetVisualStateGroups" />
      <MemberSignature Language="F#" Value="see GetVisualStateGroups" Usage="see GetVisualStateGroups" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStateGroupsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisualStateGroupsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisualStateGroupsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisualStateGroupsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisualStateGroupsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisualStateGroupsProperty : System.Windows.DependencyProperty" Usage="System.Windows.VisualStateManager.VisualStateGroupsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.VisualStateManager.VisualStateGroups" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>