<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a06289148efbd4e1466e223308d59b98e5550843" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66008516" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type FrameworkElement = class&#xA;    inherit UIElement&#xA;    interface IFrameworkInputElement&#xA;    interface IInputElement&#xA;    interface ISupportInitialize&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit un jeu de niveau infrastructure WPF de propriétés, d’événements et de méthodes pour les éléments WPF (Windows Presentation Foundation). Cette classe représente l’implémentation de niveau infrastructure WPF fournie qui repose sur les API de niveau noyau WPF définies par <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> est le point de connexion entre les classes d’élément de niveau infrastructure WPF et le jeu au niveau du noyau WPF de <xref:System.Windows.UIElement> services de présentation. Pour plus d’informations sur ces concepts, consultez [WPF Architecture](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> étend <xref:System.Windows.UIElement> et ajoute les fonctionnalités suivantes :  
  
-   **Définition de système de disposition**: <xref:System.Windows.FrameworkElement> fournit des implémentations spécifiques de niveau infrastructure WPF pour certaines méthodes qui ont été définies en tant que membres virtuels dans <xref:System.Windows.UIElement>. Plus particulièrement, <xref:System.Windows.FrameworkElement> scelle certaines substitutions de disposition de niveau noyau WPF et fournit à la place un équivalent de niveau infrastructure WPF que les classes dérivées doit substituer à la place. Par exemple, <xref:System.Windows.FrameworkElement> scellés <xref:System.Windows.UIElement.ArrangeCore%2A> mais fournit <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Ces modifications reflètent le fait qu’à l’infrastructure WPF est un système de disposition complète en place qui peut restituer les <xref:System.Windows.FrameworkElement> classe dérivée. À WPF de base au niveau, certains membres qui seront structure générale [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] une disposition basée sur solution sont en place, mais le moteur réel du système de disposition n’est pas défini. Pour plus d’informations, consultez [Disposition](~/docs/framework/wpf/advanced/layout.md).  
  
-   **L’arborescence logique :** Le général [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] modèle de programmation est souvent exprimé en termes d’en cours d’une arborescence d’éléments. Prise en charge pour exprimer l’arborescence d’éléments sous forme d’arborescence logique et qui accompagne prise en charge pour la définition de cette arborescence dans le balisage est implémentée à le <xref:System.Windows.FrameworkElement> niveau. Notez toutefois que <xref:System.Windows.FrameworkElement> délibérément ne définit pas un modèle de contenu et laisse cette responsabilité aux classes dérivées. Pour plus d’informations, consultez [Arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Événements de durée de vie d’objet :** Il est souvent utile de savoir quand un élément est initialisé (le constructeur est appelé) ou lorsque l’élément est tout d’abord chargé dans une arborescence logique. <xref:System.Windows.FrameworkElement> définit plusieurs événements liés à la durée de vie des objets qui fournissent des raccordements utiles pour les opérations de code-behind qui impliquent des éléments, telles que l’ajout des éléments enfants. Pour plus d’informations, consultez [événements de durée de vie d’objet](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Prise en charge de liaison de données et les références de ressources dynamiques :** La prise en charge au niveau de la propriété pour la liaison de données et des ressources est implémentée par le <xref:System.Windows.DependencyProperty> quant à dans le système de propriétés, mais la capacité à résoudre une valeur de membre qui est stockée comme un <xref:System.Windows.Expression> (la construction de programmation qui se trouve sous les deux liaison de données et ressources dynamiques) est implémentée par <xref:System.Windows.FrameworkElement>. Pour plus d’informations, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md) et [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Styles :** <xref:System.Windows.FrameworkElement> définit le <xref:System.Windows.FrameworkElement.Style%2A> propriété. Toutefois, <xref:System.Windows.FrameworkElement> ne pas encore définir la prise en charge des modèles, ou prennent en charge les éléments décoratifs. Ces fonctionnalités sont introduites par des classes de contrôle telles que <xref:System.Windows.Controls.Control> et <xref:System.Windows.Controls.ContentControl>.  
  
-   **Plus prise en charge de l’animation :** Une prise en charge de l’animation a déjà été défini au niveau du noyau WPF, mais <xref:System.Windows.FrameworkElement> développe ceci en implémentant <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> et les membres.  
  
 Comme illustré dans la hiérarchie de classes, nombreux [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] classes dérivent <xref:System.Windows.FrameworkElement>, directement ou via les classes de base intermédiaires comme <xref:System.Windows.Controls.Panel> ou <xref:System.Windows.Controls.Control>.  
  
 Si vous prévoyez d’utiliser <xref:System.Windows.FrameworkElement> comme classe de base, vous souhaiterez peut-être tout d’abord examiner les classes dérivées existantes. <xref:System.Windows.FrameworkElement> prend en charge un nombre de scénarios de base, mais ne dispose pas d’un certain nombre de fonctionnalités qui sont souhaitables pour un « élément » dans le sens d’un bloc de construction qui vous permet de créer également [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Par exemple, un <xref:System.Windows.FrameworkElement> ne définit pas de n’importe quel modèle de contenu true ; <xref:System.Windows.FrameworkElement> comme une classe de base ne définit pas une propriété qui peut créer [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] éléments enfants. En particulier, vous souhaiterez peut-être examiner <xref:System.Windows.Controls.Control> et <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualHeight : double" Usage="System.Windows.FrameworkElement.ActualHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la hauteur rendue de cet élément.</summary>
        <value>Hauteur de l'élément, exprimée en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est 0 (zéro).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est une valeur calculée basée sur les autres entrées de hauteur et le système de disposition. La valeur est définie par le système de disposition lui-même, selon une passe de rendu et peut donc rester légèrement derrière la valeur définie des propriétés telles que <xref:System.Windows.FrameworkElement.Height%2A> qui constituent la base de la modification d’entrée.  
  
 Étant donné que <xref:System.Windows.FrameworkElement.ActualHeight%2A> est une valeur calculée, vous devez être conscient qu’il peut y avoir plusieurs ou incrémentielles signalées modifications à la suite de diverses opérations par le système de disposition. Celui-ci peut en effet calculer l’espace de mesure requis pour les éléments enfants, les contraintes de l’élément parent, et ainsi de suite.  
  
 Bien que vous ne pouvez pas définir cette propriété à partir de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], vous pouvez baser un <xref:System.Windows.Trigger> sur sa valeur dans un style.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant affiche les différentes propriétés de hauteur.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.ActualHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberSignature Language="F#" Value="member this.ActualWidth : double" Usage="System.Windows.FrameworkElement.ActualWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la largeur rendue de cet élément.</summary>
        <value>Largeur de l'élément, exprimée en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est 0 (zéro).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est une valeur calculée basée sur les autres entrées de la largeur et le système de disposition. La valeur est définie par le système de disposition lui-même, selon une passe de rendu et peut donc rester légèrement derrière la valeur définie des propriétés telles que <xref:System.Windows.FrameworkElement.Width%2A> qui constituent la base de la modification d’entrée.  
  
 Étant donné que <xref:System.Windows.FrameworkElement.ActualWidth%2A> est une valeur calculée, vous devez être conscient qu’il peut y avoir plusieurs ou incrémentielles signalées modifications à la suite de diverses opérations par le système de disposition. Celui-ci peut en effet calculer l’espace de mesure requis pour les éléments enfants, les contraintes de l’élément parent, et ainsi de suite.  
  
 Bien que vous ne pouvez pas définir cette propriété à partir de [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], vous pouvez baser un <xref:System.Windows.Trigger> sur sa valeur dans un style.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant affiche les différentes propriétés de la largeur.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ActualWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.ActualWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddLogicalChild : obj -&gt; unit" Usage="frameworkElement.AddLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Élément enfant à ajouter.</param>
        <summary>Ajoute l'objet fourni à l'arborescence logique de cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour l’implémentation de collections sur les objets qui représentent les éléments enfants logiques d’un élément. La maintenance des collections d’éléments enfants peut-être être effectuée dans les accesseurs Get ou les accesseurs Set, gestion des événements Changed, constructeurs, ou dans les types de collections eux-mêmes de classe.  
  
 Pour les auteurs de contrôle, la manipulation de l’arborescence logique à ce niveau n’est pas recommandé, sauf si aucun des modèles de contenu pour les classes de contrôle de base disponibles sont adaptées à votre scénario de contrôle. Considérez le sous-classement au niveau de <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, et <xref:System.Windows.Controls.HeaderedItemsControl>. Ces classes fournissent un modèle de contenu avec la mise en œuvre spécifique d’éléments enfants d’arborescence logique via dédié [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], ainsi que la prise en charge d’autres fonctionnalités généralement souhaitables dans un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] contrôle comme style via des modèles. Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> peut de lever une exception si elle est appelée à la fois lorsque l’arborescence logique est itérée par un autre processus.  
  
   
  
## Examples  
 L’exemple suivant implémente un `Child` propriété sur personnalisé <xref:System.Windows.FrameworkElement> qui effectue sa propre implémentation de la couche visuelle. L’accesseur Set de propriété est conçue afin que si la valeur change, l’ancienne valeur est supprimée à partir de l’arborescence logique, ainsi que d’une collection visuelle spécifique à la classe. La valeur de propriété est mis en cache, et ensuite la nouvelle valeur est ajoutée à l’arborescence logique et la collection visuelle personnalisée.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberSignature Language="F#" Value="member this.ApplyTemplate : unit -&gt; bool" Usage="frameworkElement.ApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Génère, si nécessaire, l’arborescence d’éléments visuels du modèle actuel et retourne une valeur qui indique si l’arborescence d’éléments visuels a été régénérée par cet appel.</summary>
        <returns><see langword="true" /> si des éléments visuels ont été ajoutés à l’arborescence ; retourne <see langword="false" /> dans le cas contraire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applications peuvent appeler cette méthode pour garantir que l’arborescence visuelle d’un élément est terminée. Cette étape de garantie peut être nécessaire si le code est chargé de vérifier les éléments enfants dans l’arborescence. Pour la logique habituelle dans les applications appelant <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> n’est pas nécessaire, étant donné que les modèles seront appliqués automatiquement aux éléments à un point approprié dans leur durée de vie.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> est appelée sur toutes les mesures de passer par le système de disposition de niveau framework WPF.  
  
 <xref:System.Windows.FrameworkElement> les classes dérivées peuvent utiliser le <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> Gestionnaire de classe pour être informé des cas où cette méthode a été appelée explicitement, ou par le système de disposition. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> est appelé une fois le modèle est complètement généré et attaché à l’arborescence logique.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="frameworkElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Dernière zone dans le parent que cet élément doit utiliser pour se réorganiser et réorganiser ses enfants.</param>
        <summary>Implémente <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (défini comme virtuel dans <see cref="T:System.Windows.UIElement" />) et scelle l'implémentation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est sealed. Pour substituer le code dans votre élément personnalisé spécifiquement pour la réorganisation de la disposition des éléments, votre <xref:System.Windows.FrameworkElement> classe dérivée doit substituer <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.ArrangeOverride finalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Dernière zone dans le parent que cet élément doit utiliser pour se réorganiser et réorganiser ses enfants.</param>
        <summary>En cas de substitution dans une classe dérivée, positionne les éléments enfants et détermine la taille d’une classe dérivée <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Taille réelle utilisée.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Les auteurs de contrôles qui souhaitent personnaliser la passe de réorganisation du traitement de disposition doivent remplacer cette méthode. Le modèle d’implémentation doit appeler <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> sur chaque élément enfant visible, puis transmettez la taille pour chaque élément enfant en tant que désirée finale la <paramref name="finalRect" /> paramètre. Éléments parents doivent appeler <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> sur chaque enfant, sinon les ne seront pas rendu des éléments enfants.  
  
De nombreuses classes dérivées offrent des implémentations de cette méthode. Remarquables sont : <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> et <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para></block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="frameworkElement.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre le processus d'initialisation pour cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous ajustez les de manière à ne pas encore exposer ou l’élément à l’arborescence d’éléments, vous pouvez appeler cette méthode pour des éléments individuels. Par exemple, vous avez peut-être créé un nouveau <xref:System.Windows.FrameworkElement>, mais le n'avez pas encore associé à aucune arborescence logique. Ou bien, l’arborescence logique où votre élément est un élément enfant qu’il contient ne peut pas être connecté à une fenêtre ou d’une page de l’application.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Implémentez cette méthode pour fournir une gestion spéciale qui doit se produire avant que votre élément est initialisé pendant le processus de chargement de l’élément.  
  
Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation. Une implémentation possible consiste à utiliser cette méthode comme un raccordement dans vos propres routines d’initialisation de classe privée qui ne sont pas déjà activées par les constructeurs.  
  
L’implémentation de base lève une exception si <see cref="M:System.Windows.FrameworkElement.BeginInit" /> est appelée plusieurs fois sur le même élément avant de <see cref="M:System.Windows.FrameworkElement.EndInit" /> qui est appelée.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lance la séquence d'actions contenues dans la table de montage séquentiel fournie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard -&gt; unit" Usage="frameworkElement.BeginStoryboard storyboard" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <summary>Commence la séquence d'actions contenues dans la table de montage séquentiel fournie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plus des scénarios d’animation n’utilisent pas cette méthode. En général, vous créez le <xref:System.Windows.Media.Animation.Storyboard> ou <xref:System.Windows.Media.Animation.BeginStoryboard> en tant qu’élément dans le balisage et placer le <xref:System.Windows.EventTrigger> contenu sur un élément. Lorsque déclenché par l’événement, puis l’animation s’exécute. La plupart des aspects de contrôle d’un <xref:System.Windows.Media.Animation.Storyboard> peuvent être adressés par les propriétés qui sont exposées dans le balisage.  
  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les horloges de chronologie sont associés à l’animation sont supprimées dès que l’animation atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir exécuté une seule fois. Contrôle d’une animation requiert également que la table de montage séquentiel ont un [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) ou soit accessible par référence dans le code.  
  
   
  
## Examples  
 L’exemple suivant récupère un <xref:System.Windows.Media.Animation.Storyboard> à partir de ressources, puis exécute <xref:System.Windows.Media.Animation.Storyboard> quand un événement interne est géré par classes.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <param name="handoffBehavior">Valeur de l'énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</param>
        <summary>Lance la séquence d'actions contenues dans la table de montage séquentiel fournie, les options précisant ce qui doit se produire si la propriété est déjà animée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plus des scénarios d’animation n’utilisent pas cette méthode. En général, vous créez le <xref:System.Windows.Media.Animation.Storyboard> ou <xref:System.Windows.Media.Animation.BeginStoryboard> en tant qu’élément dans le balisage et placer le <xref:System.Windows.EventTrigger> contenu sur un élément. Lorsque déclenché par l’événement, puis l’animation s’exécute. La plupart des aspects de contrôle d’un <xref:System.Windows.Media.Animation.Storyboard> peuvent être adressés par les propriétés qui sont exposées dans le balisage.  
  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les horloges de chronologie sont associés à l’animation sont supprimées dès que l’animation atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir exécuté une seule fois. Contrôle d’une animation requiert également que la table de montage séquentiel ont un [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) ou soit accessible par référence dans le code.  
  
 Comportement de transfert peut être spécifié en tant qu’attribut de <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas les horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs façons de supprimer une horloge :  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 L’exemple suivant récupère un <xref:System.Windows.Media.Animation.Storyboard> à partir de ressources, puis exécute <xref:System.Windows.Media.Animation.Storyboard> quand un événement interne est géré par classes.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.BeginStoryboard : System.Windows.Media.Animation.Storyboard * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="frameworkElement.BeginStoryboard (storyboard, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Table de montage séquentiel à lancer.</param>
        <param name="handoffBehavior">Valeur de l'énumération qui décrit le comportement à adopter si une propriété décrite dans la table de montage séquentiel est déjà animée.</param>
        <param name="isControllable">Déclare si l'animation est contrôlable (peut être suspendue) après avoir démarré.</param>
        <summary>Lance la séquence d'actions contenues dans la table de montage séquentiel fournie, avec un état spécifié pour le contrôle de l'animation après qu'elle ait démarré.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plus des scénarios d’animation n’utilisent pas cette méthode. En général, vous créez le <xref:System.Windows.Media.Animation.Storyboard> ou <xref:System.Windows.Media.Animation.BeginStoryboard> en tant qu’élément dans le balisage et placer le <xref:System.Windows.EventTrigger> contenu sur un élément. Lorsque déclenché par l’événement, puis l’animation s’exécute. La plupart des aspects de contrôle d’un <xref:System.Windows.Media.Animation.Storyboard> peuvent être adressés par les propriétés qui sont exposées dans le balisage.  
  
 Pour les signatures qui n’utilisent pas le `isControllable`, paramètre, ou lorsque ce paramètre est spécifié `false`, les horloges de chronologie sont associés à l’animation sont supprimées dès que l’animation atteint la période de « Remplissage ». Par conséquent, l’animation ne peut pas être redémarrée après avoir exécuté une seule fois. Contrôle d’une animation requiert également que la table de montage séquentiel ont un [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) ou soit accessible par référence dans le code.  
  
 Comportement de transfert peut être spécifié en tant qu’attribut de <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>À l’aide de la composition HandoffBehavior  
 Lorsque vous appliquez un <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> à une propriété à l’aide de la <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, n’importe quel <xref:System.Windows.Media.Animation.Clock> objets précédemment associés à cette propriété continuent de consommer des ressources système, contrairement au système de minutage supprime pas les horloges automatiquement.  
  
 Pour éviter les problèmes de performances lorsque vous appliquez un grand nombre d’horloges à l’aide de <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, vous devez supprimer la composition des horloges de la propriété animée lorsqu’elles ont terminé. Il existe plusieurs façons de supprimer une horloge :  
  
-   Pour supprimer toutes les horloges d’une propriété, utilisez le <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> méthode de l’objet animé. Spécifiez la propriété animée comme premier paramètre, et `null` en tant que la seconde. Cette opération supprime toutes les horloges d’animation à partir de la propriété.  
  
-   Pour supprimer un spécifique <xref:System.Windows.Media.Animation.AnimationClock> à partir d’une liste d’horloges, utilisez la <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété de la <xref:System.Windows.Media.Animation.AnimationClock> pour récupérer un <xref:System.Windows.Media.Animation.ClockController>, puis appelez le <xref:System.Windows.Media.Animation.ClockController.Remove%2A> méthode de la <xref:System.Windows.Media.Animation.ClockController>. Cela s’effectue généralement dans le <xref:System.Windows.Media.Animation.Clock.Completed> Gestionnaire d’événements pour une horloge. Notez que seules les horloges racine peuvent être contrôlées par un <xref:System.Windows.Media.Animation.ClockController>; le <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriété d’une horloge enfant retourne `null`. Notez également que le <xref:System.Windows.Media.Animation.Clock.Completed> événement n’est pas déclenché si la durée effective de l’horloge est illimitée.  Dans ce cas, l’utilisateur doit déterminer quand appeler <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Il s’agit principalement d’un problème pour les animations sur des objets qui ont une durée de vie longue.  Lorsqu’un objet est par le garbage collecté, ses horloges sont également déconnectées et récupérées.  
  
 Pour plus d’informations sur les objets clock, consultez [Animation et vue d’ensemble du système de minutage](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingGroup : System.Windows.Data.BindingGroup with get, set" Usage="System.Windows.FrameworkElement.BindingGroup" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</summary>
        <value><see cref="T:System.Windows.Data.BindingGroup" /> utilisé pour l'élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Data.BindingGroup> peut être utilisé pour valider les valeurs de plusieurs propriétés d’un objet. Par exemple, supposons qu’une application invite l’utilisateur à entrer une adresse et remplit ensuite un objet de type `Address`, qui a les propriétés `Street`, `City`, `ZipCode`, et `Country`, avec les valeurs que l’utilisateur fourni. L’application a un panneau qui contient quatre <xref:System.Windows.Controls.TextBox> contrôles, chacun d’eux est lié à une des propriétés de l’objet. Vous pouvez utiliser un <xref:System.Windows.Controls.ValidationRule> dans un <xref:System.Windows.Data.BindingGroup> pour valider le `Address` objet. Par exemple, le <xref:System.Windows.Controls.ValidationRule> pouvez vous assurer que le code postal est valide pour le pays de l’adresse.  
  
 Les éléments enfants héritent le <xref:System.Windows.Data.BindingGroup> à partir de leurs éléments parents, tout comme avec toute autre propriété pouvant être héritées.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Les exemples suivants font partie d’une application qui vérifie si l’utilisateur a défini les propriétés de deux objets de valeurs identiques. Le premier exemple crée deux <xref:System.Windows.Controls.TextBox> contrôles, chacun d’eux est lié à une autre source de données. Le <xref:System.Windows.Controls.StackPanel> a un <xref:System.Windows.Data.BindingGroup> qui contient un <xref:System.Windows.Controls.ValidationRule> qui vérifie que les deux chaînes sont égales.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 L’exemple suivant montre le <xref:System.Windows.Controls.ValidationRule> qui utilise l’exemple précédent.  Dans le <xref:System.Windows.Controls.ValidationRule.Validate%2A> substitution de méthode, l’exemple obtient chaque objet source à partir de la <xref:System.Windows.Data.BindingGroup> et vérifie si les propriétés des objets sont égale.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Pour appeler le <xref:System.Windows.Controls.ValidationRule>, appelez le <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> (méthode).  L’exemple suivant appelle <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> lorsque l’événement click du bouton se produit.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BindingGroupProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Essaie de mettre cet élément en vue, dans toutes régions déroulantes dans lesquelles il est contenu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : unit -&gt; unit" Usage="frameworkElement.BringIntoView " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Essaie de mettre cet élément en vue, dans toutes régions déroulantes dans lesquelles il est contenu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En appelant cette méthode, vous déclenchez un <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement provient de l’élément actuel. Cet événement est déclenché afin qu’elle puisse être gérée par un <xref:System.Windows.Controls.ScrollViewer>, ou une classe dérivée ou semblable. Le comportement attendu est que l’événement est géré par l’élément parent, marqué comme géré dans les données d’événement, et la source de l’événement est placée dans la vue à travers le code incorporé dans le <xref:System.Windows.Controls.ScrollViewer> contrôle. Ni le <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement ni le <xref:System.Windows.FrameworkElement.BringIntoView%2A> méthode transmettre toutes les informations sur le succès ou l’échec, autre que celui qui l’événement est généralement marqué comme géré sur réussite. Raisons de l’échec peut inclure des paramètres de l’élément, tel que <xref:System.Windows.UIElement.Visibility%2A> en cours d’une valeur autre que <xref:System.Windows.Visibility.Visible>.  
  
 Si vous utilisez la signature qui ne spécifie pas un `targetRectangle`, puis la taille de la totalité de l’élément (son <xref:System.Windows.UIElement.RenderSize%2A>) sera rendu visible.  
  
 En appelant cette méthode, vous éventuellement appeler <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> sur toute zone défilante parente qui contient l’élément. Si cet élément n’est pas contenu dans une zone avec défilement, le <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement est déclenché, mais il n’y aura aucun effet car il existe des écouteurs d’événements.  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire pour un événement de navigation d’application qui répond quand le [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] en cours de la navigation inclut un fragment. Le fragment est nommé dans le [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] suivant le signe dièse (#), et le comportement implémenté provoque l’élément à faire défiler dans la vue dans le cadre. <xref:System.Windows.FrameworkElement.BringIntoView%2A> et <xref:System.Windows.FrameworkElement.RequestBringIntoView> demande que le défilement dans l’exemple.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberSignature Language="F#" Value="member this.BringIntoView : System.Windows.Rect -&gt; unit" Usage="frameworkElement.BringIntoView targetRectangle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Taille spécifiée de l'élément qui doit également être mis en vue.</param>
        <summary>Tente de mettre en vue les dimensions de la région indiquée de cet élément, incluse dans toute région déroulante que ce soit qui le contient.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En appelant cette méthode, vous déclenchez un <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement provient de l’élément actuel. Cet événement est déclenché afin qu’elle puisse être gérée par un <xref:System.Windows.Controls.ScrollViewer>, ou une classe dérivée ou semblable. Le comportement attendu est que l’événement est géré par l’élément parent, marqué comme géré dans les données d’événement, et la source de l’événement est placée dans la vue à travers le code incorporé dans le <xref:System.Windows.Controls.ScrollViewer> contrôle. Ni le <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement ni le <xref:System.Windows.FrameworkElement.BringIntoView%2A> méthode transmettre toutes les informations sur le succès ou l’échec, autre que celui qui l’événement est généralement marqué comme géré sur réussite. Raisons de l’échec peut inclure des paramètres de l’élément, tel que <xref:System.Windows.UIElement.Visibility%2A> en cours d’une valeur autre que <xref:System.Windows.Visibility.Visible>.  
  
 Si vous utilisez la signature qui ne spécifie pas un `targetRectangle`, puis la taille de la totalité de l’élément (son <xref:System.Windows.UIElement.RenderSize%2A>) sera rendu visible.  
  
 En appelant cette méthode, vous éventuellement appeler <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> sur toute zone défilante parente qui contient l’élément. Si cet élément n’est pas contenu dans une zone avec défilement, le <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement est déclenché, mais il n’y aura aucun effet car il existe des écouteurs d’événements.  
  
   
  
## Examples  
 L’exemple suivant comprend un grand graphique dans une zone de défilement contrainte. Un bouton sur la page a un gestionnaire qui fait défiler la vue à une région particulière du graphique.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Controls.ContextMenu with get, set" Usage="System.Windows.FrameworkElement.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l’élément de menu contextuel qui doit apparaître chaque fois que le menu contextuel est demandé par l’[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] à partir de cet élément.</summary>
        <value>Menu contextuel affecté à cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> lui-même est un <xref:System.Windows.FrameworkElement> classe dérivée, et il est techniquement possible pour <xref:System.Windows.Controls.ContextMenu> lui-même pour avoir un <xref:System.Windows.FrameworkElement.ContextMenu%2A> propriété. Toutefois, cela crée une expérience de menu contextuel à confusion pour l’utilisateur et cette pratique n’est pas recommandée.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuClosing : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant qu'un menu contextuel sur l'élément ne soit fermé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour supprimer la fermeture menus contextuels, les gestionnaires de l’événement doivent marquer comme géré.  
  
 Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer la définition du service sous-jacent de l’événement :  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkElement> qui expose l’événement de service sous-jacent ne mappe pas les <xref:System.Windows.FrameworkElement.ContextMenuClosing> identificateur telles que vous pouvez l’utiliser en tant que déclencheur).  
  
 <xref:System.Windows.Controls.ContextMenu> lui-même est un <xref:System.Windows.FrameworkElement> classe dérivée, mais la <xref:System.Windows.FrameworkElement.ContextMenuClosing> événement ne sera pas déclenché par un menu contextuel directement. Au lieu de cela, l’événement est déclenché à partir de l’élément qui « possède » le menu contextuel en tant que propriété et est déclenché uniquement lorsqu’un utilisateur tente de fermer un menu contextuel dans l’interface utilisateur. Toutefois, il est possible pour <xref:System.Windows.Controls.ContextMenu> lui-même pour avoir un <xref:System.Windows.FrameworkElement.ContextMenu%2A> propriété (un menu contextuel imbriqué). Dans ce cas le <xref:System.Windows.Controls.ContextMenu> possède vraiment imbriqué <xref:System.Windows.Controls.ContextMenu> et peut déclencher l’événement, avec la source de l’événement étant le menu contextuel imbriqué.  
  
 Le <xref:System.Windows.Controls.ContextMenu> lui-même comporte également un événement similaire (<xref:System.Windows.Controls.ContextMenu.Closed>) mais le <xref:System.Windows.Controls.ContextMenu.Closed> événement ne vous fournit pas la possibilité d’annuler l’action de l’utilisateur.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Substituer <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> pour implémenter la gestion de classe pour cet événement dans les classes dérivées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " Usage="member this.ContextMenuOpening : System.Windows.Controls.ContextMenuEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un menu contextuel sur l'élément est ouvert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour ouvrir manuellement des menus contextuels, gestionnaires des événements doivent marquer l’événement comme étant géré. Sinon, la valeur existante de la <xref:System.Windows.FrameworkElement.ContextMenu%2A> propriété sera utilisée pour ouvrir automatiquement un menu contextuel. Marquage de l’événement géré annule effectivement l’action par défaut et peut être une opportunité pour réinitialiser la valeur de la <xref:System.Windows.FrameworkElement.ContextMenu%2A> propriété, puis ouvrez le nouveau <xref:System.Windows.Controls.ContextMenu>. Toutefois, il existe un problème de synchronisation que vous devez connaître. Pour remplacer complètement le menu contextuel via un <xref:System.Windows.FrameworkElement.ContextMenuOpening> gestionnaire, le menu contextuel initial ne doit pas être null / vide. Ou bien, vous devrez peut-être gérer l’événement et ouvrez manuellement un nouveau menu contextuel. Pour plus d’informations, consultez [Guide pratique pour Gérer l’événement ContextMenuOpening](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Pour utiliser cet événement comme un <xref:System.Windows.EventTrigger> dans un style, vous devez référencer l’événement attaché sous-jacent :  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Cette utilisation est requise car l’implémentation d’événement sur <xref:System.Windows.FrameworkElement> qui expose l’événement de service sous-jacent ne mappe pas les <xref:System.Windows.FrameworkElement.ContextMenuOpening> identificateur telles que vous pouvez l’utiliser dans les déclencheurs).  
  
 <xref:System.Windows.Controls.ContextMenu> lui-même est un <xref:System.Windows.FrameworkElement> classe dérivée, mais cet événement n’est pas déclenché dans le menu contextuel est ouvert en tant que source. L’événement est déclenché à partir de l’élément qui « possède » le menu contextuel en tant que propriété et est déclenché uniquement lorsqu’un utilisateur tente d’ouvrir un menu contextuel dans l’interface utilisateur. Il est possible pour <xref:System.Windows.Controls.ContextMenu> lui-même pour avoir un <xref:System.Windows.FrameworkElement.ContextMenu%2A> propriété, mais vous devez éviter ce scénario (pour plus d’informations, consultez <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 Le <xref:System.Windows.Controls.ContextMenu> lui-même comporte également un événement similaire (<xref:System.Windows.Controls.ContextMenu.Opened>) mais <xref:System.Windows.Controls.ContextMenu.Opened> ne vous fournit pas la possibilité d’annuler l’action de l’utilisateur.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Substituer <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> pour implémenter la gestion de classe pour cet événement dans les classes dérivées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ContextMenuProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.FrameworkElement.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le curseur qui s'affiche lorsque le pointeur de la souris est sur cet élément.</summary>
        <value>Curseur à afficher. La valeur par défaut est <see langword="null" /> conformément à cette propriété de dépendance. Toutefois, la valeur pratique par défaut au moment de l’exécution provient de divers facteurs.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous définissez cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processeur s’appuie sur la conversion de type pour la <xref:System.Windows.Input.Cursor> classe pour évaluer la chaîne. La chaîne fournie doit être évaluée en une <xref:System.Windows.Input.CursorType> valeur. Pour plus d'informations, consultez <xref:System.Windows.Input.Cursor>.  
  
 Si le curseur établi par cette propriété ou n’affiche pas lorsque le pointeur de la souris est au-dessus de cet élément est également dépendant de la valeur de la <xref:System.Windows.FrameworkElement.ForceCursor%2A> propriété. En outre, liées aux événements de considérations telles qu’un glisser active, capture de la souris, les modes dans des contrôles et ainsi de suite, d’édition de texte affecte également le curseur avec une priorité plus élevée que la valeur que vous spécifiez dans cette propriété.  
  
 Pour rétablir le comportement de la définition de cette propriété sur la valeur par défaut éventuelle, affectez-lui la valeur `null` à nouveau.  
  
 Le `null` par défaut signifie en réalité que la détermination de la valeur de curseur pratique est différée ici et doit être obtenue à partir d’un autre emplacement. Si présentés sans valeurs par programmation à partir de n’importe quelle source, le curseur par défaut qui se trouve visuellement sur une [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] application sera une flèche. Toutefois, les modifications transitoires du curseur ne sont pas définies le <xref:System.Windows.FrameworkElement.Cursor%2A> valeurs des éléments lorsqu’ils sont transmis. Le <xref:System.Windows.FrameworkElement.Cursor%2A> des valeurs de propriété sera uniquement rapport non null dans les cas où il a été effectivement défini, par exemple via le code ou un style. Chaque mouvement de la souris sur un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] application déclenche une <xref:System.Windows.UIElement.QueryCursor> événement. L’événement se propage et tout élément le long de l’itinéraire a la possibilité de gérer l’événement et définir la valeur du curseur via les arguments de cet événement. C’est le mécanisme qui produit le curseur visuellement apparent dans la plupart des cas. Si un <xref:System.Windows.UIElement.QueryCursor> gestionnaire renvoie un résultat de curseur, puis le fait que l’événement est géré et qu’il a une valeur modifiée dans les arguments est prioritaire sur la valeur de la <xref:System.Windows.FrameworkElement.Cursor%2A> propriété à n’importe quel niveau, sauf si <xref:System.Windows.FrameworkElement.ForceCursor%2A> est défini.  
  
 Si vous ne créez ne pas un curseur personnalisé, vous définissez généralement cette propriété sur une valeur de propriété statique de la <xref:System.Windows.Input.Cursors> classe. Paramètre <xref:System.Windows.FrameworkElement.Cursor%2A> dans le code requiert l’une des opérations suivantes :  
  
-   Appelez le <xref:System.Windows.Input.Cursor> constructeur pour obtenir un <xref:System.Windows.Input.Cursor> instance. Les deux signatures de la <xref:System.Windows.Input.Cursor> constructeur utiliser flux ou des fichiers, en prévision que vous créez le <xref:System.Windows.Input.Cursor> objet pour un curseur personnalisé.  
  
-   Utilisez le <xref:System.Windows.Input.CursorConverter> classe et ses <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> méthode pour spécifier un curseur par <xref:System.Windows.Input.CursorType>, ou une chaîne qui peut correspondre à un <xref:System.Windows.Input.CursorType>et effectuer un cast de revenir à <xref:System.Windows.Input.Cursor>.  
  
 Définition de la <xref:System.Windows.Input.Cursor> sur une valeur personnalisée n’est pas activé en mode de confiance partielle. Pour plus d’informations sur les curseurs personnalisés, consultez [vue d’ensemble de l’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir délibérément le graphique du curseur.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.CursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataContext : obj with get, set" Usage="System.Windows.FrameworkElement.DataContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte de données d’un élément quand il participe à la liaison de données.</summary>
        <value>Objet à utiliser comme contexte de données.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Contexte de données* est un concept qui permet aux éléments d’hériter des informations de leurs éléments parents sur la source de données qui est utilisé pour la liaison, ainsi que d’autres caractéristiques de la liaison, telles que le chemin d’accès.  
  
 Contexte de données peut être directement défini comme un objet .NET, avec les liaisons qui évaluent aux propriétés de cet objet. Vous pouvez également définir le contexte de données un <xref:System.Windows.Data.DataSourceProvider> objet.  
  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants sans autre valeur pour <xref:System.Windows.FrameworkElement.DataContext%2A> établi par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.DataContext%2A> la valeur de l’élément parent le plus proche avec cette valeur attribuée.  
  
 Vous pouvez également utiliser une des propriétés suivantes de la <xref:System.Windows.Data.Binding> classe pour spécifier la source de liaison explicitement :
  
    - <xref:System.Windows.Data.Binding.ElementName%2A>.
    - <xref:System.Windows.Data.Binding.Source%2A>.
    - <xref:System.Windows.Data.Binding.RelativeSource%2A>. 
  
  Pour plus d'informations, voir [Procédure : Spécifiez la Source de liaison](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 Dans XAML, <xref:System.Windows.FrameworkElement.DataContext%2A> est généralement définie comme un <xref:System.Windows.Data.Binding> déclaration. Vous pouvez utiliser la syntaxe d’élément de propriété ou de syntaxe d’attribut. Syntaxe d’attribut est indiquée dans l’exemple de cette page. Vous pouvez également utiliser le code pour définir <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> est une propriété pouvant être liée pour permettre les scénarios où un contexte peut être lié à un autre. Toutefois, si vous liez à <xref:System.Windows.FrameworkElement.DataContext%2A>, veillez à ne pas créer des références circulaires de liaison (ne pas lier un <xref:System.Windows.FrameworkElement.DataContext%2A> à lui-même, il est possible de le faire en raison de la nature de l’héritage de valeur de propriété de la <xref:System.Windows.FrameworkElement.DataContext%2A> propriété).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *dataContextObject*  
 Un objet incorporé directement qui sert de contexte de données pour toutes les liaisons dans l’élément parent. En règle générale, cet objet est un <xref:System.Windows.Data.Binding> ou un autre <xref:System.Windows.Data.BindingBase> classe dérivée. Les données brutes de tout type d’objet prévu pour la liaison peuvent également être placées ici, avec les liaisons réelles définies ultérieurement.  
  
 *bindingUsage*  
 Utilisation de liaison qui prend la valeur à un contexte de données approprié. Pour plus d’informations, consultez [Binding, extension de balisage](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Une des opérations suivantes : [ `StaticResource` ](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) ou [ `DynamicResource` ](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md). Cette utilisation est utilisée lorsque vous faites référence aux données brutes définies en tant qu’objet dans les ressources. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 L’identificateur de clé pour l’objet qui est demandé à partir d’un <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 L’exemple suivant illustre comment un contexte de données agit sur une liaison et fournit les informations qui définissent les valeurs spécifiques des propriétés liées.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberSignature Language="F#" Value="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.DataContextChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand le contexte de données de cet événement change.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir une explication des contextes de données et la liaison de données, consultez [vue d’ensemble de la liaison de données](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Lorsque le <xref:System.Windows.FrameworkElement.DataContext%2A> susceptibles d’être affectées pour un élément change, toutes les propriétés liées aux données sur cet élément. Cela s’applique à tous les éléments qui sont des éléments enfants de l’élément actuel dans l’arborescence logique, qui héritent du contexte de données, ainsi que l’élément actuel lui-même. Toutes ces liaisons existantes doivent ré-interpréter le nouveau <xref:System.Windows.FrameworkElement.DataContext%2A> et réévaluera les résultats de la liaison. Le moteur de liaison de données n’est pas déterministe sur l’ordre de ces réévaluations relatives au déclenchement de la <xref:System.Windows.FrameworkElement.DataContextChanged> événement. Les réévaluations peuvent se produire avant l’événement, après l’événement, ou dans toute combinaison.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DataContextProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DataContextProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultStyleKey : obj with get, set" Usage="System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la clé à utiliser pour faire référence au style pour ce contrôle, quand des styles de thème sont utilisés ou définis.</summary>
        <value>Clé du style. Pour fonctionner correctement dans le cadre de la recherche du style de thème, cette valeur doit être le <see cref="T:System.Type" /> du contrôle auquel le style va être appliqué.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété n’est pas généralement définie via une de ses accesseurs de propriété direct. Au lieu de cela, vous substituez les métadonnées spécifiques au type de cette propriété de dépendance chaque fois que vous créez un nouveau <xref:System.Windows.FrameworkElement> classe dérivée. Lorsque vous dérivez un contrôle, appelez le <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> méthode par rapport à la <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> identificateur, dans le constructeur statique du contrôle dérivé de classe (ou l’initialisation de classe équivalente).  
  
 En général, un contrôle remplace la valeur par défaut de cette propriété peut être son propre type, mais dans certains cas peut également utiliser un type de base pour lesquelles il existe un style dans les dictionnaires de thème. Cela est uniquement pratique si les modèles de contrôle du contrôle de base définissent entièrement la représentation visuelle de ce contrôle dérivé, et si les exposent les types dérivés des membres supplémentaires ne nécessitent pas d’éléments supplémentaires dans le cadre du modèle de contrôle.  
  
 Si vous souhaitez que votre élément ou un contrôle de délibérément ne pas utiliser les styles de thème, définissez le <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> propriété `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de substitutions de propriété de dépendance métadonnées discutée dans les notes. Ce code définit une classe de contrôle personnalisé `NumericUpDown` destinée à être utilisée à partir d’un assembly de bibliothèque de contrôle dédié. Le constructeur statique illustré fait référence à une fonction d’initialisation privée, enregistre un gestionnaire de classe (un autre scénario de sous-classement de contrôle commun ; consultez [marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) et enfin remplace le <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> des métadonnées de propriété de dépendance sur la `NumericUpDown` classe. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> Retourne toujours son propre type comme clé prévue, qui est la convention que le système de style de thème utilise pour rechercher le style de contrôles arbitraires sans style. L’exemple complet définit également le style de thème du contrôle réel qui est référencé par cette clé ; consultez [contrôle personnalisé NumericUpDown avec thème et prise en charge d’UI Automation, exemple](https://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown2.cs)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown2.vb)]  

  Le code source complet pour cet exemple est disponible sur GitHub pour les deux [ C# ](https://github.com/dotnet/samples/tree/master/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary) et [Visual Basic](https://github.com/dotnet/samples/tree/master/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary).

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=160025">Contrôle personnalisé NumericUpDown avec thème et prise en charge d’UI Automation, exemple</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable DefaultStyleKeyProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="frameworkElement.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique que le processus d'initialisation pour l'élément est terminé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.FrameworkElement.BeginInit%2A> a été appelé précédemment, la base de mise en œuvre déclenchera le <xref:System.Windows.FrameworkElement.Initialized> événement. Sinon, si <xref:System.Windows.FrameworkElement.BeginInit%2A> n’a pas été appelé ou qu’il ne peut pas être déterminé si <xref:System.Windows.FrameworkElement.BeginInit%2A> a été appelée, <xref:System.Windows.FrameworkElement.Initialized> n’est pas déclenché et une exception est levée à la place.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.FrameworkElement.EndInit" /> a été appelé sans que <see cref="M:System.Windows.FrameworkElement.BeginInit" /> l'ait été précédemment sur l'élément.</exception>
        <block subset="none" type="overrides"><para>Implémentez cette méthode pour fournir une gestion spéciale qui doit se produire lorsque votre élément est initialisé pendant le processus de chargement de l’élément.  
  
Votre implémentation doit appeler l’implémentation de base, car l’implémentation de base (valeur par défaut) définit certains indicateurs internes pour effectuer le suivi de l’initialisation.</para></block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.FindName : string -&gt; obj" Usage="frameworkElement.FindName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de l’élément demandé.</param>
        <summary>Recherche un élément qui a le nom de l’identificateur fourni.</summary>
        <returns>Élément demandé. Il peut s’agir de la valeur <see langword="null" /> si aucun élément correspondant n’a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’élément a des éléments enfants, ces éléments enfants sont tous recherchés de manière récursive pour l’élément nommé demandé.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> opère au sein de la portée de nom de l’élément actuel. Pour plus d’informations, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
        <related type="Article" href="https://msdn.microsoft.com/library/b7e61222-e8cf-48d2-acd0-6df3b7685d48">Attribut x : Name</related>
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="frameworkElement.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificateur clé de la ressource demandée.</param>
        <summary>Recherche une ressource d'après la clé spécifiée et lève une exception si la ressource demandée est introuvable.</summary>
        <returns>Ressource demandée. Si aucune ressource n'est trouvée avec la clé indiquée, une exception est levée. Une valeur <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> peut également être retournée dans le cas d'une exception.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Si vous appelez cette méthode pour une clé qui est introuvable, une exception est levée. Si vous ne souhaitez pas gérer les exceptions qui résultent de l’appel <xref:System.Windows.FrameworkElement.FindResource%2A>, appelez <xref:System.Windows.FrameworkElement.TryFindResource%2A> à la place. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Retourne `null` quand une ressource demandée est introuvable et ne lève pas d’exception.  
  
 Si la ressource est introuvable sur l’élément appelant, l’élément parent dans l’arborescence logique est recherché, puis l’application, puis les thèmes et enfin les ressources système. Cette méthodologie de recherche est identique à la façon dont l’arborescence de la recherche est effectuée si une ressource a été demandée par une référence de ressource dynamique dans le balisage. Pour plus d’informations sur la recherche de ressources, consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 En règle générale, vous devez immédiatement caster un <xref:System.Windows.FrameworkElement.FindResource%2A> retourner valeur pour le type de la propriété que vous affectez la valeur de la ressource retournée.  
  
 Clés de ressources ne sont pas nécessairement des chaînes. Par exemple, styles pour des contrôles au niveau du thème sont délibérément la clé de la <xref:System.Type> de contrôle, les styles d’application ou une page de contrôles utilisent généralement cette même clé convention. Pour plus d’informations, consultez [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md) ou [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 L’exemple suivant obtient une ressource nommée, il effectue un cast en un type approprié pour remplir une propriété.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException"><paramref name="resourceKey" /> était introuvable et un gestionnaire d'événements n'existe pas pour l'événement <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />.  
  
ou 
 <paramref name="resourceKey" /> était introuvable et la propriété <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> est <see langword="false" /> dans l'événement <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceKey" /> est <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberSignature Language="F#" Value="member this.FlowDirection : System.Windows.FlowDirection with get, set" Usage="System.Windows.FrameworkElement.FlowDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le sens utilisé pour le texte et d’autres éléments de l’[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] dans tout élément parent qui contrôle leur disposition.</summary>
        <value>Sens du texte et des autres éléments de l’[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] dans leur élément parent, en tant que valeur de l’énumération. La valeur par défaut est <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les jeux de l’utilisation de propriétés de dépendance le <xref:System.Windows.FrameworkElement.FlowDirection%2A> sur cet élément. En raison de l’héritage de valeur de propriété, paramètre <xref:System.Windows.FrameworkElement.FlowDirection%2A> sur un élément peut entraîner la définition <xref:System.Windows.FrameworkElement.FlowDirection%2A> sur tous les éléments enfants qui n’a pas défini <xref:System.Windows.FrameworkElement.FlowDirection%2A> localement ou via d’autres moyens tels que les styles.  
  
 Cette propriété n’est pas définie automatiquement dans le cadre des informations de culture application, car un élément peut contenir le contenu qui n’est pas nécessairement destinée à respecter le sens de déroulement général impliqué par les informations de culture. Pour plus d’informations sur les considérations relatives à la globalisation, consultez [globalisation pour WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Cette propriété a une définie [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] accesseur de propriété, pour qu’il fonctionne comme une propriété de dépendance. Toutefois, il est également inscrit comme attaché, donc il peut également fonctionner comme une propriété jointe. L’inscription attachée est principalement pour que l’héritage de valeur de propriété est prise en charge, mais la propriété peut également être utilisée comme une propriété jointe true. L’utilisation de la propriété jointe est pertinente uniquement si l’objet que vous souhaitez définir le sens de déroulement sur a un <xref:System.Windows.FrameworkElement> élément parent qui effectue la disposition sur elle, n’est lui-même pas un <xref:System.Windows.FrameworkElement>et ne possède pas déjà directement définie `FlowDirection` propriété. (Partie du flux de documents comme classes <xref:System.Windows.Documents.Block> et <xref:System.Windows.Documents.Inline> définir leurs propres `FlowDirection`, et cette propriété peut également définir la direction du flux. La valeur de propriété est ensuite lu par l’hôte de contenu éventuelle sans nécessiter l’utilisation de la propriété jointe.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
 \<*object* **FlowDirection**="<xref:System.Windows.FlowDirection>"/>  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Utilisation de texte XAML  
 Cette propriété peut également être définie sur les classes qui ne sont pas <xref:System.Windows.FrameworkElement> des classes dérivées et par ce qui suit [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] attaché l’utilisation de la propriété :  
  
 `<` *object* `FrameworkElement.`**FlowDirection**="<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Cette propriété est une propriété de dépendance et une propriété jointe ; consultez la section Notes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FlowDirectionProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FocusVisualStyle : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une propriété qui permet la personnalisation de l’apparence, des effets ou d’autres caractéristiques de style qui s’appliquent à cet élément quand il capture le focus clavier.</summary>
        <value>Style souhaité à appliquer sur le focus. La valeur par défaut déclarée dans la propriété de dépendance est un <see cref="T:System.Windows.Style" /> statique vide. Toutefois, la valeur effective au moment de l’exécution est souvent (mais pas toujours) un style tel qu’il est fourni par la prise en charge du thème pour les contrôles.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété affecte l’apparence visuelle mais ne signale pas <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> dans les métadonnées. Il s’agit, car la modification de l’apparence visuelle est pilotée par événements et ne peut-être pas s’appliquer à tout moment et par conséquent ne doit pas généralement signaler toute information visual ou une disposition dans les métadonnées.  
  
 Point de vue conceptuel, le comportement visuel de focus appliqué à un contrôle doit être cohérent du contrôle. La méthode la plus sensible pour appliquer la cohérence consiste à modifier uniquement le style de focus visuel si vous composez un thème entier. Définition de cette propriété sur des styles de contrôle et non comme faisant partie d’un thème n’est pas l’utilisation prévue de cette propriété, car elle peut entraîner une expérience utilisateur ambiguë concernant le focus clavier. Si vous prévoyez un comportement spécifique au contrôle qui est délibérément pas cohérent à travers un thème, une approche bien meilleure consiste à utiliser des déclencheurs dans les styles pour les propriétés de l’état d’entrées individuelles, telles que <xref:System.Windows.UIElement.IsFocused%2A> ou <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>et à le faire d’une façon qui ne pas visuellement, interférer avec n’importe quel style de focus visuel existant. Pour plus d’informations sur l’intention de conception de <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> et d’autres propriétés du focus, consultez [focus dans les contrôles et FocusVisualStyle](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourceExtension*  
 Une des opérations suivantes :, ou. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clé qui identifie le style demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée. Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Une référence de liaison à l’aide [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) ou <xref:System.Windows.Data.Binding> est également possible, mais rare.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusVisualStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ForceCursor : bool with get, set" Usage="System.Windows.FrameworkElement.ForceCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si cet objet <see cref="T:System.Windows.FrameworkElement" /> doit forcer l'[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] à effectuer le rendu du curseur tel qu'il est déclaré par la propriété <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <value><see langword="true" /> si la présentation du curseur, lorsque ce dernier se trouve sur cet élément, est forcée d'utiliser les paramètres actuels <see cref="P:System.Windows.FrameworkElement.Cursor" /> pour le curseur (y compris sur tous les éléments enfants) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous définissez cette propriété sur `true` vous remplacerez les préférences de curseur établies par les éléments enfants. Par conséquent, en général application sous peine [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] peut prêter à confusion pour l’utilisateur, en particulier si les éléments enfants essaient de spécifier des curseurs. Paramètre <xref:System.Windows.FrameworkElement.ForceCursor%2A> est plus appropriée dans les scénarios de sous-classement ou de composition de contrôle.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant force la valeur du curseur.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ForceCursorProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="member this.GetBindingExpression : System.Windows.DependencyProperty -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.GetBindingExpression dp" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><see cref="T:System.Windows.DependencyProperty" /> cible de laquelle obtenir la liaison.</param>
        <summary>Retourne <see cref="T:System.Windows.Data.BindingExpression" /> qui représente la liaison sur la propriété spécifiée.</summary>
        <returns><see cref="T:System.Windows.Data.BindingExpression" /> si la propriété cible possède une liaison active ; sinon, retourne <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La vérification de la valeur de retour pour `null` est une technique que vous pouvez utiliser pour déterminer si une propriété possède une liaison active.  
  
 Cette méthode est simplement un wrapper pratique autour du <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> (méthode). <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> passe l’instance actuelle et la `dp` paramètre <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetFlowDirection : System.Windows.DependencyObject -&gt; System.Windows.FlowDirection" Usage="System.Windows.FrameworkElement.GetFlowDirection element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Élément pour lequel retourner un <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</param>
        <summary>Obtient la valeur de la propriété jointe <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> pour le <see cref="T:System.Windows.DependencyObject" /> spécifié.</summary>
        <returns>Sens du flux demandé, sous forme de valeur de l’énumération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’objectif principal de cette méthode consiste à prendre en charge la syntaxe de propriété jointe pour le <xref:System.Windows.FrameworkElement.FlowDirection%2A> propriété, autorisant ainsi enfant des éléments de fourni <xref:System.Windows.FrameworkElement> pour spécifier le sens de déroulement pour la disposition au sein de leur élément parent. Pour obtenir la valeur sur actuel <xref:System.Windows.FrameworkElement>, utilisez la méthode directe [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] accesseur <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="frameworkElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Taille de la partie de l'élément qui assure la présentation visuelle.</param>
        <summary>Retourne une géométrie pour un masque de découpage. Le masque s'applique si le système de disposition essaie de réorganiser un élément qui est plus grand que l'espace d'affichage disponible.</summary>
        <returns>Géométrie du découpage.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marges à soustraire de la `layoutSlotSize` en tant que partie du comportement de système de disposition.  
  
 Une référence null retournée indique qu’aucun découpage n’aura lieu. Retourne l’implémentation par défaut toujours `null` lorsque <xref:System.Windows.UIElement.ClipToBounds%2A> est `false`. Cette méthode se substitue à <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. Le <xref:System.Windows.FrameworkElement> implémentation utilise <xref:System.Windows.FrameworkElement.MaxHeight%2A> et <xref:System.Windows.FrameworkElement.MaxWidth%2A> dans ses calculs. Plusieurs sous-classes de <xref:System.Windows.FrameworkElement> substituer cette méthode à nouveau. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, les remplacements pour toujours retourner `null` , car les ornements sont souvent délibérément en dehors des limites normales. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> et <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> retourner `null` si <xref:System.Windows.UIElement.ClipToBounds%2A> est `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Retourne l’implémentation par défaut toujours <see langword="null" /> lorsque <see cref="P:System.Windows.UIElement.ClipToBounds" /> est <see langword="false" />. Remplacements sont généralement censées se conserver ce comportement, bien qu’il existe des exceptions, en fonction de la relation et l’objectif de la classe dérivée et sa logique de disposition par opposition à la classe de base.</para></block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberSignature Language="F#" Value="member this.GetTemplateChild : string -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetTemplateChild childName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Nom de l'enfant à rechercher.</param>
        <summary>Retourne l'élément nommé dans l'arborescence d'éléments visuels d'un <see cref="T:System.Windows.Controls.ControlTemplate" /> instancié.</summary>
        <returns>Élément demandé. Peut correspondre à une <see langword="null" /> si aucun élément du nom demandé n'existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Modèles dans [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ont une portée de nom autonome. Il s’agit, car les modèles sont réutilisés et n’importe quel nom défini dans un modèle ne peut pas rester unique lorsque plusieurs instances d’un contrôle instancient son modèle. Appelez le <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> méthode pour retourner des références aux objets qui proviennent du modèle après son instanciation. Vous ne pouvez pas utiliser le <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> méthode pour rechercher des éléments à partir de modèles, car <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> agit en général plus étendue, et il n’existe aucune connexion entre la <xref:System.Windows.Controls.ControlTemplate> classe lui-même et le modèle instancié une fois qu’il est appliqué.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> Fournit la même fonction que cette méthode. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> protégé public au lieu de, et utilise des considérations correctes de portée de nom qui lui permettent d’accéder au modèle au sein d’un élément et la recherche d’éléments nommés. Utilisez <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> lorsque vous avez besoin obtenir un élément en dehors de son contrôle parent.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="frameworkElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un parent logique alternatif pour cet élément s’il n’existe aucun parent visuel.</summary>
        <returns>Retourne une valeur autre que <see langword="null" /> quand une implémentation de niveau infrastructure WPF de cette méthode a une connexion de parent non visuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. La valeur par défaut <xref:System.Windows.FrameworkElement> implémentation retourne le seul parent visuel attendu, ce qui est le même résultat que l’obtention de la <xref:System.Windows.FrameworkElement.Parent%2A> valeur. Les implémentations de classe dérivée peuvent retourner d’autres relations parentes.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="frameworkElement.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de base zéro de l’élément enfant demandé dans la collection.</param>
        <summary>Substitue <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> et retourne un enfant à l’index spécifié tiré d’une collection d’éléments enfants.</summary>
        <returns>Élément enfant demandé. La valeur ne doit pas retourner <see langword="null" /> ; si l’index fourni dépasse la plage établie, une exception est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le <xref:System.Windows.FrameworkElement> implémentation, le seul index valide est égal à zéro. Le modèle de contenu pour <xref:System.Windows.FrameworkElement.GetVisualChild%2A> prend en charge de zéro ou un élément enfant, et non une collection.  
  
   
  
## Examples  
 L’exemple suivant montre comment un ornement personnalisé utilise les valeurs déclarées par un <xref:System.Windows.Media.VisualCollection> qu’il gère pour ses enfants visuels. Ces valeurs sont indiquées par des remplacements de <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> et <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette implémentation est uniquement valide pour les éléments qui ne maintiennent pas n’importe quelle collection plus descriptive d’éléments enfants visuels. Tout élément qui n’a pas une telle collection doit substituer cette méthode et mapper l’index à un index équivalent dans la collection d’éléments enfants qui est pris en charge par cet élément. Un index dans la plage comprise entre zéro et <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (moins un) doit retourner un élément valide ; n’importe quel autre type d’index doit lever une exception d’out-of-range. Un exemple d’un type d’élément qui ne prend pas en charge une collection d’enfants et substitue <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> pour retourner plusieurs enfants possibles est <see cref="T:System.Windows.Controls.Panel" />.  
  
L’implémentation par défaut dans <see cref="T:System.Windows.FrameworkElement" /> ne suppose qu’un seul enfant visuel. Toute valeur passée <paramref name="index" /> autre que zéro génère une exception levée. Plusieurs éléments communs, tels que les décorateurs, les ornements ou les éléments avec le rendu spécialisé, substituent le <see cref="T:System.Windows.FrameworkElement" /> implémentation (de l’implémentation de classes de base intermédiaires). Certaines implémentations appliquent toujours un enfant visuel alors que d’autres autorisent une collection.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Height : double with get, set" Usage="System.Windows.FrameworkElement.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la hauteur suggérée de l’élément.</summary>
        <value>Hauteur de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est <see cref="F:System.Double.NaN" />. Cette valeur doit être supérieure ou égale à 0.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> est une des trois propriétés accessibles en écriture sur <xref:System.Windows.FrameworkElement> qui spécifient des informations de hauteur. Les deux autres sont <xref:System.Windows.FrameworkElement.MinHeight%2A> et <xref:System.Windows.FrameworkElement.MaxHeight%2A>. S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la hauteur réelle qui est le premier <xref:System.Windows.FrameworkElement.MinHeight%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxHeight%2A>et enfin, s’il s’agit dans les limites, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Si cet élément est un élément enfant dans un autre élément, puis en définissant cette propriété sur une valeur est vraiment qu’une valeur suggérée. Le système de disposition, ainsi que la logique de disposition spécifique de l’élément parent utilisera la valeur comme une entrée non liants pendant le processus de mise en page. En pratique, un <xref:System.Windows.FrameworkElement> est presque toujours l’élément enfant de quelque chose d’autre ; même si vous définissez la <xref:System.Windows.FrameworkElement.Height%2A> sur <xref:System.Windows.Window>. (Pour <xref:System.Windows.Window>, que la valeur est utilisée lorsque le modèle d’application sous-jacent établit les hypothèses de rendu de base qui créent le Hwnd qui héberge l’application.)  
  
 En outre acceptables <xref:System.Double> valeurs, cette propriété peut également être <xref:System.Double.NaN?displayProperty=nameWithType>. Voici comment vous spécifiez le comportement de dimensionnement automatique dans le code. Dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] vous définissez la valeur à la chaîne « Auto » (non respect de la casse) pour activer le comportement de dimensionnement automatique. Comportement de dimensionnement automatique implique que l’élément remplira la hauteur à sa disposition. Notez toutefois que des contrôles spécifiques fournissent fréquemment des valeurs par défaut via leurs styles de thème par défaut qui désactive le comportement de dimensionnement, sauf si elle est réactivée spécifiquement automatique.  
  
 La valeur de retour de cette propriété est toujours identique à n’importe quelle valeur a été définie. En revanche, la valeur de la <xref:System.Windows.FrameworkElement.ActualHeight%2A> peuvent varier. Cela peut se produire soit statiquement car la disposition a rejeté la taille suggérée pour une raison quelconque, ou momentanément. Le système de disposition fonctionne de façon asynchrone par rapport à l’ensemble du système de propriétés de <xref:System.Windows.FrameworkElement.Height%2A> et a ne peut-être pas traitée cette modification de propriété de dimensionnement encore en particulier.  
  
 Les restrictions de valeur sur le <xref:System.Double> sont appliquées par un <xref:System.Windows.ValidateValueCallback> mécanisme. Si vous essayez de définir une valeur non valide, une exception au moment de l’exécution est levée.  
  
 Outre la vérification de validation, il est une valeur supérieure non déterministe pour <xref:System.Windows.FrameworkElement.Height%2A> qui est appliquée par le système de disposition (il s’agit d’un très grand nombre, supérieur à <xref:System.Single.MaxValue?displayProperty=nameWithType> mais plus petit que <xref:System.Double.MaxValue?displayProperty=nameWithType>). Si vous dépassez cette limite, l’élément ne s’affichera pas et aucune exception n’est levée. Ne définissez pas <xref:System.Windows.FrameworkElement.Height%2A> à une valeur qui est beaucoup plus important que la taille maximale de n’importe quel affichage visuel, ou peut dépasser cette limite supérieure non déterministe.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Consultez la section Notes pour plus d’informations sur la limite supérieure. Cette valeur est interprétée comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
 **Auto**  
 Active le comportement de dimensionnement automatique. Consultez la section Notes.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Height" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalAlignment : System.Windows.HorizontalAlignment with get, set" Usage="System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les caractéristiques d'alignement horizontal appliquées à cet élément lorsqu'il est composé dans un élément parent, par exemple un contrôle de type Panel ou d'éléments.</summary>
        <value>Un paramètre d’alignement horizontal, sous forme de valeur de l’énumération. La valeur par défaut est <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.FrameworkElement.Height%2A> et <xref:System.Windows.FrameworkElement.Width%2A> propriétés sont définies explicitement sur un élément, ces dimensions ont une priorité pendant la disposition et annulent les effets typiques du paramètre <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> à <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> est le [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] accesseur de propriété pour ce qui est en réalité une propriété de dépendance. Cette propriété de dépendance particulière a assez souvent et sa valeur « par défaut » apparente défini différemment dans chaque élément de sous-classe, en particulier les contrôles. Cela se produit généralement dans un des deux façons : la propriété de dépendance est réinscrit à une sous-classe spécifique, mais avec des métadonnées différentes pour définir ses valeurs par défaut ; ou bien, il existe un style par défaut en cours d’application qui définit cette valeur de propriété de dépendance différemment. Par exemple, apparent « défaut » de <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> pour un <xref:System.Windows.Controls.Label> contrôle sera <xref:System.Windows.HorizontalAlignment.Left>, même si <xref:System.Windows.Controls.Label> hérite <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> directement à partir de <xref:System.Windows.FrameworkElement>. Il s’agit, car cette valeur est réinitialisée dans le style par défaut de <xref:System.Windows.Controls.Label>, dans le modèle de contrôle du style.  
  
 <xref:System.Windows.Controls.Canvas> n’utilise pas <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> lors de la composition de disposition, car <xref:System.Windows.Controls.Canvas> est basé sur le positionnement absolu.  
  
 Cas hérité par <xref:System.Windows.Controls.Label> ou les classes dérivées, <xref:System.Windows.Controls.Label> redéfinit la valeur par défaut de cette propriété de dépendance <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberSignature Language="F#" Value="member this.InheritanceBehavior : System.Windows.InheritanceBehavior with get, set" Usage="System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les limites de la portée de l'héritage des valeurs de propriétés, la recherche de clés de ressources et la recherche de RelativeSource FindAncestor.</summary>
        <value>Valeur de l’énumération. La valeur par défaut est <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certaines limites dans l’élément d’arborescence ensemble <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> délibérément limiter la portée du comportement d’héritage pour une recherche de ressource de force pour vérifier les ressources d’application, ou pour empêcher une recherche RelativeSource FindAncestor à partir de l’interrogation de l’élément actuel ni toute autre. Recherche de RelativeSource FindAncestor se produit lorsqu’une liaison utilise un <xref:System.Windows.Data.RelativeSource> qui a son <xref:System.Windows.Data.RelativeSource.Mode%2A> propriété définie sur la <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> valeur.  
  
 Si vous souhaitez que votre classe dérivée de définir cette propriété, vous devez le faire dans le constructeur statique ou dans d’autres routines d’initialisation.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="T:System.Windows.FrameworkElement" /> est initialisé. Cet événement coïncide avec les cas où la valeur de la propriété <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> passe de <see langword="false" /> (ou d'un état indéfini) à <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est déclenché chaque fois que le <xref:System.Windows.FrameworkElement.EndInit%2A> ou <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> méthodes sont appelées. Appels pour les deux méthodes peuvent provenir de code d’application, ou via le [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] comportement du processeur lorsqu’un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] page est traitée.  
  
 Si vous choisissez de gérer <xref:System.Windows.FrameworkElement.Loaded> ou <xref:System.Windows.FrameworkElement.Initialized> dépend de vos besoins. Si vous n’avez pas besoin lire les propriétés de l’élément, envisagez de réinitialiser les propriétés et n’avez pas besoin des informations de disposition, <xref:System.Windows.FrameworkElement.Initialized> peut être l’événement le plus adapté. Si vous avez besoin de toutes les propriétés de l’élément soit disponible, et que vous définissez des propriétés qui sont susceptibles de réinitialiser la disposition, <xref:System.Windows.FrameworkElement.Loaded> peut être l’événement le plus adapté. Soyez prudent de réentrance si votre gestionnaire réinitialise toutes les propriétés qui sont interprétées par le système de disposition pour indiquer qu’une nouvelle passe de disposition est nécessaire. (Vous devrez peut-être vérifier la <xref:System.Windows.FrameworkPropertyMetadata> passer des valeurs sur la propriété si vous ne savez pas de propriétés pouvant nécessiter une nouvelle disposition si elles sont modifiées.)  
  
 Pour plus d’informations sur la séquence d’événements d’objet pour un <xref:System.Windows.FrameworkElement>et également pour plusieurs connexes d’application et les classes d’éléments, consultez [événements de durée de vie d’objet](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputScope : System.Windows.Input.InputScope with get, set" Usage="System.Windows.FrameworkElement.InputScope" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte pour l’entrée utilisée par ce <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Portée d’entrée, qui modifie la façon dont l’entrée provenant d’autres méthodes d’entrée est interprétée. La valeur par défaut est <see langword="null" /> (ce qui entraîne une gestion par défaut des commandes).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants sans autre valeur pour <xref:System.Windows.FrameworkElement.InputScope%2A> établi par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.InputScope%2A> la valeur de l’élément ancêtre le plus proche avec cette valeur attribuée.  
  
 Bien qu’un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] utilisation de la syntaxe est répertoriée et est autorisée syntaxiquement, la définition de cette propriété [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] n’est pas courante.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable InputScopeProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Windows.FrameworkElement.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet élément a été initialisé, soit pendant le traitement d’un processeur [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], soit en ayant explicitement demandé à ce que sa méthode <see cref="M:System.Windows.FrameworkElement.EndInit" /> soit appelée.</summary>
        <value><see langword="true" /> si l’élément est initialisé selon le traitement [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] susmentionné ou les appels de méthode ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété peut également être `true` si cet élément a été déplacé au sein de l’arborescence logique, tel qu’il a un nouvel élément parent et par conséquent soit rechargé.  
  
 Cette propriété est utile si vous utilisez également <xref:System.Windows.FrameworkElement.BeginInit%2A> et <xref:System.Windows.FrameworkElement.EndInit%2A>. Éléments dans l’arborescence logique qui est chargé par un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] processeur sont assurément initialisés. Éléments pas dans l’arborescence logique sont initialisés lorsque <xref:System.Windows.FrameworkElement.EndInit%2A> est appelée. En l’absence de toute gestion spécifique de <xref:System.Windows.FrameworkElement.BeginInit%2A> et <xref:System.Windows.FrameworkElement.EndInit%2A>, cela se produit dès que le constructeur retourne le résultat initialisé.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLoaded : bool" Usage="System.Windows.FrameworkElement.IsLoaded" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet élément a été chargé en vue de sa présentation.</summary>
        <value><see langword="true" /> si l'élément actif est attaché à une arborescence d'éléments et a été restitué ; <see langword="false" /> si l'élément n'a jamais été attaché à une arborescence d'éléments chargée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À partir d’un nouvellement construit <xref:System.Windows.FrameworkElement>, cette propriété a commencé par `false`et reste `true` quand il est défini `true`, même si l’élément est supprimé par la suite d’une arborescence logique connectée par le code. `true` état est défini par la logique de présentation générale lorsque les éléments sont chargés dans le moteur de présentation.  
  
 En général, les éléments chargés sont rendus, mais pas tous <xref:System.Windows.FrameworkElement> une présentation et autres propriétés, telles que les classes dérivées ont <xref:System.Windows.UIElement.Visibility%2A> peuvent influencer la présentation.  
  
   
  
## Examples  
 L’exemple suivant implémente deux gestionnaires : un seul serveur gère le <xref:System.Windows.FrameworkElement.Loaded> événements de l’élément racine, afin de s’assurer que l’élément racine de page est chargé car il s’agit de l’importance de l’événement. L’autre gestionnaire est raccordé à un contrôle utilisateur et appelle <xref:System.Windows.FrameworkElement.IsLoaded%2A> pour vous assurer que l’élément racine est entièrement chargé. Les deux gestionnaires d’appellent la même fonction (non illustrée) qui remplira les éléments enfants avec les données actualisées.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Language : System.Windows.Markup.XmlLanguage with get, set" Usage="System.Windows.FrameworkElement.Language" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations de langue de localisation/globalisation qui s’appliquent à un élément.</summary>
        <value>Informations de langue pour cet élément. La valeur par défaut est <see cref="T:System.Windows.Markup.XmlLanguage" /> avec la chaîne "en-US" comme valeur de <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les formats de chaîne respectent la norme RFC 3066. Par exemple, aux États-Unis L’anglais est « en-US ». Pour plus d’informations sur les valeurs et le format, consultez <xref:System.Windows.Markup.XmlLanguage>.  
  
 Cette propriété de dépendance hérite des valeurs de propriété. S’il existe des éléments enfants sans autre valeur pour <xref:System.Windows.FrameworkElement.Language%2A> établie par le biais des valeurs locales ou de styles, le système de propriétés définira la valeur soit la <xref:System.Windows.FrameworkElement.Language%2A> la valeur de l’élément ancêtre le plus proche avec cette valeur attribuée.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] définit la signification générale de la `xml:lang` attribut. <xref:System.Windows.FrameworkElement.Language%2A> expose essentiellement la signification de cet attribut comme une propriété de dépendance. <xref:System.Windows.FrameworkElement.Language%2A> peut être ajusté par programmation et peut participer à l’héritage de propriété de la valeur de système d’une manière qui correspond à la `xml:lang` attribut peut hériter à portée d’élément enfant dans [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Si vous définissez <xref:System.Windows.FrameworkElement.Language%2A>, cette valeur devient la `xml:lang` et remplace toute valeur. Pour plus d’informations, consultez [XML : lang dans XAML de gestion des](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LanguageProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LanguageProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LayoutTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.FrameworkElement.LayoutTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une transformation de conception graphique qui doit s’appliquer à cet élément quand la disposition est effectuée.</summary>
        <value>Transformation que cet élément doit utiliser. La valeur par défaut est <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> affecte les résultats de la mise en page.  
  
 Définition d’une transformation fournit des fonctionnalités puissantes de mise à l’échelle et de rotation. Toutefois, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> ignore <xref:System.Windows.Media.TranslateTransform> operations. Il s’agit, car le comportement du système de disposition pour les éléments enfants d’un <xref:System.Windows.FrameworkElement> corrige automatiquement tout offset à la position d’un élément à l’échelle ou pivotée dans la mise en page et le système de coordonnées de l’élément parent.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> peut entraîner des performances médiocres des applications si vous l’appelez dans un scénario qui ne requiert pas une passe entière par le système de disposition. Lorsque vous appliquez un <xref:System.Windows.FrameworkElement.LayoutTransform%2A> à la <xref:System.Windows.Controls.Panel.Children%2A> collection de la <xref:System.Windows.Controls.Panel>, il déclenche une nouvelle passe par le système de disposition et force objets tout à l’écran pour remesurer et à réorganiser. Si vous mettez à jour l’application complète [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], cette fonctionnalité peut être exactement ce dont vous avez besoin. Toutefois, si vous n’avez pas besoin une passe de disposition complète, utilisez la <xref:System.Windows.UIElement.RenderTransform%2A> propriété, qui n’appelle pas le système de disposition et par conséquent, est généralement un meilleur choix pour ce scénario.  
  
 Exemples de scénarios où <xref:System.Windows.FrameworkElement.LayoutTransform%2A> serait utile incluent : faire pivoter des éléments tels que les composants de menu de horizontale à la verticale ou vice versa, mise à l’échelle d’éléments (Zoom) sur le focus, en fournissant le comportement d’édition, etc.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant montre comment appliquer un <xref:System.Windows.FrameworkElement.LayoutTransform%2A> à un élément. L’exemple crée une instance de <xref:System.Windows.Controls.Button> et l’héberge dans un parent <xref:System.Windows.Controls.Grid>. Il utilise également le <xref:System.Windows.FrameworkElement.LayoutTransform%2A> propriété pour appliquer un <xref:System.Windows.Media.RotateTransform> à la <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=158252">Exemple de transformations 2D</related>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LayoutTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberSignature Language="F#" Value="member this.Loaded : System.Windows.RoutedEventHandler " Usage="member this.Loaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l’élément est disposé, rendu et prêt pour l’interaction.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> est généralement le dernier événement déclenché dans une séquence d’initialisation d’éléments. Il est toujours déclenché après <xref:System.Windows.FrameworkElement.Initialized>. Si vous choisissez de gérer <xref:System.Windows.FrameworkElement.Loaded> ou <xref:System.Windows.FrameworkElement.Initialized> dépend de vos besoins. Si vous n’avez pas besoin lire les propriétés de l’élément, envisagez de réinitialiser les propriétés et n’avez pas besoin des informations de disposition, <xref:System.Windows.FrameworkElement.Initialized> peut être l’événement le plus adapté. Si vous avez besoin de toutes les propriétés de l’élément soit disponible, et que vous définissez des propriétés qui sont susceptibles de réinitialiser la disposition, <xref:System.Windows.FrameworkElement.Loaded> peut être l’événement le plus adapté. Soyez prudent de réentrance si votre gestionnaire réinitialise toutes les propriétés qui sont interprétées par le système de disposition pour indiquer qu’une nouvelle passe de disposition est nécessaire. (Vous devrez peut-être vérifier la <xref:System.Windows.FrameworkPropertyMetadata> passer des valeurs sur la propriété si vous ne savez pas de propriétés pouvant nécessiter une nouvelle disposition si elles sont modifiées.)  
  
 Pour plus d’informations sur la séquence d’événements d’objet pour un <xref:System.Windows.FrameworkElement>et également pour plusieurs connexes d’application et les classes d’éléments, consultez [événements de durée de vie d’objet](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés. Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.  
  
 <xref:System.Windows.FrameworkElement.Loaded> et <xref:System.Windows.FrameworkElement.Unloaded> peuvent tous deux être déclenchés sur des contrôles suite aux modifications du thème système initiée par l’utilisateur. Un changement de thème entraîne une invalidation du modèle de contrôle et l’arborescence visuelle de relation contenant-contenu, ce qui entraîne l’ensemble du contrôle décharger et recharger. Par conséquent <xref:System.Windows.FrameworkElement.Loaded> ne peut pas censé pour se produire uniquement quand une page est chargée via la navigation vers la page.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LoadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.LoadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.Loaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.FrameworkElement.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un énumérateur pour les éléments enfants logiques de cet élément.</summary>
        <value>Un énumérateur pour les éléments enfants logiques de cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> vous permet d’itérer sur les éléments enfants. Cela est utile pour les éléments qui ne dispose pas d’une collection définie dédiée mais contiennent toujours plus d’un élément enfant, en particulier <xref:System.Windows.FrameworkContentElement> éléments enfants.  
  
 Pour plus d’informations sur l’utilisation <xref:System.Windows.FrameworkElement.LogicalChildren%2A> et <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/c5358e14-d24c-44c7-b5eb-6062a4fd981c">x:Array, extension de balisage</related>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.FrameworkElement.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la marge extérieure d’un élément.</summary>
        <value>Fournit des valeurs de marge pour l’élément. La valeur par défaut est <see cref="T:System.Windows.Thickness" /> avec toutes les propriétés égales à 0 (zéro).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La marge est l’espace entre cet élément et d’autres éléments qui lui sont adjacents quand la disposition crée le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Éléments partagés peuvent être des éléments homologues (tels que les autres éléments dans la collection d’un contrôle parent commun), ou peuvent également être le parent de cet élément.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> est défini comme un <xref:System.Windows.Thickness> structure plutôt que comme un nombre afin que la marge peut être définie de façon asymétrique. Le <xref:System.Windows.Thickness> structure lui-même prend en charge la conversion de type chaîne afin que vous puissiez spécifier un asymétrique <xref:System.Windows.FrameworkElement.Margin%2A> dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] également la syntaxe d’attribut.  
  
 Une marge non nulle applique un espace en dehors de la disposition de l’élément <xref:System.Windows.FrameworkElement.ActualWidth%2A> et <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Les marges sont additifs pour les éléments frères dans une disposition ; par exemple, deux éléments adjacents à la fois avec une marge de 30 définies sur le bord adjacent aurait 60 unités d’espace entre eux.  
  
 Les éléments qui présentent une marge définie ne limitent pas en général, la taille de l’objet <xref:System.Windows.FrameworkElement.Margin%2A> si l’espace rectangulaire alloué n’est pas assez grande pour que la marge plus la zone de contenu d’élément. La zone de contenu d’élément sera contraint au lieu de cela, lorsque la disposition est calculée. Le seul cas où les marges seraient limitées est également si le contenu est déjà limité jusqu’à zéro.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *left, top, right, bottom*  
 Nombre de valeurs comprises entre 0 et <xref:System.Double.PositiveInfinity> qui spécifient les quatre propriétés de dimension possibles d’un <xref:System.Windows.Thickness> structure.  
  
 L’utilisation de l’attribut accepte également les valeurs abrégés qui s’appliquent dans l’ordre indiqué, symétriquement et logiquement. Par exemple, `Margin="20"` sera interprété comme signifiant un <xref:System.Windows.Thickness> avec toutes les propriétés définies sur 20. `Margin="20,50"` sera interprété comme signifiant un <xref:System.Windows.Thickness> avec <xref:System.Windows.Thickness.Left%2A> et <xref:System.Windows.Thickness.Right%2A> de 20, et <xref:System.Windows.Thickness.Top%2A> et <xref:System.Windows.Thickness.Bottom%2A> défini sur 50.  
  
 L’unité par défaut pour un <xref:System.Windows.Thickness> mesure est [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Vous pouvez également spécifier des autres unités en ajoutant les chaînes de type d’unité `cm`, `in`, ou `pt` à toute mesure.  
  
 Nombre de valeurs fournies en tant que [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] attributs pas besoin de spécifier des points de décimale (0 est acceptable, ne devra pas être indiqué comme 0.0). Pour plus d’informations sur [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] l’utilisation, consultez <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Une référence d’objet à un existant <xref:System.Windows.Thickness>. Cela peut être un `}`, a, ou `}` référence. Pour plus d’informations sur [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] l’utilisation, consultez <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxHeight : double with get, set" Usage="System.Windows.FrameworkElement.MaxHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la contrainte de hauteur maximale de l'élément.</summary>
        <value>Hauteur maximale de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est <see cref="F:System.Double.PositiveInfinity" />. Il peut s’agir de n’importe quelle valeur supérieure ou égale à 0.0. <see cref="F:System.Double.PositiveInfinity" /> est également valide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est une des trois propriétés sur <xref:System.Windows.FrameworkElement> qui spécifient des informations de hauteur. Les deux autres sont <xref:System.Windows.FrameworkElement.MinHeight%2A> et <xref:System.Windows.FrameworkElement.Height%2A>.  S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la hauteur réelle est le premier <xref:System.Windows.FrameworkElement.MinHeight%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxHeight%2A>et enfin si chacun d'entre eux est dans les limites, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Les restrictions de valeur sur le <xref:System.Double> sont appliquées par un <xref:System.Windows.ValidateValueCallback> mécanisme. Si vous essayez de définir une valeur non valide, une exception au moment de l’exécution est levée.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object MaxHeight="double"/>  
- or -  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Ceci est interprété comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 Le même <xref:System.Double> applique des restrictions comme indiqué dans la section de la valeur de propriété, à ceci près que vous devez utiliser [x : Static, Extension de balisage](~/docs/framework/xaml-services/x-static-markup-extension.md) si vous devez définir explicitement la valeur soit <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.MaxHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWidth : double with get, set" Usage="System.Windows.FrameworkElement.MaxWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la contrainte de largeur maximale de l'élément.</summary>
        <value>Largeur maximale de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est <see cref="F:System.Double.PositiveInfinity" />. Il peut s’agir de n’importe quelle valeur supérieure ou égale à 0.0. <see cref="F:System.Double.PositiveInfinity" /> est également valide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est une des trois propriétés sur <xref:System.Windows.FrameworkElement> qui spécifient des informations sur la largeur. Les deux autres sont <xref:System.Windows.FrameworkElement.MinWidth%2A> et <xref:System.Windows.FrameworkElement.Width%2A>. S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la largeur réelle est le premier <xref:System.Windows.FrameworkElement.MinWidth%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxWidth%2A>et enfin si chacun d'entre eux est dans les limites, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Les restrictions de valeur sur le <xref:System.Double> sont appliquées par un <xref:System.Windows.ValidateValueCallback> mécanisme. Si vous essayez de définir une valeur non valide, une exception au moment de l’exécution est levée.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Ceci est interprété comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 Le même <xref:System.Double> applique des restrictions comme indiqué dans la section de la valeur de propriété, à ceci près que vous devez utiliser [x : Static, Extension de balisage](~/docs/framework/xaml-services/x-static-markup-extension.md) pour définir la valeur pour être <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MaxWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.MaxWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Taille disponible que l’élément parent peut donner aux éléments enfants.</param>
        <summary>Implémente le comportement de système de disposition de passe de mesure de base pour <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Taille souhaitée de cet élément dans la disposition.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode remplace <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> pour connecter au niveau du noyau WPF et les implémentations de mesure de disposition de niveau framework WPF. Le <xref:System.Windows.FrameworkElement> implémentation scelle la méthode. Pour ajuster le comportement de disposition de passe de mesure de tout élément qui s’appuie sur le niveau de framework WPF, substituez <xref:System.Windows.FrameworkElement.MeasureOverride%2A> à la place. Pour ajuster la passe de mesure comportement de disposition d’un élément qui ne repose pas délibérément sur l’infrastructure WPF ou utilisez <xref:System.Windows.FrameworkElement>, substituer <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureOverride : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="frameworkElement.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Taille disponible que cet élément peut donner aux éléments enfants. Vous pouvez définir une valeur infinie pour indiquer que l’élément se redimensionne en fonction du contenu disponible.</param>
        <summary>En cas de substitution dans une classe dérivée, mesure dans la disposition la taille nécessaire pour les éléments enfants et détermine une taille pour la classe dérivée de <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Taille dont cet élément estime avoir besoin lors de la disposition, en fonction de ses calculs des tailles des éléments enfants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituer <xref:System.Windows.FrameworkElement.MeasureOverride%2A> pour implémenter le comportement de dimensionnement de disposition personnalisée pour votre élément tel qu’il participe le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] système de disposition. Votre implémentation doit effectuer les opérations suivantes :  
  
1.  Effectuer une itération de la collection votre élément particulier d’enfants qui font partie de disposition, appel <xref:System.Windows.UIElement.Measure%2A> sur chaque élément enfant.  
  
2.  Obtenez immédiatement <xref:System.Windows.UIElement.DesiredSize%2A> sur l’enfant (cela est défini en tant que propriété après <xref:System.Windows.UIElement.Measure%2A> est appelée).  
  
3.  Calculer la taille totale souhaitée du parent d’après la mesure des éléments enfants.  
  
 La valeur de retour de <xref:System.Windows.FrameworkElement.MeasureOverride%2A> doit être la taille de l’élément souhaité, qui devient alors la mesure d’entrée pour l’élément parent de l’élément actuel. Ce même processus se poursuit via le système de disposition jusqu'à ce que l’élément racine de la page est atteint.  
  
 Pendant ce processus, les éléments enfants peuvent retourner une valeur plus élevée <xref:System.Windows.UIElement.DesiredSize%2A> taille qu’initial `availableSize` pour indiquer que l’élément enfant nécessite davantage d’espace. Cela peut être gérée dans votre propre implémentation en introduisant une région déroulante, en redimensionnant le contrôle parent, en établissant un mode quelconque de commande empilée ou un nombre quelconque de solutions pour la mesure ou de réorganisation du contenu.  
  
> [!IMPORTANT]
>  Les éléments doivent appeler <xref:System.Windows.UIElement.Measure%2A> sur chaque enfant pendant ce processus, sinon les éléments enfants ne seront pas correctement en taille réelle ou organisées.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Le code non compilé suivant montre ce motif d’implémentation.  <c>VisualChildren</c> représente une propriété de collection énumérable des enfants que votre propre élément doit définir. La propriété peut être n’importe quel nom. <c>VisualChildren</c> est un nom d’espace réservé pour les besoins de cet exemple, <c>VisualChildren</c> n’est pas un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] tel que fourni par [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] ou une partie d’un modèle d’affectation de noms. 
  
[!code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)] [!code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinHeight : double with get, set" Usage="System.Windows.FrameworkElement.MinHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la contrainte de hauteur minimale de l'élément.</summary>
        <value>Hauteur minimale de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est 0,0. Il peut s’agir de n’importe quelle valeur supérieure ou égale à 0.0. Cependant, <see cref="F:System.Double.PositiveInfinity" /> et <see cref="F:System.Double.NaN" /> ne sont pas valides.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est une des trois propriétés sur <xref:System.Windows.FrameworkElement> qui spécifient des informations de hauteur.  Les deux autres sont <xref:System.Windows.FrameworkElement.Height%2A> et <xref:System.Windows.FrameworkElement.MaxHeight%2A>. S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la hauteur réelle est le premier <xref:System.Windows.FrameworkElement.MinHeight%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxHeight%2A>et enfin si chacun d'entre eux est dans les limites, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Les restrictions de valeur sur le <xref:System.Double> sont appliquées par un <xref:System.Windows.ValidateValueCallback> mécanisme. Si vous essayez de définir une valeur non valide, une exception au moment de l’exécution est levée.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Ceci est interprété comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 Le même <xref:System.Double> applique des restrictions comme indiqué dans la section de la valeur de propriété.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.MinHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.MinWidth : double with get, set" Usage="System.Windows.FrameworkElement.MinWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la contrainte de largeur minimale de l'élément.</summary>
        <value>Largeur minimale de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est 0,0. Il peut s’agir de n’importe quelle valeur supérieure ou égale à 0.0. Cependant, <see cref="F:System.Double.PositiveInfinity" /> et <see cref="F:System.Double.NaN" /> ne sont pas valides.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est une des trois propriétés sur <xref:System.Windows.FrameworkElement> qui spécifient des informations sur la largeur.  Les deux autres sont <xref:System.Windows.FrameworkElement.Width%2A> et <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la largeur réelle est le premier <xref:System.Windows.FrameworkElement.MinWidth%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxWidth%2A>et enfin si chacun d'entre eux est dans les limites, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Les restrictions de valeur sur le <xref:System.Double> sont appliquées par un <xref:System.Windows.ValidateValueCallback> mécanisme. Si vous essayez de définir une valeur non valide, une exception au moment de l’exécution est levée.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Ceci est interprété comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 Le même <xref:System.Double> applique des restrictions comme indiqué dans la section de la valeur de propriété.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MinWidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.MinWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="frameworkElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">La direction sur laquelle le focus doit être déplacé, comme une valeur de l'énumération.</param>
        <summary>Déplace le focus clavier de cet élément vers un autre élément selon un sens de parcours fourni.</summary>
        <returns>Retourne la valeur <see langword="true" /> si le focus est déplacé correctement ; <see langword="false" /> si l'élément cible, en suivant le sens spécifié, n'existe pas ou n'a pas pu faire l'objet du focus clavier.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation substitue <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> et scelle la méthode.  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire qui gère plusieurs entrées possibles. Chaque bouton représente un éventuel <xref:System.Windows.Input.FocusNavigationDirection>. Le gestionnaire effectue le suivi de l’élément avec le focus clavier actuel et appelle <xref:System.Windows.FrameworkElement.MoveFocus%2A> sur cet élément, en spécifiant la <xref:System.Windows.Input.FocusNavigationDirection> en tant que l’initialisation pour le <xref:System.Windows.Input.TraversalRequest> type de paramètre fourni.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.FrameworkElement.Name" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions(System.Windows.Markup.DesignerSerializationOptions.SerializeAsAttribute)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom d’identification de l’élément. Le nom fournit une référence afin que du code-behind, tel que le code d’un gestionnaire d’événements, puisse faire référence à un élément de balisage après qu’il a été construit pendant le traitement par un processeur [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Nom de l'élément. La valeur par défaut est une chaîne vide.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation la plus courante de cette propriété consiste à spécifier un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] nom de l’élément en tant qu’attribut dans le balisage.  
  
 Cette propriété fournit essentiellement une propriété de commodité de niveau infrastructure WPF pour définir le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Noms doivent être uniques au sein d’une portée de nom. Pour plus d’informations, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Obtenir un <xref:System.Windows.FrameworkElement.Name%2A> si vous créez des éléments de code n’est pas courant. Si vous avez déjà la référence appropriée dans le code, vous pouvez simplement appeler des méthodes et propriétés sur l’élément de référence et n’avez généralement pas besoin du <xref:System.Windows.FrameworkElement.Name%2A>. Une exception est si le <xref:System.Windows.FrameworkElement.Name%2A> chaîne a une signification surchargée, par exemple s’il est utile d’afficher ce nom dans [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Définissant un <xref:System.Windows.FrameworkElement.Name%2A> à partir de code-behind si la version d’origine <xref:System.Windows.FrameworkElement.Name%2A> a été défini à partir du balisage est également pas recommandée et la modification de la propriété après le chargement du [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ne changera pas la référence d’objet d’origine. Les références d’objet sont créés uniquement lorsque les portées de nom sous-jacentes sont créées explicitement lors de l’analyse. Vous devez appeler spécifiquement <xref:System.Windows.FrameworkElement.RegisterName%2A> pour apporter une modification effective pour le <xref:System.Windows.FrameworkElement.Name%2A> propriété d’un élément déjà chargé.  
  
 Un notable cas où le paramètre <xref:System.Windows.FrameworkElement.Name%2A> à partir du code est importante est lors de l’inscription de noms pour exécutent des éléments de tables de montage séquentiel, afin qu’ils puissent être référencés au moment de l’exécution. Avant vous pouvez inscrire un nom, vous devez également instancier et attribuer une <xref:System.Windows.NameScope> instance. Consultez la section exemple, ou [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Paramètre <xref:System.Windows.FrameworkElement.Name%2A> à partir du code est limitée à des applications, mais l’obtention d’un élément par <xref:System.Windows.FrameworkElement.Name%2A> est plus courant. Un scénario particulier est si votre application prend en charge un modèle de navigation où rechargent les pages dans l’application, et le code d’exécution n’est pas nécessairement défini pour cette page code-behind. La méthode utilitaire <xref:System.Windows.FrameworkElement.FindName%2A>, qui est disponible à partir d’un <xref:System.Windows.FrameworkElement>, peut rechercher n’importe quel élément par <xref:System.Windows.FrameworkElement.Name%2A> dans l’arborescence logique pour cet élément, recherche dans l’arborescence de manière récursive en fonction des besoins. Vous pouvez également utiliser le <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> méthode statique de <xref:System.Windows.LogicalTreeHelper>, qui prend également un <xref:System.Windows.FrameworkElement.Name%2A> chaîne en tant qu’argument.  
  
 Utilisé en général, les éléments racines (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> par exemple) implémentent l’interface <xref:System.Windows.Markup.INameScope>. Les implémentations de cette interface sont supposées renforcer les noms d’être non équivoque dans leur étendue. Les éléments racines qui définissent cette interface définissent également les limites de comportement de portée de nom pour tous les connexe [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 Le <xref:System.Windows.FrameworkElement.Name%2A> propriété sert également comme identificateur pour d’autres processus. Par exemple, le [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] modèle automation utilisera <xref:System.Windows.FrameworkElement.Name%2A> comme AutomationId pour les clients et fournisseurs.  
  
 Les valeurs de chaîne utilisées pour <xref:System.Windows.FrameworkElement.Name%2A> présentent quelques restrictions, imposée par sous-jacent [Directive x : Name](~/docs/framework/xaml-services/x-name-directive.md) défini par le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] spécification. Plus particulièrement, un <xref:System.Windows.FrameworkElement.Name%2A> doit commencer par une lettre ou le caractère de soulignement (_) et doit contenir uniquement des lettres, des chiffres ou des traits de soulignement. Pour plus d’informations, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> est une des propriétés de dépendance très peu ne peut pas être animées (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> est `true` dans les métadonnées), car le nom lui-même est essentiel pour cibler une animation. Liaison de données un <xref:System.Windows.FrameworkElement.Name%2A> est techniquement possible, mais est un scénario extrêmement rare, car une limite de données <xref:System.Windows.FrameworkElement.Name%2A> ne peut pas traiter la finalité principale de la propriété : pour fournir un point de connexion d’identificateur pour le code-behind.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.NameProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 L’exemple suivant définit la <xref:System.Windows.FrameworkElement.Name%2A> propriété dans le code, puis inscrit le nom dans nouvellement créé <xref:System.Windows.NameScope> en appelant <xref:System.Windows.FrameworkElement.RegisterName%2A>. La technique illustrée ici est une spécification d’animation avec des storyboards, ces dernières nécessitant un ciblage par le <xref:System.Windows.FrameworkElement.Name%2A>et ne peut pas être ciblés par la référence d’objet.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable NameProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.NameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberSignature Language="F#" Value="abstract member OnApplyTemplate : unit -&gt; unit&#xA;override this.OnApplyTemplate : unit -&gt; unit" Usage="frameworkElement.OnApplyTemplate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, appelé chaque fois que le code de l’application ou que des processus internes appellent <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut.  
  
 Les modèles sont la section de terminé arborescence visuelle d’un élément qui provient de la propriété de modèle d’un <xref:System.Windows.Style> qui est appliqué pour l’élément. Pour plus d’informations, consultez [Application d’un style et création de modèles](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Les classes dérivées de <see cref="T:System.Windows.FrameworkElement" /> pouvez utiliser cette méthode en tant que notification pour un large éventail de scénarios possibles : 
-Vous pouvez appeler votre propre implémentation de code qui génère le reste d’une arborescence d’éléments visuels.  
  
-Vous pouvez exécuter le code qui s’appuie sur l’arborescence d’éléments visuels à partir de modèles qui ont été appliqués, telles que l’obtention des références à des éléments nommés qui provient d’un modèle.  
  
-Vous pouvez introduire des services qui ne sont pertinentes d’exister après que l’arborescence d’éléments visuels à partir de modèles est terminée.  
  
-Vous pouvez définir des États et propriétés d’éléments dans le modèle qui dépendent d’autres facteurs. Par exemple, les valeurs de propriété peuvent uniquement être détectables en connaissant l’élément parent, ou lorsqu’un spécifique dérivée classe utilise un modèle commun.  
  
Les implémenteurs doivent toujours appeler l’implémentation de base avant leur propre implémentation. <see cref="T:System.Windows.FrameworkElement" /> lui-même a sans valeur par défaut peuvent d’implémentation, mais des classes.  
  
 <see cref="T:System.Windows.Controls.Control" /> offre une substitution semblable, <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuClosing : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois qu'un événement routé <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> non géré rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit&#xA;override this.OnContextMenuOpening : System.Windows.Controls.ContextMenuEventArgs -&gt; unit" Usage="frameworkElement.OnContextMenuOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelée chaque fois qu'un événement routé <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> non géré rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="frameworkElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Appelée chaque fois qu'un événement routé <see cref="E:System.Windows.UIElement.GotFocus" /> non géré rencontre cet élément sur son itinéraire.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à d’autres sur * méthodes exposées par les éléments de base, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> n’a pas une implémentation par défaut. Plus précisément, elle possède une implémentation qui substitue l’implémentation de null dans le niveau suivant de l’élément de base vers le bas, <xref:System.Windows.UIElement.OnGotFocus%2A>. Lorsqu’elle est appelée, <xref:System.Windows.FrameworkElement.OnGotFocus%2A> définit le comportement approprié du focus sur cet élément dans les cas où l’événement provient de l’élément actuel en raison du focus clavier. Le <xref:System.Windows.FrameworkElement.OnGotFocus%2A> gestionnaire ne marque pas les arguments d’événement comme étant géré, même quand le focus est défini à l’élément actuel. Si la source de l’événement était un autre élément dans l’arborescence (et non l’élément en cours), le gestionnaire ne fait rien.  
  
 Vous pouvez substituer cette méthode afin de pouvoir modifier le comportement de focus par défaut sur votre élément, mais n’oubliez pas que la modification de comportement de focus de cette façon peut-être être mieux exécutée par n’autorise ne pas l’élément à être carrément peut recevoir le focus (voir <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous avez l’intention de marquer l’événement géré dans les arguments, soyez conscient des conséquences sur la gestion des événements dans les autres éléments parents dans l’arborescence d’éléments. Ce gestionnaire agissant sur un événement avec un routage par propagation, la définition du focus actuel <paramref name="sender" /> par l’événement arguments peut ne pas convient. Le focus peut devoir accéder à un élément enfant composite ou à un élément parent, en fonction de la composition de certains contrôles. Par conséquent, marquer un événement de focus comme géré est uniquement recommandé si l’intégralité de l’arborescence visuelle qui distribue l’événement via fait partie de la composition d’un contrôle que vous avez créés.</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitialized : EventArgs -&gt; unit&#xA;override this.OnInitialized : EventArgs -&gt; unit" Usage="frameworkElement.OnInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.RoutedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.FrameworkElement.Initialized" />. Cette méthode est appelée chaque fois que <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> a la valeur <see langword="true" /> en interne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce particulier sur * méthode n’est pas un raccordement de gestionnaire de classe. Ni ne suit pas exactement l’établie [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] sur * convention de méthode que l’événement correspondant peut être supprimé en substituant cette méthode sans appeler l’implémentation de base.  
  
 Notez que le <xref:System.Windows.FrameworkElement.IsInitialized%2A> propriété étant en lecture seule, vous ne pouvez pas définir <xref:System.Windows.FrameworkElement.IsInitialized%2A> pour forcer le comportement de l’initialisation. Définition de l’état d’initialisation est conçu pour être utilisé uniquement par le [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>L'implémentation par défaut de cette méthode virtuelle déclenche l'événement tel qu'il est décrit ci-dessus. Les substitutions doivent appeler l'implémentation de base pour maintenir ce comportement. Si vous ne parvenez pas à appeler l’implémentation de base, non seulement vous pas déclenchera le <see cref="E:System.Windows.FrameworkElement.Initialized" /> événement normalement est généralement d’un <see cref="T:System.Windows.FrameworkElement" /> classe dérivée, mais vous supprimez également deux importantes style et le thème de style des opérations d’initialisation qui sont implémenté par cette implémentation de base.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="frameworkElement.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d’événement qui décrivent la propriété qui a changé, ainsi que les anciennes et nouvelles valeurs.</param>
        <summary>Méthode appelée chaque fois que la valeur effective d’une propriété de dépendance sur ce <see cref="T:System.Windows.FrameworkElement" /> a été mise à jour. La propriété de dépendance spécifique qui a changé est indiquée dans le paramètre d’arguments. Substitue <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas destinée à généralement détecter les modifications apportées aux propriétés ou les invalidations. Il est destiné à la place les modifications du modèle d’invalidation général si certaines informations sont connues de larges classifications de propriétés.  
  
 Cette méthode est appelée potentiellement plusieurs fois pendant la durée de vie d’un objet. Par conséquent, vous pouvez obtenir de meilleures performances si vous substituez les métadonnées de propriétés spécifiques puis attachez <xref:System.Windows.CoerceValueCallback> ou <xref:System.Windows.PropertyChangedCallback> fonctions pour les propriétés individuelles. Toutefois, vous utiliseriez cette méthode si un <xref:System.Windows.FrameworkElement> inclut un nombre important de propriétés de dépendance mises en corrélation par valeur, ou si elle inclut la logique comme comportement de rendu qui doit être réexécuté pour plusieurs cas d’invalidations de propriétés connexes.  
  
 Notez qu’il existe une portant le même nom `OnPropertyChanged` méthode avec une signature différente (le type de paramètre est <xref:System.ComponentModel.PropertyChangedEventArgs>) qui peuvent apparaître sur un nombre de classes. Que `OnPropertyChanged` est utilisé pour les notifications d’objet de données, et fait partie du contrat pour <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Appelez toujours l’implémentation de base, comme première opération dans votre implémentation. Entier sera considérablement désactivé dans le cas [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] système de propriétés, ce qui entraîne le signalement de valeurs incorrectes. Spécifique au <see cref="T:System.Windows.FrameworkElement" /> implémentation est également chargée de maintenir un état approprié pour un large éventail de propriétés qui affectent l’interface utilisateur visible. Celles-ci incluent l’invalidation de l’arborescence visuelle selon les modifications apportées au style à des moments appropriés.</para></block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberSignature Language="F#" Value="override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="frameworkElement.OnRenderSizeChanged sizeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Détails de l’ancienne taille et de la nouvelle taille impliquées dans la modification.</param>
        <summary>Déclenche l’événement <see cref="E:System.Windows.FrameworkElement.SizeChanged" />, en utilisant les informations spécifiées dans le cadre des données d’événement définitives.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Si vous appelez cette méthode réinitialise le <xref:System.Windows.FrameworkElement.ActualWidth%2A> propriété, le <xref:System.Windows.FrameworkElement.ActualHeight%2A> propriété, ou les deux, selon ce qui est spécifié comme modifié dans les arguments fournis, et à toujours déclencher l’événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ne remplacez pas cette méthode pour les scénarios classiques de disposition. Le système de disposition fonctionne de manière asynchrone délibérément afin d’assurer que disposition possible tous les réorganiser et cas de mesure sont pris en compte. Le système de disposition remplace les méthodes <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> et <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> sont généralement suffisantes pour toute personnalisation de disposition requises. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> est exposé comme une machine virtuelle. Vous pouvez remplacer <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> pour corriger des cas exceptionnels où un changement de comportement d’exécution aux événements combinées avec le contrôle d’entrée la recomposition dans la réponse peut donner des informations de disposition inexactes.  
  
Vous pouvez toujours substituer cette méthode dans les classes dérivées (elle est protégée mais pas sealed). Appelez toujours l’implémentation de base pour conserver le comportement mentionné ci-dessus, sauf si vous avez des raisons très spécifiques pour la désactivation du comportement de rendu de niveau infrastructure WPF par défaut. Ne pas déclencher la <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> événement entraîne un comportement de disposition non standard si vous utilisez l’implémentation du système de disposition de niveau framework WPF standard.</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit&#xA;override this.OnStyleChanged : System.Windows.Style * System.Windows.Style -&gt; unit" Usage="frameworkElement.OnStyleChanged (oldStyle, newStyle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">L'ancien style.</param>
        <param name="newStyle">Le nouveau style.</param>
        <summary>Appelé lorsque le style utilisé sur cet élément change, ce qui invalide la disposition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode présente une implémentation par défaut qui définit un indicateur interne qui note la condition de style modifié.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Vous devez généralement inutile de substituer cette méthode. Toute modification à un style qui implique une mesure ou de réorganisation modification déclencherait un autre cycle de rendu, en supposant une implémentation classique de <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, ou les valeurs par défaut. Remplacements de <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> peut être approprié si votre <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> implémentations ont été délibérément ou prennent en charge les mises à jour partielles, mais encore d’appliquer des modifications aux styles plus directement. (Les mises à jour partielles serait une tentative pour éviter plusieurs appels incrémentielles à <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> et <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> sur tous les éléments enfants).</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipClosing : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois qu'un événement routé <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> non géré rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit&#xA;override this.OnToolTipOpening : System.Windows.Controls.ToolTipEventArgs -&gt; unit" Usage="frameworkElement.OnToolTipOpening e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Fournit des données sur l'événement.</param>
        <summary>Appelée chaque fois que l'événement routé <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> rencontre cette classe sur son itinéraire. Implémentez cette méthode pour ajouter la gestion de classes pour cet événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’a pas d’implémentation par défaut. Vous devez toujours appeler l’implémentation de base au cas où une classe intermédiaire dans l’héritage a implémenté cette méthode.  
  
 L’objectif de cette méthode est comparable à celui [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] modèle d’événement sur * méthodes : il fournit les moyens de gérer l’événement correspondant à partir des classes dérivées avec un gestionnaire de classe au lieu d’un gestionnaire d’instance. Dans ce cas, l’événement correspondant est un événement routé. Le modèle d’implémentation des méthodes On * est différent pour les événements routés car l’événement routé a été déclenché par un élément enfant, pas nécessairement celui qui appelle les gestionnaires, votre implémentation sera donc à prendre la source des arguments d’événement propriétés en compte (et ne devez pas essayer déclencher à nouveau l’événement dans la plupart des cas). Les sous-classes de <xref:System.Windows.FrameworkElement> peut choisir d’appeler des méthodes de gestionnaire de classe privée lorsque l’événement est reçu sur l’itinéraire. Un scénario potentiel consiste à prendre les arguments de l’événement et délibérément marquer l’événement comme géré pour raccourcir l’itinéraire.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="frameworkElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Ancien élément parent. Peut être <see langword="null" /> pour indiquer que l’élément n’avait pas de parent visuel auparavant.</param>
        <summary>Appelée en cas de modification du parent de cet élément dans l’arborescence visuelle. Substitue <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’arborescence visuelle peut être différente de l’arborescence logique, car elle omet les éléments qui ne s’affichent pas visuellement, telles que des collections et développe des éléments en fonction de la composition de leur thème et de style. Pour plus d’informations, consultez [Arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>L’implémentation par défaut de cette méthode virtuelle interroge pour le nouveau parent, déclenche différents événements d’initialisation et définit des indicateurs internes à propos de l’état d’initialisation de la <see cref="T:System.Windows.FrameworkElement" /> selon le cas. Enfin, il appelle les implémentations de base consécutives déclarée par <see cref="T:System.Windows.UIElement" />, qui appelle à son tour sa base dans <see cref="T:System.Windows.Media.Visual" />. Toujours appeler l’implémentation de base pour maintenir ce comportement, sinon le comportement d’arborescence élément pour cet élément lorsque déclaré en tant qu’enfant d’un autre élément peut-être pas comme prévu.  
  
Quelques-unes des [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] classes substituer cette méthode, par exemple : <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Le scénario le plus courant consiste à appliquer que le nouveau parent doit être un type particulier. Cela peut impliquer de lever une exception si le nouveau parent a échoué à un mode quelconque de test de type. Il existe une version spécialisée de ce scénario dans les implémentations pour les éléments de liste et les éléments de menu, qui ne sont pas justifiés tout en dehors d’un parent visuel qui possède une collection appropriée pour les stocker dans. Notez que ces cas ne déclenchent pas nécessairement les exceptions, car il peut y avoir des scénarios de concepteur qui s’appuient sur la réattribution des éléments qui sont momentanément sans leurs parents « regular ».  
  
Cette méthode est également substituée dans certains éléments qui sont en général l’élément racine, tel que <see cref="T:System.Windows.Window" />. Un autre cas serait les éléments qui sont l’élément racine apparent dans le balisage mais qui génèrent automatiquement une infrastructure supérieure dans une arborescence logique compilée (tel que <see cref="T:System.Windows.Controls.Page" />). Le <see cref="T:System.Windows.Window" /> et <see cref="T:System.Windows.Controls.Page" /> implémentations scellent délibérément la méthode.</para></block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesDefaultStyle : bool with get, set" Usage="System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si cet élément incorpore des propriétés de style provenant de styles de thème.</summary>
        <value><see langword="true" /> si cet élément n'utilise pas de propriétés du style de thème ; toutes les propriétés qui proviennent du style proviennent de styles d'application locaux, et les propriétés du style de thème ne s'appliquent pas. <see langword="false" /> si les styles d'application s'appliquent en premier, puis que les styles de thème s'appliquent aux propriétés qui n'ont pas été spécifiquement définies dans les styles d'application. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation la plus courante de cette propriété est une utilisation indirecte dans l’accesseur Set d’un style qui fournit un style à thème.  
  
> [!IMPORTANT]
>  Si vous définissez <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> à `true` sur un contrôle, vous supprimez le modèle de contrôle par défaut fourni par les styles de thème. Ce modèle de contrôle inclut en général le présentateur de contenu et d’autres éléments composés qui fournissent la base [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] fonctionnalité et visualisation pour le contrôle. Si vous souhaitez que le contrôle de continuer à prendre en charge les mêmes fonctionnalités que les styles de thème par défaut, vous devez fournir un autre style avec un modèle de contrôle qui réplique la même structure. Pour plus d’informations, consultez [Vue d’ensemble de la création de contrôles](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OverridesDefaultStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l’élément parent logique de cet élément.</summary>
        <value>Parent logique de cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> peut être `null` dans les cas où un élément a été instancié, mais n’est pas attaché à aucune arborescence logique qui finit par se connecte à l’élément de niveau racine de page ou l’objet d’application.  
  
 Notez que le parent logique d’un élément peut éventuellement changer selon les fonctionnalités de votre application, et en conservant la valeur de cette propriété ne reflétera pas cette modification. Vous devez généralement obtenir la valeur juste avant que vous en avez besoin.  
  
 Consultez [arborescences dans WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) pour plus d’informations sur le parcours d’arborescence logique et les scénarios où l’utilisation <xref:System.Windows.FrameworkElement.Parent%2A> comme une technique de l’élément parent découverte est appropriée.  
  
 Le moteur de propriété recalculera potentiellement toutes les valeurs de propriété d’un élément lorsqu’il est apparenté à nouveau, car certaines propriétés héritent des valeurs dans l’arborescence logique. Le <xref:System.Windows.FrameworkElement.DataContext%2A> qui s’applique pour les liaisons peut également changer lorsque les éléments sont apparentés à nouveau.  
  
 Modification du parent d’un élément est généralement uniquement effectuée via la manipulation de collections, à l’aide de dédié méthodes add ou remove, ou via la définition des propriétés de contenu d’éléments.  
  
 Le scénario le plus courant pour l’utilisation de la <xref:System.Windows.FrameworkElement.Parent%2A> propriété consiste à obtenir une référence, puis d’obtenir différentes <xref:System.Windows.FrameworkElement> les valeurs de propriété à partir du parent. Pour les modèles, les <xref:System.Windows.FrameworkElement.Parent%2A> du modèle à long terme sera `null`. Pour franchir ce point et développer l’arborescence logique où le modèle est réellement appliqué, utilisez <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Notez que cette propriété ne signale pas de parents d’arborescence d’éléments visuels dans les cas où ceux-ci diffèrent des parents d’arborescence logique. Parents de l’arborescence d’éléments visuels ne sont pas particulièrement importantes pour les cas généraux de l’application, mais peut-être les éléments parent de votre choix pour certains cas au niveau visual. Consultez <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 L’exemple suivant montre le code qui vérifie le parent d’un élément et utilise ensuite les valeurs de propriété à partir du parent pour définir les propriétés sur l’élément enfant pour faire correspondre. Dans ce cas il s’agit des propriétés qui affectent la taille de rendu.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit&#xA;override this.ParentLayoutInvalidated : System.Windows.UIElement -&gt; unit" Usage="frameworkElement.ParentLayoutInvalidated child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Élément enfant qui signale la modification.</param>
        <summary>Prend en charge les implémentations de dispositions incrémentielles dans les sous-classes spécialisées de <see cref="T:System.Windows.FrameworkElement" />. <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> est appelé lorsqu'un élément enfant a invalidé une propriété qui est marquée dans les métadonnées comme influant sur les passes de mesure ou de réorganisation du parent pendant la phase de disposition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cet élément possède un élément enfant sur lequel une propriété quelconque a été invalidée et la propriété a été marquée comme <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ou <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> dans les métadonnées de propriété lors de l’inscription, cette méthode est appelée. L’appel de méthode indique à l’élément parent quel élément enfant particulier doit être mesuré de nouveau si cet élément prend en charge la mise à jour (incrémentielle) partielle de disposition.  
  
 Par défaut, <xref:System.Windows.FrameworkElement> ne prend pas en charge la disposition incrémentielle, puis, dans le <xref:System.Windows.FrameworkElement> classe cette méthode ne possède aucune implémentation par défaut. Le scénario où la substitution de cette méthode serait nécessaire n’est pas commun, car elle vous oblige à modifier le comportement par défaut du système de disposition.  
  
 Un exemple de scénario d’implémentation peut être une classe possédant des limitations de type pour les éléments enfants possibles qui sont considérablement plus restrictifs que le système de disposition de niveau framework WPF. En raison de la nature de ces éléments personnalisés, les modifications de propriété peut être différées délibérément lorsque vous implémentez un comportement de disposition personnalisée. Par exemple, les substitutions de méthode de mesure/réorganiser, qui tentent d’optimiser l’élément enfant passe de rendu, peut être différées pour certains types de modifications qui entraîneraient normalement une autre passe de disposition.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="frameworkElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">La direction pour laquelle une future modification de focus doit être déterminée.</param>
        <summary>Détermine l'élément suivant qui recevrait le focus relatif à cet élément pour une direction du déplacement du focus fournie, mais ne déplace pas réellement le focus.</summary>
        <returns>L'élément suivant sur lequel se déplacerait le focus si le focus était parcouru réellement. Peut retourner <see langword="null" /> si le focus ne peut pas être déplacé par rapport à cet élément pour la direction fournie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> est la méthode connexe qui déplace effectivement le focus.  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire qui gère plusieurs entrées possibles, chaque bouton représentant un éventuel <xref:System.Windows.Input.FocusNavigationDirection>. Le gestionnaire effectue le suivi de l’élément avec le focus clavier actuel et appelle <xref:System.Windows.FrameworkElement.PredictFocus%2A> sur cet élément et spécifie le texte approprié <xref:System.Windows.Input.FocusNavigationDirection> en tant que l’initialisation pour le <xref:System.Windows.Input.TraversalRequest> type de paramètre fourni. Au lieu de déplacer à cet élément en tant que <xref:System.Windows.FrameworkElement.MoveFocus%2A> feriez, le gestionnaire modifie les dimensions physiques de la destination prévue le focus à des fins de visualisation.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Spécifié l'une des directions suivantes dans le <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Ces sens ne sont pas légaux pour <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (mais le sont pour <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberSignature Language="F#" Value="member this.RegisterName : string * obj -&gt; unit" Usage="frameworkElement.RegisterName (name, scopedElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nom à utiliser pour le mappage nom-objet spécifié.</param>
        <param name="scopedElement">Objet pour le mappage.</param>
        <summary>Fournit un accesseur qui simplifie l'accès à la méthode d'inscription <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.NameScope.RegisterName%2A>. L’implémentation vérifie les éléments parents successifs jusqu'à ce qu’il trouve applicable <xref:System.Windows.NameScope> implémentation, ce qui se trouve en recherchant un élément qui implémente <xref:System.Windows.Markup.INameScope>. Pour plus d’informations sur les portées de nom, consultez [portées de nom XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Appel <xref:System.Windows.FrameworkElement.RegisterName%2A> est nécessaire pour raccorder correctement des tables de montage séquentiel pour les applications lors de la création dans le code. Il s’agit, car un de la clé d’animation de propriétés, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, utilise une recherche de nom de l’exécution au lieu d’être en mesure de prendre une référence à un élément cible. Cela est vrai même si cet élément est accessible par référence à partir du code. Pour plus d’informations sur la nécessité d’inscrire les noms pour les cibles de la table de montage séquentiel, consultez [vue d’ensemble des Storyboards](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveLogicalChild : obj -&gt; unit" Usage="frameworkElement.RemoveLogicalChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Élément à supprimer.</param>
        <summary>Supprime l’objet fourni de l’arborescence logique de cet élément. <see cref="T:System.Windows.FrameworkElement" /> met à jour les pointeurs de parents de l’arborescence logique affectée pour qu’ils restent synchronisés avec cette suppression.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour l’implémentation de collections sur les objets qui représentent les enfants logiques d’un élément. Cela peut être effectuée dans les accesseurs Get ou les accesseurs Set, les gestionnaires de classe de `Changed` événements, constructeurs, ou dans la collection de types eux-mêmes.  
  
 Pour les auteurs de contrôle, la manipulation de l’arborescence logique à ce niveau n’est pas la pratique recommandée, sauf si aucun des modèles de contenu de la classe de contrôle de base fourni n’est appropriées. Considérez le sous-classement au niveau de <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, et <xref:System.Windows.Controls.HeaderedItemsControl>. Ces classes fournissent un modèle de contenu avec l’application particulière des enfants logiques via dédié [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], ainsi que la prise en charge d’autres fonctionnalités généralement souhaitables dans un [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] contrôle comme style via des modèles.  
  
   
  
## Examples  
 L’exemple suivant implémente un `Child` propriété sur personnalisé <xref:System.Windows.FrameworkElement> qui effectue sa propre implémentation de la couche visuelle. Accesseur Set de la propriété est conçue afin que si la valeur change, l’ancienne valeur est supprimée à partir de l’arborescence logique, ainsi que d’une collection visuelle spécifique à la classe. Les valeurs sont mises en cache, et ensuite la nouvelle valeur est ajoutée à l’arborescence logique au niveau standard du framework WPF et la collection visuelle personnalisée.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberSignature Language="F#" Value="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " Usage="member this.RequestBringIntoView : System.Windows.RequestBringIntoViewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> est appelé sur cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement indique à un parent <xref:System.Windows.Controls.ScrollViewer> (ou classe dérivée) que l’élément qui déclenche le <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement doit être rendu visible dans la zone déroulante. Le <xref:System.Windows.Controls.ScrollViewer> marquera la <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement comme géré, à l’aide de gestion de classe de l’événement. En général <xref:System.Windows.FrameworkElement.RequestBringIntoView> événement données ne doivent pas être marqué comme gérées par toute classe qui ne contrôle pas une zone de défilement, ou un gestionnaire d’instance, car cela entraînerait une interférence dans le but de l’élément qui a appelé <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Stratégie de routage|Propagation|  
|délégué|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable RequestBringIntoViewEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.FrameworkElement.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le dictionnaire de ressources défini localement.</summary>
        <value>Dictionnaire de ressources actif défini localement, où chaque ressource est accessible par clé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les dictionnaires de ressources qui peuvent être définis complètement ou partiellement en [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] sont généralement créés comme élément de propriété et sont généralement sur l’élément racine pour n’importe quelle page individuel ou pour l’application. Placer le dictionnaire de ressources à ce niveau facilite la recherche d’éléments enfants individuels dans la page (ou à partir de n’importe quelle page, dans le cas d’application). Dans la plupart des scénarios d’application, nous recommandons que les styles être définis en tant qu’éléments objet dans un dictionnaire de ressources, ou être définis comme des ressources externes afin que la ressource de style entière peut être autonome (cette approche permet de concepteur distinct responsabilités du développeur en séparant les fichiers physiques qui doivent être modifiées).  
  
 Notez que cette propriété retourne uniquement le dictionnaire de ressources déclaré directement dans cet élément. Cela est différent de celui du processus de recherche de ressource réelle, où un élément enfant peut accéder à toutes les ressources définies dans chaque élément parent, la recherche de manière récursive vers le haut.  
  
 Peut également être référencées par le code à partir de la collection de ressources, mais n’oubliez pas que les ressources créées dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] sans aucun doute ne seront plus accessibles jusqu’après <xref:System.Windows.FrameworkElement.Loaded> est déclenché par l’élément qui déclare le dictionnaire. En fait, les ressources sont analysées de façon asynchrone et pas même le <xref:System.Windows.FrameworkElement.Loaded> événement est l’assurance que vous pouvez référencer un [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] défini de ressources. C’est pourquoi vous devez généralement accéder uniquement aux [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] définies des ressources dans le cadre du code au moment de l’exécution, ou par le biais des autres [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] techniques telles que les styles ou les références d’extension de ressource pour les valeurs d’attribut. Lorsque vous accédez aux ressources via le code, il est fondamentalement équivalent à un [DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) référence effectuée depuis [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Sous-jacent <xref:System.Windows.ResourceDictionary> prend en charge les méthodes requises pour ajouter, supprimer ou interroger les ressources à partir de la collection à l’aide de code. Le <xref:System.Windows.FrameworkElement.Resources%2A> propriété peut être définie pour prendre en charge le scénario du remplacement complet de la collection de ressources d’un élément à nouveau ou différent <xref:System.Windows.ResourceDictionary>.  
  
 Notez que le [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] syntaxe indiquée n’inclut pas un élément pour le <xref:System.Windows.ResourceDictionary>. Il s’agit d’un exemple de syntaxe de collection implicite ; une balise qui représente l’élément de collection peut être omise. Les éléments qui sont ajoutés en tant qu’éléments à la collection sont spécifiés à la place. Pour plus d’informations sur les collections implicites et [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], consultez [syntaxe de XAML en détail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Un cas où un <xref:System.Windows.ResourceDictionary> est encore spécifié explicitement comme un élément est si vous introduisez un dictionnaire fusionné, auquel cas il n’existe généralement aucun élément enfant pour qui <xref:System.Windows.ResourceDictionary>. Pour plus d’informations, consultez [dictionnaires de ressources fusionnés](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *oneOrMoreResourceElements*  
 Un ou plusieurs éléments objet, chacun d’eux définit une ressource. Chaque élément de propriété de ressource au sein de chaque <xref:System.Windows.ResourceDictionary> doit avoir une valeur unique pour le [Directive x : Key](~/docs/framework/xaml-services/x-key-directive.md), qui sert de clé unique lorsque les valeurs sont récupérées à partir de la <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
        <related type="Article" href="https://msdn.microsoft.com/library/1985cd45-f197-42d5-b75e-886add64b248">Attribut x : Key</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Attache une liaison à cet élément pour la propriété de dépendance spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * string -&gt; System.Windows.Data.BindingExpression" Usage="frameworkElement.SetBinding (dp, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Identifie la propriété de destination où la liaison doit être établie.</param>
        <param name="path">Le nom de propriété source ou le chemin d'accès à la propriété utilisée pour la liaison.</param>
        <summary>Rattache une liaison à cet élément, selon le nom de propriété source fourni comme une qualification de chemin d'accès à la source de données.</summary>
        <returns>Enregistre les conditions de la liaison. Cette valeur de retour peut être utile pour la vérification des erreurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>et crée un nouveau <xref:System.Windows.Data.Binding> selon fourni `path` paramètre. Cette signature est plus commode si vous établissez une liaison simple par défaut. Si vous avez besoin spécifier des propriétés de liaison à des conditions non définis par défaut, ou souhaitez utiliser un <xref:System.Windows.Data.MultiBinding> ou <xref:System.Windows.Data.PriorityBinding>, vous devez utiliser le <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> signature.  
  
   
  
## Examples  
 L’exemple suivant définit une liaison à l’aide d’un chemin d’accès spécifique.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberSignature Language="F#" Value="member this.SetBinding : System.Windows.DependencyProperty * System.Windows.Data.BindingBase -&gt; System.Windows.Data.BindingExpressionBase" Usage="frameworkElement.SetBinding (dp, binding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Identifie la propriété où la liaison doit être établie.</param>
        <param name="binding">Représente les spécificités de la liaison de données.</param>
        <summary>Attache une liaison à cet élément selon l’objet de liaison fourni.</summary>
        <returns>Enregistre les conditions de la liaison. Cette valeur de retour peut être utile pour la vérification des erreurs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est une méthode pratique pour appeler <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, qui passe l’instance actuelle comme le <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberSignature Language="F#" Value="static member SetFlowDirection : System.Windows.DependencyObject * System.Windows.FlowDirection -&gt; unit" Usage="System.Windows.FrameworkElement.SetFlowDirection (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Élément qui spécifie un sens de flux.</param>
        <param name="value">Valeur de l’énumération spécifiant le sens.</param>
        <summary>Définit la valeur de la propriété jointe <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> pour l’élément fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode prend en charge la syntaxe de propriété jointe pour le <xref:System.Windows.FrameworkElement.FlowDirection%2A> propriété, autorisant ainsi enfant des éléments de fourni <xref:System.Windows.FrameworkElement> pour spécifier le sens de déroulement pour la disposition au sein de leur élément parent. Pour définir la valeur sur actuel <xref:System.Windows.FrameworkElement>, utilisez la méthode directe [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] accesseur <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberSignature Language="F#" Value="member this.SetResourceReference : System.Windows.DependencyProperty * obj -&gt; unit" Usage="frameworkElement.SetResourceReference (dp, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Propriété à laquelle la ressource est liée.</param>
        <param name="name">Nom de la ressource.</param>
        <summary>Recherche une ressource avec le nom spécifié et lui paramètre une référence à une ressource pour la propriété spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une référence de ressource est similaire à l’utilisation d’un [Extension de balisage DynamicResource](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) dans le balisage. La référence de ressource crée une expression interne qui fournit la valeur de la propriété spécifiée sur une base différée d’exécution. L’expression sera réévaluée chaque fois que le dictionnaire de ressources indique une valeur modifiée par le biais des événements internes, ou chaque fois que l’élément actuel est apparenté à nouveau (une modification du parent modifierait le chemin de recherche du dictionnaire).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeResources : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeResources " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkElement.Resources" />.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkElement.Resources" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ceci renverra `true` tant qu’il existe au moins une ressource de clé local <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeStyle : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkElement.Style" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ceci renverra `true` si la <xref:System.Windows.Style> est définie localement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeTriggers : unit -&gt; bool" Usage="frameworkElement.ShouldSerializeTriggers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne si les processus de sérialisation doivent sérialiser le contenu de la propriété <see cref="P:System.Windows.FrameworkElement.Triggers" />.</summary>
        <returns><see langword="true" /> si la valeur de la propriété <see cref="P:System.Windows.FrameworkElement.Triggers" /> doit être sérialisée ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `true` si le <xref:System.Windows.FrameworkElement.Triggers%2A> propriété est définie localement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : System.Windows.SizeChangedEventHandler " Usage="member this.SizeChanged : System.Windows.SizeChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque les propriétés <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> ou <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> voient leur valeur se modifier sur cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés. Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.  
  
 Le système de disposition lit des propriétés dans la <xref:System.Windows.SizeChangedEventArgs> classe d’arguments de cet événement, afin de déterminer si les modifications de taille signalée doivent être considérée comme importantes. Ainsi, le système de disposition ou vos implémentations de mise en page spécifique au contrôle de ne pas forcer une modification de la disposition en raison de différences visuellement imperceptibles en hauteur ou largeur. Les différences imperceptibles peuvent être arrondis ou même résultat des calculs de des types de données à virgule flottante.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberSignature Language="F#" Value="member this.SourceUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.SourceUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la valeur source change pour toute propriété liée à cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement crée un alias pour le <xref:System.Windows.Data.Binding.SourceUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : System.Windows.Style with get, set" Usage="System.Windows.FrameworkElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style utilisé par cet élément quand il est rendu.</summary>
        <value>Style appliqué, non défini par défaut de l’élément, le cas échéant. Sinon, <see langword="null" />. La valeur par défaut d’un <see cref="T:System.Windows.FrameworkElement" /> construit par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour les contrôles, le style actuel est souvent fourni par un style par défaut de thèmes de contrôle ou à partir de styles généralement appliqué aux contrôles de ce type par les ressources au niveau page ou application (un style implicite). Cette propriété ne pas définie ou retour par défaut les styles (thème), mais il retourne un style implicite ou un style explicite qui agit sur l’élément. Dans le cas de styles implicites ou explicites, peu importe si le style est spécifié en tant que ressource ou défini localement.  
  
 Définition des styles comporte certaines restrictions. Vous pouvez réinitialiser l’ensemble <xref:System.Windows.FrameworkElement.Style%2A> propriété vers un nouveau <xref:System.Windows.Style> à tout moment, ce qui force une recomposition de disposition. Toutefois, dès que ce style est placé en cours d’utilisation par un élément chargé, le <xref:System.Windows.Style> doit être considéré comme sealed. Essayez d’apporter une modification à n’importe quelle propriété individuelle d’un style en cours d’utilisation (tels que quoi que ce soit dans la collection de <xref:System.Windows.Style.Setters%2A>) provoque une exception levée. Un style qui est défini dans le balisage est considéré comme en cours d’utilisation dès qu’il est chargé à partir d’un dictionnaire de ressources (pour les ressources), ou la page, dans qu'il est contenu est chargée (pour les styles intraligne).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> est une propriété de dépendance avec une priorité particulière. Définie localement style fonctionne généralement à la priorité la plus élevée dans le système de propriétés. Si le <xref:System.Windows.FrameworkElement.Style%2A> a la valeur null à ce stade, pendant le chargement du système de propriétés vérifie les styles implicites dans les ressources locales ou d’application qui spécifient ce type. Si le style est toujours la valeur null après cette étape, puis le style agissant à des fins de présentation vient généralement du style par défaut (thème), mais le style par défaut n’est pas retourné dans la <xref:System.Windows.FrameworkElement.Style%2A> valeur de propriété. Consultez [priorité de valeur de propriété de dépendance](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) ou [Styling and Templating](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *resourceExtension*  
 Une des opérations suivantes :, ou. Consultez [XAML ressources](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 La clé qui identifie le style demandé. La clé fait référence à une ressource existante dans un <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Syntaxe d’élément de propriété est techniquement possible, mais non recommandée pour la plupart des scénarios de style. Consultez [modèles et Styles intralignes](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Une référence de liaison à l’aide [TemplateBinding](~/docs/framework/wpf/advanced/templatebinding-markup-extension.md) ou <xref:System.Windows.Data.Binding> est également possible, mais rare.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 L’exemple suivant définit un style dans un dictionnaire de ressources.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.StyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété ambiante demandée.</param>
        <summary>Pour obtenir une description de ce membre, consultez la méthode <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns><see langword="true" /> si <paramref name="propertyName" /> est disponible ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.FrameworkElement> est castée en interface <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.FrameworkElement.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur d’objet arbitraire utilisable pour stocker des informations personnalisées sur cet élément.</summary>
        <value>La valeur prévue. Cette propriété n’a aucune valeur par défaut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est analogue aux propriétés de balise dans d’autres modèles de programmation de Microsoft, tel que Visual Basic pour Applications ou des Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> vise à fournir un emplacement de la propriété préexistant dans lequel vous pouvez stocker des informations personnalisées de base concernant les <xref:System.Windows.FrameworkElement> sans avoir à la sous-classe d’un élément.  
  
 Étant donné que cette propriété prend un objet, vous devez utiliser l’utilisation d’élément de propriété afin de définir le <xref:System.Windows.FrameworkElement.Tag%2A> propriété dans XAML pour autre chose qu’un objet avec un convertisseur de type connu et intégrées, telles qu’une chaîne. Objets utilisés de cette manière sont généralement pas dans les espaces de noms WPF standard et peuvent donc avoir besoin de mappage d’espace de noms à l’espace de noms externe afin d’être introduite en tant qu’éléments XAML. Pour plus d’informations, consultez [espaces de noms XAML et Namespace Mapping for WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) et [XAML et Classes personnalisées pour WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.TagProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TagProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.TagProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberSignature Language="F#" Value="member this.TargetUpdated : EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " Usage="member this.TargetUpdated : System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la valeur cible change pour une liaison de propriété sur cet élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement crée un alias pour le <xref:System.Windows.Data.Binding.TargetUpdated> événement est déclenché par tout <xref:System.Windows.Data.Binding> associé à cet élément. Cela signifie généralement que la liaison en question est une liaison bidirectionnelle, et que la propriété de dépendance liée affirme que la valeur de propriété précédente est désormais non valide selon un schéma de mise en cache qui prennent en charge la propriété ou la source de données ou de validation.  
  
 Utiliser les données d’événement de la <xref:System.Windows.FrameworkElement.TargetUpdated> événement pour déterminer la propriété spécifique qui signale la mise à jour de la valeur cible.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TemplatedParent : System.Windows.DependencyObject" Usage="System.Windows.FrameworkElement.TemplatedParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au modèle parent de cet élément. Cette propriété n’est pas pertinente si l’élément n’a pas été créé par l’intermédiaire d’un modèle.</summary>
        <value>L’élément dont <see cref="T:System.Windows.FrameworkTemplate" /> <see cref="P:System.Windows.FrameworkTemplate.VisualTree" /> a provoqué cet élément doit être créé. Cette valeur est souvent <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> est fréquemment `null` pour les objets qui sont créés dans votre code ou balisage d’application. Il s’agit, car vous créez ces objets directement, pas par le biais d’un modèle. Références d’objet obtenues en parcourant l’arborescence logique à partir de la racine, ou par des références de nom par défaut, ne proviennent pas d’un modèle.  
  
 Les cas où <xref:System.Windows.FrameworkElement.TemplatedParent%2A> peut ne pas être `null` incluent des opérations telles que le test de positionnement, de gestion des événements pour certains événements d’entrée bas niveau, en parcourant l’arborescence visuelle avec <xref:System.Windows.Media.VisualTreeHelper>, ou de l’utilisation d’énumérateurs, qui peuvent retourner des éléments à partir de modèles. Un autre cas est d’appeler spécifiquement <xref:System.Windows.FrameworkTemplate.FindName%2A> contre un existant <xref:System.Windows.FrameworkTemplate> et manipuler l’objet retourné.  
  
 Les modèles sont des objets en fait partagés où le contenu du modèle est créé une seule fois. Par conséquent, si vous obtenez une référence d’objet à un élément qui provenance d’un modèle, vous trouverez que l’arborescence logique apparente n’atteint pas à la racine de la page. Pour connecter une référence de modèle à l’arborescence logique de la page, vous devez obtenir le <xref:System.Windows.FrameworkElement.TemplatedParent%2A> valeur et continuer à parcourir cette arborescence d’éléments comme vous le souhaitez.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ToolTip : obj with get, set" Usage="System.Windows.FrameworkElement.ToolTip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet d'info-bulle affiché pour cet élément dans le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>L'objet d'info-bulle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de cette propriété est de type <xref:System.Windows.Controls.ToolTip>, cette valeur est alors l’info-bulle qui sera utilisé dans le [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Si la valeur est d’un autre type, cette valeur sera utilisée comme le *contenu* pour un <xref:System.Windows.Controls.ToolTip> fourni (construit) par le système. Pour plus d'informations, consultez <xref:System.Windows.Controls.ToolTipService>. La classe de service fournit des propriétés jointes qui peuvent être utilisées pour personnaliser davantage un <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *toolTipContent*  
 Chaîne qui devient le texte affiché pour le <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Objet fourni dans le formulaire d’élément objet, qui doit être utilisé comme contenu pour le <xref:System.Windows.FrameworkElement> . En règle générale, ce serait un <xref:System.Windows.FrameworkElement> ou tout autre élément qui crée une composition de disposition pour le <xref:System.Windows.FrameworkElement.ToolTip%2A>, contenant finalement le contenu de texte dans la composition. Dans ce cas, le <xref:System.Windows.Controls.ToolTip> élément est créé implicitement à partir d’analysée [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]et le *toolTipObjectContent* contenu est défini en tant que son <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> propriété.  
  
 <`ToolTip` .../>  
 Consultez <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Windows.Controls.ToolTip> dans le code, puis définit la <xref:System.Windows.FrameworkElement.ToolTip%2A> propriété sur un <xref:System.Windows.Controls.Primitives.StatusBar> contrôle.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberSignature Language="F#" Value="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipClosing : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant la fermeture d'une info-bulle sur l'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marquer le <xref:System.Windows.FrameworkElement.ToolTipClosing> événement comme géré n’annule pas la fermeture de l’info-bulle. Une fois que l’info-bulle s’affiche, fermeture de l’info-bulle est effectuée uniquement en réponse à une interaction utilisateur avec l’interface utilisateur.  
  
 Cet événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style. Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas d’ajouter/supprimer des méthodes d’événements pour l’événement de niveau de service.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Substituer <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> pour implémenter la gestion de classe pour cet événement dans les classes dérivées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipClosingEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberSignature Language="F#" Value="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " Usage="member this.ToolTipOpening : System.Windows.Controls.ToolTipEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit à l’ouverture d’une info-bulle sur l’élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour empêcher une info-bulle d’apparaître dans l’interface utilisateur, votre gestionnaire pour <xref:System.Windows.FrameworkElement.ToolTipOpening> pouvez marquer le <xref:System.Windows.Controls.ToolTipEventArgs> les données d’événement gérées. Sinon, l’info-bulle est affichée, à l’aide de la valeur de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propriété en tant que le contenu de l’info-bulle. Un autre scénario possible est que vous pouvez écrire un gestionnaire qui réinitialise la valeur de la <xref:System.Windows.FrameworkElement.ToolTip%2A> propriété pour l’élément qui est la source d’événements, juste avant que l’info-bulle s’affiche.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> n’est pas déclenché si la valeur de <xref:System.Windows.FrameworkElement.ToolTip%2A> est `null` ou autrement pas définie. Ne définissez pas délibérément <xref:System.Windows.FrameworkElement.ToolTip%2A> à `null` lorsqu’une info-bulle est ouverte ou ouverture ; cela n’a pas l’effet de la fermeture de l’info-bulle et crée en fait un artefact visuel indésirable dans l’interface utilisateur.  
  
 Le <xref:System.Windows.FrameworkElement.ToolTipOpening> événement ne peut pas être un <xref:System.Windows.EventTrigger> dans un style. Il s’agit, car le champ d’identificateur de cet événement réutilise une implémentation d’un service qui n’expose pas d’ajouter/supprimer des méthodes d’événements pour l’événement de niveau de service.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Substituer <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> pour implémenter la gestion de classe pour cet événement dans les classes dérivées.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipOpeningEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ToolTipProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Triggers : System.Windows.TriggerCollection" Usage="System.Windows.FrameworkElement.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la collection de déclencheurs établis directement sur cet élément ou dans les éléments enfants.</summary>
        <value>Collection fortement typée d’objets <see cref="T:System.Windows.Trigger" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette propriété peut uniquement être définie [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] via la syntaxe de collection indiquée, ou en accédant à l’objet de collection et en utilisant ses différentes méthodes telles que Add. La propriété pour accéder à l’objet de collection lui-même est en lecture seule, la collection elle-même est en lecture-écriture. La propriété existe uniquement sur les éléments racine. une tentative rechercher ou définir ailleurs entraîne une exception levée.  
  
 Cette propriété ne permet pas d’examiner des déclencheurs qui existent dans le cadre de styles en cours d’utilisation sur cet élément. Il signale uniquement la collection de déclencheurs qui sont littéralement ajoutés à la collection, soit dans le balisage ou de code. Éléments n’ont pas généralement ces éléments existants par défaut (via un modèle par exemple) ; Il est plus courant pour les déclencheurs qui proviennent de composition de contrôle établi dans les styles à la place.  
  
 En termes de comportement (et essaie d’établir quel effet provient de déclaré de l’élément <xref:System.Windows.FrameworkElement.Triggers%2A> collection), la condition de déclenchement et l’effet du déclencheur peut se trouver sur cet élément, ou sur ses éléments enfants dans l’arborescence logique. Notez que si vous utilisez des événements de durée de vie comme <xref:System.Windows.FrameworkElement.Loaded> pour obtenir cette collection, les déclencheurs de l’élément enfant peut ne pas encore être entièrement chargés et la collection sera plus petite qu’il serait réellement en cours d’exécution.  
  
 Notez que la collection de déclencheurs établie sur un élément prend uniquement en charge <xref:System.Windows.EventTrigger>, pas les déclencheurs de propriété (<xref:System.Windows.Trigger>). Si vous avez besoin déclencheurs de propriété, vous devez le placer dans un style ou un modèle et puis affecter ce style ou modèle soit à l’élément directement via le <xref:System.Windows.FrameworkElement.Style%2A> propriété, ou indirectement par le biais d’une référence de style implicite.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Utilisation des éléments de propriété XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *oneOrMoreTriggers*  
 Un ou plusieurs défini <xref:System.Windows.EventTrigger> éléments. Chaque déclencheur est censé contenir des références et les actions de plan conceptuel valide. Notez que cette collection peut uniquement être établie sur l’élément racine d’une page. Pour plus d’informations, consultez [Vue d’ensemble des plans conceptuels](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="frameworkElement.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Identificateur de clé de la ressource à rechercher.</param>
        <summary>Recherche une ressource avec la clé spécifiée et retourne cette ressource si elle est trouvée.</summary>
        <returns>Ressource trouvée ou <see langword="null" /> si aucune ressource avec l'argument <paramref name="key" /> n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la ressource est introuvable sur l’élément appelant, l’arborescence de la ressource parente est recherchée en amont dans l’arborescence logique, de la même façon que l’arborescence serait recherchée si une ressource était demandée par clé en cours d’exécution. La méthode retourne `null` uniquement si aucune ressource de cette clé existe n’importe où dans l’arborescence de la ressource, par les conditions existantes de l’arborescence au moment qui <xref:System.Windows.FrameworkElement.TryFindResource%2A> est appelée.  
  
 En règle générale, vous castez immédiatement la valeur de retour vers le type de la propriété que vous essayez de définir avec la valeur de la ressource retournée.  
  
 Le <xref:System.Windows.FrameworkElement.FindResource%2A> méthode a un comportement similaire, sauf qu’elle lève une exception si aucune ressource avec la clé fournie n’est retournée.  
  
   
  
## Examples  
 L’exemple suivant est implémenté comme un gestionnaire de bouton, où le bouton qui est cliqué définit son arrière-plan sur un pinceau défini par ressource obtenu en appelant <xref:System.Windows.FrameworkElement.TryFindResource%2A> sur lui-même. Cela présente l’arborescence d’éléments et recherche la ressource (la ressource elle-même est définie dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] et n’est pas affiché).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberSignature Language="F#" Value="member this.Unloaded : System.Windows.RoutedEventHandler " Usage="member this.Unloaded : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l'élément est supprimé d'une arborescence d'éléments chargés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les événements routés directs ne suivent pas d’itinéraire, ils sont gérés uniquement dans le même élément sur lequel ils sont déclenchés. Diriger les événements routés ne prennent pas en charge les autres comportements de l’événement routé : ils prennent en charge une collection de gestionnaires accessible et peut être utilisés comme un <xref:System.Windows.EventTrigger> dans un style.  
  
 <xref:System.Windows.FrameworkElement.Loaded> et <xref:System.Windows.FrameworkElement.Unloaded> peuvent tous deux être déclenchés sur des contrôles suite aux modifications du thème système initiée par l’utilisateur. Un changement de thème entraîne une invalidation du modèle de contrôle et l’arborescence visuelle de relation contenant-contenu, ce qui entraîne l’ensemble du contrôle décharger et recharger. Par conséquent <xref:System.Windows.FrameworkElement.Unloaded> ne peut pas être considéré comme se produit uniquement lorsque la navigation en dehors de la page.  
  
 Notez que le <xref:System.Windows.FrameworkElement.Unloaded> événement n’est pas déclenché après une application en cours d’arrêt a commencé. Arrêt de l’application se produit lorsque la condition définie par le <xref:System.Windows.Application.ShutdownMode%2A> propriété se produit. Si vous placez le code de nettoyage dans un gestionnaire pour le <xref:System.Windows.FrameworkElement.Unloaded> événement, comme pour un <xref:System.Windows.Window> ou un <xref:System.Windows.Controls.UserControl>, il ne peut pas être appelé comme prévu.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Informations sur les événements acheminés  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Stratégie de routage|Direct|  
|délégué|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnloadedEvent : System.Windows.RoutedEvent" Usage="System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie l'événement acheminé <see cref="E:System.Windows.FrameworkElement.Unloaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les identificateurs d’événements routés sont créés quand les événements routés sont inscrits. Ces identificateurs contiennent un nom identificateur, le type de propriétaire, le type de gestionnaire, la stratégie de routage et la méthode utilitaire pour ajouter des propriétaires à l’événement. Vous pouvez utiliser ces identificateurs pour ajouter des gestionnaires de classe.  
  
 Pour plus d’informations sur l’inscription des événements routés, consultez <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Pour plus d’informations sur l’utilisation des identificateurs d’événements routés pour ajouter des gestionnaires de classe, consultez <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.UnregisterName : string -&gt; unit" Usage="frameworkElement.UnregisterName name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom de la paire nom-objet à supprimer de la portée actuelle.</param>
        <summary>Simplifie l'accès à la méthode de désinscription <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez seulement désinscrire les noms si vous avez l’intention de réinscrire un autre élément portant ce nom même.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberSignature Language="F#" Value="member this.UpdateDefaultStyle : unit -&gt; unit" Usage="frameworkElement.UpdateDefaultStyle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réapplique le style par défaut au <see cref="T:System.Windows.FrameworkElement" /> actuel.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseLayoutRounding : bool with get, set" Usage="System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l’arrondi pour la disposition doit être appliqué à la taille et la position de cet élément lors de la disposition.</summary>
        <value><see langword="true" /> si l’arrondi pour la disposition est appliqué ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> propriété pour un élément est `true`, toutes les valeurs de pixel non intégrales sont calculées lors de la <xref:System.Windows.UIElement.Measure%2A> et <xref:System.Windows.UIElement.Arrange%2A> passes sont arrondies à des valeurs en pixels entières.  
  
 Cette propriété est héritée par les éléments enfants.  
  
> [!NOTE]
>  Vous devez définir <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> à `true` sur l’élément racine. Le système de disposition ajoute des coordonnées enfants aux coordonnées parent ; Par conséquent, si les coordonnées du parent ne sont pas sur une limite de pixel, les coordonnées enfants sont également pas sur une limite de pixel. Si <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> ne peut pas être défini à la racine, définissez <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> sur l’enfant pour obtenir l’effet souhaité.  
  
 Dessiner des objets sur les limites des pixels élimine les bords semi transparentes qui sont produites par l’anticrénelage lorsqu’un bord se trouve au milieu d’un pixel de périphérique. L’illustration suivante montre la sortie d’une ligne unique de largeur de pixels qui se trouve au milieu d’un pixel de périphérique. La ligne sur la gauche n’utilise pas l’arrondi de disposition et est lissé. La ligne sur la droite utilise l’arrondi de disposition.  
  
 ![Anti&#45;ligne possède un alias par rapport à la ligne d’un pixel unique. ] (~/add/media/pixelsnaplinecompare.PNG "Ligne lissée par rapport à la ligne d’un pixel unique.")  
  
 Lorsque vous utilisez l’arrondi de disposition et <xref:System.Windows.GridUnitType.Star> de dimensionnement, le système de disposition crée de petites variations dans les mesures de colonne ou une ligne pour éviter le rendu de sous-pixel. Par exemple, si une grille a une largeur totale de 100 avec 3 colonnes de taille <xref:System.Windows.GridUnitType.Star>, au lieu de créer trois colonnes qui ont une largeur égale de 33,3, le système de disposition crée 2 colonnes qui ont une largeur de 33 et qui a une largeur de 34.  
  
> [!NOTE]
>  Dans .NET 4.6 les modifications ont été apportées à l’arrondi de disposition pour réduire les instances de découpage dans les contrôles avec bordures. Par défaut, cette fonctionnalité est activée si votre version de Framework cible .NET Framework 4.6 ou ultérieure. Les applications qui ciblent des versions antérieures du framework peuvent choisir dans le nouveau comportement en ajoutant le paramètre suivant dans un fichier app.config : `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` Le paramètre prend uniquement effet lors de l’application est en cours d’exécution sur le .NET Framework 4.6.  
  
   
  
## Examples  
 L’exemple suivant illustre l’effet qui le <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> a de propriété sur une ligne unique-largeur en pixels. La ligne sur la gauche n’utilise pas l’arrondi de disposition et la ligne sur la droite utilise l’arrondi de disposition. Si vous redimensionnez la fenêtre lentement, vous pouvez voir la différence qu’arrondi de disposition fait.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UseLayoutRoundingProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalAlignment : System.Windows.VerticalAlignment with get, set" Usage="System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les caractéristiques d’alignement vertical appliquées à cet élément quand il est composé dans un élément parent, par exemple un contrôle de type Panel ou d’éléments.</summary>
        <value>Paramètre d’alignement vertical. La valeur par défaut est <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.FrameworkElement.Height%2A> et <xref:System.Windows.FrameworkElement.Width%2A> propriétés sont définies explicitement sur un élément, ces mesures sont prioritaires de disposition et annulent les effets normaux de la définition de cette propriété sur <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> est le [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] accesseur de propriété pour ce qui est en réalité une propriété de dépendance. Cette propriété de dépendance particulière a assez souvent et sa valeur « par défaut » apparente défini différemment dans les classes d’éléments dérivés, en particulier les contrôles. Cela se produit généralement dans un des deux façons : la propriété de dépendance est réinscrit à une classe dérivée particulière, mais avec des métadonnées différentes pour définir ses valeurs par défaut ; ou bien, il existe un style par défaut en cours d’application qui définit cette valeur de propriété de dépendance différemment. Par exemple, apparent « défaut » de <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> pour un <xref:System.Windows.Controls.ComboBoxItem> contrôle sera <xref:System.Windows.VerticalAlignment.Center>, même si <xref:System.Windows.Controls.ComboBoxItem> hérite <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> directement à partir de <xref:System.Windows.FrameworkElement>. Il s’agit, car cette valeur est réinitialisée dans le style par défaut de <xref:System.Windows.Controls.ComboBoxItem>, dans le modèle de contrôle du style.  
  
 <xref:System.Windows.Controls.Canvas> n’utilise pas <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> lors de la composition de disposition, car <xref:System.Windows.Controls.Canvas> est basé sur le positionnement absolu.  
  
 Cas hérité par <xref:System.Windows.Controls.ComboBoxItem> ou les classes dérivées, <xref:System.Windows.Controls.ComboBoxItem> redéfinit la valeur par défaut de cette propriété doit être <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’éléments enfants visuels dans cet élément.</summary>
        <value>Nombre d’éléments enfants visuels pour cet élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.FrameworkElement> implémentation de <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> retourne toujours zéro ou un. Les classes qui gèrent une collection d’enfants visuels qui peut dépasser un doivent remplacer cette propriété et <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Cette propriété est généralement utilisée pour déterminer les limites supérieures de la collection d’enfants actuelle à des fins de mise en œuvre des substitutions de disposition (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 L’exemple suivant montre comment un ornement personnalisé utilise les valeurs déclarées par un <xref:System.Windows.Media.VisualCollection> qu’il gère pour ses enfants visuels et signale ces valeurs via des substitutions de <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> et <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si votre classe prend en charge plusieurs enfants visuels dans une collection d’éléments enfants, substituez cette propriété pour retourner le nombre d’éléments dans cette collection. Vous devez effectuer cette opération même si l’objet de collection lui-même retourne un nombre. Logique de présentation d’élément au niveau du framework WPF part du principe que tous les éléments retournent un nombre valid via leurs <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> propriété.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Width : double with get, set" Usage="System.Windows.FrameworkElement.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la largeur de l'élément.</summary>
        <value>Largeur de l’élément, en [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. La valeur par défaut est <see cref="F:System.Double.NaN" />. Cette valeur doit être supérieure ou égale à 0.0. Consultez la section Notes pour plus d’informations sur la limite supérieure.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 C’est une des trois propriétés sur <xref:System.Windows.FrameworkElement> qui spécifient des informations sur la largeur.  Les deux autres sont <xref:System.Windows.FrameworkElement.MinWidth%2A> et <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  S’il existe un conflit entre ces valeurs, l’ordre d’application pour la détermination de la largeur réelle est le premier <xref:System.Windows.FrameworkElement.MinWidth%2A> doit être pris en compte, puis <xref:System.Windows.FrameworkElement.MaxWidth%2A>et enfin si chacun d'entre eux est dans les limites, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 La valeur de retour de cette propriété est toujours identique à n’importe quelle valeur a été définie. En revanche, la valeur de la <xref:System.Windows.FrameworkElement.ActualWidth%2A> peuvent varier. La mise en page peut avoir rejeté la taille suggérée pour une raison quelconque. En outre, le système de disposition fonctionne de façon asynchrone par rapport à l’ensemble du système de propriété de <xref:System.Windows.FrameworkElement.Width%2A> et a ne peut-être pas traitée cette modification de propriété de dimensionnement encore en particulier.  
  
 En outre acceptables <xref:System.Double> valeurs, cette propriété peut également être <xref:System.Double.NaN?displayProperty=nameWithType>. Ceci est la façon dont vous spécifiez le comportement de dimensionnement automatique. Dans [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] vous définissez la valeur à la chaîne « Auto » (non respect de la casse) pour activer le comportement de dimensionnement automatique. Comportement de dimensionnement automatique implique que l’élément remplissent la largeur à sa disposition. Notez toutefois que des contrôles spécifiques fournissent fréquemment des valeurs par défaut dans les styles par défaut qui désactive le comportement de dimensionnement, sauf si elle est réactivée spécifiquement automatique.  
  
 Outre la vérification de validation, il est une valeur supérieure non déterministe pour <xref:System.Windows.FrameworkElement.Width%2A> qui est appliquée par le système de disposition (il s’agit d’un très grand nombre, supérieur à <xref:System.Single.MaxValue?displayProperty=nameWithType> mais plus petit que <xref:System.Double.MaxValue?displayProperty=nameWithType>). Si vous dépassez cette limite, l’élément ne s’affichera pas et aucune exception n’est levée. Ne définissez pas <xref:System.Windows.FrameworkElement.Width%2A> à une valeur qui est beaucoup plus important que la taille maximale de n’importe quel affichage visuel, ou peut dépasser cette limite supérieure non déterministe.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Utilisation d'attributs XAML  
  
```  
<object Width="double"/>  
- or -  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Valeurs XAML  
 *double*  
 <xref:System.Double>  
  
 Représentation sous forme de chaîne un <xref:System.Double> valeur égale ou supérieure à 0.0. Consultez la section Notes pour plus d’informations sur la limite supérieure. Cette valeur est interprétée comme un [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] mesure. Chaînes n’incluent pas explicitement la virgule décimale. Par exemple, la valeur `1` est acceptable.  
  
 *qualifiedDouble*  
 Un *double* valeur comme décrit ci-dessus, suivie d’une des chaînes de déclaration d’unité suivantes : `px`, `in`, `cm`, `pt`.  
  
 `px` (valeur par défaut) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` pouces ; 1in == 96 px  
  
 `cm` centimètres ; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
 `Auto`  
 Active le comportement de dimensionnement automatique. Consultez la section Notes.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WidthProperty : System.Windows.DependencyProperty" Usage="System.Windows.FrameworkElement.WidthProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.FrameworkElement.Width" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>