<Type Name="Window" FullName="System.Windows.Window">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bafa1024a0a7ce66d57d19750ab4c0f6d3bfe2ae" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56385117" /></Metadata><TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <TypeSignature Language="F#" Value="type Window = class&#xA;    inherit ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permet de créer, configurer, afficher et gérer la durée de vie des fenêtres et boîtes de dialogue.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le point d’interaction entre un utilisateur et une application autonome est une fenêtre. Un [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] fenêtre se compose de deux zones distinctes :  
  
-   Une zone non cliente, qui héberge les ornements de windows, y compris une icône, le titre, le menu système, les boutons réduire, agrandir le bouton, bouton Restaurer, le bouton Fermer et une bordure.  
  
-   Une zone cliente, qui héberge le contenu spécifique à l’application.  
  
 Une fenêtre standard est illustrée dans la figure suivante :  
  
 ![Éléments de fenêtre](~/add/media/windowoverviewfigure1.PNG "éléments de fenêtre")  
  
 <xref:System.Windows.Window> encapsule la possibilité de créer, configurer, afficher et gérer la durée de vie des fenêtres et boîtes de dialogue et fournit les services clés suivants :  
  
 **Gestion de la durée de vie**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Gestion des fenêtres**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Apparence et le comportement**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Boîtes de dialogue**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 En outre, <xref:System.Windows.Application> expose la prise en charge spéciale pour la gestion de toutes les fenêtres dans une application :  
  
-   Application conserve une liste de toutes les fenêtres qui sont actuellement instanciés dans l’application. Cette liste est exposée par le <xref:System.Windows.Application.Windows%2A> propriété.  
  
-   Par défaut, <xref:System.Windows.Application.MainWindow%2A> est automatiquement définie avec une référence à la première <xref:System.Windows.Window> qui est instancié dans une application. Cela rendant ainsi la fenêtre de la fenêtre principale de l’application.  
  
 Un <xref:System.Windows.Window> peut être implémentée à l’aide du balisage, balisage et code-behind ou code.  
  
 <xref:System.Windows.Window> est principalement utilisée pour afficher les fenêtres et boîtes de dialogue pour les applications autonomes. Toutefois, pour les applications qui requièrent une navigation au niveau de la fenêtre, telles que des Assistants, vous pouvez utiliser <xref:System.Windows.Navigation.NavigationWindow> à la place. <xref:System.Windows.Navigation.NavigationWindow> dérive <xref:System.Windows.Window> et l’étend avec la prise en charge de la navigation de style navigateur.  
  
> [!NOTE]
>  Îles du contenu navigable peuvent être incorporés dans d’autres conteneurs de contenu et le contenu à l’aide de <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> doit `UnmanagedCode` autorisation de sécurité pour être instancié. Cela entraîne les conséquences suivantes :  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-applications autonomes déployées demande l’élévation d’autorisations lorsque lancée à partir de zones Internet ou Intranet Local.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] Cette demande quoi que ce soit inférieur à toutes les autorisations ne seront pas en mesure d’instancier des fenêtres ou boîtes de dialogue.  
  
 Pour plus d’informations sur les considérations de sécurité et de déploiement d’applications autonomes, consultez [stratégie de sécurité de WPF - sécurité de la plateforme](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Un <xref:System.Windows.Window> est un <xref:System.Windows.Controls.ContentControl>, ce qui signifie qu’il peut contenir un seul objet de tout type (par exemple, une chaîne, une image ou un panneau). Pour plus d'informations, consultez la classe <xref:System.Windows.Controls.ContentControl>. En outre, <xref:System.Windows.Window> est un élément racine et, par conséquent, ne peut pas être partie du contenu d’un autre élément.  
  
> [!NOTE]
>  Le <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, et <xref:System.Windows.Window.Left%2A> propriétés définies sur un <xref:System.Windows.Window> via un style s’appliquera pas en cours d’exécution.  
  
## <a name="customizing-the-window-control"></a>Personnalisation du contrôle de fenêtre  
 Pour appliquer les mêmes paramètres de propriété à plusieurs <xref:System.Windows.Window> contrôles, utiliser le <xref:System.Windows.FrameworkElement.Style%2A> propriété. Vous pouvez modifier la valeur par défaut <xref:System.Windows.Controls.ControlTemplate> pour donner le contrôle une apparence unique. Pour plus d’informations sur la création d’un <xref:System.Windows.Controls.ControlTemplate>, consultez [personnalisation de l’apparence d’un contrôle existant en créant un ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Pour afficher les parties et les États qui sont spécifiques à la <xref:System.Windows.Window>, consultez [fenêtre Styles et modèles](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Les propriétés de dépendance pour ce contrôle peuvent être définies par le style par défaut.  Si une propriété est définie par un style par défaut, la propriété peut changer à partir de sa valeur par défaut lorsque le contrôle s’affiche dans l’application. Le style par défaut est déterminé par le thème de bureau est utilisé lors de l’exécution de l’application.  Pour plus d’informations, consultez [thèmes WPF par défaut](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 L’exemple suivant montre comment une fenêtre standard est défini à l’aide de balisage uniquement :  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 L’exemple suivant montre comment une fenêtre standard est définie à l’aide de code :  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 L’exemple suivant montre comment une fenêtre standard est défini à l’aide d’une combinaison de balisage et code-behind.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur initialise la <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, et <xref:System.Windows.Window.Left%2A> propriétés leurs valeurs par défaut <xref:System.Windows.Window> valeurs.  
  
 Si une fenêtre est créée dans un <xref:System.AppDomain> qui a un <xref:System.Windows.Application> de l’objet, le constructeur ajoute le <xref:System.Windows.Window> objet à l’ensemble de <xref:System.Windows.Application>-gérés windows via le <xref:System.Windows.Application.Windows%2A> propriété de la <xref:System.Windows.Application> objet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour l’autorisation pour cet objet appeler des méthodes natives non sécurisées. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberSignature Language="F#" Value="member this.Activate : unit -&gt; bool" Usage="window.Activate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Essaie de mettre la fenêtre au premier plan et l'active.</summary>
        <returns><see langword="true" /> si la <see cref="T:System.Windows.Window" /> a pu être activée ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les règles qui déterminent si la fenêtre est activée sont les mêmes que celles utilisées par le [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` (fonction) (User32.dll).  
  
 Si la fenêtre est activée dans une application Windows Presentation Foundation qui n’est pas application de premier plan de l’utilisateur, <xref:System.Windows.Application.Activated> événement est déclenché.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’activer une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une fenêtre devient la fenêtre de premier plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre est activée (devient la fenêtre de premier plan) lorsque :  
  
-   La première ouverture de la fenêtre.  
  
-   Un utilisateur bascule vers une fenêtre en la sélectionnant avec la souris, en appuyant sur ALT + TAB, ou dans le Gestionnaire des tâches.  
  
-   Un utilisateur clique sur le bouton de fenêtre barre des tâches.  
  
 Windows qui doivent détecter lorsqu’elles deviennent actives peuvent gérer le <xref:System.Windows.Window.Activated> événement.  
  
 Une fois une fenêtre est activée tout d’abord, peuvent être désactivé et réactivé autant de fois pendant sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut inspecter <xref:System.Windows.Window.IsActive%2A> pour déterminer l’état d’activation dans lequel il se trouve dans.  
  
 Une application peut également être <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowsTransparency : bool with get, set" Usage="System.Windows.Window.AllowsTransparency" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la zone cliente d'une fenêtre prend en charge la transparence.</summary>
        <value><see langword="true" /> si la fenêtre prend en charge la transparence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Controls.Control.Background%2A> propriété d’une fenêtre est définie sur un transparent à l’aide de la couleur <xref:System.Windows.Media.Brushes.Transparent%2A> , par exemple, la fenêtre reste opaque. Cela signifie que le bureau et toutes les applications en cours d’exécution la fenêtre « beneath » ne peut pas être visibles. Pour activer ce type de transparence, <xref:System.Windows.Window.AllowsTransparency%2A> doit être définie sur `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> Pour faciliter la création de fenêtres non rectangulaires, il existe et, par conséquent, lorsque <xref:System.Windows.Window.AllowsTransparency%2A> a la valeur `true`, d’une fenêtre <xref:System.Windows.Window.WindowStyle%2A> propriété doit être définie sur <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Fenêtre qui a une valeur <see cref="P:System.Windows.Window.WindowStyle" /> autre que <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowsTransparencyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.AllowsTransparencyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberSignature Language="F#" Value="override this.ArrangeOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.ArrangeOverride arrangeBounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds"><see cref="T:System.Windows.Size" /> qui reflète la taille finale que la fenêtre doit utiliser pour se réorganiser elle et ses enfants.</param>
        <summary>Substituez cette méthode pour réorganiser et dimensionner une fenêtre et ses éléments enfants.</summary>
        <returns><see cref="T:System.Windows.Size" /> qui reflète la taille réelle utilisée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> n’est pas appelée lorsque le <xref:System.Windows.UIElement.Visibility%2A> propriété a la valeur <xref:System.Windows.Visibility.Collapsed>. Si la valeur de la <xref:System.Windows.UIElement.Visibility%2A> propriété est <xref:System.Windows.Visibility.Hidden> ou <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> est appelée.  
  
> [!NOTE]
>  Lorsque soit <xref:System.Windows.Window.Show%2A> ou <xref:System.Windows.Window.ShowDialog%2A> sont appelées, le <xref:System.Windows.UIElement.Visibility%2A> propriété d’un <xref:System.Windows.Window> est défini sur <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="window.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ferme manuellement une <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Window> peut être fermé à l’aide d’un des mécanismes bien connues, fournie par le système se trouve dans sa barre de titre, y compris :  
  
-   ALT + F4.  
  
-   Menu système &#124; **fermer**.  
  
-   **Fermer** bouton.  
  
 Un <xref:System.Windows.Window> peut également être fermée à l’aide d’un des mécanismes bien connus dans la zone cliente qui sont fournies par les développeurs, notamment :  
  
-   **Fichier** &#124; **Exit** sur une fenêtre principale.  
  
-   **Fichier** &#124; **fermer** ou un **fermer** bouton sur une fenêtre enfant.  
  
> [!NOTE]
>  **OK** et **Annuler** sont également des boutons sur une boîte de dialogue fournie par le développeur, bien que s’ils définissent probablement <xref:System.Windows.Window.DialogResult%2A>, qui ferme automatiquement une fenêtre qui a été ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Ces mécanismes exigent que vous puissiez appeler explicitement <xref:System.Windows.Window.Close%2A> pour fermer une fenêtre.  
  
> [!NOTE]
>  Si une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>et avec un <xref:System.Windows.Controls.Button> avec son <xref:System.Windows.Controls.Button.IsCancel%2A> propriété définie sur true, se ferme automatiquement lorsque le bouton est activé soit, ou ÉCHAP est enfoncée. Si la fenêtre a été ouvert à l’aide de <xref:System.Windows.Window.Show%2A>, toutefois, <xref:System.Windows.Window.Close%2A> doit être appelé explicitement, comme celui <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Gestionnaire d’événements pour le <xref:System.Windows.Controls.Button>.  
  
 Fermeture d’une fenêtre entraîne la <xref:System.Windows.Window.Closing> déclenchement d’événement. Si le <xref:System.Windows.Window.Closing> événement n’est pas annulé, ce qui suit se produit :  
  
-   Le <xref:System.Windows.Window> est supprimé de <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (si un <xref:System.Windows.Application> objet existe).  
  
-   Le <xref:System.Windows.Window> est supprimé du propriétaire <xref:System.Windows.Window> si la relation parent/enfant a été établie avant le détenu <xref:System.Windows.Window> a été indiqué et après le propriétaire <xref:System.Windows.Window> a été ouvert.  
  
-   L'événement <xref:System.Windows.Window.Closed> est déclenché.  
  
-   Ressources non managées créées par le <xref:System.Windows.Window> sont supprimés.  
  
-   Si <xref:System.Windows.Window.ShowDialog%2A> a été appelée pour afficher le <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> retourne.  
  
 Fermeture d’un <xref:System.Windows.Window> provoque des fenêtres qu’il possède pour être fermé. En outre, fermeture un <xref:System.Windows.Window> peut entraîner une application interrompre l’exécution en fonction de la façon dont le <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> propriété est définie.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre un **fichier** &#124; **Exit** menu géré pour appeler explicitement <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : EventHandler " Usage="member this.Closed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la fenêtre est sur le point de se fermer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois que cet événement est déclenché, une fenêtre ne peut être évitée de se fermer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" /> est défini, ou <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> ou <see cref="M:System.Windows.Window.Hide" /> est appelé pendant la fermeture d'une fenêtre.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberSignature Language="F#" Value="member this.Closing : System.ComponentModel.CancelEventHandler " Usage="member this.Closing : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit directement après l'appel de <see cref="M:System.Windows.Window.Close" /> et peut être géré pour annuler la fermeture de la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> peut être géré pour détecter si une fenêtre est en cours de fermeture (par exemple, lorsque <xref:System.Windows.Window.Close%2A> est appelée). En outre, <xref:System.Windows.Window.Closing> peut être utilisé pour empêcher la fermeture d’une fenêtre. Pour empêcher une fenêtre de fermeture, vous pouvez définir le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriété de la <xref:System.ComponentModel.CancelEventArgs> argument `true`.  
  
 Le <xref:System.Windows.Window.Closing> événement est déclenché lorsque <xref:System.Windows.Window.Close%2A> est appelée, si l’utilisateur clique sur le bouton Fermer d’une fenêtre, ou si l’utilisateur appuie sur ALT + F4.  
  
 Si une fenêtre enfant a été ouverte par sa fenêtre propriétaire en utilisant <xref:System.Windows.Window.Show%2A>et le propriétaire de la fenêtre est fermée, la fenêtre possédée <xref:System.Windows.Window.Closing> événement n’est pas déclenché. Si le propriétaire d’une fenêtre est fermé (consultez <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> n’est pas déclenché sur la fenêtre enfant.  
  
 Si <xref:System.Windows.Application.Shutdown%2A> est appelée, le <xref:System.Windows.Window.Closing> déclenché pour chaque fenêtre. Toutefois, si <xref:System.Windows.Window.Closing> est annulée, l’annulation est ignorée.  
  
 Si une session se termine, car un utilisateur se déconnecte ou arrête, <xref:System.Windows.Window.Closing> n’est pas déclenché ; gérer <xref:System.Windows.Application.SessionEnding> pour implémenter le code qui annule la fermeture de l’application.  
  
 Si vous souhaitez afficher et masquer une fenêtre plusieurs fois pendant la durée de vie d’une application, et vous ne souhaitez pas réinstancier la fenêtre chaque fois que vous l’afficher, vous pouvez gérer le <xref:System.Windows.Window.Closing> événement, cliquez sur Annuler et appeler le <xref:System.Windows.Window.Hide%2A> (méthode). Ensuite, vous pouvez appeler <xref:System.Windows.Window.Show%2A> sur la même instance pour la rouvrir.  
  
   
  
## Examples  
 L’exemple suivant montre un <xref:System.Windows.Window> qui détermine s’il doit l’intervention de l’utilisateur à fermer.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.UIElement.Visibility" /> est défini, ou <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> ou <see cref="M:System.Windows.Window.Close" /> est appelé pendant la fermeture d'une fenêtre.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberSignature Language="F#" Value="member this.ContentRendered : EventHandler " Usage="member this.ContentRendered : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après que le contenu de la fenêtre a été affiché.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la fenêtre n’a aucun contenu, cet événement n’est pas déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une fenêtre devient une fenêtre d’arrière-plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre est désactivée (devient une fenêtre d’arrière-plan) lorsque :  
  
-   Un utilisateur bascule vers une autre fenêtre de l’application actuelle.  
  
-   Un utilisateur bascule vers la fenêtre dans une autre application à l’aide de ALT + TAB ou à l’aide du Gestionnaire des tâches.  
  
-   Un utilisateur clique sur le bouton de barre des tâches pour une fenêtre dans une autre application.  
  
 Windows qui doivent détecter lorsqu’elles sont désactivées en gérant la <xref:System.Windows.Window.Deactivated> événement.  
  
 Une fois une fenêtre est désactivée, peut être réactivé et plusieurs reprises au cours de sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut inspecter <xref:System.Windows.Window.IsActive%2A> pour déterminer l’état d’activation dans lequel il se trouve dans.  
  
 Une application peut également être <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.DialogResult : Nullable&lt;bool&gt; with get, set" Usage="System.Windows.Window.DialogResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la valeur du résultat de la boîte de dialogue, qui est la valeur retournée depuis la méthode <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Valeur <see cref="T:System.Nullable`1" /> de type <see cref="T:System.Boolean" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> peut être utilisé à partir du code qui vous a montré une boîte de dialogue pour déterminer si un utilisateur a accepté (`true`) ou annulée (`false`) la boîte de dialogue. Si une boîte de dialogue a été acceptée, cela signifie pour le code qui a ouvert la boîte de dialogue pour récupérer les données qui ont été collectées par l’utilisateur et les traiter. Si une boîte de dialogue a été annulée, toutefois, autres que le code appelant doit s’arrêter tout traitement supplémentaire.  
  
 Par défaut, une boîte de dialogue est annulée lorsqu’un utilisateur effectue une des opérations suivantes :  
  
-   PressesALT + F4.  
  
-   Clique sur le **fermer** bouton.  
  
-   Sélectionne **fermer** à partir du menu système.  
  
 Dans tous ces cas, <xref:System.Windows.Window.DialogResult%2A> est `false` par défaut.  
  
 Une boîte de dialogue propose généralement un bouton spécial pour annuler une boîte de dialogue, qui est le bouton dont <xref:System.Windows.Controls.Button.IsCancel%2A> propriété est définie sur `true`. Un bouton configuré de cette façon fermera automatiquement une fenêtre lorsqu’elle est soit activée, ou lorsque la touche ÉCHAP est enfoncée. Dans ces cas, <xref:System.Windows.Window.DialogResult%2A> reste `false`.  
  
 Une boîte de dialogue fournit également généralement un bouton Accepter, qui est le bouton dont <xref:System.Windows.Controls.Button.IsDefault%2A> propriété est définie sur `true`. Un bouton configuré de cette manière déclenche son <xref:System.Windows.Controls.Primitives.ButtonBase.Click> événement lorsqu’il ou la touche entrée est enfoncée. Toutefois, il ne ferme pas automatiquement la boîte de dialogue, n’est pas la valeur <xref:System.Windows.Window.DialogResult%2A> à `true`. Vous devez écrire ce code manuellement, généralement à partir de la <xref:System.Windows.Controls.Primitives.ButtonBase.Click> Gestionnaire d’événements pour le bouton par défaut.  
  
 <xref:System.Windows.Window.DialogResult%2A> est `null` lorsque la boîte de dialogue s’affiche, mais ni acceptée ni annulée.  
  
 Une fois une boîte de dialogue se ferme, vous pouvez obtenir le résultat de la boîte de dialogue à partir de la valeur retournée par <xref:System.Windows.Window.ShowDialog%2A> (méthode), ou en examinant la <xref:System.Windows.Window.DialogResult%2A> propriété.  
  
 <xref:System.Windows.Window.DialogResult%2A> peut uniquement être définie lorsque un <xref:System.Windows.Window> est ouvert en appelant son <xref:System.Windows.Window.ShowDialog%2A> (méthode).  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment configurer un bouton OK et un bouton Annuler pour retourner le texte approprié <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Window.DialogResult" /> est défini avant qu'une fenêtre ne soit ouverte en appelant <see cref="M:System.Windows.Window.ShowDialog" />.  
  
ou 
 <see cref="P:System.Windows.Window.DialogResult" /> est défini sur une fenêtre qui est ouverte en appelant <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberSignature Language="F#" Value="member this.DpiChanged : System.Windows.DpiChangedEventHandler " Usage="member this.DpiChanged : System.Windows.DpiChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit après la modification de la résolution de l’écran d’affichage de la fenêtre.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DpiChangedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Window.DpiChangedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEvent" /> lorsque la résolution de l’écran de la fenêtre est modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberSignature Language="F#" Value="member this.DragMove : unit -&gt; unit" Usage="window.DragMove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permet de faire glisser une fenêtre à l'aide du bouton gauche de la souris au-dessus d'une zone exposée de la zone cliente de la fenêtre.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le bouton gauche de la souris doit être enfoncé lorsque <xref:System.Windows.Window.DragMove%2A> est appelée. La première consiste à détecter lorsque le bouton gauche de la souris est enfoncé pour gérer le <xref:System.Windows.UIElement.MouseLeftButtonDown> événement.  
  
 Lorsque <xref:System.Windows.Window.DragMove%2A> est appelée, la gauche bouton de la souris doit être relâché au-dessus d’une zone exposée de la zone cliente de la fenêtre.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment substituer <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> pour appeler <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le bouton gauche de la souris n'est pas enfoncé.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation de faire glisser une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetWindow : System.Windows.DependencyObject -&gt; System.Windows.Window" Usage="System.Windows.Window.GetWindow dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Objet de dépendance.</param>
        <summary>Retourne une référence à l'objet <see cref="T:System.Windows.Window" /> qui héberge l'arborescence de contenu à l'intérieur de laquelle se trouve l'objet de dépendance.</summary>
        <returns>Référence <see cref="T:System.Windows.Window" /> à la fenêtre hôte.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="window.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend une fenêtre invisible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre n’est pas fermée lorsqu’elle est masquée et ni le <xref:System.Windows.Window.Closing> ni <xref:System.Windows.Window.Closed> événement est déclenché. Au lieu de cela, la fenêtre <xref:System.Windows.UIElement.Visibility%2A> propriété est définie sur <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Si une fenêtre est l’application <xref:System.Windows.Application.MainWindow%2A> et l’application <xref:System.Windows.Application.ShutdownMode%2A> est <xref:System.Windows.ShutdownMode.OnMainWindowClose>, l’application ne s’arrête pas. De même, l’application ne s’arrête pas si une fenêtre est la seule fenêtre et le mode d’arrêt de l’application est <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Si vous souhaitez afficher et masquer une fenêtre plusieurs fois pendant la durée de vie d’une application, et vous ne souhaitez pas ré-instancier la fenêtre à chaque fois que vous l’afficher, vous pouvez gérer le <xref:System.Windows.Window.Closing> événement, cliquez sur Annuler et appeler le <xref:System.Windows.Window.Hide%2A> (méthode). Ensuite, vous pouvez appeler <xref:System.Windows.Window.Show%2A> sur la même instance pour la rouvrir.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Hide" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Icon : System.Windows.Media.ImageSource with get, set" Usage="System.Windows.Window.Icon" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une icône de fenêtre.</summary>
        <value>Objet <see cref="T:System.Windows.Media.ImageSource" /> qui représente l'icône.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les applications autonomes Windows Presentation Foundation (WPF) ont deux types d’icônes :  
  
-   Une icône d’assembly, qui est spécifiée à l’aide de la `<ApplicationIcon>` fichier de génération de propriété dans le projet de l’application. Cette icône est utilisée en tant que l’icône du bureau pour un assembly.  
  
    > [!NOTE]
    >  Lors du débogage dans Visual Studio, votre icône ne peut pas apparaître en raison du processus d’hébergement. Si vous exécutez le fichier exécutable, l’icône s’affiche. Pour plus d’informations, consultez [Processus d’hébergement (vshost.exe)](https://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Une icône par fenêtre spécifiée en définissant <xref:System.Windows.Window.Icon%2A>. Pour chaque fenêtre, cette icône est utilisée dans sa barre de titre, son bouton de barre de tâche et dans son entrée de liste de sélection d’application ALT-TAB.  
  
 Une fenêtre WPF affiche toujours une icône. Lorsque un n’est pas fourni en définissant <xref:System.Windows.Window.Icon%2A>, WPF choisit une icône à afficher selon les règles suivantes :  
  
1.  Utilisez l’icône de l’assembly, s’il est spécifié.  
  
2.  Si l’icône de l’assembly n’est pas spécifié, utilisez l’icône de Microsoft Windows par défaut.  
  
 Si vous utilisez <xref:System.Windows.Window.Icon%2A> pour spécifier une icône de fenêtre personnalisée, vous pouvez restaurer l’icône d’application par défaut en définissant <xref:System.Windows.Window.Icon%2A> à `null`.  
  
 Une seule icône peut être utilisée de plusieurs façons dans Windows, y compris affichées dans la barre de titre d’une fenêtre, la barre des tâches pour une fenêtre, la liste de sélection de fichier ALT + TAB. Chacune de ces affiche l’icône à l’aide d’une taille différente ; une icône de 16 x 16 pixels s’affiche dans la barre de titre d’une fenêtre et dans la barre des tâches, tandis qu’une icône 32 x 32 pixels s’affiche dans la liste de sélection de fichier ALT + TAB. Certaines applications, telles que [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], fournir un **vue** menu qui vous permet de choisir la taille de l’icône que vous souhaitez afficher.  
  
 Afin de répondre aux différentes tailles d’affichage, un fichier icône se compose d’un ou plusieurs icônes réelles où chacun d’eux représente une version de l’icône qui cible une profondeur de couleur et de taille spécifique. Par exemple, une icône peut avoir uniquement une seule icône 16 x 16 pixels avec 16 couleurs, tandis qu’un autre peut contenir 16 x 16 pixels et des icônes de 32 x 32 pixels avec 16 couleurs et 256 couleurs.  
  
 Si les icônes pour toutes les tailles et couleurs profondeurs possibles existent au sein d’un fichier icône, <xref:System.Windows.Window> utilisera l’icône appropriée. Si un fichier icône contient uniquement un sous-ensemble de toutes les icônes possibles, <xref:System.Windows.Window> utilise l’icône la plus appropriée suivante par ordre décroissant de taille et profondeur de couleur.  
  
 Il en résulte qu’une icône sera toujours utilisée par <xref:System.Windows.Window>, même si le n’a pas la profondeur de couleur et la taille requise. Par exemple, une icône de 16 x 16 pixels avec 16 couleurs peut être utilisée pour l’affichage sous forme d’icône 32 x 32 pixels avec 256 couleurs. Cela peut entraîner des effets visuels indésirables, tels que pixellisation, mais peut être évité en créant des icônes pour tous les tailles et palettes de couleurs.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.IconProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir une icône de fenêtre.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation définir l’icône. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IconProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IconProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsActive : bool" Usage="System.Windows.Window.IsActive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la fenêtre est active.</summary>
        <value><see langword="true" /> si la fenêtre est active ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre active est la fenêtre de premier plan actuelle de l’utilisateur et a le focus, ce qui est signalé par l’apparence de la barre de titre active. Une fenêtre active est toujours le plus élevé de toutes les fenêtres de niveau supérieur qui ne définissent pas explicitement le <xref:System.Windows.Window.Topmost%2A> propriété.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.IsActiveProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsActiveProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.IsActiveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Left : double with get, set" Usage="System.Windows.Window.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du bord gauche de la fenêtre par rapport au bureau.</summary>
        <value>Position du bord gauche de la fenêtre, en unités logiques (1/96e de pouce).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Window> est agrandie ou réduite, cette valeur représente le bord gauche de la restauration point pour le <xref:System.Windows.Window>.  
  
 Cette propriété ne peut pas être définie via un style.  
  
 Si vous ne spécifiez pas une valeur, <xref:System.Windows.Window.Left%2A> est définie sur la valeur par défaut du système. Vous pouvez également spécifier la valeur par défaut du système en définissant <xref:System.Windows.Window.Left%2A> à <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> est une valeur valide pour <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.LeftProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LeftProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.LeftProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque l’emplacement de la fenêtre est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Emplacement d’une fenêtre change lorsque :  
  
-   Un utilisateur déplace une fenêtre en faisant glisser avec la barre de titre de la fenêtre.  
  
-   Une fenêtre est déplacée après <xref:System.Windows.Window.DragMove%2A> est appelée.  
  
-   Soit le <xref:System.Windows.Window.Left%2A> ou <xref:System.Windows.Window.Top%2A> propriété est définie par programmation.  
  
-   Le **déplacer** élément de menu du menu du système d’une fenêtre est sélectionnée.  
  
-   Le <xref:System.Windows.Window.WindowState%2A> propriété est modifiée.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogicalChildren : System.Collections.IEnumerator" Usage="System.Windows.Window.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reçoit un énumérateur pour les éléments enfants logiques d'une fenêtre.</summary>
        <value><see cref="T:System.Collections.IEnumerator" /> des éléments enfants logiques d'une fenêtre.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="override this.MeasureOverride : System.Windows.Size -&gt; System.Windows.Size" Usage="window.MeasureOverride availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize"><see cref="T:System.Windows.Size" /> qui reflète la taille disponible que cette fenêtre peut donner à l'enfant. L'infini peut être renseigné comme valeur pour que la fenêtre soit redimensionnée en fonction du contenu disponible.</param>
        <summary>Substituez cette méthode pour mesurer la taille d'une fenêtre.</summary>
        <returns><see cref="T:System.Windows.Size" /> qui reflète la taille dont la fenêtre estime avoir besoin pendant la disposition, en fonction du calcul de la taille de ses enfants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> n’est pas appelée lorsque le <xref:System.Windows.UIElement.Visibility%2A> propriété a la valeur <xref:System.Windows.Visibility.Collapsed>. Si la valeur de la <xref:System.Windows.UIElement.Visibility%2A> propriété est <xref:System.Windows.Visibility.Hidden> ou <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> est appelée.  
  
> [!NOTE]
>  Lorsque soit <xref:System.Windows.Window.Show%2A> ou <xref:System.Windows.Window.ShowDialog%2A> sont appelées, le <xref:System.Windows.UIElement.Visibility%2A> propriété d’un <xref:System.Windows.Window> est défini sur <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="window.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnActivated%2A> déclenche l'événement <xref:System.Windows.Window.Activated>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnActivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnActivated%2A> sur la classe de base si <xref:System.Windows.Window.Activated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : EventArgs -&gt; unit&#xA;override this.OnClosed : EventArgs -&gt; unit" Usage="window.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosed%2A> déclenche l'événement <xref:System.Windows.Window.Closed>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnClosed%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnClosed%2A> sur la classe de base si <xref:System.Windows.Window.Closed> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnClosing : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="window.OnClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.ComponentModel.CancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnClosing%2A> déclenche l'événement <xref:System.Windows.Window.Closing>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnClosing%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnClosing%2A> sur la classe de base si <xref:System.Windows.Window.Closing> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberSignature Language="F#" Value="override this.OnContentChanged : obj * obj -&gt; unit" Usage="window.OnContentChanged (oldContent, newContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Référence à la racine de l'ancienne arborescence de contenu.</param>
        <param name="newContent">Référence à la racine de la nouvelle arborescence de contenu.</param>
        <summary>Appelée lorsque la propriété <see cref="P:System.Windows.Controls.ContentControl.Content" /> est modifiée.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentRendered : EventArgs -&gt; unit&#xA;override this.OnContentRendered : EventArgs -&gt; unit" Usage="window.OnContentRendered e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnContentRendered%2A> déclenche l'événement <xref:System.Windows.Window.ContentRendered>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnContentRendered%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnContentRendered%2A> sur la classe de base si <xref:System.Windows.Window.ContentRendered> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="window.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée et retourne un objet <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> pour ce <see cref="T:System.Windows.Window" />.</summary>
        <returns>Objet <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> pour ce <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="window.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnDeactivated%2A> déclenche l'événement <xref:System.Windows.Window.Deactivated>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnDeactivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnDeactivated%2A> sur la classe de base si <xref:System.Windows.Window.Deactivated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="window.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Le paramètre d’échelle ppp précédent.</param>
        <param name="newDpi">Le nouveau paramètre d’échelle ppp.</param>
        <summary>Appelé lorsque la résolution d’affichage de cette fenêtre change.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="window.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnLocationChanged%2A> déclenche l'événement <xref:System.Windows.Window.LocationChanged>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnLocationChanged%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnLocationChanged%2A> sur la classe de base si <xref:System.Windows.Window.LocationChanged> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="window.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données de l'événement.</param>
        <summary>Appelée lorsque l'événement <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> se produit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette implémentation ne modifie pas l’état géré (les <xref:System.Windows.RoutedEventArgs.Handled%2A> propriété) de la <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> données d’événement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous substituez <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, toujours appeler l’implémentation de base votre <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> implémentation. Faute d’appeler l’implémentation de base empêche les classes de base à partir de la gestion de l’événement, ce qui peut modifier le comportement au moment de l’exécution de la classe finale. Vous pouvez appeler l’implémentation de base avant ou après le traitement spécial, selon vos besoins.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSourceInitialized : EventArgs -&gt; unit&#xA;override this.OnSourceInitialized : EventArgs -&gt; unit" Usage="window.OnSourceInitialized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnSourceInitialized%2A> déclenche l'événement <xref:System.Windows.Window.SourceInitialized>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnSourceInitialized%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnSourceInitialized%2A> sur la classe de base si <xref:System.Windows.Window.SourceInitialized> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStateChanged : EventArgs -&gt; unit&#xA;override this.OnStateChanged : EventArgs -&gt; unit" Usage="window.OnStateChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.OnStateChanged%2A> déclenche l'événement <xref:System.Windows.Window.StateChanged>.  
  
 Un type qui dérive de <xref:System.Windows.Window> peuvent substituer <xref:System.Windows.Window.OnStateChanged%2A>. La méthode substituée doit appeler <xref:System.Windows.Window.OnStateChanged%2A> sur la classe de base si <xref:System.Windows.Window.StateChanged> doit être déclenché.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded"><see cref="T:System.Windows.Media.Visual" /> ajouté à la collection.</param>
        <param name="visualRemoved"><see cref="T:System.Windows.Media.Visual" /> supprimé de la collection.</param>
        <summary>Appelé lorsque le <see cref="T:System.Windows.Media.VisualCollection" /> de l’objet <see cref="T:System.Windows.Window" /> est modifié.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="window.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Parent précédent. Valeur null si le <see cref="T:System.Windows.DependencyObject" /> n'avait pas de parent précédent.</param>
        <summary>Appelé lorsque le parent de la fenêtre est modifié.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnedWindows : System.Windows.WindowCollection" Usage="System.Windows.Window.OwnedWindows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de fenêtres dont cette fenêtre est propriétaire.</summary>
        <value><see cref="T:System.Windows.WindowCollection" /> qui contient des références aux fenêtres dont cette fenêtre est propriétaire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre enfant est une dont <xref:System.Windows.Window.Owner%2A> propriété est définie avec une référence à une autre fenêtre, qui est connue en tant que la fenêtre propriétaire. Pour rechercher toutes les fenêtres une fenêtre propriétaire, vous pouvez énumérer <xref:System.Windows.WindowCollection> qui est retourné par la <xref:System.Windows.Window.OwnedWindows%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre comment énumérer <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Owner : System.Windows.Window with get, set" Usage="System.Windows.Window.Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la <see cref="T:System.Windows.Window" /> qui possède cette <see cref="T:System.Windows.Window" />.</summary>
        <value>Objet <see cref="T:System.Windows.Window" /> qui représente le propriétaire de cette <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand une fenêtre enfant est ouverte par une fenêtre parente en appelant <xref:System.Windows.Window.ShowDialog%2A>, une relation implicite est établie entre parent et enfant. Cette relation applique certains comportements, notamment en ce qui concerne la réduction, l’optimisation et la restauration.  
  
 Quand une fenêtre enfant est créée par une fenêtre parente en appelant <xref:System.Windows.Window.Show%2A>, toutefois, la fenêtre enfant n’a pas d’une relation avec la fenêtre parente. Cela signifie que :  
  
-   La fenêtre enfant n’a pas une référence à la fenêtre parente.  
  
-   Le comportement de la fenêtre enfant n’est pas dépendant sur le comportement de la fenêtre parente. une fenêtre peut couvrir l’autre, ou être réduite, agrandie et restaurée indépendamment de l’autre.  
  
 Vous permet de créer une relation entre une fenêtre enfant et une fenêtre parente, <xref:System.Windows.Window> prend en charge la notion de propriété. La propriété est établie lorsque la <xref:System.Windows.Window.Owner%2A> propriété d’une fenêtre (la fenêtre enfant) est définie avec une référence à une autre fenêtre (la fenêtre propriétaire).  
  
 Une fois que cette relation est établie, les comportements suivants sont d’application :  
  
-   Si une fenêtre propriétaire est réduite, ses fenêtres enfants sont ainsi réduits.  
  
-   Si une fenêtre enfant est réduite, son propriétaire n’est pas réduite.  
  
-   Si une fenêtre propriétaire est réduite, la fenêtre propriétaire et ses fenêtres enfants sont restaurés.  
  
-   Une fenêtre propriétaire ne peut jamais couvrir une fenêtre enfant.  
  
-   Fenêtres enfants qui n’ont pas été ouvertes à l’aide de <xref:System.Windows.Window.ShowDialog%2A> ne sont pas modales. L’utilisateur peut toujours interagir avec la fenêtre propriétaire.  
  
-   Si vous fermez une fenêtre propriétaire, ses fenêtres enfants sont également fermés.  
  
-   Si une fenêtre enfant a été ouverte par sa fenêtre propriétaire en utilisant <xref:System.Windows.Window.Show%2A>et le propriétaire de la fenêtre est fermée, la fenêtre possédée <xref:System.Windows.Window.Closing> événement n’est pas déclenché.  
  
 Lorsque vous ouvrez une fenêtre enfant en appelant <xref:System.Windows.Window.ShowDialog%2A>, vous devez également définir le <xref:System.Windows.Window.Owner%2A> propriété de la fenêtre enfant. Si vous ne le faites pas, vos utilisateurs ne sont pas être en mesure de restaurer la fenêtre enfant et fenêtre parente en appuyant sur le bouton de barre des tâches. Au lieu de cela, en appuyant sur le bouton de barre des tâches génèrera une liste de windows, y compris la fenêtre enfant et parent, pour les utilisateurs ; seule la fenêtre sélectionnée est restaurée.  
  
> [!IMPORTANT]
>  Vous devez également définir le <xref:System.Windows.Window.Owner%2A> propriété sur une fenêtre est ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A> pour garantir un comportement correct avec.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment établir la relation parentes.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Une fenêtre essaie d'être son propre propriétaire. 
ou 
Deux fenêtres essaient de se posséder l'une l'autre.</exception>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Windows.Window.Owner" /> est définie sur une fenêtre visible affichée à l'aide de <see cref="M:System.Windows.Window.ShowDialog" />.  
  
ou 
La propriété <see cref="P:System.Windows.Window.Owner" /> est définie avec une fenêtre qui n'a pas été affichée auparavant.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeMode : System.Windows.ResizeMode with get, set" Usage="System.Windows.Window.ResizeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le mode de redimensionnement.</summary>
        <value>Valeur <see cref="T:System.Windows.ResizeMode" /> spécifiant le mode de redimensionnement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il existe quatre options :  
  
-   **NoResize**. L’utilisateur ne peut pas redimensionner la fenêtre. Les zones d’agrandissement et réduction ne sont pas affichés.  
  
-   **CanMinimize**. L’utilisateur peut uniquement réduire la fenêtre et restaurez-la à partir de la barre des tâches. Les cases Réduire et Agrandir sont affichés, mais seule la case réduire est activée.  
  
-   **CanResize**. L’utilisateur a la pleine possibilité de redimensionner la fenêtre, en utilisant les cases Réduire et agrandir et un plan déplaçable autour de la fenêtre. Les cases Réduire et Agrandir sont affichés et activés. (Valeur par défaut).  
  
-   **CanResizeWithGrip**. Cette option a la même fonctionnalité que <xref:System.Windows.ResizeMode.CanResize>, mais ajoute une « poignée de redimensionnement » vers le coin inférieur droit de la fenêtre.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ResizeModeProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ResizeModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ResizeModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberSignature Language="F#" Value="member this.RestoreBounds : System.Windows.Rect" Usage="System.Windows.Window.RestoreBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille et l'emplacement d'une fenêtre avant qu'elle ne soit réduite ou agrandie.</summary>
        <value><see cref="T:System.Windows.Rect" /> qui spécifie la taille et l'emplacement d'une fenêtre avant sa réduction ou son agrandissement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le rectangle de restauration est la région occupée par la fenêtre avant qu’il a été réduite ou agrandie. Vous pouvez utiliser <xref:System.Windows.Window.RestoreBounds%2A> pour enregistrer la dernière taille et l’emplacement d’une fenêtre avant la fermeture d’une application et récupérer ces valeurs la prochaine fois qu’une application commence à restaurer une fenêtre à la façon dont un utilisateur l’a laissé.  
  
 Si vous interrogez <xref:System.Windows.Window.RestoreBounds%2A> avant l’affichage de la fenêtre ou qui a été fermée, <xref:System.Windows.Rect.Empty%2A> est retournée.  
  
> [!NOTE]
>  Impossible d’obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Windows.Window.RestoreBounds%2A> et le stockage isolé pour vérifier que la taille et l’emplacement d’une fenêtre sont les mêmes qu’ils lors du dernier affichage de la fenêtre.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation de requête pour la taille et l’emplacement d’une fenêtre rectangle englobant. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="window.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une fenêtre et retourne sans attendre la fermeture de la nouvelle fenêtre ouverte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque la <xref:System.Windows.Window> classe est instanciée, elle n’est pas visible par défaut. <xref:System.Windows.Window.Show%2A> affiche une fenêtre et retourne immédiatement, sans attendre que la fenêtre à fermer. Par conséquent, la fenêtre ouverte n’empêche pas les utilisateurs d’interagir avec d’autres fenêtres dans l’application. Ce type de fenêtre est appelé un *non modale* fenêtre. Des exemples courants de windows non modales sont palettes, boîtes à outils et fenêtres de propriétés. Pour empêcher un utilisateur à l’interaction avec une fenêtre spécifique, la fenêtre doit être ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Une fenêtre est ouverte en appelant <xref:System.Windows.Window.Show%2A> est pas automatiquement ont une relation avec la fenêtre qui l’a ouverte ; plus précisément, la fenêtre ouverte ne sait pas quelle fenêtre ouverte. Cette relation peut être établie à l’aide de la <xref:System.Windows.Window.Owner%2A> propriété et géré à l’aide du <xref:System.Windows.Window.OwnedWindows%2A> propriété.  
  
 Appel <xref:System.Windows.Window.Show%2A> donne le même résultat final en tant que paramètre <xref:System.Windows.UIElement.Visibility%2A> propriété de la <xref:System.Windows.Window> objet <xref:System.Windows.Visibility.Visible>. Toutefois, il est une différence entre les deux à partir d’une perspective de minutage.  
  
 Appel <xref:System.Windows.Window.Show%2A> est une opération synchrone qui retourne uniquement une fois que le <xref:System.Windows.FrameworkElement.Loaded> événement sur la fenêtre enfant a été déclenché :  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Paramètre <xref:System.Windows.UIElement.Visibility%2A>, toutefois, est une opération asynchrone qui retourne immédiatement :  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 Lors de la définition <xref:System.Windows.UIElement.Visibility%2A>, les événements de fenêtre enregistrés avant de définir <xref:System.Windows.UIElement.Visibility%2A> ne peut pas être déclenché jusqu'à ce que la méthode dans laquelle vous définissez <xref:System.Windows.UIElement.Visibility%2A> a terminé son exécution.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une fenêtre non modale.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.Show" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowActivated : bool with get, set" Usage="System.Windows.Window.ShowActivated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est activée lors de son premier affichage.</summary>
        <value><see langword="true" /> si une fenêtre est activée lors de son premier affichage ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une fenêtre avec sa <xref:System.Windows.Window.ShowActivated%2A> propriété définie sur `false` est ouvert, la fenêtre n’est pas activée et que sa <xref:System.Windows.Window.Activated> événement n’est pas déclenché manuellement que lorsqu’un utilisateur Active la fenêtre en la sélectionnant. Une fois que la fenêtre est sélectionnée, il active et désactive normalement.  
  
 Pour empêcher une fenêtre d’en cours d’activation quand il s’ouvre, le <xref:System.Windows.Window.ShowActivated%2A> propriété doit être définie sur `false` avant l’affichage de la fenêtre (en appelant <xref:System.Windows.Window.Show%2A>) ; le paramètre <xref:System.Windows.Window.ShowActivated%2A> à `false` après une fenêtre a aucun effet.  
  
 Paramètre <xref:System.Windows.Window.ShowActivated%2A> à `false` sur une fenêtre qui est ouvert de façon modale, en appelant <xref:System.Windows.Window.ShowDialog%2A>, n’a aucun impact réel. Bien que la fenêtre modale ne sera pas activée, la fenêtre modale empêche l’utilisateur d’activer d’autres fenêtres de l’application ouverte.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ShowActivatedProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le balisage pour configurer une fenêtre s’ouvre sans en cours d’activation.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 L’exemple suivant montre comment utiliser le code pour configurer une fenêtre à ouvrir sans être activée.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowActivatedProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowActivatedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberSignature Language="F#" Value="member this.ShowDialog : unit -&gt; Nullable&lt;bool&gt;" Usage="window.ShowDialog " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ouvre une fenêtre et retourne uniquement lorsque la nouvelle fenêtre ouverte est fermée.</summary>
        <returns>Valeur <see cref="T:System.Nullable`1" /> de type <see cref="T:System.Boolean" /> qui spécifie si l'activité a été acceptée (<see langword="true" />) ou annulée (<see langword="false" />). La valeur de retour est la valeur de la propriété <see cref="P:System.Windows.Window.DialogResult" /> avant la fermeture d'une fenêtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quand un <xref:System.Windows.Window> classe est instanciée, elle n’est pas visible par défaut. <xref:System.Windows.Window.ShowDialog%2A> Affiche la fenêtre, désactive toutes les autres fenêtres dans l’application et retourne uniquement lorsque la fenêtre est fermée. Ce type de fenêtre est appelé un *modale* fenêtre.  
  
 Fenêtres modales sont principalement utilisées en tant que boîtes de dialogue. Une boîte de dialogue est un type spécial de fenêtre que les applications utilisent pour interagir avec les utilisateurs pour effectuer des tâches, telles que l’ouverture de fichiers ou de l’impression de documents. Boîtes de dialogue permettent généralement aux utilisateurs d’accepter ou annuler la tâche pour laquelle elles ont été affichées avant la fermeture de la boîte de dialogue. <xref:System.Windows.Window.ShowDialog%2A> Retourne un <xref:System.Nullable%601> <xref:System.Boolean> valeur qui spécifie si l’activité a été acceptée ou annulée. La valeur de retour est la valeur de la propriété <xref:System.Windows.Window.DialogResult%2A> avant la fermeture d'une fenêtre. Pour plus d'informations, consultez <xref:System.Windows.Window.DialogResult%2A>.  
  
 Une fenêtre est ouverte en appelant le <xref:System.Windows.Window.ShowDialog%2A> méthode n’a pas automatiquement une relation avec la fenêtre qui l’a ouverte ; plus précisément, la fenêtre ouverte ne sait pas quelle fenêtre ouverte. Cette relation peut être établie à l’aide de la <xref:System.Windows.Window.Owner%2A> propriété et géré à l’aide du <xref:System.Windows.Window.OwnedWindows%2A> propriété. Pour prendre en charge [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] automation (consultez [UI Automation Overview](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> doit être définie pour une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Quand une fenêtre modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre (une fenêtre ouverte en appelant <xref:System.Windows.Window.ShowDialog%2A>) est fermée, activée précédemment fenêtre est réactivée. Si une fenêtre modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre a une fenêtre propriétaire (consultez <xref:System.Windows.Window.Owner%2A>), la fenêtre propriétaire n’est pas réactivée lorsque la fenêtre modale [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fenêtre est fermée, sauf si elle a été la fenêtre activée précédemment.  
  
> [!NOTE]
>  Cette méthode ne peut pas être appelée lorsqu’une fenêtre est hébergée dans un navigateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment ouvrir une fenêtre modale.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Window.ShowDialog" /> est appelé sur une fenêtre qui se ferme (<see cref="E:System.Windows.Window.Closing" />) ou a été fermée (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour l’autorisation d’activer une fenêtre. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowInTaskbar : bool with get, set" Usage="System.Windows.Window.ShowInTaskbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la fenêtre possède un bouton dans la barre des tâches.</summary>
        <value><see langword="true" /> si la fenêtre possède un bouton dans la barre des tâches ; sinon, <see langword="false" />. Ne s'applique pas lorsque la fenêtre est hébergée dans un navigateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si <xref:System.Windows.Window.ShowInTaskbar%2A> est défini sur `true`, la fenêtre s’affiche également dans la liste de sélection d’application ALT + TAB.  
  
 L’icône qui est utilisé pour le bouton de barre des tâches et la liste de sélection d’application ALT + TAB est la valeur de la <xref:System.Windows.Window.Icon%2A> propriété.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ShowInTaskbarProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.ShowInTaskbarProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberSignature Language="F#" Value="member this.SizeToContent : System.Windows.SizeToContent with get, set" Usage="System.Windows.Window.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est automatiquement redimensionnée en fonction de la taille de son contenu.</summary>
        <value>Valeur <see cref="T:System.Windows.SizeToContent" />. La valeur par défaut est <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.WidthAndHeight>, paramètre <xref:System.Windows.FrameworkElement.Height%2A> ou <xref:System.Windows.FrameworkElement.Width%2A> n’a aucun effet ; les deux propriétés peuvent être définies, mais les valeurs qu’ils sont définis avec ne sont pas appliquées à la fenêtre.  
  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.Height>, la définition <xref:System.Windows.FrameworkElement.Height%2A> ne modifie pas la hauteur de la fenêtre.  
  
 Lorsque <xref:System.Windows.Window.SizeToContent%2A> a la valeur <xref:System.Windows.SizeToContent.Width>, la définition <xref:System.Windows.FrameworkElement.Width%2A> ne modifie pas la largeur de la fenêtre.  
  
 Si <xref:System.Windows.Window.SizeToContent%2A> a une valeur autre que <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> est automatiquement défini sur <xref:System.Windows.SizeToContent.Manual> si un utilisateur redimensionne la fenêtre à l’aide de la poignée de redimensionnement ou en faisant glisser la bordure.  
  
-   Si la taille du contenu change d’une manière qui entraîne le redimensionnement, la fenêtre <xref:System.Windows.FrameworkElement.SizeChanged> est déclenché.  
  
 Si une fenêtre est transparente (consultez <xref:System.Windows.Window.AllowsTransparency%2A>), vous devez envisager de définir <xref:System.Windows.Window.SizeToContent%2A> à <xref:System.Windows.SizeToContent.WidthAndHeight> pour vous assurer de la fenêtre ne dépasse pas son contenu visible.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.SizeToContentProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Windows.Window.SizeToContent%2A> propriété dans le code pour spécifier la façon dont une fenêtre se redimensionne en fonction de son contenu.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SizeToContentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.SizeToContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberSignature Language="F#" Value="member this.SourceInitialized : EventHandler " Usage="member this.SourceInitialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cet événement est déclenché afin de prendre en charge l'interopérabilité avec [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. Consultez <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberSignature Language="F#" Value="member this.StateChanged : EventHandler " Usage="member this.StateChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la propriété <see cref="P:System.Windows.Window.WindowState" /> de la fenêtre change.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TaskbarItemInfo : System.Windows.Shell.TaskbarItemInfo with get, set" Usage="System.Windows.Window.TaskbarItemInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la miniature de barre des tâches [!INCLUDE[win7](~/includes/win7-md.md)] pour <see cref="T:System.Windows.Window" />.</summary>
        <value>Miniature de la barre des tâches [!INCLUDE[win7](~/includes/win7-md.md)] pour <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur l’utilisation de la [!INCLUDE[win7](~/includes/win7-md.md)] voir miniatures, la barre des tâches la <xref:System.Windows.Shell.TaskbarItemInfo> classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TaskbarItemInfoProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Window.Title" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le titre d’une fenêtre.</summary>
        <value><see cref="T:System.String" /> qui contient le titre de la fenêtre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le titre d’un <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, ou [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], peut également être définie à l’aide de <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TitleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TitleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Top : double with get, set" Usage="System.Windows.Window.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position du bord supérieur de la fenêtre par rapport au bureau.</summary>
        <value>Position du haut de la fenêtre, en unités logiques (1/96").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Windows.Window> est agrandie ou réduite, cette valeur représente le bord supérieur de la restauration point pour le <xref:System.Windows.Window>.  
  
 Cette propriété ne peut pas être définie via un style.  
  
 Si vous ne spécifiez pas une valeur, <xref:System.Windows.Window.Top%2A> est définie sur la valeur par défaut du système. Vous pouvez également spécifier la valeur par défaut du système en définissant <xref:System.Windows.Window.Top%2A> à <xref:System.Double.NaN>. Ni <xref:System.Double.NegativeInfinity> ni <xref:System.Double.PositiveInfinity> est une valeur valide pour <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TopProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Topmost : bool with get, set" Usage="System.Windows.Window.Topmost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre apparaît dans l'ordre de plan le plus haut.</summary>
        <value><see langword="true" /> si la fenêtre est l'élément le plus haut ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fenêtre dont <xref:System.Windows.Window.Topmost%2A> propriété est définie sur `true` apparaît au-dessus de toutes les fenêtres dont <xref:System.Windows.Window.Topmost%2A> propriétés sont définies sur `false`.  
  
 Dans le groupe de windows qui ont <xref:System.Windows.Window.Topmost%2A> propriété est définie sur `true`, la fenêtre actuellement active est la fenêtre au premier plan. De même pour le groupe de windows qui ont <xref:System.Windows.Window.Topmost%2A> propriété est définie sur `false`.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.TopmostProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopmostProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopmostProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TopProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.TopProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStartupLocation : System.Windows.WindowStartupLocation with get, set" Usage="System.Windows.Window.WindowStartupLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position de la fenêtre lors de son premier affichage.</summary>
        <value>Valeur <see cref="T:System.Windows.WindowStartupLocation" /> qui spécifie la position supérieure gauche d'une fenêtre lorsqu'elle s'affiche pour la première fois. La valeur par défaut est <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de la `WindowStartupLocation` propriété <xref:System.Windows.WindowStartupLocation.Manual> provoque une fenêtre doit être positionné en fonction de son <xref:System.Windows.Window.Left%2A> et <xref:System.Windows.Window.Top%2A> les valeurs de propriété. Si le <xref:System.Windows.Window.Left%2A> ou <xref:System.Windows.Window.Top%2A> propriétés ne sont pas spécifiées, leurs valeurs sont déterminées par Windows.  
  
 Définition de la `WindowStartupLocation` propriété <xref:System.Windows.WindowStartupLocation.CenterScreen> provoque une fenêtre doit être positionné dans le centre de l’écran qui contient le curseur de souris.  
  
 Définition de la `WindowStartupLocation` propriété <xref:System.Windows.WindowStartupLocation.CenterOwner> provoque une fenêtre doit être positionné au centre de sa fenêtre propriétaire (consultez <xref:System.Windows.Window.Owner%2A?displayProperty=nameWithType>), si spécifiée. La fenêtre propriétaire peut être une autre fenêtre WPF ou une fenêtre non WPF.

> [!NOTE]   
>  Pour plus d’informations sur les fenêtres WPF avec les fenêtres non-WPF, consultez [interopérabilité WPF et Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) et <xref:System.Windows.Interop.WindowInteropHelper>. 

 Si la fenêtre propriétaire n’est pas spécifiée, la position de la fenêtre est déterminée de la même façon que si le `WindowStartupLocation` propriété est définie sur <xref:System.Windows.WindowStartupLocation.Manual>.

> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir la valeur de cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberSignature Language="F#" Value="member this.WindowState : System.Windows.WindowState with get, set" Usage="System.Windows.Window.WindowState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une fenêtre est restaurée, réduite ou agrandie.</summary>
        <value><see cref="T:System.Windows.WindowState" /> qui détermine si une fenêtre est restaurée, réduite ou agrandie. La valeur par défaut est <see cref="F:System.Windows.WindowState.Normal" /> (restaurée).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Avant d’une fenêtre est réduite ou agrandie, sa taille et son emplacement sont stockés dans <xref:System.Windows.Window.RestoreBounds%2A>. Lorsqu’une fenêtre est restaurée par la suite, ses valeurs de taille et l’emplacement sont restaurés avec les valeurs de <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Lorsque le <xref:System.Windows.Window.WindowState%2A> propriété est modifiée, <xref:System.Windows.Window.StateChanged> est déclenché.  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.WindowStateProperty>|  
|La valeur des propriétés de métadonnées `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStateProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberSignature Language="F#" Value="member this.WindowStyle : System.Windows.WindowStyle with get, set" Usage="System.Windows.Window.WindowStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le style de bordure d’une fenêtre.</summary>
        <value><see cref="T:System.Windows.WindowStyle" /> qui spécifie le style de bordure d'une fenêtre. La valeur par défaut est <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> peut s’agir de la <xref:System.Windows.WindowStyle> des valeurs d’énumération, y compris <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (valeur par défaut), et <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 La figure suivante montre les styles de fenêtre sur [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (thème Windows Vista Aero avec transparence activée) :  
  
 ![Styles de fenêtre](~/add/media/windowoverviewfigure6.PNG "styles de fenêtre")  
  
> [!NOTE]
>  Vous ne pouvez pas définir ou obtenir cette propriété lorsqu’une fenêtre est hébergée dans un navigateur.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Informations sur les propriétés de dépendance  
  
|||  
|-|-|  
|Champ d’identificateur|<xref:System.Windows.Window.WindowStyleProperty>|  
|La valeur des propriétés de métadonnées `true`|Aucun.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable WindowStyleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Window.WindowStyleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifie la propriété de dépendance <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>