<Type Name="Application" FullName="System.Windows.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d8f42d7fd84e44a45cf92bbe9edb7b518a077d4b" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53222263" /></Metadata><TypeSignature Language="C#" Value="public class Application : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Application extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Application" />
  <TypeSignature Language="VB.NET" Value="Public Class Application&#xA;Inherits DispatcherObject&#xA;Implements IQueryAmbient" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application : System::Windows::Threading::DispatcherObject, System::Windows::Markup::IQueryAmbient" />
  <TypeSignature Language="F#" Value="type Application = class&#xA;    inherit DispatcherObject&#xA;    interface IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Encapsule une application Windows Presentation Foundation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> est une classe qui encapsule [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] fonctionnalités spécifiques à l’application, y compris les éléments suivants :  
  
-   **Durée de vie application**: <xref:System.Windows.Application.Activated>, <xref:System.Windows.Application.Current%2A>, <xref:System.Windows.Application.Deactivated>, <xref:System.Windows.Application.DispatcherUnhandledException>, <xref:System.Windows.Application.Exit>, <xref:System.Windows.Application.Run%2A>, <xref:System.Windows.Application.SessionEnding>, <xref:System.Windows.Application.Shutdown%2A>, <xref:System.Windows.Application.ShutdownMode%2A>, <xref:System.Windows.Application.Startup>.  
  
-   **Fenêtre de la portée de l’application, de propriété et de gestion des ressources**: <xref:System.Windows.Application.FindResource%2A>, <xref:System.Windows.Application.GetContentStream%2A>, <xref:System.Windows.Application.GetResourceStream%2A>, <xref:System.Windows.Application.LoadComponent%2A>, <xref:System.Windows.Application.MainWindow%2A>, <xref:System.Windows.Application.Properties%2A>, <xref:System.Windows.Application.Resources%2A>, <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application.Windows%2A>.  
  
-   **Paramètre de ligne de commande et sortie de traitement de Code**: <xref:System.Windows.Application.Startup?displayProperty=nameWithType>, <xref:System.Windows.Application.Exit?displayProperty=nameWithType>, <xref:System.Windows.Application.Shutdown%2A?displayProperty=nameWithType>.  
  
-   **Navigation**: <xref:System.Windows.Application.FragmentNavigation>, <xref:System.Windows.Application.LoadCompleted>, <xref:System.Windows.Application.Navigated>, <xref:System.Windows.Application.Navigating>, <xref:System.Windows.Application.NavigationProgress>, <xref:System.Windows.Application.NavigationStopped>, <xref:System.Windows.Application.NavigationFailed>, <xref:System.Windows.Application.SetCookie%2A>, <xref:System.Windows.Application.GetCookie%2A>.  
  
 <xref:System.Windows.Application> implémente le modèle de singleton pour fournir un accès partagé à sa fenêtre, propriété et les services de portée de ressource. Par conséquent, seule une instance de la <xref:System.Windows.Application> classe peut être créée par <xref:System.AppDomain>.  
  
 Vous pouvez implémenter un <xref:System.Windows.Application> à l’aide du balisage, balisage et code-behind ou code. Si <xref:System.Windows.Application> est implémentée avec une balise, si le balisage ou balisage et code-behind, le fichier de balisage doit être configuré comme un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] `ApplicationDefinition` élément.  
  
> [!NOTE]
>  Une application autonome ne nécessite pas un <xref:System.Windows.Application> objet ; il est possible d’implémenter un `static` méthode de point d’entrée (`Main`) qui ouvre une fenêtre sans créer d’instance de <xref:System.Windows.Application>. Toutefois, [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] nécessitent un <xref:System.Windows.Application> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment une application standard est défini à l’aide de balisage uniquement :  
  
 [!code-xaml[ApplicationSnippets#ApplicationMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppMarkup.xaml#applicationmarkup)]  
  
 L’exemple suivant montre comment une application standard est définie à l’aide de code :  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/AppCode.cs#applicationcode)]
 [!code-vb[ApplicationSnippets#ApplicationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/appcode.vb#applicationcode)]  
  
 L’exemple suivant montre comment une application standard est défini à l’aide d’une combinaison de balisage et code-behind.  
  
 [!code-xaml[ApplicationSnippets#ApplicationXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml#applicationxaml)]  
  
 [!code-csharp[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSnippets/CSharp/App.xaml.cs#applicationcodebehind)]
 [!code-vb[ApplicationSnippets#ApplicationCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSnippets/visualbasic/application.xaml.vb#applicationcodebehind)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Public <see langword="static" /> (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. En outre, le <see cref="M:System.Windows.Application.FindResource(System.Object)" /> et <see cref="M:System.Windows.Application.TryFindResource(System.Object)" /> méthodes et les <see cref="P:System.Windows.Application.Properties" /> et <see cref="P:System.Windows.Application.Resources" /> propriétés sont thread-safe.</threadsafe>
    <altmember cref="T:System.Windows.Window" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Application ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Application();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Seule une instance de la <xref:System.Windows.Application> classe peut être créée par <xref:System.AppDomain>, pour garantir un accès partagé à un ensemble unique de données de fenêtre, de propriété et de ressources de portée application. Par conséquent, le constructeur par défaut de la <xref:System.Windows.Application> classe détecte si l’instance en cours d’initialisation est la première instance dans un <xref:System.AppDomain>; si elle n’est pas, un <xref:System.InvalidOperationException> est levée.  
  
 Le <xref:System.Windows.Application> objet actif <xref:System.AppDomain> est exposée à partir de la méthode statique <xref:System.Windows.Application.Current%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Plusieurs instances de la classe <see cref="T:System.Windows.Application" /> sont créées par <see cref="T:System.AppDomain" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberSignature Language="F#" Value="member this.Activated : EventHandler " Usage="member this.Activated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une application devient l'application de premier plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application Windows Presentation Foundation qui possède une ou plusieurs fenêtres ouvertes est activée (devient l’application de premier plan) lorsqu’une des fenêtres est activée pour la première fois dans la mesure où l’application a été lancée, ou lorsqu’une des fenêtres est activée alors que l’application est inactive : Plus précisément, l’activation se produit lorsque :  
  
-   Une application ouvre sa première fenêtre.  
  
-   Un utilisateur bascule vers l’application à l’aide de ALT + TAB ou à l’aide du Gestionnaire des tâches.  
  
-   Un utilisateur clique sur le bouton de barre des tâches pour l’une des fenêtres dans une application.  
  
 Peuvent gérer les applications qui doivent détecter lorsqu’ils activent le <xref:System.Windows.Application.Activated> événement.  
  
 Une fois une application tout d’abord activée, peuvent être désactivé et réactivé autant de fois pendant sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut gérer les deux <xref:System.Windows.Application.Activated> et <xref:System.Windows.Application.Deactivated> événements afin de déterminer quel l’activation de l’état du.  
  
 Une fois qu’une application devient active, <xref:System.Windows.Application.Activated> n’est pas déclenché à nouveau jusqu'à ce que l’application est désactivée, quel que soit le nombre de fenêtres dans une application est activé lorsque l’application est active.  
  
 <xref:System.Windows.Application.Activated> n’est pas déclenché pour [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 L’exemple suivant montre comment détecter quand une application autonome active et désactive.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Application Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Application Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Application ^ Current { System::Windows::Application ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Application" Usage="System.Windows.Application.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet <see cref="T:System.Windows.Application" /> pour le <see cref="T:System.AppDomain" /> actuel.</summary>
        <value>Objet <see cref="T:System.Windows.Application" /> pour le <see cref="T:System.AppDomain" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> est un par-<xref:System.AppDomain> type singleton qui implémente la méthode statique <xref:System.Windows.Application.Current%2A> propriété afin de fournir un accès partagé à la <xref:System.Windows.Application> instance actif <xref:System.AppDomain>. Cette conception garantit que l’état géré par <xref:System.Windows.Application>, y compris les ressources partagées et état, est disponible à partir d’un emplacement unique et partagé.  
  
 Cette propriété est thread-safe et est disponible à partir de n’importe quel thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberSignature Language="F#" Value="member this.Deactivated : EventHandler " Usage="member this.Deactivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une application cesse d'être l'application de premier plan.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application Windows Presentation Foundation qui possède une ou plusieurs fenêtres ouvertes désactive (arrête en cours de l’application de premier plan) lorsqu’un utilisateur effectue les opérations suivantes :  
  
-   Bascule vers une autre application à l’aide de ALT + TAB ou à l’aide du Gestionnaire des tâches.  
  
-   Clique avec le bouton de barre des tâches pour une fenêtre dans une autre application.  
  
 Les applications qui doivent détecter la désactivation peuvent gérer le <xref:System.Windows.Application.Deactivated> événement.  
  
 Une fois une application tout d’abord activée, peuvent être désactivé et réactivé autant de fois pendant sa durée de vie. Si le comportement ou l’état d’une application dépend de son état d’activation, il peut gérer les deux <xref:System.Windows.Application.Deactivated> et <xref:System.Windows.Application.Activated> événements afin de déterminer l’état du.  
  
 <xref:System.Windows.Application.Deactivated> n’est pas déclenché pour [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].  
  
   
  
## Examples  
 L’exemple suivant montre comment détecter quand une application autonome désactive et active.  
  
 [!code-xaml[ApplicationActivationSnippets#DetectActivationStateXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml#detectactivationstatexaml)]  
  
 [!code-csharp[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationActivationSnippets/CSharp/App.xaml.cs#detectactivationstatecodebehind)]
 [!code-vb[ApplicationActivationSnippets#DetectActivationStateCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationActivationSnippets/visualbasic/application.xaml.vb#detectactivationstatecodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
        <altmember cref="E:System.Windows.Application.Activated" />
      </Docs>
    </Member>
    <Member MemberName="DispatcherUnhandledException">
      <MemberSignature Language="C#" Value="public event System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Threading.DispatcherUnhandledExceptionEventHandler DispatcherUnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.DispatcherUnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DispatcherUnhandledException As DispatcherUnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Threading::DispatcherUnhandledExceptionEventHandler ^ DispatcherUnhandledException;" />
      <MemberSignature Language="F#" Value="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " Usage="member this.DispatcherUnhandledException : System.Windows.Threading.DispatcherUnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Threading.DispatcherUnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une exception est levée par une application mais non gérée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, Windows Presentation Foundation intercepte les exceptions non gérées, notifie les utilisateurs de l’exception à partir d’une boîte de dialogue (à partir de laquelle ils peuvent signaler l’exception) et s’arrête automatiquement une application.  
  
 Toutefois, si une application a besoin exécuter le traitement de l’exception non prise en charge personnalisée à partir d’un emplacement centralisé, vous devez gérer <xref:System.Windows.Application.DispatcherUnhandledException>.  
  
 <xref:System.Windows.Application.DispatcherUnhandledException> est déclenché par un <xref:System.Windows.Application> pour chaque exception qui n’est pas gérée par le code en cours d’exécution sur le thread d’interface utilisateur principal.  
  
 Si une exception n’est pas gérée sur un thread d’interface utilisateur de l’arrière-plan (thread avec son propre <xref:System.Windows.Threading.Dispatcher>) ou un thread de travail d’arrière-plan (thread sans un <xref:System.Windows.Threading.Dispatcher>), l’exception n’est pas transférée vers le thread d’interface utilisateur. Par conséquent, <xref:System.Windows.Application.DispatcherUnhandledException> n’est pas déclenché. Dans ces circonstances, vous devrez écrire du code pour effectuer les opérations suivantes :  
  
1.  Gérer les exceptions sur le thread d’arrière-plan.  
  
2.  Distribuer ces exceptions au thread d’interface utilisateur principal.  
  
3.  Lever à nouveau les sur le thread d’interface utilisateur sans avoir à gérer leur autoriser <xref:System.Windows.Application.DispatcherUnhandledException> à signaler.  
  
 Pour plus d’informations, consultez le [modèle de thread](~/docs/framework/wpf/advanced/threading-model.md) vue d’ensemble.  
  
 Le <xref:System.Windows.Application.DispatcherUnhandledException> est transmis au gestionnaire d’événements un <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs> argument qui contient des informations contextuelles concernant l’exception, y compris :  
  
-   L’exception (<xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Exception%2A>).  
  
-   Le <xref:System.Windows.Threading.Dispatcher> à partir d'où elle provient (<xref:System.Windows.Threading.DispatcherEventArgs.Dispatcher%2A>).  
  
 Vous pouvez utiliser ces informations pour déterminer si une exception est récupérable ou non. Une exception récupérable peut être un <xref:System.IO.FileNotFoundException>, par exemple, pendant une exception irrécupérable s’est peut-être un <xref:System.StackOverflowException>, par exemple.  
  
 Lorsque vous traitez une exception non gérée à partir de <xref:System.Windows.Application.DispatcherUnhandledException>, et vous ne souhaitez pas [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] pour poursuivre leur traitement, vous devez définir le <xref:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled%2A> propriété `true`.  
  
 Contrairement à d’autres événements qui <xref:System.Windows.Application> déclenche, <xref:System.Windows.Application.DispatcherUnhandledException> ne pas avoir une implémentation virtuelle protégée correspondante (OnDispatcherUnhandledException). Par conséquent, les classes qui dérivent de <xref:System.Windows.Application> doit toujours s’inscrire un gestionnaire d’événements avec <xref:System.Windows.Application.DispatcherUnhandledException> pour traiter les exceptions non gérées.  
  
   
  
## Examples  
 L’exemple suivant montre comment traiter les exceptions non gérées en gérant la <xref:System.Windows.Application.DispatcherUnhandledException> événement.  
  
 [!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind1)]
 [!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind1)]  
[!code-csharp[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/CSharp/App.xaml.cs#handledispatcherunhandledexceptioncodebehind2)]
[!code-vb[ApplicationDispatcherUnhandledExceptionSnippets#HandleDispatcherUnhandledExceptionCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationDispatcherUnhandledExceptionSnippets/visualbasic/application.xaml.vb#handledispatcherunhandledexceptioncodebehind2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public event System.Windows.ExitEventHandler Exit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.ExitEventHandler Exit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exit As ExitEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::ExitEventHandler ^ Exit;" />
      <MemberSignature Language="F#" Value="member this.Exit : System.Windows.ExitEventHandler " Usage="member this.Exit : System.Windows.ExitEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ExitEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit juste avant la fermeture d'une application et ne peut être annulé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application peut s’arrêter pour une des raisons suivantes :  
  
-   Le <xref:System.Windows.Application.Shutdown%2A> méthode de la <xref:System.Windows.Application> objet est appelé, explicitement ou tel que déterminé par le <xref:System.Windows.Application.ShutdownMode%2A> propriété.  
  
-   L’utilisateur met fin à la session en se déconnectant ou en cours d’arrêt.  
  
 Vous pouvez détecter lors de l’arrêt de l’application se produit en gérant la <xref:System.Windows.Application.Exit> événement et effectuer tout traitement supplémentaire requis.  
  
 Vous pouvez également gérer <xref:System.Windows.Application.Exit> pour inspecter ou modifier le code de sortie d’application lorsque vous n’avez pas besoin d’appeler <xref:System.Windows.Application.Shutdown%2A> explicitement. Le code de sortie est exposé à partir de la <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propriété de la <xref:System.Windows.ExitEventArgs> argument qui est passé à la <xref:System.Windows.Application.Exit> Gestionnaire d’événements. Lorsque l’application s’arrête en cours d’exécution, le code de sortie est passé au système d’exploitation pour un traitement ultérieur.  
  
 Si votre application gère la <xref:System.Windows.Application.SessionEnding> événement et l’annule ensuite, <xref:System.Windows.Application.Exit> n’est pas déclenché et l’application continue de s’exécuter conformément au mode d’arrêt.  
  
 Le code de sortie peut être défini à partir d’un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)], même si la valeur est ignorée.  
  
 Pour [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)], <xref:System.Windows.Application.Exit> est déclenché dans les circonstances suivantes :  
  
-   Un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] est quittée.  
  
-   Dans [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)], lorsque l’onglet qui héberge le [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] est fermé.  
  
-   Le navigateur est fermé.  
  
 Dans tous les cas, la valeur de la <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propriété est ignorée.  
  
   
  
## Examples  
 L’exemple suivant montre comment :  
  
-   Gérer le <xref:System.Windows.Application.Exit> événement.  
  
-   Examiner et mettre à jour le <xref:System.Windows.ExitEventArgs.ApplicationExitCode%2A> propriété de la <xref:System.Windows.ExitEventArgs>.  
  
-   Écrire une entrée dans un journal des applications dans un stockage isolé.  
  
-   Conserver l’état de l’application dans le stockage isolé.  
  
 [!code-xaml[ApplicationExitSnippets#HandleExitXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml#handleexitxaml)]  
  
 [!code-csharp[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationExitSnippets/CSharp/App.xaml.cs#handleexitcodebehind)]
 [!code-vb[ApplicationExitSnippets#HandleExitCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationExitSnippets/visualbasic/application.xaml.vb#handleexitcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
        <altmember cref="T:System.IO.IsolatedStorage.IsolatedStorage" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.FindResource : obj -&gt; obj" Usage="application.FindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nom de la ressource à rechercher.</param>
        <summary>Recherche une ressource d’[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], telle que <see cref="T:System.Windows.Style" /> ou <see cref="T:System.Windows.Media.Brush" />, à l’aide de la clé spécifiée et lève une exception si la ressource demandée est introuvable (consultez [Ressources XAML](~/docs/framework/wpf/advanced/xaml-resources.md)).</summary>
        <returns>Objet de la ressource demandée. Si la ressource demandée est introuvable, une <see cref="T:System.Windows.ResourceReferenceKeyNotFoundException" /> est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.FindResource%2A> recherche d’abord dans les ressources de portée application pour la ressource spécifiée. Les ressources de portée application sont gérées par <xref:System.Windows.Application>et sont exposées à partir de la <xref:System.Windows.Application.Resources%2A> propriété. Si la ressource spécifiée est introuvable dans l’ensemble de ressources de portée application, <xref:System.Windows.Application.FindResource%2A> puis suivant recherche les ressources système. Ressources système sont des ressources de shell définis par l’utilisateur et incluent des couleurs, des polices et des configurations d’interpréteur de commandes. Ceux-ci sont exposés à partir de la <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, et <xref:System.Windows.SystemParameters> respectivement, les types, en tant que propriétés statiques. Pour utiliser <xref:System.Windows.Application.FindResource%2A> pour acquérir, ces types exposent également des propriétés de clé de ressource qui sont conçues pour être transmis à <xref:System.Windows.Application.FindResource%2A>; par exemple, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Étant donné que <xref:System.Windows.Application.FindResource%2A> retourne un objet, vous devez caster la valeur retournée en type approprié si la ressource est introuvable.  
  
> [!IMPORTANT]
>  Si vous appelez cette méthode pour une clé qui est introuvable, une exception est levée. Si vous ne souhaitez pas gérer les exceptions qui résultent de l’appel <xref:System.Windows.Application.FindResource%2A>, appelez <xref:System.Windows.Application.TryFindResource%2A> à la place. <xref:System.Windows.Application.TryFindResource%2A> retourne un `null` référencer lors de la ressource demandée est introuvable et ne lève pas d’exception.  
  
 Cette méthode est thread-safe et peut être appelée à partir de n’importe quel thread.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Windows.Application.FindResource%2A> afin de trouver une ressource et de gérer <xref:System.Windows.ResourceReferenceKeyNotFoundException> si la ressource est introuvable.  
  
 [!code-csharp[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcallfindresourcecodebehind)]
 [!code-vb[ApplicationFindResourceSnippets#ApplicationCallFindResourceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcallfindresourcecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">La ressource est introuvable.</exception>
        <altmember cref="M:System.Windows.Application.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un navigateur de l'application commence à naviguer vers un fragment de contenu. La navigation démarre immédiatement si le fragment souhaité se trouve dans le contenu actuel ou après le chargement  du contenu [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] source si le fragment désiré se trouve dans un contenu différent.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.FragmentNavigation?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetContentStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetContentStream (Uri uriContent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetContentStream(class System.Uri uriContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetContentStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetContentStream (uriContent As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetContentStream(Uri ^ uriContent);" />
      <MemberSignature Language="F#" Value="static member GetContentStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetContentStream uriContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriContent" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriContent"><see cref="T:System.Uri" /> relatif qui mappe à une ressource libre.</param>
        <summary>Retourne un flux de ressources pour un fichier de données de contenu localisé au <see cref="T:System.Uri" /> spécifié (consultez [Fichiers de ressources, de contenu et de données d’une application WPF](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" /> qui contient un fichier de données de contenu localisé au <see cref="T:System.Uri" /> spécifié. Si une ressource libre est introuvable, la valeur null est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur <see cref="T:System.Uri" /> passée à <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> est null.</exception>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Uri" /> passé à <see cref="M:System.Windows.Application.GetContentStream(System.Uri)" /> est un <see cref="T:System.Uri" /> absolu.</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetCookie">
      <MemberSignature Language="C#" Value="public static string GetCookie (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCookie(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetCookie(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetCookie(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="static member GetCookie : Uri -&gt; string" Usage="System.Windows.Application.GetCookie uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" /> qui spécifie l'emplacement pour lequel le cookie a été créé.</param>
        <summary>Récupère un cookie pour l'emplacement spécifié par un <see cref="T:System.Uri" />.</summary>
        <returns>Valeur de <see cref="T:System.String" /> si le cookie existe ; sinon, une <see cref="T:System.ComponentModel.Win32Exception" /> est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.GetCookie%2A> Récupère un cookie pour spécifié <xref:System.Uri>. Si le cookie ne peut pas être récupéré, un <xref:System.ComponentModel.Win32Exception> est levée. Vous devez écrire le code pour analyser la chaîne de cookie dans une liste de paires nom/valeur.  
  
 Pour une vue d’ensemble des cookies dans [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], consultez [vue d’ensemble de la Navigation](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] est déclenchée par la fonction <see langword="InternetGetCookie" /> (appelée par <see cref="M:System.Windows.Application.GetCookie(System.Uri)" />) si un problème survient lors de la tentative de récupération du cookie spécifié.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour recevoir le cookie pour basé sur un fichier <see cref="T:System.Uri" />. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour recevoir le cookie pour un fichier non-Windows, <see cref="T:System.Uri" />. Énumération associée : <see cref="P:System.Net.WebPermission.ConnectList" /></permission>
        <altmember cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoteStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetRemoteStream (Uri uriRemote);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetRemoteStream(class System.Uri uriRemote) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRemoteStream (uriRemote As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetRemoteStream(Uri ^ uriRemote);" />
      <MemberSignature Language="F#" Value="static member GetRemoteStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetRemoteStream uriRemote" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriRemote" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriRemote"><see cref="T:System.Uri" /> qui mappe à une ressource libre au site d'origine.</param>
        <summary>Retourne un flux de ressources pour un fichier de données du site d’origine localisé au <see cref="T:System.Uri" /> spécifié (consultez [Fichiers de ressources, de contenu et de données d’une application WPF](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" /> qui contient un flux de ressources pour un fichier de données du site d'origine localisé au <see cref="T:System.Uri" /> spécifié. Si la ressource libre est introuvable, la valeur <see langword="null" /> est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur <see cref="T:System.Uri" /> passée à <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> est null.</exception>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Uri" /> passé à <see cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" /> est soit non relatif, soit absolu mais dans une forme autre que <c>pack://site_origine:,,,/</c>.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceStream">
      <MemberSignature Language="C#" Value="public static System.Windows.Resources.StreamResourceInfo GetResourceStream (Uri uriResource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Resources.StreamResourceInfo GetResourceStream(class System.Uri uriResource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.GetResourceStream(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetResourceStream (uriResource As Uri) As StreamResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Resources::StreamResourceInfo ^ GetResourceStream(Uri ^ uriResource);" />
      <MemberSignature Language="F#" Value="static member GetResourceStream : Uri -&gt; System.Windows.Resources.StreamResourceInfo" Usage="System.Windows.Application.GetResourceStream uriResource" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Resources.StreamResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriResource" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uriResource"><see cref="T:System.Uri" /> qui mappe à une ressource incorporée.</param>
        <summary>Retourne un flux de ressources pour un fichier de données de ressources localisé au <see cref="T:System.Uri" /> spécifié (consultez [Fichiers de ressources, de contenu et de données d’une application WPF](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).</summary>
        <returns><see cref="T:System.Windows.Resources.StreamResourceInfo" /> qui contient un flux de ressources pour un fichier de données de ressources localisé au <see cref="T:System.Uri" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur <see cref="T:System.Uri" /> passée à <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> est null.</exception>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Uri" /> passé à <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> est soit non relatif, soit absolu mais dans une forme autre que <c>pack://application:,,,/</c>.</exception>
        <exception cref="T:System.IO.IOException">Le <see cref="T:System.Uri" /> qui est passé à <see cref="M:System.Windows.Application.GetResourceStream(System.Uri)" /> est introuvable.</exception>
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
        <altmember cref="Overload:System.Windows.Application.LoadComponent" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contenu cible de la navigation par un navigateur de l'application a été chargé et analysé et que son rendu a commencé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.LoadCompleted?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Écouter des événements sur le contenu navigué tel que le <xref:System.Windows.FrameworkElement.Loaded> événement sur <xref:System.Windows.Controls.Page> avant que vous accédez aux propriétés du contenu navigué.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadComponent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge un fichier [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] localisé à l'[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fichier peut être un fichier de code d’application (configuré comme un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] élément de Page) ou un fichier de données d’application (un fichier de ressources, le fichier de contenu ou le site d’origine du fichier ; consultez [ressource d’Application WPF, de contenu et les fichiers de données](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static object LoadComponent (Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object LoadComponent(class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadComponent (resourceLocator As Uri) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ LoadComponent(Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : Uri -&gt; obj" Usage="System.Windows.Application.LoadComponent resourceLocator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="resourceLocator"><see cref="T:System.Uri" /> mappant sur un fichier [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relatif.</param>
        <summary>Charge un fichier [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] localisé à l'[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] spécifié et le convertit en une instance de l'objet spécifié par l'élément racine du fichier [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <returns>Instance de l'élément racine spécifié par le fichier XAML chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez convertir explicitement la valeur de retour vers le même type que l’élément racine de la [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] fichier.  
  
 Le [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fichier peut être un fichier de code d’application (configuré comme un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] élément de Page) ou un fichier de données d’application (un fichier de ressources, le fichier de contenu ou le site d’origine du fichier ; consultez [ressource d’Application WPF, de contenu et les fichiers de données](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> est un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] absolu.</exception>
        <exception cref="T:System.Exception">Le fichier n'est pas un fichier [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="LoadComponent">
      <MemberSignature Language="C#" Value="public static void LoadComponent (object component, Uri resourceLocator);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LoadComponent(object component, class System.Uri resourceLocator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.LoadComponent(System.Object,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LoadComponent (component As Object, resourceLocator As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LoadComponent(System::Object ^ component, Uri ^ resourceLocator);" />
      <MemberSignature Language="F#" Value="static member LoadComponent : obj * Uri -&gt; unit" Usage="System.Windows.Application.LoadComponent (component, resourceLocator)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="resourceLocator" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="component">Un objet du même type que l’élément racine du fichier [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</param>
        <param name="resourceLocator"><see cref="T:System.Uri" /> mappant sur un fichier [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] relatif.</param>
        <summary>Charge un fichier [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] qui se trouve à l’emplacement [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] spécifié et le convertit en une instance de l’objet spécifié par l’élément racine du fichier [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] fichier peut être un fichier de code d’application (configuré comme un [!INCLUDE[TLA#tla_msbuild](~/includes/tlasharptla-msbuild-md.md)] élément de Page) ou un fichier de données d’application (un fichier de ressources, le fichier de contenu ou le site d’origine du fichier ; consultez [ressource d’Application WPF, de contenu et les fichiers de données](~/docs/framework/wpf/app-development/wpf-application-resource-content-and-data-files.md)).  
  
> [!NOTE]
>  Cette méthode n’est pas thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceLocator" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceLocator" /> est un [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] absolu.</exception>
        <exception cref="T:System.Exception"><paramref name="component" /> est un type qui ne correspond pas à l’élément racine du fichier [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</exception>
        <altmember cref="M:System.Windows.Application.GetResourceStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetContentStream(System.Uri)" />
        <altmember cref="M:System.Windows.Application.GetRemoteStream(System.Uri)" />
      </Docs>
    </Member>
    <Member MemberName="MainWindow">
      <MemberSignature Language="C#" Value="public System.Windows.Window MainWindow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window MainWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.MainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Property MainWindow As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ MainWindow { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MainWindow : System.Windows.Window with get, set" Usage="System.Windows.Application.MainWindow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la fenêtre principale de l'application.</summary>
        <value><see cref="T:System.Windows.Window" /> désignée comme fenêtre d'application principale.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.MainWindow%2A> est automatiquement définie avec une référence à la première <xref:System.Windows.Window> objet à être instancié dans le <xref:System.AppDomain>.  
  
 Vous pouvez spécifier une fenêtre principale différente en définissant <xref:System.Windows.Application.MainWindow%2A> affectation d’un autre <xref:System.Windows.Application.Windows%2A> de l’objet à le <xref:System.Windows.Application.MainWindow%2A> propriété.  
  
 Si le <xref:System.Windows.Application.ShutdownMode%2A> propriété de la <xref:System.Windows.Application> objet est défini sur <xref:System.Windows.ShutdownMode.OnMainWindowClose>, fermeture de la fenêtre principale entraîne la fermeture de l’application.  
  
 Il est possible de définir la <xref:System.Windows.Application.MainWindow%2A> propriété à partir de [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)], si la fenêtre principale d’une application n’est pas la fenêtre qui est générée en définissant le <xref:System.Windows.Application.StartupUri%2A> propriété dans [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]. Les deux limitations de la [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] approche sont :  
  
-   Vous pouvez spécifier un [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-uniquement <xref:System.Windows.Window> ou un [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]-uniquement <xref:System.Windows.Navigation.NavigationWindow> que la fenêtre principale.  
  
-   Vous devez définir le <xref:System.Windows.UIElement.Visibility%2A> propriété de la fenêtre que vous spécifiez, sinon il ne sera pas affichée.  
  
 La référence à la première <xref:System.Windows.Window> objet à être instancié est également ajouté en tant que premier élément à la <xref:System.Windows.Application.Windows%2A> collection. Si <xref:System.Windows.Application.MainWindow%2A> est définie par la suite avec une référence à un autre <xref:System.Windows.Window>, la position de l’élément avec la référence à la fenêtre principale change, lors de l’ordre des éléments dans <xref:System.Windows.Application.Windows%2A> reste le même. Par conséquent, utilisez toujours <xref:System.Windows.Application.MainWindow%2A> pour faire référence à la fenêtre principale au lieu du premier élément de <xref:System.Windows.Application.Windows%2A>.  
  
> [!NOTE]
>  Si la fenêtre principale est un <xref:System.Windows.Navigation.NavigationWindow>, et vous devez avoir un accès spécifique à <xref:System.Windows.Navigation.NavigationWindow> membres, vous devrez effectuer un cast de la valeur de <xref:System.Windows.Application.MainWindow%2A> à <xref:System.Windows.Navigation.NavigationWindow>.  
>   
>  Cette propriété est disponible uniquement dans le thread qui a créé le <xref:System.Windows.Application> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment rechercher la fenêtre principale de l’application.  
  
 [!code-csharp[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationMainWindowSnippets/CSharp/App.xaml.cs#getapplicationmainwindowcode)]
 [!code-vb[ApplicationMainWindowSnippets#GetApplicationMainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationMainWindowSnippets/visualbasic/application.xaml.vb#getapplicationmainwindowcode)]  
  
 L’exemple suivant montre comment définir <xref:System.Windows.Application.MainWindow%2A> à l’aide de [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
 [!code-xaml[ApplicationMainWindowSnippets#SetApplicationMainWindowXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/ApplicationMainWindowSnippets/XAML/App.xaml#setapplicationmainwindowxaml)]  
  
 L’exemple suivant montre comment instancier le <xref:System.Windows.Application.MainWindow%2A> dans le code pendant le démarrage de l’application.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/App.xaml.cs#firstwindowusingcodecodebehind)]
 [!code-vb[HOWTOWindowManagementSnippets#FirstWindowUsingCodeCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/application.xaml.vb#firstwindowusingcodecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La <see cref="P:System.Windows.Application.MainWindow" /> est définie à partir d'une application hébergée dans un navigateur, telle que les [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)].</exception>
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le contenu cible de la navigation par un navigateur de l'application a été trouvé, même s'il n'a peut-être pas pu être complètement chargé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une nouvelle navigation est demandée par un navigateur dans l'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.Navigating?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'une erreur survient tandis qu'un navigateur de l'application navigue jusqu'au contenu demandé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit périodiquement pendant un téléchargement géré par un navigateur dans l'application afin de fournir des informations sur la progression de la navigation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.NavigationProgress?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationStopped" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see langword="StopLoading" /> d'un navigateur de l'application est appelée ou lorsqu'une nouvelle navigation est demandée par un navigateur alors qu'une navigation est en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un navigateur est soit une <xref:System.Windows.Navigation.NavigationWindow> ou un <xref:System.Windows.Controls.Frame>.  
  
 Consultez <xref:System.Windows.Navigation.NavigationService.NavigationStopped?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Navigated" />
        <altmember cref="E:System.Windows.Application.Navigating" />
        <altmember cref="E:System.Windows.Application.LoadCompleted" />
        <altmember cref="E:System.Windows.Application.NavigationProgress" />
        <altmember cref="E:System.Windows.Application.NavigationFailed" />
        <altmember cref="E:System.Windows.Application.FragmentNavigation" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnActivated : EventArgs -&gt; unit&#xA;override this.OnActivated : EventArgs -&gt; unit" Usage="application.OnActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnActivated%2A> déclenche l'événement <xref:System.Windows.Application.Activated>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnActivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnActivated%2A> dans la classe de base si <xref:System.Windows.Application.Activated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDeactivated : EventArgs -&gt; unit&#xA;override this.OnDeactivated : EventArgs -&gt; unit" Usage="application.OnDeactivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnDeactivated%2A> déclenche l'événement <xref:System.Windows.Application.Deactivated>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnDeactivated%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnDeactivated%2A> dans la classe de base si <xref:System.Windows.Application.Deactivated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnExit">
      <MemberSignature Language="C#" Value="protected virtual void OnExit (System.Windows.ExitEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnExit(class System.Windows.ExitEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnExit (e As ExitEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnExit(System::Windows::ExitEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnExit : System.Windows.ExitEventArgs -&gt; unit&#xA;override this.OnExit : System.Windows.ExitEventArgs -&gt; unit" Usage="application.OnExit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.ExitEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.ExitEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Exit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnExit%2A> déclenche l'événement <xref:System.Windows.Application.Exit>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peut remplacer le <xref:System.Windows.Application.OnExit%2A> (méthode). La méthode substituée doit appeler <xref:System.Windows.Application.OnExit%2A> dans la classe de base si <xref:System.Windows.Application.Exit> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFragmentNavigation">
      <MemberSignature Language="C#" Value="protected virtual void OnFragmentNavigation (System.Windows.Navigation.FragmentNavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFragmentNavigation(class System.Windows.Navigation.FragmentNavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFragmentNavigation (e As FragmentNavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFragmentNavigation(System::Windows::Navigation::FragmentNavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit&#xA;override this.OnFragmentNavigation : System.Windows.Navigation.FragmentNavigationEventArgs -&gt; unit" Usage="application.OnFragmentNavigation e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.FragmentNavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.FragmentNavigationEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.FragmentNavigation" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnFragmentNavigation%2A> déclenche l'événement <xref:System.Windows.Application.FragmentNavigation>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnFragmentNavigation%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnFragmentNavigation%2A> dans la classe de base si <xref:System.Windows.Application.FragmentNavigation> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnLoadCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadCompleted (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadCompleted(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoadCompleted (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoadCompleted(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnLoadCompleted : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnLoadCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigationEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.LoadCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnLoadCompleted%2A> déclenche l'événement <xref:System.Windows.Application.LoadCompleted>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnLoadCompleted%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnLoadCompleted%2A> dans la classe de base si <xref:System.Windows.Application.LoadCompleted> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigated">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigated (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigated(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigated (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigated(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigated : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigationEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Navigated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigated%2A> déclenche l'événement <xref:System.Windows.Application.Navigated>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnNavigated%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnNavigated%2A> dans la classe de base si <xref:System.Windows.Application.Navigated> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigating">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigating (System.Windows.Navigation.NavigatingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigating(class System.Windows.Navigation.NavigatingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigating (e As NavigatingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigating(System::Windows::Navigation::NavigatingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit&#xA;override this.OnNavigating : System.Windows.Navigation.NavigatingCancelEventArgs -&gt; unit" Usage="application.OnNavigating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigatingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigatingCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Navigating" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigating%2A> déclenche l'événement <xref:System.Windows.Application.Navigating>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnNavigating%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnNavigating%2A> dans la classe de base si <xref:System.Windows.Application.Navigating> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationFailed">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationFailed (System.Windows.Navigation.NavigationFailedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationFailed(class System.Windows.Navigation.NavigationFailedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationFailed (e As NavigationFailedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationFailed(System::Windows::Navigation::NavigationFailedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit&#xA;override this.OnNavigationFailed : System.Windows.Navigation.NavigationFailedEventArgs -&gt; unit" Usage="application.OnNavigationFailed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationFailedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigationFailedEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.NavigationFailed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationFailed%2A> déclenche l'événement <xref:System.Windows.Application.NavigationFailed>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnNavigationFailed%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnNavigationFailed%2A> dans la classe de base si <xref:System.Windows.Application.NavigationFailed> doit être déclenché.  
  
   
  
## Examples  
 <xref:System.Windows.Application.OnFragmentNavigation%2A>  
  
 <xref:System.Windows.Application.OnLoadCompleted%2A>  
  
 <xref:System.Windows.Application.OnNavigating%2A>  
  
 <xref:System.Windows.Application.OnNavigated%2A>  
  
 <xref:System.Windows.Application.OnNavigationProgress%2A>  
  
 <xref:System.Windows.Application.OnNavigationStopped%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnNavigationProgress">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationProgress (System.Windows.Navigation.NavigationProgressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationProgress(class System.Windows.Navigation.NavigationProgressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationProgress (e As NavigationProgressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationProgress(System::Windows::Navigation::NavigationProgressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit&#xA;override this.OnNavigationProgress : System.Windows.Navigation.NavigationProgressEventArgs -&gt; unit" Usage="application.OnNavigationProgress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationProgressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigationProgressEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.NavigationProgress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationProgress%2A> déclenche l'événement <xref:System.Windows.Application.NavigationProgress>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnNavigationProgress%2A>. La méthode substituée doit appeler explicitement <xref:System.Windows.Application.OnNavigationProgress%2A> dans la classe de base si <xref:System.Windows.Application.NavigationProgress> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnNavigationStopped">
      <MemberSignature Language="C#" Value="protected virtual void OnNavigationStopped (System.Windows.Navigation.NavigationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNavigationStopped(class System.Windows.Navigation.NavigationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnNavigationStopped(System.Windows.Navigation.NavigationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNavigationStopped (e As NavigationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNavigationStopped(System::Windows::Navigation::NavigationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit&#xA;override this.OnNavigationStopped : System.Windows.Navigation.NavigationEventArgs -&gt; unit" Usage="application.OnNavigationStopped e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Navigation.NavigationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Navigation.NavigationEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.NavigationStopped" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnNavigationStopped%2A> déclenche l'événement <xref:System.Windows.Application.NavigationStopped>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnNavigationStopped%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnNavigationStopped%2A> dans la classe de base si <xref:System.Windows.Application.NavigationStopped> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnFragmentNavigation(System.Windows.Navigation.FragmentNavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnLoadCompleted(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigated(System.Windows.Navigation.NavigationEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigating(System.Windows.Navigation.NavigatingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationProgress(System.Windows.Navigation.NavigationProgressEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnNavigationFailed(System.Windows.Navigation.NavigationFailedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionEnding">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionEnding (System.Windows.SessionEndingCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionEnding(class System.Windows.SessionEndingCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionEnding (e As SessionEndingCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionEnding(System::Windows::SessionEndingCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit&#xA;override this.OnSessionEnding : System.Windows.SessionEndingCancelEventArgs -&gt; unit" Usage="application.OnSessionEnding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.SessionEndingCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.SessionEndingCancelEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.SessionEnding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnSessionEnding%2A> déclenche l'événement <xref:System.Windows.Application.SessionEnding>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnSessionEnding%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnSessionEnding%2A> dans la classe de base si <xref:System.Windows.Application.SessionEnding> doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStartup">
      <MemberSignature Language="C#" Value="protected virtual void OnStartup (System.Windows.StartupEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStartup(class System.Windows.StartupEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStartup (e As StartupEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStartup(System::Windows::StartupEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStartup : System.Windows.StartupEventArgs -&gt; unit&#xA;override this.OnStartup : System.Windows.StartupEventArgs -&gt; unit" Usage="application.OnStartup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.StartupEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.StartupEventArgs" /> qui contient les données d'événement.</param>
        <summary>Déclenche l'événement <see cref="E:System.Windows.Application.Startup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.OnStartup%2A> déclenche l'événement <xref:System.Windows.Application.Startup>.  
  
 Un type qui dérive de <xref:System.Windows.Application> peuvent substituer <xref:System.Windows.Application.OnStartup%2A>. La méthode substituée doit appeler <xref:System.Windows.Application.OnStartup%2A> dans la classe de base si le <xref:System.Windows.Application.Startup> événement doit être déclenché.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="M:System.Windows.Application.OnExit(System.Windows.ExitEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Properties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IDictionary ^ Properties { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.IDictionary" Usage="System.Windows.Application.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une collection de propriétés de portée application.</summary>
        <value><see cref="T:System.Collections.IDictionary" /> qui contient les propriétés de portée application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application> expose un dictionnaire via <xref:System.Windows.Application.Properties%2A> que vous pouvez utiliser pour stocker les propriétés de portée application. Cela vous permet de partager un état avec tout le code dans un <xref:System.AppDomain> de manière thread-safe, sans devoir écrire votre propre code d’état.  
  
 Les propriétés stockées dans <xref:System.Windows.Application.Properties%2A> doivent être converties dans le type retourné approprié.  
  
 Le <xref:System.Windows.Application.Properties%2A> propriété est thread-safe et est disponible à partir de n’importe quel thread.  
  
   
  
## Examples  
 L’exemple suivant montre comment créer et utiliser une propriété de portée application à l’aide <xref:System.Windows.Application.Properties%2A>.  
  
 [!code-xaml[ApplicationPropertiesSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml1)]  
[!code-xaml[ApplicationPropertiesSnippets#MainWindowGetPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml#mainwindowgetpropertyxaml2)]  
  
 [!code-csharp[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationPropertiesSnippets/CSharp/MainWindow.xaml.cs#mainwindowgetpropertycodebehind)]
 [!code-vb[ApplicationPropertiesSnippets#MainWindowGetPropertyCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationPropertiesSnippets/visualbasic/mainwindow.xaml.vb#mainwindowgetpropertycodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="ResourceAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ResourceAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Assembly ResourceAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ResourceAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ResourceAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Assembly ^ ResourceAssembly { System::Reflection::Assembly ^ get(); void set(System::Reflection::Assembly ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResourceAssembly : System.Reflection.Assembly with get, set" Usage="System.Windows.Application.ResourceAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="T:System.Reflection.Assembly" /> qui fournit les [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] à en-tête pack pour les ressources d'une application [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</summary>
        <value>Référence au <see cref="T:System.Reflection.Assembly" /> qui fournit les [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] à en-tête pour les ressources d'une application [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ressources sont résolues au moment de l’exécution par rapport à l’assembly d’entrée, qui est identifiée par la valeur retournée par la <xref:System.Reflection.Assembly.GetEntryAssembly%2A> (méthode).  
  
 L’assembly d’entrée est l’assembly qui est retourné par <xref:System.Reflection.Assembly.GetEntryAssembly%2A> et peut être ce qui suit :  
  
-   L’assembly exécutable dans le domaine d’application par défaut.  
  
-   Le premier assembly doit être exécuté en appelant <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 Dans les cas suivants, cependant, un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly ne peut pas obtenir une référence à l’assembly d’entrée :  
  
-   Un hôtes d’application non managée (native) le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly.  
  
-   Une application managée héberge le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly en la chargeant dans un nouveau domaine d’application à l’aide d’une méthode autre que <xref:System.AppDomain.ExecuteAssembly%2A>.  
  
 Dans ces deux cas, <xref:System.Reflection.Assembly.GetEntryAssembly%2A> retourne `null`et le [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] ressources de l’assembly ne peut pas être résolus. Dans ce cas, <xref:System.Windows.Application.ResourceAssembly%2A> peut être définie, une seule fois, avec une référence à l’assembly qui doit être utilisé pour résoudre des ressources.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> ne peut être définie qu’une seule fois, car il est peu probable que l’assembly de ressource va changer suite à la [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly est chargé.  
  
> [!NOTE]
>  <xref:System.Windows.Application.ResourceAssembly%2A> Impossible de définir quand un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] assembly peut découvrir l’assembly d’entrée - autrement dit, lorsque <xref:System.Reflection.Assembly.GetEntryAssembly%2A> retourne une référence à un assembly plutôt que `null`.  
  
 Cette propriété est thread-safe et est disponible à partir de n’importe quel thread.  
  
 <xref:System.Windows.Application.ResourceAssembly%2A> est introduit dans le .NET Framework version 3.5.  Pour plus d’informations, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Une application [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] possède un assembly d'entrée ou <see cref="P:System.Windows.Application.ResourceAssembly" /> a déjà été défini.</exception>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Resources : System.Windows.ResourceDictionary with get, set" Usage="System.Windows.Application.Resources" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une collection de ressources de portée application, telles que des styles et des pinceaux.</summary>
        <value>Objet <see cref="T:System.Windows.ResourceDictionary" /> qui contient zéro ou plusieurs ressources de portée application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Application.Resources%2A> propriété peut être utilisée pour partager des ressources entre les éléments d’une application windows. En outre, le <xref:System.Windows.Application.Resources%2A> propriété est incluse dans le chemin d’accès de la recherche des ressources, qui est parcouru dans l’ordre suivant :  
  
1.  Éléments  
  
2.  Windows  
  
3.  <xref:System.Windows.Application.Resources%2A?displayProperty=nameWithType>  
  
4.  Système  
  
 Par conséquent, [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] peuvent lier des éléments à des ressources de portée application. En outre, si des ressources changent, le système de ressources garantit que cet élément propriétés qui sont liées à ces ressources sont automatiquement mis à jour pour refléter la modification.  
  
 Ressources de portée application fournissent un moyen simple pour prendre en charge un thème cohérent dans toute votre application. Vous pouvez facilement créer un thème dans [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] à l’aide de la `Application.Resources` balise. Toutefois, si votre application prend en charge plusieurs thèmes, qui peuvent contenir un grand nombre d’éléments de thème, il peut être plus facile à gérer à l’aide de <xref:System.Windows.ResourceDictionary> instance pour chaque thème. De cette façon, vous pouvez appliquer un nouveau thème en définissant la propriété de ressources appropriés <xref:System.Windows.ResourceDictionary>.  
  
 Il existe deux considérations à prendre lorsque vous utilisez <xref:System.Windows.Application.Resources%2A>. Tout d’abord, le dictionnaire *clé* est un objet, vous devez donc utiliser exactement la même instance d’objet lorsque vous définissez et obtenez une valeur de propriété (Notez que la clé respecte la casse lors de l’utilisation d’une chaîne). Ensuite, le dictionnaire *valeur* est un objet, donc vous devrez convertir la valeur vers le type souhaité lors de l’obtention d’une valeur de propriété.  
  
 <xref:System.Windows.Application.Resources%2A> est thread-safe et est disponible à partir de n’importe quel thread.  
  
   
  
## Examples  
 Cet exemple montre comment utiliser [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] avec les ressources de portée application pour créer une apparence visuelle cohérente.  
  
 [!code-xaml[ApplicationResourcesSnippets#ResourcesPropertyXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/App.xaml#resourcespropertyxaml)]  
  
 [!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml1)]  
[!code-xaml[ApplicationResourcesSnippets#WindowBackgroundPropertyXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationResourcesSnippets/CS/MainWindow.xaml#windowbackgroundpropertyxaml2)]  
  
 L’exemple suivant montre comment définir une ressource d’application dans le code et XAML.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#setapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#SetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#setapplicationscoperesourcecode)]  
  
 [!code-xaml[HOWTOApplicationModelSnippets#SetApplicationScopeResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/App.xaml#setapplicationscoperesourcexaml)]  
  
 L’exemple suivant montre comment obtenir une ressource d’application dans le code.  
  
 [!code-csharp[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/CSharp/ApplicationPropertiesSnippet.xaml.cs#getapplicationscoperesourcecode)]
 [!code-vb[HOWTOApplicationModelSnippets#GetApplicationScopeResourceCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOApplicationModelSnippets/visualbasic/applicationpropertiessnippet.xaml.vb#getapplicationscoperesourcecode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Démarre une application Windows Presentation Foundation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Function Run () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run();" />
      <MemberSignature Language="F#" Value="member this.Run : unit -&gt; int" Usage="application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Démarre une application Windows Presentation Foundation.</summary>
        <returns>Code de sortie de l'application <see cref="T:System.Int32" /> retourné au système d'exploitation lors de la fermeture de l'application. Par défaut, le code de sortie a la valeur 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.Run%2A> est appelée pour démarrer un [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] application. Si vous définissez votre <xref:System.Windows.Application> à l’aide du balisage, ou balisage et code-behind, <xref:System.Windows.Application.Run%2A> est appelé implicitement. Toutefois, si vous définissez votre <xref:System.Windows.Application> à l’aide de code, vous devez appeler explicitement <xref:System.Windows.Application.Run%2A>.  
  
 Lorsque <xref:System.Windows.Application.Run%2A> est appelée, <xref:System.Windows.Application> joint un nouveau <xref:System.Windows.Threading.Dispatcher> instance pour le thread d’interface utilisateur. Ensuite, le <xref:System.Windows.Threading.Dispatcher> l’objet <xref:System.Windows.Threading.Dispatcher.Run%2A> méthode est appelée, ce qui démarre une pompe de messages à traiter des messages windows. Enfin, le <xref:System.Windows.Threading.Dispatcher> object appelle le <xref:System.Windows.Application> l’objet le <xref:System.Windows.Application.OnStartup%2A> méthode pour déclencher le <xref:System.Windows.Application.Startup> événement. Par conséquent, le modèle d’exécution d’application a été établi au moment où vous gérez <xref:System.Windows.Application.Startup>, à quel point l’application est censée être en cours d’exécution.  
  
 Une application s’arrête lorsque <xref:System.Windows.Application.Shutdown%2A> est appelée ; la valeur de la <xref:System.Windows.Application.ShutdownMode%2A> propriété détermine le moment <xref:System.Windows.Application.Shutdown%2A> est appelée et si elle se produit automatiquement, ou vous devez explicitement appeler.  
  
 <xref:System.Windows.Application.Run%2A> peut être appelée que dans le thread qui crée le <xref:System.Windows.Application> objet. En outre, <xref:System.Windows.Application.Run%2A> ne peut pas être appelée à partir d’un [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
   
  
## Examples  
 L’exemple suivant montre une application qui utilise un personnalisé <xref:System.Windows.Application> et ne doit par conséquent appeler explicitement <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunSnippets/CSharp/App.cs#customentrypointandruncode)]
 [!code-vb[ApplicationRunSnippets#CustomEntryPointAndRunCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunSnippets/visualbasic/app.vb#customentrypointandruncode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> est appelé à partir d'une application hébergée par le navigateur (par exemple, une [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public int Run (System.Windows.Window window);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Run(class System.Windows.Window window) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Run(System.Windows.Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Run(System::Windows::Window ^ window);" />
      <MemberSignature Language="F#" Value="member this.Run : System.Windows.Window -&gt; int" Usage="application.Run window" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="window" Type="System.Windows.Window" />
      </Parameters>
      <Docs>
        <param name="window"><see cref="T:System.Windows.Window" /> qui s'ouvre automatiquement au démarrage d'une application.</param>
        <summary>Démarre une application Windows Presentation Foundation et ouvre la fenêtre spécifiée.</summary>
        <returns>Code de sortie de l'application <see cref="T:System.Int32" /> retourné au système d'exploitation lors de la fermeture de l'application. Par défaut, le code de sortie a la valeur 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge étend la <xref:System.Windows.Application.Run%2A> méthode pour ouvrir la fenêtre spécifiée après le démarrage d’une application en cours d’exécution.  
  
 Si vous définissez un code <xref:System.Windows.Application> qui ouvre une fenêtre lorsqu’elle démarre, vous appelez explicitement <xref:System.Windows.Application.Run%2A>.  
  
 Si vous créez votre <xref:System.Windows.Application> à l’aide de balisage, ou balisage et code-behind, vous pouvez ouvrir automatiquement une fenêtre à l’aide des techniques suivantes :  
  
-   De façon déclarative, en définissant <xref:System.Windows.Application.StartupUri%2A>.  
  
-   Par programme, en gérant <xref:System.Windows.Application.Startup>.  
  
   
  
## Examples  
 L’exemple suivant montre une application avec une méthode de point d’entrée statique créée manuellement qui instancie <xref:System.Windows.Application>, avant d’appeler <xref:System.Windows.Application.Run%2A>.  
  
 [!code-csharp[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationRunOL1Snippets/CSharp/App.cs#customentrypointandrunol1code)]
 [!code-vb[ApplicationRunOL1Snippets#CustomEntryPointAndRunOL1CODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationRunOL1Snippets/visualbasic/app.vb#customentrypointandrunol1code)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Windows.Application.Run" /> est appelé à partir d'une application hébergée par le navigateur (par exemple, une [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).</exception>
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SessionEnding">
      <MemberSignature Language="C#" Value="public event System.Windows.SessionEndingCancelEventHandler SessionEnding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SessionEndingCancelEventHandler SessionEnding" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.SessionEnding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SessionEnding As SessionEndingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SessionEndingCancelEventHandler ^ SessionEnding;" />
      <MemberSignature Language="F#" Value="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " Usage="member this.SessionEnding : System.Windows.SessionEndingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SessionEndingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand l’utilisateur met fin à la session Windows en se déconnectant ou en arrêtant le système d’exploitation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, une application se ferme lorsque la fin de la session Windows, ce qui se produit lorsqu’un utilisateur se déconnecte ou s’arrête. Dans ce cas, Windows vous demande de chaque application ouverte pour arrêter. Toutefois, il est possible qu’une application n’est peut-être pas prête à arrêter lorsque cela se produit. Par exemple, une application peut avoir des données qui se trouve dans un état incohérent ou au milieu d’une opération longue. Dans ces situations, il peut être souhaitable pour empêcher la session de fin et peut être plus intéressant pour permettre aux utilisateurs de décider s’il faut que la session à la fin.  
  
 Vous pouvez détecter qu’une session se termine en gérant la <xref:System.Windows.Application.SessionEnding> événement. Si une application doit empêcher la session de fin, le <xref:System.Windows.SessionEndingCancelEventArgs> argument passé au gestionnaire d’événements expose le <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> que vous définissez pour `true` (la valeur par défaut est `false`).  
  
 Si <xref:System.Windows.Application.SessionEnding> n’est pas gérée, ou est géré sans être annulé, <xref:System.Windows.Application.Shutdown%2A> est appelée et le <xref:System.Windows.Application.Exit> événement est déclenché.  
  
 Pour obtenir plus d’informations sur la raison pour laquelle la session se termine, une application peut inspecter <xref:System.Windows.SessionEndingCancelEventArgs.ReasonSessionEnding%2A>, qui est une de le <xref:System.Windows.ReasonSessionEnding> valeurs (<xref:System.Windows.ReasonSessionEnding.Logoff?displayProperty=nameWithType> et <xref:System.Windows.ReasonSessionEnding.Shutdown?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Application.SessionEnding> n’est pas déclenché par les applications de console.  
  
 <xref:System.Windows.Application.SessionEnding> est déclenché uniquement sur le thread qui crée le <xref:System.Windows.Application> objet.  
  
 <xref:System.Windows.Application.SessionEnding> n’est pas déclenché pour les applications de navigateur XAML (XBAP).  
  
   
  
## Examples  
 L’exemple suivant montre comment gérer les <xref:System.Windows.Application.SessionEnding> événement et autoriser l’utilisateur pour l’annuler.  
  
 [!code-xaml[ApplicationSessionEndingSnippets#HandlingSessionEndingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml#handlingsessionendingxaml)]  
  
 [!code-csharp[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/CSharp/App.xaml.cs#handlingsessionendingcodebehind)]
 [!code-vb[ApplicationSessionEndingSnippets#HandlingSessionEndingCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationSessionEndingSnippets/visualbasic/application.xaml.vb#handlingsessionendingcodebehind)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnSessionEnding(System.Windows.SessionEndingCancelEventArgs)" />
        <altmember cref="E:System.Windows.Application.Startup" />
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public static void SetCookie (Uri uri, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCookie(class System.Uri uri, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCookie(Uri ^ uri, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetCookie : Uri * string -&gt; unit" Usage="System.Windows.Application.SetCookie (uri, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri"><see cref="T:System.Uri" /> qui spécifie l'emplacement pour lequel le cookie doit être créé.</param>
        <param name="value"><see cref="T:System.String" /> qui contient les données de cookie.</param>
        <summary>Crée un cookie pour l'emplacement spécifié par un <see cref="T:System.Uri" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un cookie est un élément de données qui peuvent être stockées par une application sur l’ordinateur client au cours de sessions de l’application (les cookies de session) ou entre les sessions d’application (cookies persistants) arbitraire. Vous pouvez créer les deux types de cookies en appelant <xref:System.Windows.Application.SetCookie%2A>.  
  
 Données de cookie prennent généralement la forme d’une paire nom/valeur au format suivant :  
  
 `Name=Value`  
  
 Vous passez une chaîne de ce format pour <xref:System.Windows.Application.SetCookie%2A>, avec le <xref:System.Uri> de l’emplacement pour lequel le cookie doit être défini (en règle générale, le domaine d’application).  
  
 Si un cookie est un cookie de session ou un cookie persistant dépend de si le cookie de chaîne que vous transmettez à <xref:System.Windows.Application.SetCookie%2A> inclut une date d’expiration. La chaîne d’un cookie de session n’inclut pas une date d’expiration. La chaîne d’un cookie persistant est le cas et doit être au format suivant :  
  
 `NAME=VALUE; expires=DAY, DD-MMM-YYYY HH:MM:SS GMT`  
  
 Cookies persistants sont stockés dans le courant [!INCLUDE[TLA#tla_mswin](~/includes/tlasharptla-mswin-md.md)] dossier de fichiers Internet temporaires de l’installation jusqu'à leur expiration, auquel cas ils sont supprimés. Vous pouvez supprimer un cookie persistant à partir de votre application en définissant sa date d’expiration sur une valeur de date/heure qui se trouve dans le passé.  
  
 Pour une vue d’ensemble des cookies dans [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)], consultez [vue d’ensemble de la Navigation](~/docs/framework/wpf/app-development/navigation-overview.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Une erreur [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] est déclenchée par la fonction <see langword="InternetSetCookie" /> (appelée par <see cref="M:System.Windows.Application.SetCookie(System.Uri,System.String)" />) si un problème survient durant la tentative de création du cookie spécifié.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour recevoir le cookie pour basé sur un fichier <see cref="T:System.Uri" />. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour recevoir le cookie pour un fichier non-Windows, <see cref="T:System.Uri" />. Énumération associée : <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Windows.Application.GetCookie(System.Uri)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Shutdown">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Arrête une application.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown();" />
      <MemberSignature Language="F#" Value="member this.Shutdown : unit -&gt; unit" Usage="application.Shutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Arrête une application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque <xref:System.Windows.Application.Shutdown%2A> est appelée, une application cesse de s’exécuter. Vous pouvez gérer le <xref:System.Windows.Application.Exit> événement pour détecter lorsqu’une application est sur le point d’arrêt en cours d’exécution, pour effectuer tout traitement approprié.  
  
 <xref:System.Windows.Application.Shutdown%2A> est appelé implicitement par Windows Presentation Foundation dans les situations suivantes :  
  
-   Lorsque <xref:System.Windows.Application.ShutdownMode%2A> est défini sur <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
-   Lorsque le <xref:System.Windows.Application.ShutdownMode%2A> est défini sur <xref:System.Windows.ShutdownMode.OnMainWindowClose>.  
  
-   Lorsqu’un utilisateur termine une session et le <xref:System.Windows.Application.SessionEnding> événement est géré sans annulation ou non prise en charge.  
  
 Appel <xref:System.Windows.Application.Shutdown%2A> explicitement entraîne l’application à arrêter, quel que soit le <xref:System.Windows.Application.ShutdownMode%2A> paramètre. Toutefois, si <xref:System.Windows.Application.ShutdownMode%2A> a la valeur <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, vous devez appeler <xref:System.Windows.Application.Shutdown%2A> pour arrêter une application.  
  
> [!IMPORTANT]
>  Lorsque <xref:System.Windows.Application.Shutdown%2A> est appelée, l’application s’arrête, quelle que soit s’il le <xref:System.Windows.Window.Closing> de toutes les fenêtres actives est annulé.  
  
 Cette méthode peut être appelée uniquement à partir du thread qui a créé le <xref:System.Windows.Application> objet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Application.Shutdown(System.Int32)" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
        <altmember cref="M:System.Windows.Application.Run" />
        <altmember cref="M:System.Windows.Application.Run(System.Windows.Window)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.Shutdown(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(int exitCode);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : int -&gt; unit" Usage="application.Shutdown exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Code de sortie entier pour une application. Le code de sortie par défaut est 0.</param>
        <summary>Ferme une application qui retourne le code de sortie spécifié au système d'exploitation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez gérer le <xref:System.Windows.Application.Exit> événement pour définir un code de sortie. Toutefois, si vous appelez explicitement <xref:System.Windows.Application.Shutdown%2A>, et que vous gérez <xref:System.Windows.Application.Exit> uniquement pour définir un code de sortie, vous pouvez appeler <xref:System.Windows.Application.Shutdown%2A> à la place.  
  
 Cette méthode peut être appelée uniquement à partir du thread qui a créé le <xref:System.Windows.Application> objet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">autorisation d’utiliser toutes les fenêtres et événements d’entrée d’utilisateur sans restriction. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="Overload:System.Windows.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="ShutdownMode">
      <MemberSignature Language="C#" Value="public System.Windows.ShutdownMode ShutdownMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ShutdownMode ShutdownMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.ShutdownMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ShutdownMode As ShutdownMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ShutdownMode ShutdownMode { System::Windows::ShutdownMode get(); void set(System::Windows::ShutdownMode value); };" />
      <MemberSignature Language="F#" Value="member this.ShutdownMode : System.Windows.ShutdownMode with get, set" Usage="System.Windows.Application.ShutdownMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ShutdownMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la condition qui provoque l'appel de la méthode <see cref="M:System.Windows.Application.Shutdown" />.</summary>
        <value>Valeur d'énumération <see cref="T:System.Windows.ShutdownMode" />. La valeur par défaut est <see cref="F:System.Windows.ShutdownMode.OnLastWindowClose" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Arrêter d’applications en cours d’exécution uniquement lorsque le <xref:System.Windows.Application.Shutdown%2A> méthode de l’Application est appelée. Fermeture peut intervenir implicitement ou explicitement, comme spécifié par la valeur de la <xref:System.Windows.Application.ShutdownMode%2A> propriété.  
  
 Si vous définissez <xref:System.Windows.Application.ShutdownMode%2A> à <xref:System.Windows.ShutdownMode.OnLastWindowClose>, Windows Presentation Foundation (WPF) appelle implicitement <xref:System.Windows.Application.Shutdown%2A> lorsque la dernière fenêtre dans une application se ferme, même si toutes les fenêtres actuellement instanciées sont définies en tant que la fenêtre principale (voir <xref:System.Windows.Application.MainWindow%2A>).  
  
 Un <xref:System.Windows.Application.ShutdownMode%2A> de <xref:System.Windows.ShutdownMode.OnMainWindowClose> indique à WPF appeler implicitement <xref:System.Windows.Application.Shutdown%2A> lorsque le <xref:System.Windows.Application.MainWindow%2A> se ferme, même si d’autres fenêtres sont actuellement ouvertes.  
  
 La durée de vie de certaines applications ne peut pas dépendre lorsque la fenêtre principale ou la dernière fenêtre est fermée, ou peut-être pas dépendante sur windows du tout. Pour ces scénarios, vous devez définir le <xref:System.Windows.Application.ShutdownMode%2A> propriété <xref:System.Windows.ShutdownMode.OnExplicitShutdown>, ce qui nécessite une explicite <xref:System.Windows.Application.Shutdown%2A> appel de méthode pour arrêter l’application. Sinon, l’application continue de s’exécuter en arrière-plan.  
  
 <xref:System.Windows.Application.ShutdownMode%2A> peut être configuré de façon déclarative à partir de [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] ou par programmation à partir de code.  
  
 Cette propriété est disponible uniquement dans le thread qui a créé le <xref:System.Windows.Application> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment configurer <xref:System.Windows.Application.ShutdownMode%2A> pour spécifier qu’une application doit être fermée explicitement.  
  
 [!code-xaml[ApplicationShutdownModeSnippets#SetShutdownModeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationShutdownModeSnippets/CS/App.xaml#setshutdownmodexaml)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="Startup">
      <MemberSignature Language="C#" Value="public event System.Windows.StartupEventHandler Startup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.StartupEventHandler Startup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Application.Startup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Startup As StartupEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::StartupEventHandler ^ Startup;" />
      <MemberSignature Language="F#" Value="member this.Startup : System.Windows.StartupEventHandler " Usage="member this.Startup : System.Windows.StartupEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.StartupEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque la méthode <see cref="M:System.Windows.Application.Run" /> de l'objet <see cref="T:System.Windows.Application" /> est appelée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une application Windows Presentation Foundation classique peut effectuer diverses tâches d’initialisation lors de son démarrage, y compris :  
  
-   Traitement des paramètres de ligne de commande.  
  
-   Ouvrir la fenêtre principale.  
  
-   Ressources de portée application lors de l’initialisation.  
  
-   Propriétés de portée application lors de l’initialisation.  
  
 Vous pouvez spécifier de façon déclarative la fenêtre principale et les ressources de portée application à l’aide [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] (<xref:System.Windows.Application.StartupUri%2A> et <xref:System.Windows.Application.Resources%2A>, respectivement). Parfois, toutefois, les ressources ou la fenêtre principale de votre application peut uniquement être déterminée par programme au moment de l’exécution. En outre, les propriétés de portée application et les paramètres de ligne de commande peuvent uniquement être utilisés par programme. L’initialisation par programme peut être effectuée en gérant la <xref:System.Windows.Application.Startup> événement, y compris les éléments suivants :  
  
-   Acquérir et traiter des paramètres de ligne de commande, qui sont disponibles à partir de la <xref:System.Windows.StartupEventArgs.Args%2A> propriété de la <xref:System.Windows.StartupEventArgs> classe qui est passé à la <xref:System.Windows.Application.Startup> Gestionnaire d’événements.  
  
-   Initialiser les ressources de portée application à l’aide de la <xref:System.Windows.Application.Resources%2A> propriété.  
  
-   Initialiser des propriétés de portée application à l’aide de la <xref:System.Windows.Application.Properties%2A> propriété.  
  
-   Instancier et afficher une (ou plus) de windows.  
  
> [!NOTE]
>  Paramètres de ligne de commande peuvent également être acquis en appelant la méthode statique <xref:System.Environment.GetCommandLineArgs%2A> méthode de la <xref:System.Environment> objet. Toutefois, <xref:System.Environment.GetCommandLineArgs%2A> requiert une confiance totale à exécuter.  
  
 Si vous définissez <xref:System.Windows.Application.StartupUri%2A> à l’aide de [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)], la fenêtre principale est créée n’est pas disponible à partir de le le <xref:System.Windows.Application.MainWindow%2A> propriété ou le <xref:System.Windows.Application.Windows%2A> propriété de la <xref:System.Windows.Application> objet jusqu’après la <xref:System.Windows.Application.Startup> événement est traité. Si vous devez accéder à la fenêtre principale lors du démarrage, vous devez créer manuellement un nouvel objet de fenêtre à partir de votre <xref:System.Windows.Application.Startup> Gestionnaire d’événements.  
  
> [!NOTE]
>  Si votre application utilise <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> pour spécifier une stratégie d’informations d’identification, vous devez définir <xref:System.Net.AuthenticationManager.CredentialPolicy%2A> après <xref:System.Windows.Application.Startup> est déclenché ; sinon, [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] lui affecte une stratégie par défaut interne directement après le <xref:System.Windows.Application.Startup> événement a été déclenché.  
  
 Les arguments de ligne de commande qui sont passés à la <xref:System.Windows.Application.Startup> Gestionnaire d’événements ne sont pas les mêmes que les [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)] chaîne de requête qui sont passés à un [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)].  
  
   
  
## Examples  
 L’exemple suivant montre comment acquérir et traiter des options de ligne de commande à partir d’une application autonome. Si le **/StartMinimized** paramètre de ligne de commande a été fourni, l’application ouvre la fenêtre principale dans un état réduit.  
  
 [!code-xaml[ApplicationStartupSnippets#HandleStartupXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml#handlestartupxaml)]  
  
 [!code-csharp[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationStartupSnippets/CSharp/App.xaml.cs#handlestartupcodebehind)]
 [!code-vb[ApplicationStartupSnippets#HandleStartupCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationStartupSnippets/visualbasic/application.xaml.vb#handlestartupcodebehind)]  
  
 [!INCLUDE[TLA#tla_xbap#plural](~/includes/tlasharptla-xbapsharpplural-md.md)] ne peut pas récupérer et traiter des arguments de ligne de commande, car elles sont lancées avec [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)] déploiement (voir [déploiement d’une Application WPF (WPF)](~/docs/framework/wpf/app-development/deploying-a-wpf-application-wpf.md)). En revanche, ils peuvent récupérer et traiter des paramètres de chaîne de requête à partir des URL servant à les lancer.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.OnStartup(System.Windows.StartupEventArgs)" />
        <altmember cref="E:System.Windows.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="StartupUri">
      <MemberSignature Language="C#" Value="public Uri StartupUri { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri StartupUri" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.StartupUri" />
      <MemberSignature Language="VB.NET" Value="Public Property StartupUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ StartupUri { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartupUri : Uri with get, set" Usage="System.Windows.Application.StartupUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une interface utilisateur qui s'affiche automatiquement au démarrage d'une application.</summary>
        <value>Un <see cref="T:System.Uri" /> qui fait référence à l’interface utilisateur qui s’ouvre automatiquement lorsqu’une application démarre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser <xref:System.Windows.Application.StartupUri%2A> pour charger automatiquement une ressource de l’interface utilisateur lorsqu’une application démarre.  
  
 Le tableau suivant présente les types de ressources de l’interface utilisateur qui peuvent être chargées, le type de fenêtre qu’ils sont ouverts et le type d’application que ces ressources peuvent être définies en tant que le <xref:System.Windows.Application.StartupUri%2A>.  
  
|Type|Fenêtre|Type d'application|  
|----------|------------|----------------------|  
|<xref:System.Windows.Window>|<xref:System.Windows.Window>|Autonome uniquement|  
|<xref:System.Windows.Navigation.NavigationWindow>|<xref:System.Windows.Navigation.NavigationWindow>|Autonome uniquement|  
|<xref:System.Windows.Controls.Page>|<xref:System.Windows.Navigation.NavigationWindow>|Autonome/hébergées par un navigateur|  
|<xref:System.Windows.Controls.UserControl>|<xref:System.Windows.Navigation.NavigationWindow>|Autonome/hébergées par un navigateur|  
|<xref:System.Windows.Documents.FlowDocument>|<xref:System.Windows.Navigation.NavigationWindow>|Autonome/hébergées par un navigateur|  
|<xref:System.Windows.Navigation.PageFunction%601>|<xref:System.Windows.Navigation.NavigationWindow>|Autonome/hébergées par un navigateur|  
  
 En règle générale, vous définissez le <xref:System.Windows.Application.StartupUri%2A> propriété de façon déclarative dans [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)]. Toutefois, vous pouvez définir <xref:System.Windows.Application.StartupUri%2A> par programmation, telles que d’un <xref:System.Windows.Application.Startup> Gestionnaire d’événements, ce qui est utile pour les applications qui peuvent uniquement charger les ressources nécessaires pour l’interface utilisateur en cours d’exécution. Par exemple, une application peut attendre jusqu’au moment de l’exécution pour charger ses ressources si le nom de la ressource de l’interface utilisateur est stocké dans un fichier de configuration.  
  
 Si vous définissez <xref:System.Windows.Application.StartupUri%2A> de manière déclarative ou par programme, la ressource d’interface utilisateur correspondante n’est pas chargée tant qu’après le <xref:System.Windows.Application.Startup> événement est géré. Par conséquent, vous n’aurez accès à la fenêtre résultante à partir de le le <xref:System.Windows.Application.Windows%2A> propriété ou le <xref:System.Windows.Application.MainWindow%2A> propriété lors de la gestion <xref:System.Windows.Application.Startup>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Windows.Application.StartupUri" /> a la valeur null.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nom de la propriété ambiante demandée.</param>
        <summary>Demande si une propriété ambiante spécifiée est disponible dans la portée actuelle.</summary>
        <returns><see langword="true" /> si la propriété ambiante demandée est disponible ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Windows.Application> est castée en interface <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Markup.IQueryAmbient" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Application.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberSignature Language="F#" Value="member this.TryFindResource : obj -&gt; obj" Usage="application.TryFindResource resourceKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Nom de la ressource à rechercher.</param>
        <summary>Recherche la ressource spécifiée.</summary>
        <returns>Objet de la ressource demandée. Si la ressource demandée est introuvable, une référence nulle est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Application.TryFindResource%2A> recherche d’abord dans les ressources de portée application pour la ressource spécifiée. Les ressources de portée application sont gérées par <xref:System.Windows.Application>et sont exposées à partir de la <xref:System.Windows.Application.Resources%2A> propriété. Si la ressource spécifiée est introuvable dans l’ensemble de ressources de portée application, <xref:System.Windows.Application.TryFindResource%2A> puis suivant recherche les ressources système. Ressources système sont des ressources de shell définis par l’utilisateur et incluent des couleurs, des polices et des configurations d’interpréteur de commandes. Ceux-ci sont exposés à partir de la <xref:System.Windows.SystemColors>, <xref:System.Windows.SystemFonts>, et <xref:System.Windows.SystemParameters> respectivement, les types, en tant que propriétés statiques. Pour utiliser <xref:System.Windows.Application.TryFindResource%2A> pour acquérir, ces types exposent également des propriétés de clé de ressource qui sont conçues pour être transmis à <xref:System.Windows.Application.TryFindResource%2A>; par exemple, <xref:System.Windows.SystemParameters.IconWidthKey%2A>.  
  
 Étant donné que <xref:System.Windows.Application.TryFindResource%2A> retourne un objet, vous devez caster la valeur retournée en type approprié si la ressource est introuvable.  
  
 Cette méthode est thread-safe et peut être appelée à partir de n’importe quel thread.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Windows.Application.TryFindResource%2A> pour acquérir une ressource.  
  
 [!code-xaml[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/App.xaml#applicationcalltryfindresourcexaml)]  
  
 [!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind1)]
 [!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind1)]  
[!code-csharp[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/CSharp/MainWindow.xaml.cs#applicationcalltryfindresourcecodebehind2)]
[!code-vb[ApplicationTryFindResourceSnippets#ApplicationCallTryFindResourceCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationTryFindResourceSnippets/visualbasic/mainwindow.xaml.vb#applicationcalltryfindresourcecodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Application.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Windows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection Windows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection Windows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Application.Windows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Windows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ Windows { System::Windows::WindowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Windows : System.Windows.WindowCollection" Usage="System.Windows.Application.Windows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les fenêtres instanciées dans une application.</summary>
        <value><see cref="T:System.Windows.WindowCollection" /> qui contient des références à tous les objets de fenêtre dans le <see cref="T:System.AppDomain" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Windows.Window> référence est ajoutée automatiquement à <xref:System.Windows.Application.Windows%2A> dès qu’une fenêtre est instanciée sur le [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] thread ; windows qui sont créés par le processus de travail threads ne sont pas ajoutés. Un <xref:System.Windows.Window> référence est automatiquement supprimée après son <xref:System.Windows.Window.Closing> événement a été géré et avant son <xref:System.Windows.Window.Closed> événement est déclenché.  
  
 Par défaut, le premier élément ajouté à la <xref:System.Windows.Application.Windows%2A> propriété devient le <xref:System.Windows.Application.MainWindow%2A>.  
  
 Cette propriété est disponible uniquement dans le thread qui a créé le <xref:System.Windows.Application> objet.  
  
   
  
## Examples  
 L’exemple suivant montre comment énumérer les <xref:System.Windows.Application.Windows%2A> propriété pour générer un menu Windows de niveau supérieur, qui est commun à [!INCLUDE[TLA#tla_mdi](~/includes/tlasharptla-mdi-md.md)] les applications telles que [!INCLUDE[TLA#tla_xl](~/includes/tlasharptla-xl-md.md)], ou comme des applications d’Interface SDI (Single Document) de plusieurs instances [!INCLUDE[TLA#tla_word](~/includes/tlasharptla-word-md.md)].  
  
 [!code-csharp[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/WindowMenuItem.cs#windowmenuitemcode)]
 [!code-vb[ApplicationWindowsSnippets#WindowMenuItemCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/windowmenuitem.vb#windowmenuitemcode)]  
  
 [!code-xaml[ApplicationWindowsSnippets#MainWindowSetWindowsXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml#mainwindowsetwindowsxaml)]  
  
 [!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind1)]
 [!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind1)]  
[!code-csharp[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/ApplicationWindowsSnippets/CSharp/MainWindow.xaml.cs#mainwindowsetwindowscodebehind2)]
[!code-vb[ApplicationWindowsSnippets#MainWindowSetWindowsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ApplicationWindowsSnippets/visualbasic/mainwindow.xaml.vb#mainwindowsetwindowscodebehind2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Window" />
      </Docs>
    </Member>
  </Members>
</Type>