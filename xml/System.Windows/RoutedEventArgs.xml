<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a03c4f8cd6f46e0811f54af7dc69e0ab173f1753" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48756017" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="11476-101">Contient des données d’événements et des informations état associées à un événement routé.</span>
      <span class="sxs-lookup">
        <span data-stu-id="11476-101">Contains state information and event data associated with a routed event.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-102">Différents <xref:System.Windows.RoutedEventArgs> peut être utilisé avec un seul <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="11476-102">Different <xref:System.Windows.RoutedEventArgs> can be used with a single <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>.</span></span> <span data-ttu-id="11476-103">Cette classe est chargée d’empaqueter les données d’événement pour un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, fournissant des informations d’état des événements supplémentaires et est utilisé par le système d’événements pour appeler le gestionnaire associé à l’événement routé.</span><span class="sxs-lookup"><span data-stu-id="11476-103">This class is responsible for packaging the event data for a <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, providing extra event state information, and is used by the event system for invoking the handler associated with the routed event.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="11476-104">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-104">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="11476-105">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-105">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-106">Lorsque vous utilisez ce constructeur sans paramètre, le toutes les propriétés publiques de la nouvelle <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :</span><span class="sxs-lookup"><span data-stu-id="11476-106">When using this parameterless constructor, all public properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="11476-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-107"><xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="11476-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`</span><span class="sxs-lookup"><span data-stu-id="11476-108"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="11476-109"><xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-109"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="11476-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-110"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="11476-111">Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> , cela signifie simplement que le <xref:System.Windows.RoutedEventArgs> données n’effectue aucune tentative pour spécifier la source.</span><span class="sxs-lookup"><span data-stu-id="11476-111">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that the <xref:System.Windows.RoutedEventArgs> data makes no attempt to specify the source.</span></span> <span data-ttu-id="11476-112">Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont renseignées en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.</span><span class="sxs-lookup"><span data-stu-id="11476-112">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="11476-113">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-113">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11476-114">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-114">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-115">Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :</span><span class="sxs-lookup"><span data-stu-id="11476-115">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="11476-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`</span><span class="sxs-lookup"><span data-stu-id="11476-116"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="11476-117"><xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-117"><xref:System.Windows.RoutedEventArgs.Source%2A> defaults to `null`.</span></span>  
  
-   <span data-ttu-id="11476-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-118"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="11476-119">Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> , cela signifie simplement que cela <xref:System.Windows.RoutedEventArgs> n’effectue aucune tentative pour spécifier la source.</span><span class="sxs-lookup"><span data-stu-id="11476-119">Null values for <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> only mean that this <xref:System.Windows.RoutedEventArgs> makes no attempt to specify the source.</span></span> <span data-ttu-id="11476-120">Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont renseignées en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.</span><span class="sxs-lookup"><span data-stu-id="11476-120">When this instance is used in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>, the  <xref:System.Windows.RoutedEventArgs.Source%2A> and <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> values are populated based on the element that raised the event and are passed on to listeners through the routing.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11476-121">L’exemple suivant construit un nouveau <xref:System.Windows.RoutedEventArgs> pour une utilisation dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="11476-121">The following example constructs a new <xref:System.Windows.RoutedEventArgs> for use in a call to <xref:System.Windows.UIElement.RaiseEvent%2A>.</span></span>  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="11476-122">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-122">The routed event identifier for this instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class.</span>
          </span>
        </param>
        <param name="source">
          <span data-ttu-id="11476-123">Autre source qui sera signalée lorsque l'événement sera géré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-123">An alternate source that will be reported when the event is handled.</span>
          </span>
          <span data-ttu-id="11476-124">La propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> est alors préremplie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-124">This pre-populates the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11476-125">Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni afin de pouvoir déclarer une source différente pour l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-125">Initializes a new instance of the <see cref="T:System.Windows.RoutedEventArgs" /> class, using the supplied routed event identifier, and providing the opportunity to declare a different source for the event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-126">Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :</span><span class="sxs-lookup"><span data-stu-id="11476-126">When using this overloaded constructor, unspecified properties of the new <xref:System.Windows.RoutedEventArgs> instance assume the following default values:</span></span>  
  
-   <span data-ttu-id="11476-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`</span><span class="sxs-lookup"><span data-stu-id="11476-127"><xref:System.Windows.RoutedEventArgs.Handled%2A> defaults to `false`</span></span>  
  
-   <span data-ttu-id="11476-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.</span><span class="sxs-lookup"><span data-stu-id="11476-128"><xref:System.Windows.RoutedEventArgs.OriginalSource%2A> defaults to `null`.</span></span>  
  
 <span data-ttu-id="11476-129">Valeurs null <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sont remplis en fonction de l’élément qui a déclenché l’événement et transmises par le routage, mais elles seront `null` avant l’appel.</span><span class="sxs-lookup"><span data-stu-id="11476-129">Null values for <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> are populated based on the element that raised the event and passed on through the routing, but will read `null` prior to invocation.</span></span>  
  
 <span data-ttu-id="11476-130">Utilisez cette signature lors du passage <xref:System.Windows.RoutedEventArgs> à des éléments virtuels tels que <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, où les arguments sont utilisés pour appeler <xref:System.Windows.UIElement.RaiseEvent%2A> en interne.</span><span class="sxs-lookup"><span data-stu-id="11476-130">Use this signature when passing <xref:System.Windows.RoutedEventArgs> to virtuals such as <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, where the arguments are used to call <xref:System.Windows.UIElement.RaiseEvent%2A> internally.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11476-131">Obtient ou définit une valeur qui indique l’état actuel de la gestion des événements pour un événement routé le long de son itinéraire.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-131">Gets or sets a value that indicates the present state of the event handling for a routed event as it travels the route.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11476-132">Définition, affectez <see langword="true" /> si l’événement doit être marqué comme géré ; sinon <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-132">If setting, set to <see langword="true" /> if the event is to be marked handled; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="11476-133">Si la lecture de cette valeur, <see langword="true" /> indique qu’un gestionnaire de classe ou un gestionnaire d’instance le long de l’itinéraire a déjà marqué cet événement comme géré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-133">If reading this value, <see langword="true" /> indicates that either a class handler, or some instance handler along the route, has already marked this event handled.</span>
          </span>
          <span data-ttu-id="11476-134">
            <see langword="false" /> indique qu’aucun gestionnaire n’a marqué l’événement comme géré.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-134">
              <see langword="false" />.indicates that no such handler has marked the event handled.</span>
          </span>
          <span data-ttu-id="11476-135">La valeur par défaut est <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-135">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-136">Marquage de l’événement géré limite la visibilité de l’événement routé pour les écouteurs sur l’itinéraire d’événement.</span><span class="sxs-lookup"><span data-stu-id="11476-136">Marking the event handled will limit the visibility of the routed event to listeners along the event route.</span></span> <span data-ttu-id="11476-137">L’événement circulent toujours le reste de l’itinéraire, mais seuls les gestionnaires ajoutés avec `HandledEventsToo` `true` dans le <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> appel de méthode sera appelée en réponse.</span><span class="sxs-lookup"><span data-stu-id="11476-137">The event does still travel the remainder of the route, but only handlers specifically added with `HandledEventsToo` `true` in the <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> method call will be invoked in response.</span></span> <span data-ttu-id="11476-138">Gestionnaires par défaut sur les écouteurs d’instance (tels que ceux exprimés dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) ne sera pas appelée.</span><span class="sxs-lookup"><span data-stu-id="11476-138">Default handlers on instance listeners (such as those expressed in [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) will not be invoked.</span></span> <span data-ttu-id="11476-139">Gestion des événements qui sont marqués gérés ne sont pas un scénario courant.</span><span class="sxs-lookup"><span data-stu-id="11476-139">Handling events that are marked handled is not a common scenario.</span></span>  
  
 <span data-ttu-id="11476-140">Si vous êtes un créateur de contrôles définir vos propres événements, les décisions que vous prenez concernant les événements traités au niveau de la classe aura un impact sur les utilisateurs de votre contrôle, ainsi que tous les utilisateurs de contrôles dérivés, et potentiellement les autres éléments qui sont contenus dans votre contrôle ou qui contiennent votre contrôle.</span><span class="sxs-lookup"><span data-stu-id="11476-140">If you are a control author defining your own events, the decisions you make regarding event handling at the class level will impact users of your control as well as any users of derived controls, and potentially other elements that are either contained by your control or that contain your control.</span></span> <span data-ttu-id="11476-141">Pour plus d’informations, consultez [Marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span><span class="sxs-lookup"><span data-stu-id="11476-141">For more information, see [Marking Routed Events as Handled, and Class Handling](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
 <span data-ttu-id="11476-142">En de rares circonstances, il convient de gérer les événements où <xref:System.Windows.RoutedEventArgs.Handled%2A> est marquée `true`et modifier les arguments d’événement en modifiant <xref:System.Windows.RoutedEventArgs.Handled%2A> à `false`.</span><span class="sxs-lookup"><span data-stu-id="11476-142">In very rare circumstances it is appropriate to handle events where  <xref:System.Windows.RoutedEventArgs.Handled%2A> is marked `true`, and modify the event arguments by changing <xref:System.Windows.RoutedEventArgs.Handled%2A> to `false`.</span></span> <span data-ttu-id="11476-143">Cela peut être nécessaire dans certaines zones d’événements d’entrée de contrôles, tels que la gestion des clés de <xref:System.Windows.UIElement.KeyDown> et <xref:System.Windows.UIElement.TextInput> où à faible niveau de haut niveau des événements d’entrée sont en concurrence pour la gestion, et chacun essayant d’adopter une stratégie de routage différente.</span><span class="sxs-lookup"><span data-stu-id="11476-143">This can be necessary in certain areas of input events of controls, such as key handling of <xref:System.Windows.UIElement.KeyDown> versus <xref:System.Windows.UIElement.TextInput> where low level and high level input events compete for the handling, and each is attempting to work with a different routing strategy.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11476-144">L’exemple suivant implémente un gestionnaire d’événements qui marque l’événement géré.</span><span class="sxs-lookup"><span data-stu-id="11476-144">The following example implements an event handler that marks the event handled.</span></span>  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">
          <span data-ttu-id="11476-145">Implémentation de gestionnaire générique/délégué à appeler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-145">The generic handler / delegate implementation to be invoked.</span>
          </span>
        </param>
        <param name="genericTarget">
          <span data-ttu-id="11476-146">Cible sur laquelle le gestionnaire fourni doit être appelé.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-146">The target on which the provided handler should be invoked.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11476-147">En cas de substitution dans une classe dérivée, fournit un moyen d’appeler des gestionnaires d’événements d’une manière propre au type, ce qui peut améliorer l’efficacité par rapport à l’implémentation de base.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-147">When overridden in a derived class, provides a way to invoke event handlers in a type-specific way, which can increase efficiency over the base implementation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-148">L’implémentation de base intègre la réflexion pour déterminer le gestionnaire approprié pour tous les cas où le gestionnaire n’est pas <xref:System.Windows.RoutedEventHandler>, et cette étape de réflexion a certaines conséquences de performances.</span><span class="sxs-lookup"><span data-stu-id="11476-148">The base implementation incorporates reflection to determine the right handler for any case where the handler is not literally <xref:System.Windows.RoutedEventHandler>, and this reflection step does have some performance consequences.</span></span> <span data-ttu-id="11476-149">Appels peuvent être effectuées plus efficaces en vous appuyant ne pas sur la réflexion.</span><span class="sxs-lookup"><span data-stu-id="11476-149">Invocations can be made more efficient by not relying on reflection.</span></span> <span data-ttu-id="11476-150">C’est le scénario qui motive cette méthode est disponible pour toute classe d’arguments d’événement routé choisir de remplacer.</span><span class="sxs-lookup"><span data-stu-id="11476-150">This is the scenario that motivates this method being available for any routed event arguments class that choose to override it.</span></span> <span data-ttu-id="11476-151">Implémentations ne doivent pas appeler la base pour cette méthode, car votre implémentation doit déjà être chargée d’appeler les gestionnaires de type sécurisé.</span><span class="sxs-lookup"><span data-stu-id="11476-151">Implementations should not call the base for this method, because your implementation should already be responsible for invoking the type safe handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11476-152">Voici le pseudocode suivant illustre un modèle de base qui peut être utilisé pour l’implémentation.</span><span class="sxs-lookup"><span data-stu-id="11476-152">The following is pseudocode that illustrates a basic pattern that can be used for implementation.</span></span> <span data-ttu-id="11476-153">Ici, `MyRoutedEventHandler` est une sous-classe de <xref:System.Windows.RoutedEventHandler>.</span><span class="sxs-lookup"><span data-stu-id="11476-153">Here, `MyRoutedEventHandler` is a subclass of <xref:System.Windows.RoutedEventHandler>.</span></span>  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="11476-154">Cette méthode est conçue pour être substituée par les classes de données d’événement dérivé à appeler plus efficacement leurs délégués.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-154">This method is intended to be overridden by derived event data classes to provide more efficient invocation of their delegates.</span>
            </span>
            <span data-ttu-id="11476-155">L’implémentation doit effectuer un cast fourni <paramref name="genericHandler" /> à spécifique au type délégué, puis appeler ce gestionnaire.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-155">The implementation should cast the provided <paramref name="genericHandler" /> to the type-specific delegate, and then invoke that handler.</span>
            </span>
            <span data-ttu-id="11476-156">L’implémentation par défaut va tenter d’appeler le gestionnaire fourni, essayez d’effectuer un cast en tant que <see cref="T:System.Windows.RoutedEventHandler" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-156">The default implementation will attempt to invoke the provided handler, attempting to cast it as <see cref="T:System.Windows.RoutedEventHandler" />.</span>
            </span>
            <span data-ttu-id="11476-157">Si <paramref name="genericHandler" /> ou <paramref name="genericTarget" /> est fourni en tant que <see langword="null" />, des exceptions sont levées.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-157">If either <paramref name="genericHandler" /> or <paramref name="genericTarget" /> is provided as <see langword="null" />, exceptions will be raised.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="11476-158">Nouvelle valeur de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-158">The new value that <see cref="P:System.Windows.RoutedEventArgs.Source" /> is being set to.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="11476-159">En cas de substitution dans une classe dérivée, fournit un point d'entrée de notification de rappel dès que la valeur de propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> d'une instance change.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-159">When overridden in a derived class, provides a notification callback entry point whenever the value of the <see cref="P:System.Windows.RoutedEventArgs.Source" /> property of an instance changes.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="11476-160">Modifier la source indiquée d’un événement par programmation peut requérir la mise à jour les données spécifiques au type de l’événement.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-160">Changing the reported source of an event programmatically can potentially require updating the type-specific data within the event.</span>
            </span>
            <span data-ttu-id="11476-161">Pour cette raison, le <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> méthode virtuelle est protégée et est conçue pour être substituée par les sous-classes de <see cref="T:System.Windows.RoutedEventArgs" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-161">For this reason, the <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> method is protected virtual and is intended to be overridden by subclasses of <see cref="T:System.Windows.RoutedEventArgs" />.</span>
            </span>
            <span data-ttu-id="11476-162">Cette méthode n’a pas d’implémentation par défaut.</span>
            <span class="sxs-lookup">
              <span data-stu-id="11476-162">This method has no default implementation.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11476-163">Obtient la source de signalement d’origine telle que déterminée par un test de positionnement pur, avant tout ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pouvant être effectué par une classe parente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-163">Gets the original reporting source as determined by pure hit testing, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment by a parent class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11476-164">Source de création de rapports d'origine avant que la gestion de classe n'ait effectué un ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pour aplatir des arborescences d'éléments composées.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-164">The original reporting source, before any possible <see cref="P:System.Windows.RoutedEventArgs.Source" /> adjustment made by class handling, which may have been done to flatten composited element trees.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-165">Cette propriété acquiert sa valeur, avant de la classe les gestionnaires d’événements ou les gestionnaires d’instance sont appelés et est ajustée jamais au-delà de ce point.</span><span class="sxs-lookup"><span data-stu-id="11476-165">This property acquires its value once, before the class event handlers or any instance handlers are invoked, and is never adjusted past this point.</span></span> <span data-ttu-id="11476-166">Les informations de source d’origine sont en lecture seule pour les gestionnaires de classe ou des implémentations de la classe, comme il est signalé dans les données d’événement.</span><span class="sxs-lookup"><span data-stu-id="11476-166">The original source information is read-only to class handlers or class implementations, just as it is reported in the event data.</span></span>  
  
 <span data-ttu-id="11476-167">Cas où la source peut être ajustée, notamment les éléments de contenu à l’intérieur d’un modèle de contenu pour un contrôle (le contenu d’un élément de liste, par exemple, signalera l’élément de liste en tant que le <xref:System.Windows.RoutedEventArgs.Source%2A> et l’élément réel dans l’élément de liste sera le <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span><span class="sxs-lookup"><span data-stu-id="11476-167">Common cases where the source may be adjusted include content elements inside a content model for a control (the contents of a list item, for instance, will report the list item element as the <xref:System.Windows.RoutedEventArgs.Source%2A> and the actual element within the list item will be the <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.</span></span>  
  
 <span data-ttu-id="11476-168">Ajustement de source par différents éléments et les modèles de contenu varie à partir d’une classe à une classe.</span><span class="sxs-lookup"><span data-stu-id="11476-168">Source adjustment by various elements and content models varies from class to class.</span></span> <span data-ttu-id="11476-169">Chaque classe qui ajuste les sources d’événements essaie de prévoir quelle source les plus utiles à un rapport de plus de scénarios d’entrée et les scénarios pour lesquels cette classe est destinée, et puis jeux source comme le <xref:System.Windows.RoutedEventArgs.Source%2A>.</span><span class="sxs-lookup"><span data-stu-id="11476-169">Each class that adjusts event sources attempts to anticipate which source is the most useful to report for most input scenarios and the scenarios for which the class is intended, and then sets that source as the <xref:System.Windows.RoutedEventArgs.Source%2A>.</span></span> <span data-ttu-id="11476-170">Si cette source n’est pas celui qui est en rapport avec votre gestion de l’événement, essayez de vérifier <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> à la place si elle signale une source différente qui est plus adaptée.</span><span class="sxs-lookup"><span data-stu-id="11476-170">If this source is not the one that has relevance to your handling of the event, try checking <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> instead to see if it reports a different source that is more suitable.</span></span> <span data-ttu-id="11476-171">Pour plus d’informations sur les événements d’entrée, consultez [vue d’ensemble d’entrée](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="11476-171">For more details on input events, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11476-172">Obtient ou définit le <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associé à cette instance <see cref="T:System.Windows.RoutedEventArgs" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-172">Gets or sets the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associated with this <see cref="T:System.Windows.RoutedEventArgs" /> instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11476-173">Identificateur de l’événement qui a été appelée.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-173">The identifier for the event that has been invoked.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-174">Vous ne pouvez pas définir cette valeur sur un <xref:System.Windows.RoutedEventArgs> qui a déjà été acheminé (par exemple, si vous avez obtenu les arguments via un gestionnaire).</span><span class="sxs-lookup"><span data-stu-id="11476-174">You cannot set this value on a <xref:System.Windows.RoutedEventArgs> that has already been routed (for instance, if you obtained the arguments through a handler).</span></span> <span data-ttu-id="11476-175">Une telle tentative génère une exception.</span><span class="sxs-lookup"><span data-stu-id="11476-175">Attempting to do so will generate an exception.</span></span> <span data-ttu-id="11476-176">Vous pouvez uniquement la définir sur une instance qui n’a pas encore été utilisée pour générer un appel de l’événement.</span><span class="sxs-lookup"><span data-stu-id="11476-176">You can only set it on an instance that has not yet been used to generate an invocation of the event.</span></span>  
  
 <span data-ttu-id="11476-177">La valeur de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ne peut pas être `null` à tout moment.</span><span class="sxs-lookup"><span data-stu-id="11476-177">The value of <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> cannot be `null` at any time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="11476-178">L’exemple suivant crée des données d’événement routé avec un constructeur initial et définit ensuite la <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propriété comme opération suivante.</span><span class="sxs-lookup"><span data-stu-id="11476-178">The following example creates new routed event data with an initial constructor and then sets the <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> property as a subsequent operation.</span></span> <span data-ttu-id="11476-179">Vous devez avoir <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> défini avant de déclencher l’événement routé.</span><span class="sxs-lookup"><span data-stu-id="11476-179">You must have <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> set prior to raising the routed event.</span></span>  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="11476-180">A tenté de modifier la valeur <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> lors de l'acheminement de l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-180">Attempted to change the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> value while the event is being routed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="11476-181">Obtient ou définit une référence à l’objet ayant déclenché l’événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-181">Gets or sets a reference to the object that raised the event.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="11476-182">Objet ayant déclenché l'événement.</span>
          <span class="sxs-lookup">
            <span data-stu-id="11476-182">The object that raised the event.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="11476-183">Pour toute propagation des événements qui a poursuivi son itinéraire au-delà de l’élément qui l’a déclenché routés, et pour n’importe quel tunneling acheminés d’événement qui n’a pas encore atteint l’élément qui l’a déclenché, la valeur de <xref:System.Windows.RoutedEventArgs.Source%2A> sera différente de la valeur de la `sender` paramètre de la classe d’arguments d’événement.</span><span class="sxs-lookup"><span data-stu-id="11476-183">For any bubbling routed event that has actually traveled the route beyond the element that raised it, and for any tunneling routed event that has not yet tunneled down to the element that raised it, the value of <xref:System.Windows.RoutedEventArgs.Source%2A> will be different than the value of the `sender` parameter of the event arguments class.</span></span> <span data-ttu-id="11476-184">Lequel des deux éléments impliqués dans l’événement sont le plus important dans un gestionnaire donné (<xref:System.Windows.RoutedEventArgs.Source%2A>, l’élément qui l’a déclenché, ou `sender`, l’élément qui le gère actuellement) dépend de la logique d’application qui est votre gestionnaire adressage.</span><span class="sxs-lookup"><span data-stu-id="11476-184">Which of the two elements involved in the event is of the most importance in any given handler (<xref:System.Windows.RoutedEventArgs.Source%2A>, the element that raised it, or `sender`, the element that is currently handling it) is dependent on the application logic that your handler is addressing.</span></span>  
  
 <span data-ttu-id="11476-185">Définition de cette propriété est faite en général uniquement lors de la substitution ou l’implémentation d’autres [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] qui ajustent des sources d’événements, par exemple quand un événement de gestion de classe.</span><span class="sxs-lookup"><span data-stu-id="11476-185">Setting this property is typically only done when overriding or implementing other [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that adjust event sources, such as when class handling an event.</span></span> <span data-ttu-id="11476-186">Réinitialisation des sources d’événements apparentes à partir des gestionnaires d’instance est déconseillée, en particulier lorsque le gestionnaire ne marque pas l’événement comme géré.</span><span class="sxs-lookup"><span data-stu-id="11476-186">Resetting apparent event sources from instance handlers is not recommended, particularly when the handler does not mark the event as handled.</span></span>  
  
 <span data-ttu-id="11476-187">Si vous redéfinissez <xref:System.Windows.RoutedEventArgs.Source%2A> pour signaler une source d’événements différents, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuera à signaler la source en tant que première déclenchée par l’origine <xref:System.Windows.UIElement.RaiseEvent%2A> appeler.</span><span class="sxs-lookup"><span data-stu-id="11476-187">If you do reset <xref:System.Windows.RoutedEventArgs.Source%2A> to report a different event source, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> will continue to report the source as first raised by the originating <xref:System.Windows.UIElement.RaiseEvent%2A> call.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>