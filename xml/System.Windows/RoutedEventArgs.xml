<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="080bf18b8af519d6c4e1430189ee3f1103adf805" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37490957" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contient des données d’événements et des informations état associées à un événement routé.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Différents <xref:System.Windows.RoutedEventArgs> peut être utilisé avec un seul <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Cette classe est chargée d’empaqueter les données d’événement pour un <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, fournissant des informations d’état des événements supplémentaires et est utilisé par le système d’événements pour appeler le gestionnaire associé à l’événement routé.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez ce constructeur sans paramètre, le toutes les propriétés publiques de la nouvelle <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> , cela signifie simplement que le <xref:System.Windows.RoutedEventArgs> données n’effectue aucune tentative pour spécifier la source. Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont renseignées en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> valeur par défaut est `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> , cela signifie simplement que cela <xref:System.Windows.RoutedEventArgs> n’effectue aucune tentative pour spécifier la source. Lorsque cette instance est utilisée dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>, le <xref:System.Windows.RoutedEventArgs.Source%2A> et <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeurs sont renseignées en fonction de l’élément qui a déclenché l’événement et est passé aux écouteurs par le routage.  
  
   
  
## Examples  
 L’exemple suivant construit un nouveau <xref:System.Windows.RoutedEventArgs> pour une utilisation dans un appel à <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Identificateur d'événement routé pour cette instance de la classe <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Autre source qui sera signalée lorsque l'événement sera géré. La propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> est alors préremplie.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.RoutedEventArgs" /> à l'aide de l'identificateur d'événement routé fourni afin de pouvoir déclarer une source différente pour l'événement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Propriétés du nouveau n’est pas spécifié lorsque vous utilisez ce constructeur surchargé, <xref:System.Windows.RoutedEventArgs> instance Supposons que les valeurs par défaut suivantes :  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> valeur par défaut est `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> valeur par défaut est `null`.  
  
 Valeurs null <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> sont remplis en fonction de l’élément qui a déclenché l’événement et transmises par le routage, mais elles seront `null` avant l’appel.  
  
 Utilisez cette signature lors du passage <xref:System.Windows.RoutedEventArgs> à des éléments virtuels tels que <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, où les arguments sont utilisés pour appeler <xref:System.Windows.UIElement.RaiseEvent%2A> en interne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique l’état actuel de la gestion des événements pour un événement routé le long de son itinéraire.</summary>
        <value>Définition, affectez <see langword="true" /> si l’événement doit être marqué comme géré ; sinon <see langword="false" />. Si la lecture de cette valeur, <see langword="true" /> indique qu’un gestionnaire de classe ou un gestionnaire d’instance le long de l’itinéraire a déjà marqué cet événement comme géré. <see langword="false" /> indique qu’aucun gestionnaire n’a marqué l’événement comme géré.  La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Marquage de l’événement géré limite la visibilité de l’événement routé pour les écouteurs sur l’itinéraire d’événement. L’événement circulent toujours le reste de l’itinéraire, mais seuls les gestionnaires ajoutés avec `HandledEventsToo` `true` dans le <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> appel de méthode sera appelée en réponse. Gestionnaires par défaut sur les écouteurs d’instance (tels que ceux exprimés dans [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) ne sera pas appelée. Gestion des événements qui sont marqués gérés ne sont pas un scénario courant.  
  
 Si vous êtes un créateur de contrôles définir vos propres événements, les décisions que vous prenez concernant les événements traités au niveau de la classe aura un impact sur les utilisateurs de votre contrôle, ainsi que tous les utilisateurs de contrôles dérivés, et potentiellement les autres éléments qui sont contenus dans votre contrôle ou qui contiennent votre contrôle. Pour plus d’informations, consultez [Marquage des événements routés comme gérés et gestion de classe](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 En de rares circonstances, il convient de gérer les événements où <xref:System.Windows.RoutedEventArgs.Handled%2A> est marquée `true`et modifier les arguments d’événement en modifiant <xref:System.Windows.RoutedEventArgs.Handled%2A> à `false`. Cela peut être nécessaire dans certaines zones d’événements d’entrée de contrôles, tels que la gestion des clés de <xref:System.Windows.UIElement.KeyDown> et <xref:System.Windows.UIElement.TextInput> où à faible niveau de haut niveau des événements d’entrée sont en concurrence pour la gestion, et chacun essayant d’adopter une stratégie de routage différente.  
  
   
  
## Examples  
 L’exemple suivant implémente un gestionnaire d’événements qui marque l’événement géré.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Implémentation de gestionnaire générique/délégué à appeler.</param>
        <param name="genericTarget">Cible sur laquelle le gestionnaire fourni doit être appelé.</param>
        <summary>En cas de substitution dans une classe dérivée, fournit un moyen d’appeler des gestionnaires d’événements d’une manière propre au type, ce qui peut améliorer l’efficacité par rapport à l’implémentation de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’implémentation de base intègre la réflexion pour déterminer le gestionnaire approprié pour tous les cas où le gestionnaire n’est pas <xref:System.Windows.RoutedEventHandler>, et cette étape de réflexion a certaines conséquences de performances. Appels peuvent être effectuées plus efficaces en vous appuyant ne pas sur la réflexion. C’est le scénario qui motive cette méthode est disponible pour toute classe d’arguments d’événement routé choisir de remplacer. Implémentations ne doivent pas appeler la base pour cette méthode, car votre implémentation doit déjà être chargée d’appeler les gestionnaires de type sécurisé.  
  
   
  
## Examples  
 Voici le pseudocode suivant illustre un modèle de base qui peut être utilisé pour l’implémentation. Ici, `MyRoutedEventHandler` est une sous-classe de <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cette méthode est conçue pour être substituée par les classes de données d’événement dérivé à appeler plus efficacement leurs délégués. L’implémentation doit effectuer un cast fourni <paramref name="genericHandler" /> à spécifique au type délégué, puis appeler ce gestionnaire.  L’implémentation par défaut va tenter d’appeler le gestionnaire fourni, essayez d’effectuer un cast en tant que <see cref="T:System.Windows.RoutedEventHandler" />. Si <paramref name="genericHandler" /> ou <paramref name="genericTarget" /> est fourni en tant que <see langword="null" />, des exceptions sont levées.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Nouvelle valeur de <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>En cas de substitution dans une classe dérivée, fournit un point d'entrée de notification de rappel dès que la valeur de propriété <see cref="P:System.Windows.RoutedEventArgs.Source" /> d'une instance change.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Modifier la source indiquée d’un événement par programmation peut requérir la mise à jour les données spécifiques au type de l’événement. Pour cette raison, le <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> méthode virtuelle est protégée et est conçue pour être substituée par les sous-classes de <see cref="T:System.Windows.RoutedEventArgs" />.  Cette méthode n’a pas d’implémentation par défaut.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la source de signalement d’origine telle que déterminée par un test de positionnement pur, avant tout ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pouvant être effectué par une classe parente.</summary>
        <value>Source de création de rapports d'origine avant que la gestion de classe n'ait effectué un ajustement <see cref="P:System.Windows.RoutedEventArgs.Source" /> pour aplatir des arborescences d'éléments composées.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété acquiert sa valeur, avant de la classe les gestionnaires d’événements ou les gestionnaires d’instance sont appelés et est ajustée jamais au-delà de ce point. Les informations de source d’origine sont en lecture seule pour les gestionnaires de classe ou des implémentations de la classe, comme il est signalé dans les données d’événement.  
  
 Cas où la source peut être ajustée, notamment les éléments de contenu à l’intérieur d’un modèle de contenu pour un contrôle (le contenu d’un élément de liste, par exemple, signalera l’élément de liste en tant que le <xref:System.Windows.RoutedEventArgs.Source%2A> et l’élément réel dans l’élément de liste sera le <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Ajustement de source par différents éléments et les modèles de contenu varie à partir d’une classe à une classe. Chaque classe qui ajuste les sources d’événements essaie de prévoir quelle source les plus utiles à un rapport de plus de scénarios d’entrée et les scénarios pour lesquels cette classe est destinée, et puis jeux source comme le <xref:System.Windows.RoutedEventArgs.Source%2A>. Si cette source n’est pas celui qui est en rapport avec votre gestion de l’événement, essayez de vérifier <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> à la place si elle signale une source différente qui est plus adaptée. Pour plus d’informations sur les événements d’entrée, consultez [vue d’ensemble d’entrée](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> associé à cette instance <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Identificateur de l’événement qui a été appelée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous ne pouvez pas définir cette valeur sur un <xref:System.Windows.RoutedEventArgs> qui a déjà été acheminé (par exemple, si vous avez obtenu les arguments via un gestionnaire). Une telle tentative génère une exception. Vous pouvez uniquement la définir sur une instance qui n’a pas encore été utilisée pour générer un appel de l’événement.  
  
 La valeur de <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> ne peut pas être `null` à tout moment.  
  
   
  
## Examples  
 L’exemple suivant crée des données d’événement routé avec un constructeur initial et définit ensuite la <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> propriété comme opération suivante. Vous devez avoir <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> défini avant de déclencher l’événement routé.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tenté de modifier la valeur <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> lors de l'acheminement de l'événement.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une référence à l’objet ayant déclenché l’événement.</summary>
        <value>Objet ayant déclenché l'événement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour toute propagation des événements qui a poursuivi son itinéraire au-delà de l’élément qui l’a déclenché routés, et pour n’importe quel tunneling acheminés d’événement qui n’a pas encore atteint l’élément qui l’a déclenché, la valeur de <xref:System.Windows.RoutedEventArgs.Source%2A> sera différente de la valeur de la <C3/> paramètre de la classe d’arguments d’événement. Lequel des deux éléments impliqués dans l’événement sont le plus important dans un gestionnaire donné (<xref:System.Windows.RoutedEventArgs.Source%2A>, l’élément qui l’a déclenché, ou `sender`, l’élément qui le gère actuellement) dépend de la logique d’application qui est votre gestionnaire adressage.  
  
 Définition de cette propriété est faite en général uniquement lors de la substitution ou l’implémentation d’autres [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] qui ajustent des sources d’événements, par exemple quand un événement de gestion de classe. Réinitialisation des sources d’événements apparentes à partir des gestionnaires d’instance est déconseillée, en particulier lorsque le gestionnaire ne marque pas l’événement comme géré.  
  
 Si vous redéfinissez <xref:System.Windows.RoutedEventArgs.Source%2A> pour signaler une source d’événements différents, <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> continuera à signaler la source en tant que première déclenchée par l’origine <xref:System.Windows.UIElement.RaiseEvent%2A> appeler.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>