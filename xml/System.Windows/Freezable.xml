<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="666b4c45528d1a4fc25516699cd25e3d50389a70" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064716" /></Metadata><TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Freezable = class&#xA;    inherit DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Définit un objet qui a un état modifiable et un état en lecture seule (figé). Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> fournissent une notification de modifications détaillée, peuvent être rendues immuables et peuvent être clonées.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Freezable> classe fournit des fonctionnalités spéciales qui peuvent aider à améliorent les performances de l’application lors de l’utilisation des objets qui sont coûteuses à modifier ou copier. Exemples de <xref:System.Windows.Freezable> objets incluent les éléments suivants :  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Dérivation de Freezable  
 Une classe qui dérive de <xref:System.Windows.Freezable> acquiert les fonctionnalités suivantes :  
  
-   États spéciaux : (un en lecture seule figé) et un état accessible en écriture.  
  
-   Sécurité des threads : figé <xref:System.Windows.Freezable> objet peut être partagé entre plusieurs threads.  
  
-   Notification de modifications détaillée : Contrairement à d’autres <xref:System.Windows.DependencyObject> objets, un <xref:System.Windows.Freezable> objet fournit des notifications de modification lorsque les valeurs de sous-propriété changent.  
  
-   Le clonage facile : la classe Freezable a déjà implémenté plusieurs méthodes qui génèrent des clones complets.  
  
 Pour plus d’informations sur l’utilisation et la création de votre propre <xref:System.Windows.Freezable> , consultez [vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Tout membre <see langword="static" /> de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Lorsque le <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété est <see langword="false" />, un <see cref="T:System.Windows.Freezable" /> objet est accessible uniquement à partir du thread sur lequel il a été créé. Tente d’y accéder à partir d’un autre thread lève une <see cref="T:System.InvalidOperationException" />. Le <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> et <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> méthodes fournissent la prise en charge pour le marshaling vers le thread approprié.  
  
Lors de leur <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété est <see langword="true" />, <see cref="T:System.Windows.Freezable" /> objets sont libres de threads.  Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance d’un <see cref="T:System.Windows.Freezable" /> classe dérivée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit du constructeur accessibilité protégée d’une classe abstraite.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFreeze : bool" Usage="System.Windows.Freezable.CanFreeze" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l’objet peut être rendu non modifiable.</summary>
        <value><see langword="true" /> si l’objet actif peut être rendu non modifiable ou s’il l’est déjà ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Cette implémentation de méthode utilise la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode avec <paramref name="isChecking" /> définie sur <see langword="true" /> pour déterminer si un <see cref="T:System.Windows.Freezable" /> peut être rendu non modifiable. Pour modifier le comportement de cette propriété dans une classe dérivée, substituez le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler " Usage="member this.Changed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsque le <see cref="T:System.Windows.Freezable" /> ou un objet qu’il contient est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous tentez d’ajouter ou supprimer des gestionnaires d’événements lorsque l’objet actuel n’est pas modifiable (lorsque le <xref:System.Windows.Freezable.IsFrozen%2A> propriété est `true`), une exception est levée.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Freezable" Usage="freezable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable de <see cref="T:System.Windows.Freezable" />, en créant des copies complètes des valeurs de l’objet. Lors de la copie des propriétés de dépendance de l’objet, cette méthode copie les expressions (qui peuvent ne plus se résoudre), mais pas les animations ni leurs valeurs actuelles.</summary>
        <returns>Clone modifiable de l'objet actif. La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source est <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes génèrent des clones modifiables de figé <xref:System.Windows.Freezable> objets (les méthodes également le cloner <xref:System.Windows.Freezable> les objets qui ne sont pas gelés). Le clone est effectivement une copie complète de l’objet actuel.  
  
 Le tableau suivant résume les différences entre le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes.  
  
|Action|Comportement de la méthode clone|Méthode CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copie d’une propriété de dépendance qui a une expression|L’expression est copiée, mais peut ne plus être résolues. Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.|  
|Copie d’une propriété de dépendance animée|La valeur de propriété base (non animées) est copiée. Animations ne sont pas copiées.|Valeur animée actuelle de la propriété est copiée. Animations ne sont pas copiées.|  
  
 Notez que les propriétés non définies ne sont pas copiées. Si une propriété non définie a la valeur par défaut qui est figé <xref:System.Windows.Freezable>, que la valeur de propriété est figée dans le clone modifiable.  
  
## <a name="move-a-freezable-between-threads"></a>Déplacer un élément Freezable entre les Threads  
 Cette méthode peut être utile pour déplacer un <xref:System.Windows.Freezable> entre les threads. Tout d’abord, vérifiez le <xref:System.Windows.Freezable> non modifiable en appelant son <xref:System.Windows.Freezable.Freeze%2A> (méthode). À présent un autre thread peut accéder à la <xref:System.Windows.Freezable> et faire un local <xref:System.Windows.Freezable.Clone%2A> qui lui permet d’accéder.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette méthode utilise <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> pour générer le clone. Pour modifier le comportement de cette méthode dans une classe dérivée, substituez le <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> (méthode).</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Objet à cloner.</param>
        <summary>Fait de l’instance un clone (copie complète) du <see cref="T:System.Windows.Freezable" /> spécifié utilisant des valeurs de propriété (non animée) de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Windows.Freezable.Clone%2A> (méthode) et ne doit pas être appelée directement à partir de votre code, à l’exception lors de l’appel de l’implémentation de base lors de la substitution de cette méthode. Pour créer une copie modifiable de l’objet en cours, appelez <xref:System.Windows.Freezable.Clone%2A> au lieu d’appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer les raisons suivantes : 
-Votre classe dérivée a des données qui ne sont pas exposées par le biais de propriétés de dépendance.  
  
-Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être effectué en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui n’êtes pas obligé d’effectuer une initialisation supplémentaire n’êtes pas obligé de substituer <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent exécuter uniquement les tâches qui n’est pas effectuée par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de toutes les propriétés accessibles en écriture définies localement, y compris des expressions internes.  
  
Si l’objet a des propriétés de dépendance liées aux données, les expressions sont copiées mais peuvent ne plus être résolues. Pour plus d’informations sur les objets liés aux données de clonage, consultez [vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, la valeur de base (non animées) de ces propriétés est copiée. Animations ne sont pas copiées.  
  
Notez que propriétés non définies ne sont pas copiées, ni les propriétés en lecture seule. Si une telle propriété a la valeur par défaut qui est figé <see cref="T:System.Windows.Freezable" />, que la valeur de propriété est figée dans le clone modifiable.  
  
La liste suivante récapitule le comportement attendu pour cette méthode : 
-La copie générée contient des copies de tous les <see cref="T:System.Windows.Freezable" /> sous-objets.  
  
-Propriétés non définies et en lecture seule ne sont pas copiées.  
  
-Les expressions sont copiées.  
  
-Aucun de ces sous-objets sont figées lors de la création.  
  
-La copie de lui-même n’est pas figée.  
  
-Animations ne sont pas copiés.  
  
-Seules les valeurs de base propriété sont copiés, pas actuelles des valeurs animées.</para></block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberSignature Language="F#" Value="member this.CloneCurrentValue : unit -&gt; System.Windows.Freezable" Usage="freezable.CloneCurrentValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un clone modifiable (copie intégrale) de le <see cref="T:System.Windows.Freezable" /> à l’aide de ses valeurs actuelles.</summary>
        <returns>Clone modifiable de l'objet actif. La valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de l’objet cloné est <see langword="false" />, même si la valeur de la propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> de la source est <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes génèrent des clones modifiables de figé <xref:System.Windows.Freezable> objets (les méthodes également le cloner <xref:System.Windows.Freezable> les objets qui ne sont pas gelés). Le clone est effectivement une copie complète de l’objet actuel.  
  
 Le tableau suivant résume les différences entre le <xref:System.Windows.Freezable.Clone%2A> et <xref:System.Windows.Freezable.CloneCurrentValue%2A> méthodes.  
  
|Action|Comportement de la méthode clone|Méthode CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Copie d’une propriété de dépendance qui a une expression|L’expression est copiée, mais peut ne plus être résolues. Pour plus d’informations, consultez [Vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.|  
|Copie d’une propriété de dépendance animée|La valeur de propriété base (non animées) est copiée. Animations ne sont pas copiées.|Valeur animée actuelle de la propriété est copiée. Animations ne sont pas copiées.|  
  
 Notez que les propriétés non définies ne sont pas copiées. Si une propriété non définie a la valeur par défaut qui est figé <xref:System.Windows.Freezable>, que la valeur de propriété est figée dans le clone modifiable.  
  
## <a name="move-a-freezable-between-threads"></a>Déplacer un élément Freezable entre les Threads  
 Cette méthode peut être utile pour déplacer un <xref:System.Windows.Freezable> entre les threads. Tout d’abord, vérifiez le <xref:System.Windows.Freezable> non modifiable à l’aide de son <xref:System.Windows.Freezable.Freeze%2A> (méthode). À présent un autre thread peut accéder à la <xref:System.Windows.Freezable> et générer un clone local qui lui permet d’accéder.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette méthode utilise la <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> méthode pour générer le clone ; <see cref="T:System.Windows.Freezable" /> implémenteurs de substituent <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> devez vous assurer que la copie n’est pas figée lors de la création.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member CloneCurrentValueCore : System.Windows.Freezable -&gt; unit&#xA;override this.CloneCurrentValueCore : System.Windows.Freezable -&gt; unit" Usage="freezable.CloneCurrentValueCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> à cloner.</param>
        <summary>Fait de l’instance un clone (copie complète) modifiable du <see cref="T:System.Windows.Freezable" /> spécifié à l’aide des valeurs de propriété actuelles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Windows.Freezable.CloneCurrentValue%2A> (méthode) et ne doit pas être appelée directement à partir de votre code, à l’exception lors de l’appel de l’implémentation de base lors de la substitution de cette méthode. Pour créer une copie modifiable de l’objet en cours, appelez <xref:System.Windows.Freezable.CloneCurrentValue%2A> au lieu d’appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer les raisons suivantes : 
-Votre classe dérivée a des données qui ne sont pas exposées par le biais de propriétés de dépendance.  
  
-Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être effectué en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui n’êtes pas obligé d’effectuer une initialisation supplémentaire n’êtes pas obligé de substituer <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent exécuter uniquement les tâches qui n’est pas effectuée par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de toutes les propriétés accessibles en écriture, définies localement. Si l’objet contient les propriétés de dépendance avec des expressions (par exemple, une liaison de données), la valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.  
  
Si l’objet a des propriétés de dépendance animées, la valeur animée actuelle de ces propriétés est copiée, mais les animations ne sont pas.  
  
Notez que propriétés non définies ne sont pas copiées, ni les propriétés en lecture seule. Si une telle propriété a la valeur par défaut qui est figé <see cref="T:System.Windows.Freezable" />, que la valeur de propriété est figée dans le clone modifiable.  
  
La liste suivante récapitule le comportement attendu pour cette méthode.  
  
-La copie générée contient des copies de tous les <see cref="T:System.Windows.Freezable" /> sous-objets.  
  
-Propriétés non définies et en lecture seule ne sont pas copiées.  
  
-Si une propriété est animée, sa valeur actuelle est copiée, mais l’animation proprement dite n’est pas.  
  
-Aucun de ces sous-objets sont figées lors de la création.  
  
-La copie de lui-même n’est pas figée.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Nouvelle instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode protégée, et les implémentations spécifiques aux objets pour le comportement dépendent de l’implémentation de substitution de la <xref:System.Windows.Freezable.CreateInstanceCore%2A> (méthode), lequel cette méthode appelle en interne.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="freezable.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas d’implémentation dans une classe dérivée, crée une nouvelle instance de la <see cref="T:System.Windows.Freezable" /> classe dérivée.</summary>
        <returns>Nouvelle instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’appelez pas cette méthode directement (sauf lorsque vous appelez base dans une implémentation). Cette méthode est appelée en interne par le <xref:System.Windows.Freezable.CreateInstance%2A> méthode chaque fois qu’une nouvelle instance de la <xref:System.Windows.Freezable> est créé.  
  
   
  
## Examples  
 L’exemple suivant montre une implémentation classique de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Chaque <see cref="T:System.Windows.Freezable" /> classe dérivée doit implémenter cette méthode. Une implémentation classique consiste à simplement appeler le constructeur par défaut et retournent le résultat.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rend un <see cref="T:System.Windows.Freezable" /> objet non modifiable et définit sa <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété <see langword="true" />, ou des tests si un <see cref="T:System.Windows.Freezable" /> objet peut être rendu non modifiable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberSignature Language="F#" Value="member this.Freeze : unit -&gt; unit" Usage="freezable.Freeze " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rend l’objet actif non modifiable et attribue à sa propriété <see cref="P:System.Windows.Freezable.IsFrozen" /> la valeur <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour éviter la possibilité d’une <xref:System.InvalidOperationException> lorsque vous appelez cette méthode, vérifiez la <xref:System.Windows.Freezable.CanFreeze%2A> propriété afin de déterminer si le <xref:System.Windows.Freezable> peut être rendu non modifiable avant d’appeler cette méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.Freezable" /> ne peut pas être rendu non modifiable.</exception>
        <block subset="none" type="overrides"><para>Cette méthode utilise la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode permettant d’apporter la <see cref="T:System.Windows.Freezable" /> non modifiable. Pour modifier le comportement de gel, substituez le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberSignature Language="F#" Value="static member Freeze : System.Windows.Freezable * bool -&gt; bool" Usage="System.Windows.Freezable.Freeze (freezable, isChecking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Objet à vérifier ou à rendre non modifiable. Si <paramref name="isChecking" /> est <see langword="true" />, l’objet est vérifié pour déterminer s’il peut être rendu non modifiable. Si <paramref name="isChecking" /> est <see langword="false" />, l’objet est rendu non modifiable, si possible.</param>
        <param name="isChecking"><see langword="true" /> pour retourner une indication de si l’objet peut être figée (sans le figer réellement) ; <see langword="false" /> pour figer réellement l’objet.</param>
        <summary>Si le <paramref name="isChecking" /> paramètre est <see langword="true" />, cette méthode indique si le texte spécifié <see cref="T:System.Windows.Freezable" /> peut être rendu non modifiable. Si le <paramref name="isChecking" /> paramètre est <see langword="false" />, cette méthode tente d’effectuer spécifié <see cref="T:System.Windows.Freezable" /> non modifiable et indique si l’opération a réussi.</summary>
        <returns>Si <paramref name="isChecking" /> est <see langword="true" />, cette méthode retourne <see langword="true" /> si spécifié <see cref="T:System.Windows.Freezable" /> peut être rendu non modifiable, ou <see langword="false" /> si elle ne peut pas être rendu non modifiable. Si <paramref name="isChecking" /> est <see langword="false" />, cette méthode retourne <see langword="true" /> si spécifié <see cref="T:System.Windows.Freezable" /> est désormais non modifiable, ou <see langword="false" /> si elle ne peut pas être rendu non modifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’appelez pas cette méthode, sauf si vous dérivez de <xref:System.Windows.Freezable> et en remplaçant le <xref:System.Windows.Freezable.FreezeCore%2A> (méthode).  Cette méthode peut être utilisée dans le <xref:System.Windows.Freezable.FreezeCore%2A> méthode pour figer les données membres de classe qui sont eux-mêmes <xref:System.Windows.Freezable> objets.  
  
 Il est très bien pour appeler cette méthode à nouveau sur un <xref:System.Windows.Freezable> objet qui est déjà figé (non modifiable).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lorsque <paramref name="isChecking" /> est <see langword="false" />, la tentative de rendre <paramref name="freezable" /> non modifiable a échoué ; l’objet est présent dans un état inconnu (il peut être partiellement figé).</exception>
        <block subset="none" type="overrides"><para>Cette méthode utilise la <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> méthode permettant d’apporter la <see cref="T:System.Windows.Freezable" /> non modifiable. Pour modifier le comportement de gel, substituez le <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> (méthode).</para></block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="freezable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" /> pour retourner une indication de si l’objet peut être figée (sans le figer réellement) ; <see langword="false" /> pour figer réellement l’objet.</param>
        <summary>Rend le <see cref="T:System.Windows.Freezable" /> d’objet non modifiable ou vérifie si elle peut être rendue non modifiable.</summary>
        <returns>Si <paramref name="isChecking" /> est <see langword="true" />, cette méthode retourne <see langword="true" /> si le <see cref="T:System.Windows.Freezable" /> peut être rendu non modifiable, ou <see langword="false" /> si elle ne peut pas être rendu non modifiable. Si <paramref name="isChecking" /> est <see langword="false" />, cette méthode retourne <see langword="true" /> si if spécifié <see cref="T:System.Windows.Freezable" /> est désormais non modifiable, ou <see langword="false" /> si elle ne peut pas être rendu non modifiable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’appelez pas cette méthode directement (sauf lorsque vous appelez base dans une implémentation). Cette méthode est appelée en interne par le <xref:System.Windows.Freezable.CanFreeze%2A> propriété (avec `isChecking` égal à `true`) et le <xref:System.Windows.Freezable.Freeze%2A> (méthode) (avec `isChecking` égale à `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see cref="T:System.Windows.Freezable" /> les implémenteurs doivent substituer cette méthode lorsque la classe contient des données qui ne sont pas stockées à l’aide des propriétés de dépendance.  
  
Une implémentation classique serait appeler la base, puis appelez la méthode statique <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> (méthode) sur tous les <see cref="T:System.Windows.Freezable" /> propriétés contenant la classe, retournant typées <see langword="true" /> uniquement si toutes les propriétés figées (ou auraient pu être figées, dans le cas de spécification <see langword="true" /> pour <paramref name="isChecking" />).</para></block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie figée de le <see cref="T:System.Windows.Freezable" />, à l’aide de valeurs de propriété (non-animées) de base. Étant donné que la copie est figée, toutes les sous-objets figés sont copiés par référence.</summary>
        <returns>Une copie figée de le <see cref="T:System.Windows.Freezable" />. La copie <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété est définie sur <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez vérifier le <xref:System.Windows.Freezable.CanFreeze%2A> propriété avant d’appeler cette méthode pour vérifier que le <xref:System.Windows.Freezable> peut être figée. À l’aide de cette méthode est similaire à la création d’une copie à l’aide de la <xref:System.Windows.Freezable.Clone%2A> et figer ensuite avec le <xref:System.Windows.Freezable.Freeze%2A> (méthode).  
  
 Le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes peuvent améliorer les performances de copie, car ils ne clonent pas <xref:System.Windows.Freezable> sous-objets qui sont déjà figé ; elles les copient seulement par référence.  
  
 Le tableau suivant résume les différences entre le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes.  
  
|Action|Méthode GetAsFrozen|Méthode GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copie d’une propriété de dépendance qui a une expression|La méthode lève un <xref:System.InvalidOperationException> , car il ne peut pas <xref:System.Windows.Freezable.Freeze%2A> la propriété.|La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.|  
|Copie d’une propriété de dépendance animée|La valeur de propriété base (non animées) est copiée. Animations ne sont pas copiées.|Valeur animée actuelle de la propriété est copiée. Animations ne sont pas copiées.|  
  
 Notez que propriétés non définies ne sont pas copiées, ni les propriétés en lecture seule.  
  
 Pour créer une copie de la <xref:System.Windows.Freezable> qui est non figé, utilisez la <xref:System.Windows.Freezable.Clone%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.Freezable" /> ne peut pas être figé parce qu’il contient des expressions ou des propriétés animées.</exception>
        <block subset="none" type="overrides"><para>Cette méthode utilise virtuel <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> méthode pour générer le clone.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Instance à copier.</param>
        <summary>Transforme l’instance en clone figé du <see cref="T:System.Windows.Freezable" /> spécifié utilisant des valeurs de propriété (non animée) de base.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Windows.Freezable.GetAsFrozen%2A> (méthode) et ne doit pas être appelée directement à partir de votre code, à l’exception lors de l’appel de l’implémentation de base lors de la substitution de cette méthode. Pour créer une copie figée de l’objet en cours, appelez <xref:System.Windows.Freezable.GetAsFrozen%2A> au lieu d’appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de <see cref="T:System.Windows.Freezable" /> vous devrez peut-être remplacer cette méthode. Pour remplacer les raisons suivantes : 
-Votre classe dérivée a des données qui ne sont pas exposées par le biais de propriétés de dépendance.  
  
-Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être effectué en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui n’êtes pas obligé d’effectuer une initialisation supplémentaire n’êtes pas obligé de substituer <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent exécuter uniquement les tâches qui n’est pas effectuée par l’implémentation par défaut. L’implémentation par défaut effectue des copies complètes de n’importe quel Freezables non figés et une copie superficielle de tous les autres accessible en écriture, localement définir les propriétés qu’il contient. Si l’objet a des propriétés de dépendance liées aux données, les expressions sont copiées mais peuvent ne plus pouvoir se résoudre ; Pour plus d’informations sur les objets liés aux données de clonage, consultez [vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, les valeurs de base (non animées) de ces propriétés sont copiées. Animations ne sont pas copiées.  
  
Notez que propriétés non définies ne sont pas copiées, ni les propriétés en lecture seule.  
  
Si vous substituez cette méthode, vous devez appeler l’implémentation de base.  
  
Vous n’avez pas besoin <see cref="M:System.Windows.Freezable.Freeze" /> valeurs comme ils sont copiés.  Le résultat est figé par <see cref="M:System.Windows.Freezable.GetAsFrozen" /> avant d’être retourné.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentValueAsFrozen : unit -&gt; System.Windows.Freezable" Usage="freezable.GetCurrentValueAsFrozen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie figée de le <see cref="T:System.Windows.Freezable" /> à l’aide de valeurs de propriété actuelles. Étant donné que la copie est figée, toutes les sous-objets figés sont copiés par référence.</summary>
        <returns>Une copie figée de le <see cref="T:System.Windows.Freezable" />. La copie <see cref="P:System.Windows.Freezable.IsFrozen" /> propriété est définie sur <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de cette méthode est similaire à la création d’une copie à l’aide de la <xref:System.Windows.Freezable.CloneCurrentValue%2A> et figer ensuite avec le <xref:System.Windows.Freezable.Freeze%2A> (méthode).  
  
 Le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes peuvent améliorer les performances de copie, car ils ne clonent pas <xref:System.Windows.Freezable> sous-objets qui sont déjà figé ; elles les copient seulement par référence.  
  
 Le tableau suivant résume les différences entre le <xref:System.Windows.Freezable.GetAsFrozen%2A> et <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> méthodes.  
  
|Action|Méthode GetAsFrozen|Méthode GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Copie d’une propriété de dépendance qui a une expression|La méthode lève un <xref:System.InvalidOperationException> , car il ne peut pas <xref:System.Windows.Freezable.Freeze%2A> la propriété.|La valeur actuelle de l’expression est copiée, mais pas l’expression elle-même.|  
|Copie d’une propriété de dépendance animée|La valeur de propriété base (non animées) est copiée. Animations ne sont pas copiées.|Valeur animée actuelle de la propriété est copiée. Animations ne sont pas copiées.|  
  
 Notez que propriétés non définies ne sont pas copiées, ni les propriétés en lecture seule.  
  
 Pour créer une copie de la <xref:System.Windows.Freezable> qui est non figé, utilisez la <xref:System.Windows.Freezable.CloneCurrentValue%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Cette méthode utilise virtuel <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> méthode pour générer le clone.</para></block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberSignature Language="F#" Value="abstract member GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit&#xA;override this.GetCurrentValueAsFrozenCore : System.Windows.Freezable -&gt; unit" Usage="freezable.GetCurrentValueAsFrozenCore sourceFreezable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable"><see cref="T:System.Windows.Freezable" /> à copier et figer.</param>
        <summary>Convertit l’instance actuelle en un clone figé du <see cref="T:System.Windows.Freezable" /> spécifié. Si l’objet a des propriétés de dépendance animées, leurs valeurs animées actuelles sont copiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée par le <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> (méthode) et ne doit pas être appelée directement à partir de votre code, à l’exception lors de l’appel de l’implémentation de base lors de la substitution de cette méthode. Pour créer une copie figée de l’objet en cours, appelez <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> au lieu d’appeler cette méthode directement.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Si vous dérivez de <see cref="T:System.Windows.Freezable" />, vous devrez peut-être remplacer cette méthode. Pour remplacer les raisons suivantes : 
-Votre classe dérivée a des données qui ne sont pas exposées par le biais de propriétés de dépendance.  
  
-Votre classe dérivée doit effectuer une initialisation supplémentaire qui ne peut pas être effectué en substituant simplement <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Par exemple, cela s’applique si votre classe dérivée implémente <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
Les classes qui stockent toutes leurs données dans les propriétés de dépendance et qui n’êtes pas obligé d’effectuer une initialisation supplémentaire n’êtes pas obligé de substituer <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
Il est essentiel que toutes les implémentations appellent l’implémentation de base de cette méthode. Les implémentations doivent exécuter uniquement les tâches qui n’est pas effectuée par l’implémentation par défaut. L’implémentation par défaut crée un nouveau <see cref="T:System.Windows.Freezable" /> à l’aide de la <see cref="M:System.Windows.Freezable.CreateInstance" /> (méthode) et en fait des copies complètes des Freezables non figés et une copie superficielle de tous les autres accessible en écriture, il contient des propriétés définies localement. Si l’objet a des propriétés de dépendance liées aux données, les liaisons de données sont copiées, mais peuvent ne plus pouvoir se résoudre ; Pour plus d’informations sur les objets liés aux données de clonage, consultez [vue d’ensemble des objets Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Si l’objet a des propriétés de dépendance animées, la valeur animée actuelle de ces propriétés est copiée, mais les animations ne sont pas.  
  
Propriétés de dépendance en lecture seule dans un <see cref="T:System.Windows.Freezable" /> ne sont pas copiées par cette implémentation par défaut.  
  
Si vous substituez cette méthode, vous devez appeler l’implémentation de base.  
  
Vous n’avez pas besoin <see cref="M:System.Windows.Freezable.Freeze" /> valeurs comme ils sont copiés.  Le résultat est figé par <see cref="M:System.Windows.Freezable.GetAsFrozen" /> avant d’être retourné.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFrozen : bool" Usage="System.Windows.Freezable.IsFrozen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l’objet est actuellement modifiable.</summary>
        <value><see langword="true" /> si l’objet est figé et ne peut pas être modifié ; <see langword="false" /> si l’objet peut être modifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentative de modification d’un objet lors de sa <xref:System.Windows.Freezable.IsFrozen%2A> propriété est `true` lève une <xref:System.InvalidOperationException>.  
  
 Cette propriété est en lecture seule à partir de la perspective du modèle objet. De la documentation sur <xref:System.Windows.Freezable> comportements peuvent mentionner « définit <xref:System.Windows.Freezable.IsFrozen%2A> à `true`» ou langue similaire lorsque vous présentez le comportement d’autres méthodes de <xref:System.Windows.Freezable>, mais ce comportement se produit en interne dans les instances de classe, Lorsque les méthodes de l’instance manipulent les variables privées qui existent au sein de la classe abstraite. Pour définir la valeur de cette propriété, vous devez appeler <xref:System.Windows.Freezable.Freeze%2A>. Il s’agit effectivement une opération à usage unique pour modifier le <xref:System.Windows.Freezable.IsFrozen%2A> propriété à partir de la valeur par défaut initiale `false` l’état le `true` état. Il n’existe aucun moyen disponibles pour définir la valeur à `false`. Au lieu de cela, vous pouvez modifier toute copie complète effectuée à partir de la version d’origine (voir la <xref:System.Windows.Freezable.Clone%2A> méthode). Il s’agit par conception et comment n’importe quelle classe dérivée doit se comporter lorsqu’il est appliqué aux cas où le <xref:System.Windows.Freezable> modèle est utile.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : unit -&gt; unit&#xA;override this.OnChanged : unit -&gt; unit" Usage="freezable.OnChanged " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Appelé quand l’objet <see cref="T:System.Windows.Freezable" /> actuel est modifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est appelée chaque fois que le <xref:System.Windows.Freezable.Changed> événement se produit.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Lorsque vous implémentez une classe qui dérive de <see cref="T:System.Windows.Freezable" />, vous pouvez substituer cette méthode pour effectuer des tâches.</para></block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Garantit que les pointeurs de contexte appropriés sont établis pour un membre de données de type <see cref="T:System.Windows.DependencyObject" /> qui a simplement été modifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">La valeur précédente du membre de données.</param>
        <param name="newValue">La valeur actuelle du membre de données.</param>
        <summary>Garantit que les pointeurs de contexte appropriés sont établis pour un <see cref="T:System.Windows.DependencyObjectType" /> membre de données qui a simplement été définie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être appelée <xref:System.Windows.Freezable> les héritiers chaque fois qu’un <xref:System.Windows.DependencyObject> membre de données qui n’est pas stockée en tant qu’un <xref:System.Windows.DependencyProperty> est définie.  
  
 Cette méthode ne doit pas être appelé pour <xref:System.Windows.DependencyObject> les membres de données qui sont stockées en utilisant un <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.OnFreezablePropertyChanged : System.Windows.DependencyObject * System.Windows.DependencyObject * System.Windows.DependencyProperty -&gt; unit" Usage="freezable.OnFreezablePropertyChanged (oldValue, newValue, property)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">La valeur précédente du membre de données.</param>
        <param name="newValue">La valeur actuelle du membre de données.</param>
        <param name="property">Propriété ayant changé.</param>
        <summary>Ce membre prend en charge l’infrastructure [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] et n’est pas destiné à être directement utilisé à partir de votre code.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnPropertyChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="freezable.OnPropertyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Données d’événement qui contiennent des informations sur les propriétés modifiées, les anciennes valeurs et les nouvelles.</param>
        <summary>Substitue l’implémentation <see cref="T:System.Windows.DependencyObject" /> de <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /> pour appeler également tous les gestionnaires <see cref="E:System.Windows.Freezable.Changed" /> en réponse à une propriété de dépendance variable de type <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les données d’événement contient des informations sur uniquement le <xref:System.Windows.Freezable> lui-même. Aucune information de sous-propriété doit être obtenue via le <xref:System.Windows.Freezable.Changed> gestionnaires.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberSignature Language="F#" Value="member this.ReadPreamble : unit -&gt; unit" Usage="freezable.ReadPreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garantit que le <see cref="T:System.Windows.Freezable" /> est accessible à partir d’un thread valide. Les héritiers de <see cref="T:System.Windows.Freezable" /> doit appeler cette méthode au début de n’importe quel [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] qui lit les données membres qui ne sont pas des propriétés de dépendance.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doit appeler la <see cref="M:System.Windows.Freezable.ReadPreamble" /> méthode avant de tenter d’accéder à des membres qui ne sont pas des propriétés de dépendance. Le <see cref="M:System.Windows.Freezable.WritePreamble" /> méthode doit être appelée avant que les membres de ce type sont écrites dans.  
  
Cette méthode ne fait rien que pour appeler <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberSignature Language="F#" Value="member this.WritePostscript : unit -&gt; unit" Usage="freezable.WritePostscript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Déclenche l’événement <see cref="E:System.Windows.Freezable.Changed" /> pour le <see cref="T:System.Windows.Freezable" /> et appelle sa méthode <see cref="M:System.Windows.Freezable.OnChanged" />. Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doivent appeler cette méthode à la fin de toute API qui modifie des membres de classe qui ne sont pas stockés en tant que propriétés de dépendance.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doivent appeler cette méthode à la fin de toute API qui modifie un membre de classe qui n’est pas stocké comme un <see cref="T:System.Windows.DependencyProperty" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberSignature Language="F#" Value="member this.WritePreamble : unit -&gt; unit" Usage="freezable.WritePreamble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vérifie que le <see cref="T:System.Windows.Freezable" /> n’est pas figé et qu’il est accessible à partir d’un contexte de thread valid. <see cref="T:System.Windows.Freezable" /> les héritiers doivent appeler cette méthode au début de toute [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] qui écrit dans les membres de données qui ne sont pas des propriétés de dépendance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> pour vérifier le contexte de thread est accessible, et elle lève une exception si le <xref:System.Windows.Freezable> instance est déjà figée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Windows.Freezable" /> instance est figée et ne peut pas avoir ses membres en écriture.</exception>
        <block subset="none" type="overrides"><para>Les classes qui dérivent de <see cref="T:System.Windows.Freezable" /> doit appeler <see cref="M:System.Windows.Freezable.WritePreamble" /> avant de tenter d’écrire dans tous les membres qui ne sont pas des propriétés de dépendance. Si vous appelez <see cref="M:System.Windows.Freezable.WritePreamble" /> dans un [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], vous pouvez omettre un appel à <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para></block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>