<Type Name="Console" FullName="System.Console">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11975612915ad3e42f126e0e2802efa769e2d774" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48744423" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <TypeSignature Language="F#" Value="type Console = class" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Représente les flux standard d'entrée, de sortie et d'erreur pour les applications console. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La console est une fenêtre de système d’exploitation où les utilisateurs interagissent avec le système d’exploitation ou avec une application console basée sur le texte en entrant la saisie de texte via le clavier de l’ordinateur et en lisant la sortie de texte à partir du terminal de l’ordinateur. Par exemple, dans le système d’exploitation Windows, la console est appelée à la fenêtre d’invite de commandes et accepte les commandes MS-DOS. Le <xref:System.Console> classe fournit la prise en charge de base pour les applications qui lisent et écrivent des caractères dans la console.  
  
 Pour plus d’informations sur le développement avec le <xref:System.Console> de classe, consultez les sections suivantes :  
  
-   [Flux d’e/s de console](#Streams)  
  
-   [Mémoire tampon d’écran et la fenêtre de Console](#Buffer)  
  
-   [Prise en charge Unicode pour la Console](#Unicode)  
  
-   [Opérations courantes](#Operations)  
  
-   [Notes de publication .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Flux d’e/s de console  
 Lorsqu’une application de console démarre, le système d’exploitation associe automatiquement trois flux d’e/s à la console : standard d’entrée de flux, les flux de sortie standard et les flux de sortie d’erreur standard. Votre application peut lire l’entrée d’utilisateur à partir du flux d’entrée standard ; écrire des données normales dans le flux de sortie standard ; et écrire des données de l’erreur dans le flux de sortie d’erreur standard. Ces flux sont présentés à votre application en tant que les valeurs de la <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, et <xref:System.Console.Error%2A?displayProperty=nameWithType> propriétés.  
  
 Par défaut, la valeur de la <xref:System.Console.In%2A> propriété est un <xref:System.IO.TextReader?displayProperty=nameWithType> objet qui représente le clavier et les valeurs de la <xref:System.Console.Out%2A> et <xref:System.Console.Error%2A> propriétés sont <xref:System.IO.TextWriter?displayProperty=nameWithType> objets qui représentent une fenêtre de console. Toutefois, vous pouvez définir ces propriétés dans des flux qui ne représentent pas la fenêtre de console ou le clavier ; par exemple, vous pouvez définir ces propriétés dans des flux qui représentent des fichiers. Pour rediriger l’entrée standard, la sortie standard ou le flux d’erreur standard, appelez le <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, ou <xref:System.Console.SetError%2A?displayProperty=nameWithType> (méthode), respectivement. Opérations d’e/s qui utilisent ces flux sont synchronisées, ce qui signifie que plusieurs threads capable de lire, ou écrire dans les flux de données. Cela signifie que les méthodes qui sont habituellement asynchrones, tels que <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, exécuter de façon synchrone si l’objet représente un flux de console.  
  
> [!NOTE]
>  N’utilisez pas le <xref:System.Console> classe pour afficher la sortie dans des applications sans assistance, telles que les applications de serveur. Appels aux méthodes telles que <xref:System.Console.Write%2A?displayProperty=nameWithType> et <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> n’ont aucun effet dans les applications GUI.  
  
 <xref:System.Console> les membres de classe qui fonctionnent normalement lorsque le flux sous-jacent est dirigé vers une console peuvent lever une exception si le flux est redirigé, par exemple, dans un fichier. Programmez votre application pour intercepter <xref:System.IO.IOException?displayProperty=nameWithType> exceptions si vous redirigez un flux standard. Vous pouvez également utiliser le <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, et <xref:System.Console.IsErrorRedirected%2A> propriétés pour déterminer si un flux standard est redirigé avant d’effectuer une opération qui lève une <xref:System.IO.IOException?displayProperty=nameWithType> exception.  
  
 Il est parfois utile d’appeler explicitement les membres des objets de flux de données représentés par le <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, et <xref:System.Console.Error%2A> propriétés. Par exemple, par défaut, le <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> méthode lit l’entrée à partir du flux d’entrée standard. De même, la <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> méthode écrit des données dans le flux de sortie standard et les données sont suivies de la chaîne de terminaison de ligne par défaut, c'est-à-dire un retour chariot et saut de ligne (« \r\n »). Toutefois, la <xref:System.Console> classe ne fournit pas de méthode correspondante pour écrire des données dans le flux de sortie d’erreur standard, ou une propriété à modifier la chaîne de terminaison de ligne pour les données écrites dans ce flux.  
  
 Vous pouvez résoudre ce problème en définissant le <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriété de la <xref:System.Console.Out%2A> ou <xref:System.Console.Error%2A> propriété à une autre chaîne de terminaison de ligne. Par exemple, l’instruction c# suivante définit la chaîne de terminaison de ligne pour le flux de sortie d’erreur standard à deux retour chariot et les séquences de saut de ligne :  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Vous pouvez ensuite appeler explicitement la <xref:System.IO.TextWriter.WriteLine%2A> méthode de l’objet de flux de sortie d’erreur, comme dans l’instruction c# suivante :  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Mémoire tampon d’écran et la fenêtre de Console  
 Deux fonctionnalités étroitement liées de la console sont la mémoire tampon d’écran et la fenêtre de console. Texte est réellement lues ou écrit dans des flux appartenant à la console, mais semble être lu ou écrit une zone détenue par la console de la mémoire tampon d’écran. La mémoire tampon d’écran est un attribut de la console et est organisé comme une grille rectangulaire de lignes et colonnes où chaque intersection de la grille ou une cellule de caractère, peut contenir un caractère. Chaque caractère possède sa propre couleur de premier plan, et chaque cellule de caractère a sa propre couleur d’arrière-plan.  
  
 La mémoire tampon d’écran est affichée via une zone rectangulaire appelée la fenêtre de console. La fenêtre de console est un autre attribut de la console ; Il n’est pas la console elle-même, qui est une fenêtre de système d’exploitation. La fenêtre de console est organisée en lignes et colonnes est inférieur ou égal à la taille de la mémoire tampon d’écran et peut être déplacée pour afficher différentes zones de la mémoire tampon écran sous-jacente. Si la mémoire tampon d’écran est supérieure à la fenêtre de console, la console affiche automatiquement les barres de défilement afin de la fenêtre de console peut être repositionnée sur la zone de mémoire tampon d’écran.  
  
 Un curseur indique la position de mémoire tampon écran où texte est actuellement lue ou écrit. Le curseur peut être masqué ou visibles, et sa hauteur peut être modifié. Si le curseur est visible, la position de fenêtre de console est automatiquement déplacée donc le curseur se trouve toujours dans la vue.  
  
 L’origine des coordonnées de cellule de caractère dans la mémoire tampon d’écran est l’angle supérieur gauche, et les positions du curseur et de la fenêtre de console sont mesurées par rapport à cette origine. Utilisez les index de base zéro pour spécifier les positions ; Autrement dit, spécifiez la ligne supérieure comme ligne 0 et la colonne à l’extrême gauche en tant que colonne 0. La valeur maximale pour les index de ligne et de colonne est <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Prise en charge Unicode pour la Console  
 En général, la console lit l’entrée et écrit la sortie à l’aide de la page de codes de console en cours, qui définit des paramètres régionaux du système par défaut. Une page de codes peut gérer uniquement un sous-ensemble de caractères Unicode disponibles, donc si vous essayez d’affichage des caractères qui ne sont pas mappés à une page de codes particulier, la console ne sont pas en mesure d’afficher tous les caractères ou de les représenter avec précision. L'exemple de code suivant illustre ce problème. Il essaie d’afficher les caractères de l’alphabet cyrillique de U + 0410 à U + 044F dans la console. Si vous exécutez l’exemple sur un système qui utilise la page de codes 437, chaque caractère est remplacé par un point d’interrogation ( ?), étant donné que les caractères cyrilliques ne correspondent pas aux caractères dans la page de codes 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 La prise en charge des pages de codes, la <xref:System.Console> classe prend en charge UTF-8 est un encodage avec la <xref:System.Text.UTF8Encoding> classe. Commençant par le .NET Framework 4.5, le <xref:System.Console> classe prend également en charge le codage UTF-16 le <xref:System.Text.UnicodeEncoding> classe. Pour afficher les caractères Unicode dans la console. vous définissez le <xref:System.Console.OutputEncoding%2A> propriété <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>.  
  
 Prise en charge des caractères Unicode requiert l’encodeur afin de reconnaître un caractère Unicode particulier et nécessite également une police qui a les glyphes nécessaires au rendu de ce caractère. Pour afficher correctement les caractères Unicode dans la console, vous devez définir la police de la console à un non raster ou d’une police TrueType comme Consolas ou Lucida Console. L’exemple suivant montre comment vous pouvez modifier par programmation la police à partir d’une police raster Lucida Console.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Toutefois, les polices TrueType peuvent afficher uniquement un sous-ensemble de glyphes. Par exemple, la police Lucida Console affiche uniquement les 643 de 64 000 caractères disponibles allant de U + 0021 à U + FB02. Pour voir une police particulière des caractères qui prend en charge, ouvrez le **polices** applet du Panneau de configuration, choisissez la **rechercher un caractère** option et choisir la police des jeux de caractère dont vous souhaitez examiner dans le ** Police** liste de la **table des caractères** fenêtre.  
  
 Windows utilise la liaison de polices pour afficher des glyphes qui ne sont pas disponibles dans une police particulière. Pour plus d’informations sur la police de liaison pour afficher les jeux de caractères supplémentaires, consultez [globalisation pas à pas : polices](http://go.microsoft.com/fwlink/?LinkId=229111). Polices liés sont définis dans la sous-clé HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink du Registre. Chaque entrée associée à cette sous-clé correspond au nom d’une police de base, et sa valeur est un tableau de chaînes qui définit les fichiers de polices et les polices qui sont liés à la police de base. Chaque membre du tableau définit une police liée et prend la forme *nom de fichier de police*,*nom de la police*. L’exemple suivant illustre comment vous pouvez définir par programme une police liée nommée SimSun trouvé dans un fichier de police nommé simsun.ttc qui affiche les caractères Han simplifié.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Prise en charge Unicode pour la console présente les limitations suivantes :  
  
-   Encodage UTF-32 n’est pas pris en charge. La seule prise en charge d’Unicode encodages sont UTF-8 et UTF-16, qui sont représentées par le <xref:System.Text.UTF8Encoding> et <xref:System.Text.UnicodeEncoding> des classes, respectivement.  
  
-   Sortie de bidirectionnel n’est pas pris en charge.  
  
-   Affichage des caractères en dehors du plan multilingue de base (autrement dit, des paires de substitution) n’est pas compatible, même si elles sont définies dans un fichier de polices lié.  
  
-   Affichage des caractères dans les scripts complexes n’est pas pris en charge.  
  
-   Combinant les séquences de caractères (autrement dit, les caractères qui se composent d’un caractère de base et un ou plusieurs caractères d’association) sont affichés sous forme de caractères distincts. Pour contourner cette limitation, vous pouvez normaliser la chaîne à afficher en appelant le <xref:System.String.Normalize%2A?displayProperty=nameWithType> méthode avant d’envoyer la sortie à la console. Dans l’exemple suivant, une chaîne qui contient le caractère de la combinaison de séquence U + 0061 U + 0308 s’affiche sur la console comme deux caractères avant la chaîne de sortie est normalisée et comme un caractère unique après le <xref:System.String.Normalize%2A?displayProperty=nameWithType> méthode est appelée.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Notez que la normalisation est une solution viable que si la séquence de caractères Unicode standard pour le caractère inclut un formulaire préalable composé qui correspond à un particulier combining.  
  
-   Si une police fournit un glyphe pour un point de code dans la zone d’utilisation privée, ce glyphe s’affiche. Toutefois, étant donné que les caractères dans la zone d’utilisation privée sont spécifiques à l’application, cela peut être pas le glyphe attendu.  
  
 L’exemple suivant affiche une plage de caractères Unicode dans la console. L’exemple accepte trois paramètres de ligne de commande : le début de la plage à afficher, à la fin de la plage à afficher et s’il faut utiliser l’encodage de console actuel (`false`) ou de l’encodage UTF-16 (`true`). Il suppose que la console utilise une police TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Opérations courantes  
 Le <xref:System.Console> classe contient les méthodes suivantes pour l’entrée de la console de lecture et écriture de la sortie de console :  
  
-   Les surcharges de la <xref:System.Console.ReadKey%2A> méthode lire un caractère individuel.  
  
-   Le <xref:System.Console.ReadLine%2A> méthode lit une ligne d’entrée entière.  
  
-   Le <xref:System.Console.Write%2A> surcharges de méthode convertir une instance d’un type valeur, un tableau de caractères ou un ensemble d’objets en une chaîne mise en forme ou non mis en forme, puis écrire cette chaîne dans la console.  
  
-   Un parallèle ensemble de <xref:System.Console.WriteLine%2A> sortie de la même chaîne comme des surcharges de méthode le <xref:System.Console.Write%2A> surcharges mais également ajouter une chaîne de terminaison de ligne.  
  
 Le <xref:System.Console> classe contient également des méthodes et propriétés pour effectuer les opérations suivantes :  
  
-   Obtient ou définit la taille de la mémoire tampon d’écran. Le <xref:System.Console.BufferHeight%2A> et <xref:System.Console.BufferWidth%2A> propriétés vous permettent d’obtenir ou définir la hauteur de la mémoire tampon et la largeur, respectivement et le <xref:System.Console.SetBufferSize%2A> méthode vous permet de définir la taille de mémoire tampon dans un seul appel de méthode.  
  
-   Obtient ou définit la taille de la fenêtre de console. Le <xref:System.Console.WindowHeight%2A> et <xref:System.Console.WindowWidth%2A> propriétés vous permettent d’obtenir ou définir la hauteur de la fenêtre et la largeur, respectivement et le <xref:System.Console.SetWindowSize%2A> méthode vous permet de définir la taille de fenêtre dans un seul appel de méthode.  
  
-   Obtient ou définit la taille du curseur. Le <xref:System.Console.CursorSize%2A> propriété spécifie la hauteur du curseur dans une cellule de caractère.  
  
-   Obtient ou définit la position de la fenêtre de console par rapport à la mémoire tampon d’écran. Le <xref:System.Console.WindowTop%2A> et <xref:System.Console.WindowLeft%2A> propriétés vous permettent d’obtenir ou définir la ligne du haut et la colonne de gauche de la mémoire tampon d’écran qui s’affiche dans la fenêtre de console, et le <xref:System.Console.SetWindowPosition%2A> méthode vous permet de définir ces valeurs dans un seul appel de méthode.  
  
-   Obtenir ou définir la position du curseur en bien ou en définissant le <xref:System.Console.CursorTop%2A> et <xref:System.Console.CursorLeft%2A> propriétés, ou définir la position du curseur en appelant le <xref:System.Console.SetCursorPosition%2A> (méthode).  
  
-   Déplacer ou supprimer des données dans la mémoire tampon d’écran en appelant le <xref:System.Console.MoveBufferArea%2A> ou <xref:System.Console.Clear%2A> (méthode).  
  
-   Obtenir ou définir les couleurs de premier plan et d’arrière-plan à l’aide de la <xref:System.Console.ForegroundColor%2A> et <xref:System.Console.BackgroundColor%2A> propriétés, ou de réinitialiser l’arrière-plan et premier plan pour leurs couleurs par défaut en appelant le <xref:System.Console.ResetColor%2A> (méthode).  
  
-   Lire le son d’un signal sonore via le haut-parleur de la console en appelant le <xref:System.Console.Beep%2A> (méthode).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notes de publication  
 Dans le .NET Framework sur le bureau, le <xref:System.Console> classe utilise l’encodage retourné par `GetConsoleCP` et `GetConsoleOutputCP`, ce qui en général, est une page de codes d’encodage. Par exemple le code, sur les systèmes dont la culture est anglais (États-Unis), page de codes 437 est l’encodage qui est utilisé par défaut. Toutefois, [!INCLUDE[net_core](~/includes/net-core-md.md)] peut effectuer uniquement un sous-ensemble limité de ces encodages disponibles. Dans ce cas, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> est utilisé en tant que l’encodage par défaut pour la console.  
  
 Si votre application dépend des codages de page de codes spécifique, vous pouvez toujours les rendre disponibles en procédant comme suit *avant* vous appeler les <xref:System.Console> méthodes :  
  
1.  Ajoutez une référence à l’assembly System.Text.Encoding.CodePages.dll à votre projet.  
  
2.  Récupérer le <xref:System.Text.EncodingProvider> de l’objet à partir de la <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriété.  
  
3.  Passer le <xref:System.Text.EncodingProvider> de l’objet à la <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> méthode permettant d’apporter les autres encodages pris en charge par le fournisseur d’encodage disponible.  
  
 Le <xref:System.Console> classe puis utilisent automatiquement l’encodage du système par défaut au lieu d’UTF-8, sous réserve que vous avez enregistré le fournisseur d’encodage avant d’appeler une <xref:System.Console> méthodes de sortie.  
  
   
  
## Examples  
 L’exemple suivant montre comment lire les données et écrire des données dans l’entrée standard et le flux de sortie. Notez que ces flux peuvent être redirigés à l’aide de la <xref:System.Console.SetIn%2A> et <xref:System.Console.SetOut%2A> méthodes.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : ConsoleColor with get, set" Usage="System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur d'arrière-plan de la console.</summary>
        <value>Valeur qui spécifie la couleur d'arrière-plan de la console, c'est-à-dire la couleur affichée derrière chaque caractère. La valeur par défaut est noir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une modification apportée à la <xref:System.Console.BackgroundColor%2A> propriété n'affecte que la sortie qui est écrite dans les cellules de caractère individuel après la modification de la couleur d’arrière-plan. Pour modifier la couleur d’arrière-plan de la fenêtre de console dans sa globalité, définissez le <xref:System.Console.BackgroundColor%2A> propriété et appelez le <xref:System.Console.Clear%2A> (méthode). L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Une opération get pour une application Windows, dans lequel une console n’existe pas, renvoie <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant enregistre les valeurs de la <xref:System.ConsoleColor> énumération dans un tableau et stocke les valeurs actuelles de la <xref:System.Console.BackgroundColor%2A> et <xref:System.Console.ForegroundColor%2A> propriétés à des variables. Il remplace ensuite la couleur de premier plan pour chaque couleur de la <xref:System.ConsoleColor> énumération sauf à la couleur qui correspond à l’arrière-plan actuel, et il modifie la couleur d’arrière-plan pour chaque couleur de la <xref:System.ConsoleColor> énumération à l’exception de la couleur qui correspond à la premier plan actuels. (Si la couleur de premier plan est identique à la couleur d’arrière-plan, le texte n’est pas visible.) Enfin, il appelle le <xref:System.Console.ResetColor%2A> méthode pour restaurer les couleurs de la console d’origine.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La couleur spécifiée dans une opération set n’est pas un membre valide de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit le son d'un signal sonore via le haut-parleur de la console.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="System.Console.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le son d'un signal sonore via le haut-parleur de la console.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le signal sonore est lu à une fréquence de 800 hertz pour une durée égale à 200 millisecondes.  
  
> [!NOTE]
>  Le <xref:System.Console.Beep%2A> méthode n’est pas prise en charge sur les éditions 64 bits de Windows Vista et Windows XP.  
  
 <xref:System.Console.Beep%2A> encapsule un appel vers le Windows [un signal sonore de la fonction](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Si <xref:System.Console.Beep%2A> génère un son sur les versions de Windows avant Windows 7 dépend de la présence d’une puce de minuterie d’intervalle programmable 8254. À compter de Windows 7, cela dépend du périphérique audio par défaut.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.Beep%2A> (méthode). L’exemple accepte un nombre compris entre 1 et 9 comme argument de ligne de commande et lit le signal sonore ce nombre de fois.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Cette méthode a été exécutée sur un serveur, tel que SQL Server, qui n’autorise pas l’accès à l’interface utilisateur.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberSignature Language="F#" Value="static member Beep : int * int -&gt; unit" Usage="System.Console.Beep (frequency, duration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">Fréquence du signal sonore, comprise entre 37 et 32 767 hertz.</param>
        <param name="duration">Durée du signal sonore mesurée en millisecondes.</param>
        <summary>Lit le son d'un signal sonore à la fréquence et pendant la durée spécifiées, via le haut-parleur de la console.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> encapsule un appel vers le Windows [un signal sonore de la fonction](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Si <xref:System.Console.Beep%2A> génère un son sur les versions de Windows avant Windows 7 dépend de la présence d’une puce de minuterie d’intervalle programmable 8254. À compter de Windows 7, cela dépend du périphérique audio par défaut.  
  
> [!NOTE]
>  Le <xref:System.Console.Beep%2A> méthode n’est pas prise en charge sur les éditions 64 bits de Windows Vista et Windows XP.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.Beep%2A> méthode en lisant les premières notes d’une chanson via le haut-parleur de la console.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="frequency" /> est inférieur à 37 ou supérieur à 32 767 hertz.  
  
- ou - 
 <paramref name="duration" /> est inférieur ou égal à zéro.</exception>
        <exception cref="T:System.Security.HostProtectionException">Cette méthode a été exécutée sur un serveur, tel que SQL Server, qui n’autorise pas l’accès à la console.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferHeight : int with get, set" Usage="System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la hauteur de la zone de mémoire tampon.</summary>
        <value>Hauteur, en lignes, de la zone de mémoire tampon.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété définit le nombre de lignes (ou lignes) stockées dans la mémoire tampon qui est accessible par une fenêtre de mode console. En revanche, le <xref:System.Console.WindowHeight%2A> propriété définit le nombre de lignes réellement affichées dans la fenêtre de console à un moment donné. Si le nombre de lignes réellement écrites dans la mémoire tampon dépasse le nombre de lignes définies par le <xref:System.Console.WindowHeight%2A> propriété, la fenêtre peut défiler verticalement afin qu’il affiche un nombre contigu de lignes qui correspondent à la <xref:System.Console.WindowHeight%2A> propriété et se trouvent n’importe où dans la mémoire tampon.  
  
 Si une opération ensembliste diminue la valeur de la <xref:System.Console.BufferHeight%2A> propriété, les lignes plus élevées sont supprimés. Par exemple, si le nombre de lignes est réduit à partir de 300 à 250, 0 à 49 les lignes est supprimées, et 50 et 299 deviennent des lignes existantes lignes 249 à 0.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.BufferHeight%2A> et <xref:System.Console.BufferWidth%2A> propriétés. L’exemple signale les dimensions d’une fenêtre de système d’exploitation défini sur une taille de mémoire tampon de 300 lignes et 85 colonnes.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur incluse dans une opération ensembliste est inférieure ou égale à zéro.  
  
- ou - 
La valeur incluse dans une opération ensembliste est supérieure ou égale à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
La valeur incluse dans une opération ensembliste est inférieure à <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BufferWidth : int with get, set" Usage="System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la largeur de la zone de mémoire tampon.</summary>
        <value>Largeur, en colonnes, de la zone de mémoire tampon.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une opération ensembliste diminue la valeur de la <xref:System.Console.BufferWidth%2A> propriété, les colonnes de plus à droite sont supprimés. Par exemple, si le nombre de colonnes est réduit de 80 à 60, colonnes 60 et 79 de chaque ligne sont supprimés.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.BufferHeight%2A> et <xref:System.Console.BufferWidth%2A> propriétés. L’exemple signale les dimensions d’une fenêtre de système d’exploitation défini sur une taille de mémoire tampon de 300 lignes et 85 colonnes.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur incluse dans une opération ensembliste est inférieure ou égale à zéro.  
  
- ou - 
La valeur incluse dans une opération ensembliste est supérieure ou égale à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
La valeur incluse dans une opération ensembliste est inférieure à <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberSignature Language="F#" Value="member this.CancelKeyPress : ConsoleCancelEventHandler " Usage="member this.CancelKeyPress : System.ConsoleCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la touche de modification (Ctrl) <see cref="F:System.ConsoleModifiers.Control" /> et la touche de console (C) <see cref="F:System.ConsoleKey.C" /> ou la touche d'arrêt sont utilisées simultanément (Ctrl+C ou Ctrl+Pause).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est utilisé conjointement avec <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> et <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. Le <xref:System.Console.CancelKeyPress> événement permet d’intercepter le signal Ctrl + C pour que le Gestionnaire d’événements peut décider s’il faut poursuivre l’exécution ou de mettre fin à une application de console. Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 Lorsque l’utilisateur appuie sur Ctrl + C ou Ctrl + Pause, le <xref:System.Console.CancelKeyPress> événement est déclenché et l’application <xref:System.ConsoleCancelEventHandler> Gestionnaire d’événements est exécuté. Le Gestionnaire d’événements reçoit un <xref:System.ConsoleCancelEventArgs> objet qui a deux propriétés utiles :  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, qui vous permet de déterminer si le gestionnaire a été appelé à la suite de l’utilisateur en appuyant sur Ctrl + C (la valeur de propriété est <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) ou Ctrl + Attn (la valeur de propriété est <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, qui vous permet de déterminer comment à votre application doit répondre à l’utilisateur en appuyant sur Ctrl + C ou Ctrl + Pause. Par défaut, le <xref:System.ConsoleCancelEventArgs.Cancel%2A> propriété est `false`, qui ne se termine lorsque le Gestionnaire d’événements s’arrête l’exécution du programme de causes. Modification de sa propriété `true` Spécifie que l’application doit continuer à exécuter.  
  
> [!TIP]
>  Si votre application présente des exigences simples, vous pouvez utiliser le <xref:System.Console.TreatControlCAsInput%2A> propriété plutôt qu’à cet événement. En définissant cette propriété sur `false`, vous pouvez vous assurer que votre application est toujours s’arrête si l’utilisateur appuie sur Ctrl + C. En lui affectant `true`, vous pouvez vous assurer que l’en appuyant sur Ctrl + C ne sera pas arrêter l’application.  
  
 Le Gestionnaire d’événements pour cet événement est exécuté sur un thread de pool de threads.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.Console.CancelKeyPress> événement est utilisé. Lorsque vous appuyez sur Ctrl + C, l’opération de lecture est interrompue et le `myHandler` Gestionnaire d’événements est appelé. Lors de l’entrée au gestionnaire d’événements, le <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> propriété est `false`, ce qui signifie que le processus en cours se termine lorsque le Gestionnaire d’événements s’arrête. Toutefois, le Gestionnaire d’événements définit la <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> propriété `true`, ce qui signifie que le processus de se terminer et reprend l’opération de lecture.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CapsLock : bool" Usage="System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la bascule de la touche VERR. MAJ est activée ou désactivée.</summary>
        <value>
          <see langword="true" /> si VERR. MAJ est activé ; <see langword="false" /> si VERR. MAJ est désactivé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberSignature Language="F#" Value="static member Clear : unit -&gt; unit" Usage="System.Console.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Efface la mémoire tampon et la fenêtre correspondante de la console contenant les informations d'affichage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 À l’aide de la <xref:System.Console.Clear%2A> méthode est équivalente à l’appel MS-DOS `cls` commande dans la fenêtre d’invite de commandes. Lorsque le <xref:System.Console.Clear%2A> méthode est appelée, le curseur se place automatiquement dans le coin supérieur gauche de la fenêtre et le contenu de la mémoire tampon d’écran est défini sur les espaces à l’aide de couleurs d’arrière-plan de premier plan actuelle.  
  
> [!NOTE]
>  Essayez d’appeler le <xref:System.Console.Clear%2A> méthode lors de la sortie d’une application de console est redirigée vers un fichier lève un <xref:System.IO.IOException>. Pour éviter ce problème, encapsulez toujours un appel à la <xref:System.Console.Clear%2A> méthode dans un `try`...`catch` bloc.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Console.Clear%2A> méthode pour effacer la console avant d’exécuter une boucle, invite l’utilisateur pour sélectionner une couleur de premier plan et d’arrière-plan et entrez une chaîne à afficher. Si l’utilisateur choisit de ne pas quitter le programme, les couleurs de premier plan et d’arrière-plan d’origine de la console sont restaurés et <xref:System.Console.Clear%2A> méthode est appelée à nouveau avant de relancer l’exécution de la boucle.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 L’exemple s’appuie sur un `GetKeyPress` méthode pour valider la sélection de l’utilisateur d’une couleur de premier plan et d’arrière-plan.  
  
 Cet exemple montre la <xref:System.Console.CursorLeft%2A> et <xref:System.Console.CursorTop%2A> propriétés et le <xref:System.Console.SetCursorPosition%2A> et <xref:System.Console.Clear%2A> méthodes. L’exemple positionne le curseur, qui détermine l’emplacement de l’écriture suivante, pour dessiner un rectangle de 5 caractères à l’aide d’une combinaison de 5 « + », «&#124;», et «- » chaînes. Notez que le rectangle pourrait être dessiné avec moins d’étapes à l’aide d’une autre combinaison de chaînes.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorLeft : int with get, set" Usage="System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position de colonne du curseur dans la zone de mémoire tampon.</summary>
        <value>Position actuelle, en colonnes, du curseur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre la <xref:System.Console.CursorLeft%2A> et <xref:System.Console.CursorTop%2A> propriétés et le <xref:System.Console.SetCursorPosition%2A> et <xref:System.Console.Clear%2A> méthodes. L’exemple positionne le curseur, qui détermine l’emplacement de l’écriture suivante, pour dessiner un rectangle de 5 caractères à l’aide d’une combinaison de 5 « + », «&#124;», et «- » chaînes. Notez que le rectangle pourrait être dessiné avec moins d’étapes à l’aide d’une autre combinaison de chaînes.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur d’une opération ensembliste est inférieure à zéro.  
  
- ou - 
La valeur d’une opération ensembliste est supérieure ou égale à <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorSize : int with get, set" Usage="System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la hauteur du curseur dans une cellule de caractère.</summary>
        <value>Taille du curseur exprimée en pourcentage de la hauteur d'une cellule de caractère. La valeur de la propriété est comprise entre 1 et 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’apparence du curseur varie, allant d’une ligne horizontale en bas de la cellule lorsque la valeur de propriété est 1, pour remplir complètement la cellule lorsque la valeur de propriété est 100.  
  
   
  
## Examples  
 Cet exemple montre le <xref:System.Console.CursorSize%2A> propriété. L’exemple augmente la taille du curseur chaque fois qu’une touche de console est enfoncée, puis restaure le curseur à sa taille d’origine avant de s’arrêter.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur spécifiée dans une opération ensembliste est inférieure à 1 ou supérieure à 100.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CursorTop : int with get, set" Usage="System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position de ligne du curseur dans la zone de mémoire tampon.</summary>
        <value>Position actuelle, en lignes, du curseur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre la <xref:System.Console.CursorLeft%2A> et <xref:System.Console.CursorTop%2A> propriétés et le <xref:System.Console.SetCursorPosition%2A> et <xref:System.Console.Clear%2A> méthodes. L’exemple positionne le curseur, qui détermine l’emplacement de l’écriture suivante, pour dessiner un rectangle de 5 caractères à l’aide d’une combinaison de 5 « + », «&#124;», et «- » chaînes. Notez que le rectangle pourrait être dessiné avec moins d’étapes à l’aide d’une autre combinaison de chaînes.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur d’une opération ensembliste est inférieure à zéro.  
  
- ou - 
La valeur d’une opération ensembliste est supérieure ou égale à <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CursorVisible : bool with get, set" Usage="System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur indiquant si le curseur est visible.</summary>
        <value>
          <see langword="true" /> si le curseur est visible ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre le <xref:System.Console.CursorVisible%2A> propriété. L’exemple rend le curseur visible si la première colonne d’entrée est un caractère « + » ou invisible si l’entrée est un '-' caractères.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Error : System.IO.TextWriter" Usage="System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le flux de sortie d'erreur standard.</summary>
        <value>
          <see cref="T:System.IO.TextWriter" /> qui représente le flux de sortie d'erreur standard.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce flux d’erreur standard est défini sur la console par défaut. Elle peut être définie dans un autre flux avec le <xref:System.Console.SetError%2A> (méthode). Une fois que le flux d’erreur standard est redirigé, il peut être acquis à nouveau en appelant le <xref:System.Console.OpenStandardError%2A> (méthode).  
  
 Dans les applications de console dont la sortie d’information est souvent redirigée vers un fichier, l’erreur standard de flux disponibles via le <xref:System.Console.Error%2A> propriété peut être utilisée pour afficher des informations sur la console même si la sortie est redirigée. L’exemple suivant affiche les tables de produit de 10 numéros à la fois en commençant par 1. Après chaque ensemble de 10 chiffres, le <xref:System.Console.Error%2A> propriété est utilisée pour demander à l’utilisateur s’il faut afficher l’ensemble suivant. Si la sortie standard est redirigée vers un fichier, l’utilisateur est invité toujours si la routine doit générer l’ensemble suivant de produits.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant est un utilitaire de ligne de commande nommé ExpandTabs qui remplace les caractères de tabulation dans un fichier texte avec quatre espaces, la valeur définie par le `tabSize` variable. Il redirige l’entrée standard et diffuse en continu sur les fichiers de sortie, mais utilise le <xref:System.Console.Error%2A> propriété à écrire le flux d’erreur standard dans la console. Il peut être lancé depuis la ligne de commande, vous devez fournir le nom du fichier qui contient des caractères de tabulation et le nom du fichier de sortie.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 L’exemple suivant est une visionneuse du fichier texte simple qui affiche le contenu d’un ou plusieurs fichiers texte dans la console. Si aucun argument de ligne de commande, ou si tous les fichiers passés comme arguments de ligne de commande n’existent pas, l’exemple appelle la <xref:System.Console.SetError%2A> appelle la méthode pour rediriger les informations d’erreur dans un fichier, le <xref:System.Console.OpenStandardError%2A> en train de redemander l’erreur standard (méthode) diffuser en continu et indique que les informations d’erreur a été écrites dans un fichier.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Notez que le <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> propriété est définie sur `true` avant de redemander le flux d’erreurs. Cela garantit que sortie est envoyée à la console immédiatement plutôt que mis en mémoire tampon.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberSignature Language="F#" Value="member this.ForegroundColor : ConsoleColor with get, set" Usage="System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la couleur de premier plan de la console.</summary>
        <value>
          <see cref="T:System.ConsoleColor" /> qui spécifie la couleur de premier plan de la console, c'est-à-dire la couleur de chaque caractère affiché. La valeur par défaut est gris.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une opération get pour une application Windows, dans lequel une console n’existe pas, renvoie <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 L’exemple suivant vérifie si les couleurs d’arrière-plan de la console est noir et, dans le cas, il modifie la couleur d’arrière-plan rouge et la couleur de premier plan sur noir.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 L’exemple suivant enregistre les valeurs de la <xref:System.ConsoleColor> énumération dans un tableau et stocke les valeurs actuelles de la <xref:System.Console.BackgroundColor%2A> et <xref:System.Console.ForegroundColor%2A> propriétés à des variables. Il remplace ensuite la couleur de premier plan pour chaque couleur de la <xref:System.ConsoleColor> énumération sauf à la couleur qui correspond à l’arrière-plan actuel, et il modifie la couleur d’arrière-plan pour chaque couleur de la <xref:System.ConsoleColor> énumération à l’exception de la couleur qui correspond à la premier plan actuels. (Si la couleur de premier plan est identique à la couleur d’arrière-plan, le texte n’est pas visible.) Enfin, il appelle le <xref:System.Console.ResetColor%2A> méthode pour restaurer les couleurs de la console d’origine.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La couleur spécifiée dans une opération set n’est pas un membre valide de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.In : System.IO.TextReader" Usage="System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le flux d'entrée standard.</summary>
        <value>
          <see cref="T:System.IO.TextReader" /> qui représente le flux d'entrée standard.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, cette propriété est définie dans le flux d’entrée standard. Cette propriété peut être définie dans un autre flux avec le <xref:System.Console.SetIn%2A> (méthode).  
  
 Les opérations de lecture du flux d’entrée standard exécutent de façon synchrone. Autrement dit, ils bloquent jusqu'à ce que l’opération de lecture spécifiée est terminée. Cela est vrai même si une méthode asynchrone, tel que <xref:System.IO.TextReader.ReadLineAsync%2A>, est appelée sur le <xref:System.IO.TextReader> objet retourné par la <xref:System.Console.In%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `In` propriété.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InputEncoding : System.Text.Encoding with get, set" Usage="System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'encodage que la console utilise pour lire l'entrée.</summary>
        <value>Encodage utilisé pour lire l'entrée de la console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La console utilise la codage d’entrée pour traduire l’entrée au clavier en un caractère correspondant. L’encodage d’entrée incorpore une page de codes qui mappe des codes de caractère de clavier 256 caractères individuels. Les différentes pages de code incluent des caractères spéciaux différents, généralement personnalisés pour une langue ou un groupe de langues.  
  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], une opération get de propriété peut retourner une valeur mise en cache au lieu de l’encodage actuel d’entrée de la console. Cela peut se produire si la valeur de la <xref:System.Console.InputEncoding%2A> propriété est modifiée par un moyen autre que d’une assignation à la <xref:System.Console.InputEncoding%2A> propriété, telles que l’appel de la Windows `SetConsoleCP` fonction ou à l’aide de la `chcp` commande à partir d’un script PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur de propriété dans une opération set est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur s’est produite lors de l’exécution de cette opération.</exception>
        <exception cref="T:System.Security.SecurityException">Votre application n’est pas autorisée à effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour lire et écrire dans ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsErrorRedirected : bool" Usage="System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le flux de sortie d'erreur a été redirigé à partir du flux d'erreur standard.</summary>
        <value>
          <see langword="true" /> si la sortie d'erreur est redirigée ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputRedirected : bool" Usage="System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'entrée a été redirigée à partir du flux d'entrée standard.</summary>
        <value>
          <see langword="true" /> si l'entrée est redirigée ; sinon <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOutputRedirected : bool" Usage="System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la sortie a été redirigée à partir du flux de sortie standard.</summary>
        <value>
          <see langword="true" /> si la sortie est redirigée ; sinon <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyAvailable : bool" Usage="System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'appui sur une touche est disponible dans le flux d'entrée.</summary>
        <value>
          <see langword="true" /> si l'appui sur une touche est disponible, sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété est retournée immédiatement. Autrement dit, le <xref:System.Console.KeyAvailable%2A> propriété ne bloque pas l’entrée jusqu'à ce qu’une touche est disponible.  
  
 Utilisez le <xref:System.Console.KeyAvailable%2A> propriété conjointement avec uniquement le <xref:System.Console.ReadKey%2A> (méthode), pas le <xref:System.Console.Read%2A> ou <xref:System.Console.ReadLine%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Console.KeyAvailable%2A> propriété pour créer une boucle qui s’exécute jusqu'à ce qu’une touche est enfoncée.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.InvalidOperationException">L’entrée standard est redirigée vers un fichier au lieu du clavier.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowHeight : int" Usage="System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le plus grand nombre possible de lignes de fenêtre de console, selon la police et la résolution d’écran actuelles.</summary>
        <value>Hauteur de la plus grande fenêtre de console possible mesurée en lignes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LargestWindowWidth : int" Usage="System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le plus grand nombre possible de colonnes de fenêtre de console, selon la police et la résolution d’écran actuelles.</summary>
        <value>Largeur de la plus grande fenêtre de console possible mesurée en colonnes.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie une zone source spécifiée de la mémoire tampon d'écran dans une zone de destination spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Colonne la plus à gauche de la zone source.</param>
        <param name="sourceTop">Ligne supérieure de la zone source.</param>
        <param name="sourceWidth">Nombre de colonnes de la zone source.</param>
        <param name="sourceHeight">Nombre de lignes de la zone source.</param>
        <param name="targetLeft">Colonne la plus à gauche de la zone de destination.</param>
        <param name="targetTop">Ligne supérieure de la zone de destination.</param>
        <summary>Copie une zone source spécifiée de la mémoire tampon d'écran dans une zone de destination spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les paramètres source et de destination spécifient une position située en dehors des limites de la mémoire tampon d’écran actuelle, seule la partie de la zone source adaptée à la zone de destination est copiée. Autrement dit, la zone source est découpée pour correspondre à la mémoire tampon d’écran actuelle.  
  
 Le <xref:System.Console.MoveBufferArea%2A> méthode copie la zone source vers la zone de destination. Si la zone de destination ne croise pas la zone source, la zone source est remplie avec des espaces à l’aide de couleurs de premier plan et d’arrière-plan actuelles. Sinon, la partie croisée de la zone source n’est pas remplie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un ou plusieurs paramètres sont inférieurs à zéro.  
  
- ou - 
 <paramref name="sourceLeft" /> ou <paramref name="targetLeft" /> est supérieur ou égal à <see cref="P:System.Console.BufferWidth" />.  
  
- ou - 
 <paramref name="sourceTop" /> ou <paramref name="targetTop" /> est supérieur ou égal à <see cref="P:System.Console.BufferHeight" />.  
  
- ou - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> est supérieur ou égal à <see cref="P:System.Console.BufferHeight" />.  
  
- ou - 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> est supérieur ou égal à <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="F#" Value="static member MoveBufferArea : int * int * int * int * int * int * char * ConsoleColor * ConsoleColor -&gt; unit" Usage="System.Console.MoveBufferArea (sourceLeft, sourceTop, sourceWidth, sourceHeight, targetLeft, targetTop, sourceChar, sourceForeColor, sourceBackColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Colonne la plus à gauche de la zone source.</param>
        <param name="sourceTop">Ligne supérieure de la zone source.</param>
        <param name="sourceWidth">Nombre de colonnes de la zone source.</param>
        <param name="sourceHeight">Nombre de lignes de la zone source.</param>
        <param name="targetLeft">Colonne la plus à gauche de la zone de destination.</param>
        <param name="targetTop">Ligne supérieure de la zone de destination.</param>
        <param name="sourceChar">Caractère utilisé pour remplir la zone source.</param>
        <param name="sourceForeColor">Couleur de premier plan utilisée pour remplir la zone source.</param>
        <param name="sourceBackColor">Couleur d'arrière-plan utilisée pour remplir la zone source.</param>
        <summary>Copie une zone source spécifiée de la mémoire tampon d'écran dans une zone de destination spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si les paramètres de destination et source spécifient une position située au-delà des limites de la mémoire tampon d’écran actuelle, seule la partie de la zone source adaptée à la zone de destination est copiée. Autrement dit, la zone source est découpée pour correspondre à la mémoire tampon d’écran actuelle.  
  
 Le <xref:System.Console.MoveBufferArea%2A> méthode copie la zone source vers la zone de destination. Si la zone de destination ne croise pas la zone source, la zone source est remplie avec le caractère spécifié par `sourceChar`, à l’aide des couleurs spécifiées par `sourceForeColor` et `sourceBackColor`. Sinon, la partie croisée de la zone source n’est pas remplie.  
  
 Le <xref:System.Console.MoveBufferArea%2A> méthode n’effectue aucune opération si `sourceWidth` ou `sourceHeight` est égal à zéro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Un ou plusieurs paramètres sont inférieurs à zéro.  
  
- ou - 
 <paramref name="sourceLeft" /> ou <paramref name="targetLeft" /> est supérieur ou égal à <see cref="P:System.Console.BufferWidth" />.  
  
- ou - 
 <paramref name="sourceTop" /> ou <paramref name="targetTop" /> est supérieur ou égal à <see cref="P:System.Console.BufferHeight" />.  
  
- ou - 
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> est supérieur ou égal à <see cref="P:System.Console.BufferHeight" />.  
  
- ou - 
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> est supérieur ou égal à <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Au moins l’un des deux paramètres n’est pas un membre de l’énumération <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.NumberLock : bool" Usage="System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si la bascule de la touche VERR. NUM est activée ou désactivée.</summary>
        <value>
          <see langword="true" /> si VERR. NUM est activé, <see langword="false" /> si VERR. NUM est désactivé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert le flux d'erreur standard.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquiert le flux d'erreur standard.</summary>
        <returns>Flux d'erreur standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux d’erreur standard lorsqu’il a été modifié par le <xref:System.Console.SetError%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant est une visionneuse du fichier texte simple qui affiche le contenu d’un ou plusieurs fichiers texte dans la console. Si aucun argument de ligne de commande, ou si tous les fichiers passés comme arguments de ligne de commande n’existent pas, l’exemple appelle la <xref:System.Console.SetError%2A> appelle la méthode pour rediriger les informations d’erreur dans un fichier, le <xref:System.Console.OpenStandardError%2A> en train de redemander l’erreur standard (méthode) diffuser en continu et indique que les informations d’erreur a été écrites dans un fichier.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Notez que le <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> propriété est définie sur `true` avant de redemander le flux d’erreurs. Cela garantit que sortie est envoyée à la console immédiatement plutôt que mis en mémoire tampon.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardError : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardError bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Taille de la mémoire tampon du flux interne.</param>
        <summary>Acquiert le flux d'erreur standard, défini sur une taille de mémoire tampon spécifiée.</summary>
        <returns>Flux d'erreur standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux d’erreur standard lorsqu’il a été modifié par le <xref:System.Console.SetError%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est inférieur ou égal à zéro.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert le flux d'entrée standard.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquiert le flux d'entrée standard.</summary>
        <returns>Flux d'entrée standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux d’entrée standard lorsqu’il a été modifié par le <xref:System.Console.SetIn%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `OpenStandardInput` propriété.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardInput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardInput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Taille de la mémoire tampon du flux interne.</param>
        <summary>Acquiert le flux d'entrée standard, défini sur une taille de mémoire tampon spécifiée.</summary>
        <returns>Flux d'entrée standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux de sortie standard lorsqu’il a été modifié par le <xref:System.Console.SetIn%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `OpenStandardInput` propriété.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est inférieur ou égal à zéro.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Acquiert le flux de sortie standard.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : unit -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acquiert le flux de sortie standard.</summary>
        <returns>Flux de sortie standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux de sortie standard lorsqu’il a été modifié par le <xref:System.Console.SetOut%2A> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Console.OpenStandardOutput%2A>. Remplace quatre espaces consécutifs d'une chaîne par une tabulation. Pour l’exécuter, vous devez fournir deux arguments de ligne de commande. Le premier est le nom d'un fichier texte existant vers lequel rediriger le flux d'entrée standard. Le deuxième est le nom du fichier vers lequel rediriger le flux de sortie standard. Ce fichier n'a pas besoin d'exister. Si tel est le cas, son contenu est remplacé.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberSignature Language="F#" Value="static member OpenStandardOutput : int -&gt; System.IO.Stream" Usage="System.Console.OpenStandardOutput bufferSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Taille de la mémoire tampon du flux interne.</param>
        <summary>Acquiert le flux de sortie standard, défini sur une taille de mémoire tampon spécifiée.</summary>
        <returns>Flux de sortie standard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être utilisée pour acquérir à nouveau le flux de sortie standard lorsqu’il a été modifié par le <xref:System.Console.SetOut%2A> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Console.OpenStandardOutput%2A>. Remplace quatre espaces consécutifs d'une chaîne par une tabulation. Pour l’exécuter, vous devez fournir deux arguments de ligne de commande. Le premier est le nom d'un fichier texte existant vers lequel rediriger le flux d'entrée standard. Le deuxième est le nom du fichier vers lequel rediriger le flux de sortie standard. Ce fichier n'a pas besoin d'exister. Si tel est le cas, son contenu est remplacé.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> est inférieur ou égal à zéro.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Out : System.IO.TextWriter" Usage="System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le flux de sortie standard.</summary>
        <value>
          <see cref="T:System.IO.TextWriter" /> qui représente le flux de sortie standard.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est définie dans le flux de sortie standard par défaut. Cette propriété peut être définie dans un autre flux avec le <xref:System.Console.SetOut%2A> (méthode).  
  
 Notez que les appels à `Console.Out.WriteLine` méthodes sont équivalentes aux appels correspondant <xref:System.Console.WriteLine%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Console.Out%2A> propriété pour afficher un tableau contenant les noms des fichiers dans le répertoire actif de l’application vers le périphérique de sortie standard. Ensuite, il définit la sortie standard vers un fichier nommé Files.txt et répertorie les éléments du tableau dans le fichier. Enfin, il définit la sortie au flux de sortie standard et affiche à nouveau les éléments du tableau pour le périphérique de sortie standard.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OutputEncoding : System.Text.Encoding with get, set" Usage="System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'encodage que la console utilise pour écrire la sortie.</summary>
        <value>Encodage utilisé pour écrire la sortie de la console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La console utilise l’encodage de sortie pour convertir les caractères écrits par une application dans les caractères d’affichage de console correspondants. La page de codes par défaut qui utilise la console est déterminée par les paramètres régionaux système.  
  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], une opération get de propriété peut retourner une valeur mise en cache au lieu de l’encodage de sortie actuel de la console. Cela peut se produire si la valeur de la <xref:System.Console.OutputEncoding%2A> propriété est modifiée par un moyen autre que d’une assignation à la <xref:System.Console.OutputEncoding%2A> propriété, telles que l’appel de la Windows `SetConsoleOutputCP` (fonction).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La valeur de propriété dans une opération set est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur s’est produite lors de l’exécution de cette opération.</exception>
        <exception cref="T:System.Security.SecurityException">Votre application n’est pas autorisée à effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">pour lire et écrire dans ces sous-fenêtres et les fenêtres de niveau supérieur.  Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Des encodages Unicode, le <see cref="T:System.Console" /> classe prend en charge l’encodage avec UTF-8 le <see cref="T:System.Text.UTF8Encoding" /> classe et, en commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il prend en charge le codage UTF-16 le <see cref="T:System.Text.UnicodeEncoding" /> classe. Encodage UTF-32 avec la <see cref="T:System.Text.UTF32Encoding" /> classe n’est pas prise en charge. Tentative de définition de l’encodage de sortie au format UTF-32 lève une <see cref="T:System.IO.IOException" />.  
  
Notez que l’afficher correctement les caractères Unicode dans la console requiert les éléments suivants : 
-La console doit utiliser une police TrueType, comme Lucida Console ou Consolas, pour afficher les caractères.  
  
-Une police utilisée par la console doit définir le glyphe particulier ou les glyphes à afficher. La console peut tirer parti de la police de liaison pour afficher des glyphes à partir de polices liés si la police de base ne contient-elle pas une définition pour ce glyphe.  
  
Pour plus d’informations sur la prise en charge Unicode encodage par la console, consultez la section « Unicode prend en charge pour la Console » dans la <see cref="T:System.Console" /> classe.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberSignature Language="F#" Value="static member Read : unit -&gt; int" Usage="System.Console.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit le caractère suivant du flux d'entrée standard.</summary>
        <returns>Caractère suivant du flux d'entrée, ou caractère négatif (-1) s'il n'y a pas d'autres caractères à lire.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Console.Read%2A> méthode bloque son retour pendant que vous tapez des caractères d’entrée ; elle se termine lorsque vous appuyez sur la <xref:System.ConsoleKey.Enter> clé. En appuyant sur entrée ajoute une séquence d’arrêt de ligne de dépend de la plateforme à votre entrée (par exemple, Windows ajoute une séquence de sauts de ligne de chariot). Les appels suivants à la <xref:System.Console.Read%2A> méthode récupérer votre un caractère d’entrée à la fois. Après le dernier caractère est récupéré, <xref:System.Console.Read%2A> bloque son retour à nouveau et le cycle se répète.  
  
> [!IMPORTANT]
>  Le <xref:System.Console.ReadLine%2A> (méthode), ou le <xref:System.Console.KeyAvailable%2A> propriété et <xref:System.Console.ReadKey%2A> (méthode), il est préférable à l’utilisation de la <xref:System.Console.Read%2A> (méthode).  
  
 Notez que la méthode ne retourne pas -1, sauf si vous effectuez l’une des actions suivantes :  
  
-   Appuyer simultanément sur le <xref:System.ConsoleModifiers.Control> touche de modification et <xref:System.ConsoleKey.Z> touche de console (Ctrl + Z), qui signale la condition de fin de fichier.  
  
-   Appuyez sur une touche équivalente qui signale la condition de fin de fichier, telles que la touche de fonction F6 dans Windows.  
  
-   Rediriger le flux d’entrée à une source, tel qu’un fichier texte, qui possède un caractère de fin de fichier réel.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.Read%2A> (méthode).  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le caractère suivant ou la touche de fonction sur laquelle l'utilisateur a appuyé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberSignature Language="F#" Value="static member ReadKey : unit -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le caractère suivant ou la touche de fonction sur laquelle l'utilisateur a appuyé. La touche enfoncée s'affiche dans la fenêtre de console.</summary>
        <returns>Objet qui décrit la constante <see cref="T:System.ConsoleKey" /> et, le cas échéant, le caractère Unicode qui correspond à la touche de console enfoncée. L'objet <see cref="T:System.ConsoleKeyInfo" /> décrit également, dans une combinaison d'opérations de bits de valeurs <see cref="T:System.ConsoleModifiers" />, si une ou plusieurs touches de modification MAJ, ALT ou CTRL ont été enfoncées en même temps que la touche de console.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Console.ReadKey%2A> méthode attend, autrement dit, blocs sur le thread émettant le <xref:System.Console.ReadKey%2A> (méthode), jusqu'à ce qu’une touche de caractère ou une fonction est enfoncée. Un caractère ou une fonction peut être enfoncée en association avec un ou plusieurs touches de modification MAJ, Alt et/ou Ctrl. Toutefois, en appuyant sur une touche de modification en soi n’entraîne pas la <xref:System.Console.ReadKey%2A> méthode à retourner.  
  
 En fonction de votre application, vous souhaiterez peut-être utiliser le <xref:System.Console.ReadKey%2A> méthode conjointement avec le <xref:System.Console.KeyAvailable%2A> propriété.  
  
 Le <xref:System.Console.ReadKey%2A> méthode lit à partir du clavier, même si l’entrée standard est redirigée vers un fichier avec le <xref:System.Console.SetIn%2A> (méthode).  
  
   
  
## Examples  
 Le plus souvent utilisé pour la <xref:System.Console.ReadKey> méthode consiste à arrêter l’exécution du programme jusqu'à ce que l’utilisateur appuie sur une clé et l’application se termine ou affiche une fenêtre supplémentaire d’informations. L’exemple suivant utilise la <xref:System.Console.ReadKey> méthode pour attendre l’utilisateur appuie sur la touche entrée avant de mettre fin à l’application.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Notez que cette surcharge de la <xref:System.Console.ReadKey%2A> méthode par défaut renvoie les clés affichables que l’utilisateur appuie sur la console. Pour les supprimer, appelez le <xref:System.Console.ReadKey%2A> méthode avec un `intercept` argument de `true`.  
  
 L’exemple suivant utilise la <xref:System.Console.ReadKey> méthode pour afficher des informations sur clé qui l’utilisateur a appuyé sur...  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Console.In" /> est redirigée à partir d’un flux autre que la console.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberSignature Language="F#" Value="static member ReadKey : bool -&gt; ConsoleKeyInfo" Usage="System.Console.ReadKey intercept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Détermine s'il faut afficher ou non la touche enfoncée dans la fenêtre de la console. <see langword="true" /> pour ne pas afficher la touche enfoncée ; sinon, <see langword="false" />.</param>
        <summary>Obtient le caractère suivant ou la touche de fonction sur laquelle l'utilisateur a appuyé. La touche enfoncée s'affiche éventuellement dans la fenêtre de console.</summary>
        <returns>Objet qui décrit la constante <see cref="T:System.ConsoleKey" /> et, le cas échéant, le caractère Unicode qui correspond à la touche de console enfoncée. L'objet <see cref="T:System.ConsoleKeyInfo" /> décrit également, dans une combinaison d'opérations de bits de valeurs <see cref="T:System.ConsoleModifiers" />, si une ou plusieurs touches de modification MAJ, ALT ou CTRL ont été enfoncées en même temps que la touche de console.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Console.ReadKey%2A> méthode attend, autrement dit, blocs sur le thread émettant le <xref:System.Console.ReadKey%2A> (méthode), jusqu'à ce qu’une touche de caractère ou une fonction est enfoncée. Un caractère ou une fonction peut être enfoncée en association avec un ou plusieurs touches de modification MAJ, Alt et/ou Ctrl. Toutefois, en appuyant sur une touche de modification en soi n’entraîne pas la <xref:System.Console.ReadKey%2A> méthode à retourner.  
  
 Si le `intercept` paramètre est `true`, la touche enfoncée est interceptée et pas affichée dans la fenêtre de console ; sinon, la touche enfoncée s’affiche.  
  
 En fonction de votre application, vous souhaiterez peut-être utiliser le <xref:System.Console.ReadKey%2A> méthode conjointement avec le <xref:System.Console.KeyAvailable%2A> propriété.  
  
 Le <xref:System.Console.ReadKey%2A> méthode lit à partir du clavier, même si l’entrée standard est redirigée vers un fichier avec le <xref:System.Console.SetIn%2A> (méthode).  
  
   
  
## Examples  
 Le plus souvent utilisé pour la <xref:System.Console.ReadKey%2A> méthode consiste à arrêter l’exécution du programme jusqu'à ce que l’utilisateur appuie sur une clé et l’application se termine ou affiche une fenêtre supplémentaire d’informations. L’exemple suivant utilise la <xref:System.Console.ReadKey%28System.Boolean%29> méthode pour attendre l’utilisateur appuie sur la touche entrée avant de mettre fin à l’application. Notez que, si l’utilisateur appuie sur une autre clé, il n'est pas répercutée dans la console.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 L’exemple suivant utilise la <xref:System.Console.ReadKey%28System.Boolean%29> méthode pour afficher des informations sur la touche enfoncée par un utilisateur sans afficher cette clé dans la console.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Console.In" /> est redirigée à partir d’un flux autre que la console.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="static member ReadLine : unit -&gt; string" Usage="System.Console.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lit la ligne de caractères suivante du flux d'entrée standard.</summary>
        <returns>Ligne de caractères suivante du flux d'entrée, ou <see langword="null" /> s'il n'y a plus de lignes disponibles.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Console.ReadLine%2A> méthode lit une ligne à partir du flux d’entrée standard. (Pour la définition d’une ligne, consultez le paragraphe après la liste suivante.) Cela signifie que :  
  
-   Si le périphérique d’entrée standard est le clavier, la <xref:System.Console.ReadLine%2A> méthode s’interrompt jusqu'à ce que l’utilisateur appuie sur le **entrée** clé.  
  
     Le plus souvent utilisé pour la <xref:System.Console.ReadLine%2A> méthode consiste à suspendre l’exécution du programme avant l’effacement de la console et d’afficher les nouvelles informations à ce dernier, ou pour inviter l’utilisateur à appuyer sur la touche entrée avant de mettre fin à l’application. L'exemple suivant illustre ce comportement.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Si l’entrée standard est redirigée vers un fichier, le <xref:System.Console.ReadLine%2A> méthode lit une ligne de texte à partir d’un fichier. Par exemple, ce qui suit est un fichier texte nommé ReadLine1.txt :  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     L’exemple suivant utilise la <xref:System.Console.ReadLine%2A> méthode pour lire l’entrée est redirigée à partir d’un fichier. L’opération de lecture se termine lorsque la méthode retourne `null`, ce qui indique qu’aucune ligne ne reste à lire.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Après la compilation de l’exemple pour un exécutable ReadLine1.exe nommée, vous pouvez l’exécuter à partir de la ligne de commande avec la syntaxe  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     pour lire le contenu du fichier et les afficher dans la console.  
  
 Une ligne est définie comme une séquence de caractères suivi d’un retour chariot (0x000d hexadécimal), un saut de ligne (0x000a hexadécimal) ou la valeur de la <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriété. La chaîne retournée ne contient pas de caractère de fin. Par défaut, la méthode lit l’entrée d’une mémoire tampon d’entrée de 256 caractères. Étant donné que cela inclut le <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> (s), la méthode peut lire les lignes qui contiennent jusqu'à 254 caractères. Pour lire des lignes plus longues, appelez le <xref:System.Console.OpenStandardInput%28System.Int32%29> (méthode).  
  
 Le <xref:System.Console.ReadLine%2A> méthode s’exécute de façon synchrone. Autrement dit, elle demeure bloquée jusqu'à ce qu’une ligne est lue ou la combinaison de touches Ctrl + Z est activée. Le <xref:System.Console.In%2A> propriété retourne un <xref:System.IO.TextReader> objet qui représente le flux d’entrée standard et qui contient à la fois synchrone <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> méthode et asynchrone <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> (méthode). Toutefois, lorsqu’il est utilisé en tant que flux d’entrée standard de la console, le <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> exécute de façon synchrone plutôt qu’asynchrone et retourne un `Task<String>` uniquement après la fin de l’opération de lecture.  
  
 Si cette méthode lève un <xref:System.OutOfMemoryException> exception, la position du lecteur dans sous-jacent <xref:System.IO.Stream> objet est avancé par le nombre de caractères que la méthode a été en mesure de lire, mais les caractères déjà lus dans le texte interne <xref:System.Console.ReadLine%2A> sont de la mémoire tampon ignoré. Étant donné que la position du lecteur dans le flux ne peut pas être modifiée, les caractères déjà lus sont irrécupérables et sont accessibles uniquement en réinitialisant le <xref:System.IO.TextReader>. Si la position initiale dans le flux de données est inconnue ou le flux ne prend pas en charge la recherche, sous-jacent <xref:System.IO.Stream> doit également être réinitialisé. Pour éviter une telle situation et produire du code robuste, vous devez utiliser le <xref:System.Console.KeyAvailable%2A> propriété et <xref:System.Console.ReadKey%2A> (méthode) et store les caractères lus dans une mémoire tampon allouée au préalable.  
  
 Si le caractère de Ctrl + Z est activé lorsque la méthode lit l’entrée de la console, la méthode retourne `null`. Cela permet l’utilisateur afin d’éviter de clavier supplémentaires entrée quand le <xref:System.Console.ReadLine%2A> méthode est appelée dans une boucle. L’exemple suivant illustre ce scénario.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant requiert deux arguments de ligne de commande : le nom d’un fichier texte existant et le nom d’un fichier à écrire la sortie. Il ouvre le fichier texte existant et redirige l’entrée standard à partir du clavier à ce fichier. Il redirige également la sortie standard à partir de la console vers le fichier de sortie. Il utilise ensuite le <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> méthode pour lire chaque ligne dans le fichier, remplace chaque séquence de quatre espaces par un caractère de tabulation et utilise le <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> méthode pour écrire le résultat dans le fichier de sortie.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire est insuffisante pour allouer une mémoire tampon à la chaîne retournée.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le nombre de caractères dans la ligne de caractères suivante est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberSignature Language="F#" Value="static member ResetColor : unit -&gt; unit" Usage="System.Console.ResetColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Définit les couleurs de premier plan et d'arrière-plan de la console sur leurs valeurs par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les couleurs de premier plan et d’arrière-plan sont restaurés dans les couleurs qui existaient au moment où le processus en cours a commencé. Pour plus d’informations, consultez le <xref:System.Console.ForegroundColor%2A> et <xref:System.Console.BackgroundColor%2A> propriétés.  
  
   
  
## Examples  
 L’exemple suivant enregistre les valeurs de la <xref:System.ConsoleColor> énumération dans un tableau et stocke les valeurs actuelles de la <xref:System.Console.BackgroundColor%2A> et <xref:System.Console.ForegroundColor%2A> propriétés à des variables. Il remplace ensuite la couleur de premier plan pour chaque couleur de la <xref:System.ConsoleColor> énumération sauf à la couleur qui correspond à l’arrière-plan actuel, et il modifie la couleur d’arrière-plan pour chaque couleur de la <xref:System.ConsoleColor> énumération à l’exception de la couleur qui correspond à la premier plan actuels. (Si la couleur de premier plan est identique à la couleur d’arrière-plan, le texte n’est pas visible.) Enfin, il appelle le <xref:System.Console.ResetColor%2A> méthode pour restaurer les couleurs de la console d’origine.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetBufferSize : int * int -&gt; unit" Usage="System.Console.SetBufferSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Largeur de la zone de mémoire tampon mesurée en colonnes.</param>
        <param name="height">Hauteur de la zone de mémoire tampon mesurée en lignes.</param>
        <summary>Définit la hauteur et la largeur de la zone de mémoire tampon d'écran sur les valeurs spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, et <xref:System.Console.CursorVisible%2A> propriétés ; et le <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, et <xref:System.Console.ReadKey%2A> méthodes. L’exemple dessine un motif de grille dans la mémoire tampon d’écran en fonction de la largeur de la mémoire tampon écran. Ensuite, l’exemple déplace la fenêtre de console en réponse de la flèche haut, bas, flèche gauche ou flèche droite clés de console est enfoncée. Le modèle de grille vous permet de visualiser le déplacement de la fenêtre de console par rapport à la mémoire tampon d’écran.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="height" /> ou <paramref name="width" /> est inférieur ou égal à zéro.  
  
- ou - 
 <paramref name="height" /> ou <paramref name="width" /> est supérieur ou égal à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
 <paramref name="width" /> est inférieur à <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.  
  
- ou - 
 <paramref name="height" /> est inférieur à <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetCursorPosition : int * int -&gt; unit" Usage="System.Console.SetCursorPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Position de colonne du curseur. Les colonnes sont numérotées de gauche à droite à partir de 0.</param>
        <param name="top">Position de ligne du curseur. Les lignes sont numérotées de haut en bas à partir de 0.</param>
        <summary>Définit la position du curseur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Console.SetCursorPosition%2A> méthode pour spécifier où doit commencer l’opération d’écriture suivante dans la fenêtre de console. Si la position du curseur spécifiée est hors de la zone qui est actuellement visible dans la fenêtre de console, l’origine de la fenêtre change automatiquement pour que le curseur soit visible.  
  
 Le curseur se déplace automatiquement vers le caractère suivant chaque fois qu’un caractère est écrite dans la fenêtre de console. Si le curseur se trouve à la position de caractère à droite en bas de la fenêtre de console, la prochaine écriture opération provoque la fenêtre de console pour faire défiler le curseur reste visible. Si vous souhaitez écrire un caractère en bas à droite sans provoquer de la fenêtre de console faire défiler, utilisez le <xref:System.Console.MoveBufferArea%2A> méthode pour déplacer un caractère vers cette position.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.CursorLeft%2A> et <xref:System.Console.CursorTop%2A> propriétés et le <xref:System.Console.SetCursorPosition%2A> et <xref:System.Console.Clear%2A> méthodes. L’exemple positionne le curseur, qui détermine l’emplacement de l’écriture suivante, pour dessiner un rectangle de 5 caractères à l’aide d’une combinaison de 5 « + », «&#124;», et «- » chaînes. Notez que le rectangle pourrait être dessiné avec moins d’étapes à l’aide d’une autre combinaison de chaînes.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> ou <paramref name="top" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="left" /> est supérieur ou égal à <see cref="P:System.Console.BufferWidth" />.  
  
- ou - 
 <paramref name="top" /> est supérieur ou égal à <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberSignature Language="F#" Value="static member SetError : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetError newError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Flux représentant la nouvelle sortie d'erreur standard.</param>
        <summary>Définit la propriété <see cref="P:System.Console.Error" /> avec l'objet <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Console.Error%2A> propriété est définie sur le flux de sortie d’erreur standard.  
  
 Un <xref:System.IO.StreamWriter> qui encapsule un <xref:System.IO.FileStream> peut être utilisé pour envoyer des messages d’erreur dans un fichier.  
  
   
  
## Examples  
 L’exemple suivant montre comment rediriger le flux d’erreur standard vers un fichier.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newError" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberSignature Language="F#" Value="static member SetIn : System.IO.TextReader -&gt; unit" Usage="System.Console.SetIn newIn" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Flux représentant la nouvelle entrée standard.</param>
        <summary>Définit la propriété <see cref="P:System.Console.In" /> avec l'objet <see cref="T:System.IO.TextReader" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Console.In%2A> propriété est définie sur le flux d’entrée standard.  
  
 Un <xref:System.IO.StreamReader> qui encapsule un <xref:System.IO.FileStream> peut être utilisé pour recevoir l’entrée à partir d’un fichier.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Console.SetIn%2A>. Remplace quatre espaces consécutifs d'une chaîne par une tabulation. Pour l’exécuter, vous devez fournir deux arguments de ligne de commande. Le premier est le nom d'un fichier texte existant vers lequel rediriger le flux d'entrée standard. Le deuxième est le nom du fichier vers lequel rediriger le flux de sortie standard. Ce fichier n'a pas besoin d'exister. Si tel est le cas, son contenu est remplacé.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newIn" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberSignature Language="F#" Value="static member SetOut : System.IO.TextWriter -&gt; unit" Usage="System.Console.SetOut newOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Flux représentant la nouvelle sortie standard.</param>
        <summary>Définit la propriété <see cref="P:System.Console.Out" /> avec l'objet <see cref="T:System.IO.TextWriter" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le <xref:System.Console.Out%2A> propriété est définie sur le flux de sortie standard.  
  
 Un <xref:System.IO.StreamWriter> qui encapsule un <xref:System.IO.FileStream> peut être utilisé pour envoyer la sortie vers un fichier. Exemple :  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Console.SetOut%2A>. Remplace quatre espaces consécutifs d'une chaîne par une tabulation. Pour l’exécuter, vous devez fournir deux arguments de ligne de commande. Le premier est le nom d'un fichier texte existant vers lequel rediriger le flux d'entrée standard. Le deuxième est le nom du fichier vers lequel rediriger le flux de sortie standard. Ce fichier n'a pas besoin d'exister. Si tel est le cas, son contenu est remplacé.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newOut" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L'appelant n'a pas l'autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberSignature Language="F#" Value="static member SetWindowPosition : int * int -&gt; unit" Usage="System.Console.SetWindowPosition (left, top)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Position de colonne de l'angle supérieur gauche de la fenêtre de console.</param>
        <param name="top">Position de ligne de l'angle supérieur gauche de la fenêtre de console.</param>
        <summary>Définit la position de la fenêtre de console par rapport à la mémoire tampon d'écran.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La fenêtre de système d’exploitation affiche la fenêtre de console, et la fenêtre de console affiche une partie de la mémoire tampon d’écran. Le <xref:System.Console.SetWindowPosition%2A> méthode affectent la position de la fenêtre de console par rapport à la mémoire tampon d’écran, mais n’affecte pas la position de la fenêtre de système d’exploitation par rapport au bureau.  
  
 Les fenêtres de console et de système d’exploitation n’affectent généralement pas mutuellement. Toutefois, si la mémoire tampon d’écran ne peut pas être affiché dans les limites actuelles de la fenêtre de console, le système d’exploitation ajoute automatiquement les barres de défilement dans la fenêtre de système d’exploitation. Dans ce cas, déplacer les barres de défilement de fenêtre de système d’exploitation affectent la position de la fenêtre de console, et le déplacement de la fenêtre de console avec la <xref:System.Console.SetWindowPosition%2A> méthode affecte la position des barres de défilement de fenêtre de système d’exploitation.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, et <xref:System.Console.CursorVisible%2A> propriétés ; et le <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, et <xref:System.Console.ReadKey%2A> méthodes. L’exemple dessine un motif de grille dans la mémoire tampon d’écran en fonction de la largeur de la mémoire tampon écran. Ensuite, l’exemple déplace la fenêtre de console en réponse de la flèche haut, bas, flèche gauche ou flèche droite clés de console est enfoncée. Le modèle de grille vous permet de visualiser le déplacement de la fenêtre de console par rapport à la mémoire tampon d’écran.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> ou <paramref name="top" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> est supérieur à <see cref="P:System.Console.BufferWidth" />.  
  
- ou - 
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> est supérieur à <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberSignature Language="F#" Value="static member SetWindowSize : int * int -&gt; unit" Usage="System.Console.SetWindowSize (width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Largeur de la fenêtre de console mesurée en colonnes.</param>
        <param name="height">Hauteur de la fenêtre de console mesurée en lignes.</param>
        <summary>Définit la hauteur et la largeur de la fenêtre de console sur les valeurs spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre la <xref:System.Console.SetWindowSize%2A> (méthode) et le <xref:System.Console.WindowWidth%2A> et <xref:System.Console.WindowHeight%2A> propriétés. Vous devez exécuter l’exemple pour voir l’effet de la modification de la taille de fenêtre de console.  
  
 L’exemple rapporte les dimensions d’une fenêtre de console la valeur 85 colonnes et 43 lignes, puis attend qu’une clé à enfoncer. Lorsqu’une touche est enfoncée, les dimensions de la fenêtre de console sont divisés par deux, les nouvelles dimensions sont signalées et l’exemple attend une autre touche. Enfin, lorsqu’une touche est enfoncée, la fenêtre de console est restaurée à ses dimensions d’origine et l’exemple se termine.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="width" /> ou <paramref name="height" /> est inférieur ou égal à zéro.  
  
- ou - 
 <paramref name="width" /> plus <see cref="P:System.Console.WindowLeft" /> ou <paramref name="height" /> plus <see cref="P:System.Console.WindowTop" /> est supérieur ou égal à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
 <paramref name="width" /> ou <paramref name="height" /> est supérieur à la plus grande largeur ou hauteur de fenêtre possible compte tenu de la police de la console et de la résolution d’écran actuellement définies.</exception>
        <exception cref="T:System.Security.SecurityException">L’utilisateur n’est pas autorisé à effectuer cette action.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le titre à afficher dans la barre de titre de la console.</summary>
        <value>Chaîne à afficher dans la barre de titre de la console. La longueur maximale de la chaîne de titre est limitée à 24 500 caractères.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Cet exemple montre le <xref:System.Console.Title%2A> propriété. L’exemple affiche le titre de la fenêtre de système d’exploitation en cours, attend une touche, puis affiche un nouveau titre.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dans une opération get, le titre récupéré est plus long que 24 500 caractères.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Dans une opération set, le titre spécifié est plus long que 24 500 caractères.</exception>
        <exception cref="T:System.ArgumentNullException">Dans une opération set, le titre spécifié est <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TreatControlCAsInput : bool with get, set" Usage="System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la combinaison de la touche de modification <see cref="F:System.ConsoleModifiers.Control" /> et de la touche de console (Ctrl+C) <see cref="F:System.ConsoleKey.C" /> est traitée comme une entrée ordinaire ou comme une interruption gérée par le système d'exploitation.</summary>
        <value>
          <see langword="true" /> si Ctrl+C est traité comme entrée ordinaire ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur de la <xref:System.Console.TreatControlCAsInput%2A> propriété est `false` et appuyé sur Ctrl + C, les touches enfoncées ne sont pas stockées dans la mémoire tampon d’entrée et le système d’exploitation met fin au processus en cours d’exécution. Valeur par défaut.  
  
> [!CAUTION]
>  Utilisez cette propriété judicieusement, car la valeur `true` a un effet dramatique. La plupart des utilisateurs attendent Ctrl + C pour arrêter une application de console. Si vous désactivez l’effet de Ctrl + C, l’utilisateur doit se souvenir d’utiliser Ctrl + Pause pour arrêter l’application, qui est une combinaison de touches moins familier.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.TreatControlCAsInput%2A> propriété.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Impossible d’obtenir ou définir le mode d’entrée de la mémoire tampon d’entrée de la console.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowHeight : int with get, set" Usage="System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la hauteur de la zone de la fenêtre de console.</summary>
        <value>Hauteur de la fenêtre de console mesurée en lignes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentez de définir la valeur de la <xref:System.Console.WindowHeight%2A> propriété lorsque la sortie est redirigée lève soit une <xref:System.ArgumentOutOfRangeException> ou un <xref:System.IO.IOException> exception. Pour éviter une exception, vous pouvez définir la valeur de cette propriété uniquement si le <xref:System.Console.IsOutputRedirected%2A> retourne de la propriété `false`.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.SetWindowSize%2A> (méthode) et le <xref:System.Console.WindowWidth%2A> et <xref:System.Console.WindowHeight%2A> propriétés. Vous devez exécuter l’exemple pour voir l’effet de la modification de la taille de fenêtre de console.  
  
 L’exemple rapporte les dimensions d’une fenêtre de console la valeur 85 colonnes et 43 lignes, puis attend une touche. Lorsqu’une touche est enfoncée, les dimensions de la fenêtre de console sont divisés par deux, les nouvelles dimensions sont signalées et l’exemple attend une autre touche. Enfin, lorsqu’une touche est enfoncée la fenêtre de console est restaurée à ses dimensions d’origine et l’exemple se termine.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de la propriété <see cref="P:System.Console.WindowWidth" /> ou la valeur de la propriété <see cref="P:System.Console.WindowHeight" /> est inférieure ou égale à 0.  
  
- ou - 
La somme de la valeur de la propriété <see cref="P:System.Console.WindowHeight" /> et de la valeur de la propriété <see cref="P:System.Console.WindowTop" /> est supérieure ou égale à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
La valeur de la propriété <see cref="P:System.Console.WindowWidth" /> ou <see cref="P:System.Console.WindowHeight" /> est supérieure à la plus grande largeur ou hauteur de fenêtre possible compte tenu de la police de la console et de la résolution d’écran actuellement définies.</exception>
        <exception cref="T:System.IO.IOException">Erreur de lecture ou d’écriture des informations.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowLeft : int with get, set" Usage="System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position la plus à gauche de la zone de la fenêtre de console par rapport à la mémoire tampon d'écran.</summary>
        <value>Position de la fenêtre de console la plus à gauche mesurée en colonnes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La console représente une fenêtre rectangulaire dans une zone rectangulaire de mémoire tampon plus grande. La fenêtre et la mémoire tampon sont mesurées verticalement par leur nombre de lignes et horizontalement par leur nombre de colonnes. Les dimensions de la zone de mémoire tampon sont définies par le <xref:System.Console.BufferHeight%2A> et <xref:System.Console.BufferWidth%2A> propriétés. Les dimensions de la zone de la console sont définies par le <xref:System.Console.WindowHeight%2A> et <xref:System.Console.WindowWidth%2A> propriétés. Le <xref:System.Console.WindowLeft%2A> propriété détermine quelle colonne de la zone de mémoire tampon s’affiche dans la première colonne de la fenêtre de console. La valeur de la <xref:System.Console.WindowLeft%2A> propriété peut aller de 0 à <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Essayez de définir une valeur en dehors de cette plage lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Quand une fenêtre de console s’ouvre, la valeur par défaut de la <xref:System.Console.WindowLeft%2A> est égale à zéro, ce qui indique que la première colonne indiquée par la console correspond à la première colonne (la colonne à la position zéro) dans la zone de mémoire tampon. La largeur par défaut de la fenêtre de console et de la zone de mémoire tampon est 80 colonnes. Cela signifie que le <xref:System.Console.WindowLeft%2A> propriété peut être modifiée uniquement si la fenêtre de console est rendue plus étroite ou la zone de mémoire tampon est rendue plus large.  
  
 Notez que si la largeur de la zone de mémoire tampon dépasse la largeur de la fenêtre de console, la valeur de la <xref:System.Console.WindowLeft%2A> propriété est automatiquement ajustée lorsque l’utilisateur utilise la barre de défilement horizontale pour définir la relation de la fenêtre à la zone de mémoire tampon.  
  
 Tentative de définition de la valeur de la <xref:System.Console.WindowLeft%2A> propriété lors de la sortie est redirigée lève une <xref:System.IO.IOException> exception. Pour empêcher cette exception, vous pouvez définir la valeur de cette propriété uniquement si le <xref:System.Console.IsOutputRedirected%2A> retourne de la propriété `false`.  
  
   
  
## Examples  
 L’exemple suivant ouvre une fenêtre de console de la colonne de 80 et définit une zone de mémoire tampon de 120 colonnes larges. Il affiche des informations sur la taille de fenêtre et la mémoire tampon, puis attend que l’utilisateur appuie sur la touche gauche ou la touche flèche droite. Dans le premier cas, il décrémente la valeur de la <xref:System.Console.WindowLeft%2A> propriété de 1 si le résultat est une valeur autorisée. Dans ce cas, il augmente la valeur de la <xref:System.Console.WindowLeft%2A> propriété d’une unité si le résultat est autorisé. Notez que l’exemple n’a pas à gérer un <xref:System.ArgumentOutOfRangeException>, car il vérifie que la valeur à assigner à la <xref:System.Console.WindowLeft%2A> propriété n’est pas négative et n’entraîne pas la somme de la <xref:System.Console.WindowLeft%2A> et <xref:System.Console.WindowWidth%2A> propriétés dépasse le <xref:System.Console.BufferWidth%2A> valeur de propriété.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dans une opération ensembliste, la valeur à affecter est inférieure à zéro.  
  
- ou - 
Suite à l’affectation, <see cref="P:System.Console.WindowLeft" /> plus <see cref="P:System.Console.WindowWidth" /> dépasseraient <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Erreur de lecture ou d’écriture des informations.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTop : int with get, set" Usage="System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la position supérieure de la zone de la fenêtre de console par rapport à la mémoire tampon d'écran.</summary>
        <value>Position supérieure de la fenêtre de console mesurée en lignes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La console représente une fenêtre rectangulaire dans une zone rectangulaire de mémoire tampon plus grande. La fenêtre et la mémoire tampon sont mesurées verticalement par leur nombre de lignes et horizontalement par leur nombre de colonnes. Les dimensions de la zone de mémoire tampon sont définies par le <xref:System.Console.BufferHeight%2A> et <xref:System.Console.BufferWidth%2A> propriétés. Les dimensions de la zone de la console sont définies par le <xref:System.Console.WindowHeight%2A> et <xref:System.Console.WindowWidth%2A> propriétés. Le <xref:System.Console.WindowTop%2A> propriété détermine quelle ligne de la zone de mémoire tampon est affichée dans la première colonne de la fenêtre de console. La valeur de la <xref:System.Console.WindowTop%2A> propriété peut aller de 0 à <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Essayez de définir une valeur en dehors de cette plage lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Tentative de définition de la valeur de la <xref:System.Console.WindowTop%2A> propriété lors de la sortie est redirigée lève une <xref:System.IO.IOException> exception. Pour empêcher cette exception, vous pouvez définir la valeur de cette propriété uniquement si le <xref:System.Console.IsOutputRedirected%2A> retourne de la propriété `false`.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, et <xref:System.Console.CursorVisible%2A> propriétés ; et le <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, et <xref:System.Console.ReadKey%2A> méthodes. L’exemple dessine un motif de grille dans la mémoire tampon d’écran en fonction de la largeur de la mémoire tampon écran. Ensuite, l’exemple déplace la fenêtre de console en réponse de la flèche haut, bas, flèche gauche ou flèche droite clés de console est enfoncée. Le modèle de grille vous permet de visualiser le déplacement de la fenêtre de console par rapport à la mémoire tampon d’écran.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Dans une opération ensembliste, la valeur à affecter est inférieure à zéro.  
  
- ou - 
Suite à l’affectation, <see cref="P:System.Console.WindowTop" /> plus <see cref="P:System.Console.WindowHeight" /> dépasseraient <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Erreur de lecture ou d’écriture des informations.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.WindowWidth : int with get, set" Usage="System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la largeur de la fenêtre de console.</summary>
        <value>Largeur de la fenêtre de console mesurée en colonnes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentez de définir la valeur de la <xref:System.Console.WindowWidth%2A> propriété lorsque la sortie est redirigée lève soit une <xref:System.ArgumentOutOfRangeException> ou un <xref:System.IO.IOException> exception. Pour éviter une exception, vous pouvez définir la valeur de cette propriété uniquement si le <xref:System.Console.IsOutputRedirected%2A> retourne de la propriété `false`.  
  
   
  
## Examples  
 Cet exemple montre la <xref:System.Console.SetWindowSize%2A> (méthode) et le <xref:System.Console.WindowWidth%2A> et <xref:System.Console.WindowHeight%2A> propriétés. Vous devez exécuter l’exemple pour voir l’effet de la modification de la taille de fenêtre de console.  
  
 L’exemple rapporte les dimensions d’une fenêtre de console la valeur 85 colonnes et 43 lignes, puis attend une touche. Lorsqu’une touche est enfoncée, les dimensions de la fenêtre de console sont divisés par deux, les nouvelles dimensions sont signalées et l’exemple attend une autre touche. Enfin, lorsqu’une touche est enfoncée la fenêtre de console est restaurée à ses dimensions d’origine et l’exemple se termine.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de la propriété <see cref="P:System.Console.WindowWidth" /> ou la valeur de la propriété <see cref="P:System.Console.WindowHeight" /> est inférieure ou égale à 0.  
  
- ou - 
La somme de la valeur de la propriété <see cref="P:System.Console.WindowHeight" /> et de la valeur de la propriété <see cref="P:System.Console.WindowTop" /> est supérieure ou égale à <see cref="F:System.Int16.MaxValue" />.  
  
- ou - 
La valeur de la propriété <see cref="P:System.Console.WindowWidth" /> ou <see cref="P:System.Console.WindowHeight" /> est supérieure à la plus grande largeur ou hauteur de fenêtre possible compte tenu de la police de la console et de la résolution d’écran actuellement définies.</exception>
        <exception cref="T:System.IO.IOException">Erreur de lecture ou d’écriture des informations.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit la représentation textuelle de la ou des valeurs spécifiées dans le flux de sortie standard.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberSignature Language="F#" Value="static member Write : bool -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur booléenne spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, qui génère une <xref:System.Boolean.TrueString?displayProperty=nameWithType> ou <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberSignature Language="F#" Value="static member Write : char -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la valeur du caractère Unicode spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member Write : char[] -&gt; unit" Usage="System.Console.Write buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères Unicode.</param>
        <summary>Écrit le tableau de caractères Unicode spécifié dans le flux de sortie standard.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Write : decimal -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur <see cref="T:System.Decimal" /> spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberSignature Language="F#" Value="static member Write : double -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur à virgule flottante double précision spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberSignature Language="F#" Value="static member Write : int -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière signée 32 bits spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberSignature Language="F#" Value="static member Write : int64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière signée 64 bits spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Int64.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : obj -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire ou <see langword="null" />.</param>
        <summary>Écrit la représentation textuelle de l'objet spécifié dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` est `null`, rien n’est écrit et aucune exception n’est levée. Sinon, le `ToString` méthode `value` est appelée pour produire sa représentation sous forme de chaîne, et la chaîne obtenue est écrite dans le flux de sortie standard.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberSignature Language="F#" Value="static member Write : single -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur à virgule flottante simple précision spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Single.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Write : string -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la valeur de chaîne spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur est `null`, rien n’est écrit dans le flux de sortie standard.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint32 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière non signée 32 bits spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member Write : uint64 -&gt; unit" Usage="System.Console.Write value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière non signée 64 bits spécifiée dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj -&gt; unit" Usage="System.Console.Write (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle de l'objet spécifié dans le flux de sortie standard à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'exemple suivant utilise la méthode `WriteLine` pour montrer les spécificateurs de format standard pour les nombres, les dates et les énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj[] -&gt; unit" Usage="System.Console.Write (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg">Tableau d’objets à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle du tableau d'objets spécifiés dans le flux de sortie standard à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Le `arg` paramètre est un tableau de paramètres. Arguments peuvent être passés à la méthode sous la forme d’un tableau ou liste d’éléments de cinq ou plus. Les exemples illustrent les deux formes d’appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant définit un `Person` classe avec un nombre de propriétés qui fournissent des informations relatives à un individu. Son `GetDescription` méthode retourne un tableau qui contient toutes les valeurs de propriété, sauf une. L’exemple utilise ensuite le tableau retourné par la `GetDescription` méthode pour afficher les valeurs de l’objet Person.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Notez que l’exemple appelle la <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> méthode plutôt que la <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> (méthode), car elle tente d’afficher la valeur de la `Person.Remarks` propriété sur la même ligne. Pour ce faire, il examine la valeur de la <xref:System.Console.CursorLeft%2A> et <xref:System.Console.WindowWidth%2A> propriétés pour déterminer si l’espace est suffisant pour la Remarque à ajuster.  S’il existe, il affiche la ligne. Si ce n’est pas le cas, il écrit une ligne, met en retrait de trois espaces et affiche la Remarque.  
  
 L’exemple suivant est identique à la première, sauf qu’il fournit une liste de cinq éléments en tant que le `arg` argument au lieu d’un tableau de paramètres.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="arg" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Cette méthode n’est pas appelée par du code C++. Le compilateur C++ résout les appels à [System.Console.Write](xref:System.Console.Write*) qui incluent une chaîne et une liste de paramètres d’objets quatre ou plus comme un appel à <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Il résout les appels à [System.Console.Write](xref:System.Console.Write*) qui incluent une chaîne et un tableau d’objets comme un appel à <see cref="M:System.Console.Write(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member Write : char[] * int * int -&gt; unit" Usage="System.Console.Write (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères Unicode.</param>
        <param name="index">Position de départ dans <c>buffer</c>.</param>
        <param name="count">Nombre de caractères à écrire.</param>
        <summary>Écrit le sous-tableau de caractères Unicode spécifié dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode écrit `count` caractères en commençant à la position `index` de `buffer` au flux de sortie standard.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> plus <paramref name="count" /> spécifient une position qui ne se trouve pas dans <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés dans le flux de sortie standard à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'exemple suivant utilise la méthode `WriteLine` pour montrer les spécificateurs de format standard pour les nombres, les dates et les énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg2">Troisième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés dans le flux de sortie standard à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L'exemple suivant utilise la méthode `WriteLine` pour montrer les spécificateurs de format standard pour les nombres, les dates et les énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L'exemple suivant illustre l'utilisation de la méthode `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Write : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.Write (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg2">Troisième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg3">Quatrième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés et la liste des paramètres de longueur variable dans le flux de sortie standard à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette API n'est pas conforme CLS. L’alternative conforme CLS est <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Les compilateurs c# et Visual Basic résoudre automatiquement un appel à cette méthode comme un appel à <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de paramètres de variables avec le <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> (méthode). La méthode est appelée avec une chaîne de format composite et cinq éléments de format.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Cette méthode est marquée avec le <see langword="vararg" /> mot clé, ce qui signifie qu’il prend en charge un nombre variable de paramètres. La méthode peut être appelée à partir de Visual C++, mais il ne peut pas être appelée à partir du code c# ou Visual Basic. Les compilateurs c# et Visual Basic résolvent les appels aux <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> comme des appels à <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Écrit les données spécifiées suivies du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le terminateur de ligne par défaut est une chaîne dont la valeur est un retour chariot suivi d’un saut de ligne (« \r\n » en c#, ou `vbCrLf` en Visual Basic). Vous pouvez modifier la marque de fin de ligne en définissant le <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriété de la <xref:System.Console.Out%2A> propriété vers une autre chaîne.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberSignature Language="F#" Value="static member WriteLine : unit -&gt; unit" Usage="System.Console.WriteLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Écrit le terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le terminateur de ligne par défaut est une chaîne dont la valeur est un retour chariot suivi d’un saut de ligne (« \r\n » en c#, ou `vbCrLf` en Visual Basic). Vous pouvez modifier la marque de fin de ligne en définissant le <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriété de la <xref:System.Console.Out%2A> propriété vers une autre chaîne. Cet exemple en fournit une illustration.  
  
   
  
## Examples  
 L’exemple modifie le terminateur de ligne à partir de sa valeur par défaut de « \r\n » ou `vbCrLf` à « \r\n\r\n » ou `vbCrLf`  +  `vbCrLf`. Il appelle ensuite la <xref:System.Console.WriteLine> et <xref:System.Console.WriteLine%28System.String%29> méthodes pour afficher la sortie à la console.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : bool -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur booléenne spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant génère dix entiers aléatoires et utilise le <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> méthode pour indiquer s’ils sont égaux.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la valeur du caractère Unicode spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] -&gt; unit" Usage="System.Console.WriteLine buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères Unicode.</param>
        <summary>Écrit le tableau de caractères Unicode spécifié suivi du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : decimal -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur <see cref="T:System.Decimal" /> spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : double -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur à virgule flottante double précision spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Double.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière signée 32 bits spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière signée 64 bits spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Int64.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : obj -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de l'objet spécifié suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `value` a la valeur `null`, seule la marque de fin de ligne est écrite. Sinon, le `ToString` méthode `value` est appelée pour produire sa représentation sous forme de chaîne, et la chaîne obtenue est écrite dans le flux de sortie standard.  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Console.WriteLine%28System.Object%29> méthode pour afficher chaque valeur dans un tableau d’objets dans la console.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : single -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur à virgule flottante simple précision spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.Single.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la valeur de chaîne spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la valeur est `null`, seul le terminateur de ligne est écrite dans le flux de sortie standard.  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine> (méthode).  
  
   
  
## Examples  
 L’exemple modifie le terminateur de ligne à partir de sa valeur par défaut de « \r\n » ou `vbCrLf` à « \r\n\r\n » ou `vbCrLf`  +  `vbCrLf`. Il appelle ensuite la <xref:System.Console.WriteLine> et <xref:System.Console.WriteLine%28System.String%29> méthodes pour afficher la sortie à la console.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint32 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière non signée 32 bits spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member WriteLine : uint64 -&gt; unit" Usage="System.Console.WriteLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à écrire.</param>
        <summary>Écrit la représentation textuelle de la valeur entière non signée 64 bits spécifiée suivie du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La représentation textuelle de `value` est créée en appelant le <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle de l'objet spécifié suivie du terminateur de la ligne active dans le flux de sortie standard, à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> méthode pour afficher cinq généré de façon aléatoire <xref:System.Boolean> valeurs.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 L’exemple suivant appelle la <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> méthode pour afficher la date actuelle.   Notez que le format d’élément dans le `format` argument utilise « D » [chaîne de format de date et heure standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) pour afficher la date dans le format de date longue de la culture actuelle.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj[] -&gt; unit" Usage="System.Console.WriteLine (format, arg)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg">Tableau d’objets à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle du tableau d'objets spécifié suivie du terminateur de la ligne active dans le flux de sortie standard, à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L'exemple suivant décrit les spécificateurs de format standard pour les nombres, les dates et énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="arg" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Cette méthode n’est pas appelée par du code C++. Le compilateur C++ résout les appels à [System.Console.WriteLine](xref:System.Console.WriteLine*) qui incluent une chaîne et une liste de paramètres d’objets quatre ou plus comme un appel à <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Il résout les appels à [System.Console.WriteLine](xref:System.Console.WriteLine*) qui incluent une chaîne et un tableau d’objets comme un appel à <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="static member WriteLine : char[] * int * int -&gt; unit" Usage="System.Console.WriteLine (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Tableau de caractères Unicode.</param>
        <param name="index">Position de départ dans <c>buffer</c>.</param>
        <param name="count">Nombre de caractères à écrire.</param>
        <summary>Écrit le sous-tableau de caractères Unicode spécifié suivi du terminateur de la ligne active dans le flux de sortie standard.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode écrit `count` caractères en commençant à la position `index` de `buffer` au flux de sortie standard.  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> plus <paramref name="count" /> spécifient une position qui ne se trouve pas dans <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés suivie du terminateur de la ligne active dans le flux de sortie standard, à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L'exemple suivant décrit les spécificateurs de format standard pour les nombres, les dates et énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg2">Troisième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés suivie du terminateur de la ligne active dans le flux de sortie standard, à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L'exemple suivant décrit les spécificateurs de format standard pour les nombres, les dates et énumérations.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 L’exemple suivant est une calculatrice de conseil qui calcule une info-bulle de 18 % et utilise le <xref:System.Console.WriteLine%2A> méthode pour afficher le montant des frais d’origine, le montant du pourboire et la quantité totale. L’exemple est une application console qui oblige l’utilisateur à fournir le montant des frais d’origine comme un paramètre de ligne de commande.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member WriteLine : string * obj * obj * obj * obj -&gt; unit" Usage="System.Console.WriteLine (format, arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Chaîne de format composite.</param>
        <param name="arg0">Premier objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg1">Deuxième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg2">Troisième objet à écrire à l’aide de <c>format</c>.</param>
        <param name="arg3">Quatrième objet à écrire à l’aide de <c>format</c>.</param>
        <summary>Écrit la représentation textuelle des objets spécifiés et la liste des paramètres de longueur variable suivies du terminateur de la ligne active dans le flux de sortie standard, à l'aide des informations de mise en forme spécifiées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette API n'est pas conforme CLS. L’alternative conforme CLS est <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Les compilateurs c# et Visual Basic résoudre automatiquement un appel à cette méthode comme un appel à <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) du .NET Framework pour convertir la valeur d’un objet en sa représentation sous forme de texte et incorporer cette représentation dans une chaîne. La chaîne obtenue est écrite dans le flux de sortie.  
  
 Le `format` paramètre se compose de zéro ou plusieurs exécutions de texte associées à zéro ou plusieurs espaces réservés indexés, appelés éléments de format qui correspondent à un objet dans la liste de paramètres de cette méthode. Le processus de mise en forme remplace chaque élément de format par la représentation textuelle de la valeur de l’objet correspondant.  
  
 La syntaxe d’un élément de format est `{` *index*[`,`*alignement*] [`:`*formatString*]`}`, qui spécifie un index obligatoire, la longueur facultative et alignement du texte mis en forme et une chaîne facultative de caractères spécificateurs de format qui régissent la façon dont la valeur de l’objet correspondant est mis en forme.  
  
 Le .NET Framework fournit une prise en charge complète de la mise en forme, est décrite plus en détail dans les rubriques suivantes de mise en forme.  
  
-   Pour plus d’informations sur la fonctionnalité de mise en forme composite pris en charge par les méthodes telles que <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>et certaines surcharges de <xref:System.Console.WriteLine%2A>, consultez [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md).  
  
-   Pour plus d’informations sur les spécificateurs de format numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour plus d’informations sur date et l’heure de spécificateurs de format, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour plus d’informations sur les spécificateurs de format d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour plus d’informations sur la mise en forme, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).  
  
 Pour plus d’informations sur le terminateur de ligne, consultez la section Notes de la <xref:System.Console.WriteLine%2A> méthode qui n’accepte aucun paramètre.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation d’arguments variables avec la <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> (méthode). La méthode est appelée avec une chaîne de format composite et cinq éléments de format.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> est <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">La spécification du format dans <paramref name="format" /> n’est pas valide.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour modifier ces sous-fenêtres et les fenêtres de niveau supérieur. Énumération associée : <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Cette méthode est marquée avec le <see langword="vararg" /> mot clé, ce qui signifie qu’il prend en charge un nombre variable de paramètres. La méthode peut être appelée à partir de Visual C++, mais il ne peut pas être appelée à partir du code c# ou Visual Basic. Les compilateurs c# et Visual Basic résolvent les appels aux <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> comme des appels à <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
  </Members>
</Type>