<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="db064d353c67ace9507c584308e2af55606afd7b" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56778548" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente les déclarations de types : types classe, types interface, types tableau, types valeur, types énumération, paramètres de type, définitions de type générique et types génériques construits ouverts ou fermés.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` est la racine de la <xref:System.Reflection> fonctionnalité et constitue le principal moyen d’accéder aux métadonnées. Utiliser les membres de <xref:System.Type> pour obtenir des informations sur une déclaration de type, sur les membres d’un type (par exemple, les constructeurs, méthodes, champs, propriétés et événements d’une classe), ainsi que le module et l’assembly dans lequel la classe est déployée.  
  
 Aucune autorisation n’est requise pour utiliser la réflexion pour obtenir des informations sur les types et leurs membres, indépendamment de leurs niveaux d’accès de code. Aucune autorisation n’est requise pour le code d’utiliser la réflexion pour accéder aux membres publics ou autres membres dont les niveaux d’accès rendre visible pendant la compilation normale. Toutefois, votre code peut utiliser la réflexion pour accéder aux membres qui seraient normalement inaccessibles, tels que les méthodes privées ou internes ou les champs protégés d’un type de votre classe n’hérite pas, votre code doit avoir <xref:System.Security.Permissions.ReflectionPermission>. Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type` est une classe de base abstraite qui permet plusieurs implémentations. Le système fournira toujours la classe dérivée `RuntimeType`. Dans la réflexion, toutes les classes commençant par le mot Runtime sont créés une seule fois par objet dans les opérations de comparaison système et la prise en charge.  
  
> [!NOTE]
>  Dans les scénarios multithread, ne verrouillent pas <xref:System.Type> objets afin de synchroniser l’accès à `static` données. Tout autre code sur laquelle vous n’avez aucun contrôle, pourrait également verrouiller votre type de classe. Cela peut entraîner un blocage. Au lieu de cela, synchroniser l’accès aux données statiques en verrouillant privé `static` objet.  
  
> [!NOTE]
>  Une classe dérivée peut accéder aux membres protégés des classes de base du code appelant. En outre, l’accès est autorisé aux membres de l’assembly de l’assembly du code appelant. En règle générale, si vous êtes autorisé à accéder dans le code à liaison anticipée, puis vous sont également autorisés dans le code à liaison tardive.  
  
> [!NOTE]
>  Les interfaces qui étendent les autres interfaces n’héritent pas les méthodes définies dans les interfaces étendues.  
  
 Dans cette section :  
  
 [Les types représente un objet de Type ?](#WhatTypes)   
 [Récupération d’un objet de Type](#Retrieve)   
 [Comparaison d’égalité des objets de type](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Les types représente un objet de Type ?  
 Cette classe est thread-safe ; plusieurs threads peuvent lire simultanément à partir d’une instance de ce type. Une instance de la <xref:System.Type> classe peut représenter l’un des types suivants :  
  
-   Classes  
  
-   Types de valeur  
  
-   Tableaux  
  
-   Interfaces  
  
-   Énumérations  
  
-   Délégués  
  
-   Types génériques construits et définitions de type générique  
  
-   Arguments de type et les paramètres de type des types génériques construits, les définitions de type générique et les définitions de méthode générique  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Récupération d’un objet de Type  
 Le <xref:System.Type> objet associé à un type particulier peut être obtenu de plusieurs manières :  
  
-   L’instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode retourne un <xref:System.Type> objet qui représente le type d’une instance. Étant donné que tous les types managés dérivent <xref:System.Object>, le <xref:System.Object.GetType%2A> méthode peut être appelée sur une instance de n’importe quel type.  
  
     L’exemple suivant appelle la <xref:System.Object.GetType%2A?displayProperty=nameWithType> méthode pour déterminer le type de runtime de chaque objet dans un tableau d’objets.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   La méthode statique <xref:System.Type.GetType%2A?displayProperty=nameWithType> méthodes retournent un <xref:System.Type> objet qui représente un type spécifié par son nom qualifié complet.  
  
-   Le <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> méthodes retournent `Type` objets qui représentent les types définis dans un module. La première méthode peut être utilisée pour obtenir un tableau de <xref:System.Type> objets pour tous les types publics et privés définis dans un module. (Vous pouvez obtenir une instance de `Module` via la <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> (méthode), ou via le <xref:System.Type.Module%2A?displayProperty=nameWithType> propriété.)  
  
-   Le <xref:System.Reflection.Assembly?displayProperty=nameWithType> objet contient un nombre de méthodes pour récupérer les classes définies dans un assembly, y compris <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, et <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Le <xref:System.Type.FindInterfaces%2A> méthode retourne une liste filtrée des types d’interface pris en charge par un type.  
  
-   Le <xref:System.Type.GetElementType%2A> méthode retourne un `Type` objet qui représente l’élément.  
  
-   Le <xref:System.Type.GetInterfaces%2A> et <xref:System.Type.GetInterface%2A> méthodes retournent <xref:System.Type> objets représentant les types d’interface pris en charge par un type.  
  
-   Le <xref:System.Type.GetTypeArray%2A> méthode retourne un tableau de <xref:System.Type> objets représentant les types spécifiés par un ensemble arbitraire d’objets. Les objets sont spécifiés avec un tableau de type <xref:System.Object>.  
  
-   Le <xref:System.Type.GetTypeFromProgID%2A> et <xref:System.Type.GetTypeFromCLSID%2A> méthodes sont fournies pour l’interopérabilité COM. Elles retournent un <xref:System.Type> objet qui représente le type spécifié par un `ProgID` ou `CLSID`.  
  
-   Le <xref:System.Type.GetTypeFromHandle%2A> méthode est fournie pour l’interopérabilité. Elle retourne un `Type` objet qui représente le type spécifié par un handle de classe.  
  
-   C# `typeof` opérateur, le C++ `typeid` opérateur et Visual Basic `GetType` opérateur obtenir la `Type` objet pour un type.  
  
-   Le <xref:System.Type.MakeGenericType%2A> méthode retourne un <xref:System.Type> objet représentant un type générique construit, qui est un type construit ouvert si sa <xref:System.Type.ContainsGenericParameters%2A> retourne de la propriété `true`, et un fermé type construit de sinon. Un type générique peut être instancié uniquement s’il est fermé.  
  
-   Le <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, et <xref:System.Type.MakeByRefType%2A> méthodes retournent <xref:System.Type> objets qui représentent, respectivement, un tableau d’un type spécifié, un pointeur vers un type spécifié et le type d’un paramètre de référence (`ref` en c#, `ByRef`en Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Comparaison d’égalité des objets de type  
 Un <xref:System.Type> objet que représente un type est unique ; autrement dit, deux <xref:System.Type> références d’objet font référence au même objet si et seulement si elles représentent le même type. Ainsi, pour la comparaison de <xref:System.Type> objets à l’aide de l’égalité de référence. L’exemple suivant compare le <xref:System.Type> objets qui représentent un nombre de valeurs entières pour déterminer si elles sont du même type.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant montre quelques caractéristiques représentatives de <xref:System.Type>. C# `typeof` opérateur (`GetType` opérateur en Visual Basic, `typeid` opérateur dans Visual C++) est utilisée pour obtenir un <xref:System.Type> objet représentant <xref:System.String>. À partir de ce <xref:System.Type> objet, le <xref:System.Type.GetMethod%2A> méthode est utilisée pour obtenir un <xref:System.Reflection.MethodInfo> représentant le <xref:System.String.Substring%2A> surcharge qui accepte un emplacement de départ et une longueur.  
  
 Pour identifier la signature de surcharge, l’exemple de code crée un tableau temporaire contenant deux <xref:System.Type> représentant des objets `int` (`Integer` en Visual Basic).  
  
> [!NOTE]
>  Pour être précis, le tableau contient deux références à l’instance de <xref:System.Type> qui représente `int` dans le domaine d’application actuel. Pour n’importe quel type, il existe une seule instance de <xref:System.Type> par domaine d’application.  
  
 L’exemple de code utilise le <xref:System.Reflection.MethodInfo> pour appeler le <xref:System.String.Substring%2A> méthode sur la chaîne « Hello, World ! » et affiche le résultat.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <block subset="none" type="overrides"><para>Lorsque vous héritez de <see langword="Type" />, vous devez substituer les membres suivants :  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">Affichage des informations de type</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les classes dérivées lors de la construction d’objets de type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Reflection.Assembly" /> dans lequel le type est déclaré. Pour les types génériques, obtient le <see cref="T:System.Reflection.Assembly" /> dans lequel le type générique est défini.</summary>
        <value>Instance de <see cref="T:System.Reflection.Assembly" /> qui décrit l'assembly contenant le type actuel. Pour les types génériques, l'instance décrit l'assembly qui contient la définition de type générique, et non pas l'assembly qui crée et utilise un type construit particulier.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> objet représente un type générique construit, cette propriété retourne l’assembly qui contient la définition de type générique. Par exemple, supposons que vous créez un assembly nommé MyGenerics.dll, qui contient la définition de type générique `MyGenericStack<T>` (`MyGenericStack(Of T)` en Visual Basic, `generic<T> ref class MyGenericStack` dans C++). Si vous créez une instance de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` en Visual Basic) dans un autre assembly, le <xref:System.Type.Assembly%2A> propriété pour le type construit retourne un <xref:System.Reflection.Assembly> objet qui représente MyGenerics.dll.  
  
 De même, si actuel <xref:System.Type> objet représente un paramètre générique non assigné `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.  
  
 Si le <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriété n’est pas disponible sur une implémentation particulière de .NET, telles que .NET Core ou de la plateforme Windows universelle, utilisez le <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriété à la place.      
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom qualifié d'assembly du type, y compris le nom de l'assembly à partir duquel l'objet <see cref="T:System.Type" /> a été chargé.</summary>
        <value>Le nom qualifié d'assembly du <see cref="T:System.Type" />, qui inclut le nom de l'assembly à partir duquel le <see cref="T:System.Type" /> a été chargé ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom qualifié d’assembly d’un type se compose du nom de type, y compris son espace de noms, suivi par une virgule, suivie du nom d’affichage de l’assembly. Le nom complet d’un assembly est obtenu en utilisant le <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Consultez <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Tous les compilateurs qui prennent en charge le common language runtime émettent le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogées, conformément aux conventions suivantes.  
  
|Délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Signe plus (+)|Précède une classe imbriquée.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Crochets ([])|Après un nom de type, indique un tableau de ce type.<br /><br /> ou<br /><br /> Pour un type générique, englobe la liste d’arguments de type générique.<br /><br /> ou<br /><br /> Dans une liste d’arguments de type, englobe un type qualifié d’assembly.|  
  
 Par exemple, le nom qualifié d’assembly pour une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Si l’espace de noms contenait un signe plus, par exemple TopNamespace, puis le signe plus (+) serait précédé d’un caractère d’échappement (\\) pour éviter qu’il soit interprété comme un séparateur d’imbrication. Réflexion émettrait cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Les noms de type peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces sont pertinents dans tous les composants de nom de type autre que le nom de l’assembly. Nom de l’assembly, espaces avant le séparateur ',', mais les espaces après le séparateur ',' sont ignorés.  
  
 Les arguments génériques de types génériques sont eux-mêmes qualifiés par le nom de l’assembly. Par exemple, dans le nom de type qualifié d’assembly pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic), `int` est développé pour le nom de type qualifié d’assembly pour <xref:System.Int32>.  
  
 Si actuel <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’assembly associé à la classe et le nom qualifié complet du type.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les attributs associés à <see cref="T:System.Type" />.</summary>
        <value>Objet <see cref="T:System.Reflection.TypeAttributes" /> qui représente l'ensemble d'attributs du <see cref="T:System.Type" />, à moins que le <see cref="T:System.Type" /> représente un paramètre de type générique, cas dans lequel la valeur est non spécifiée.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains membres de la <xref:System.Reflection.TypeAttributes> énumération sont masques qui représentent un groupe de valeurs. Chaque groupe comprend un membre dont la valeur sous-jacente est égal à zéro. Par exemple, la valeur sous-jacente de la <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> groupe est égal à zéro, car est le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> membre dans le <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> groupe. Pour cette raison, vous devez utiliser le masque avant de tester ces valeurs. Cet exemple en fournit une illustration.  
  
> [!TIP]
>  La plupart des cas, les propriétés telles que <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, et <xref:System.Type.IsSpecialName%2A> sont plus faciles à utiliser que les attributs de type.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété retourne les attributs de la définition de type générique. Par exemple, les attributs retournés pour `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic) sont les attributs de `MyGenericClass<T>` (`MyGenericClass(Of T)` en Visual Basic).  
  
 Si actuel <xref:System.Type> représente un paramètre de type générique - autrement dit, si le <xref:System.Type.IsGenericParameter%2A> retourne de la propriété `true` - le <xref:System.Reflection.TypeAttributes> valeur retournée par cette propriété n’est pas spécifié.  
  
   
  
## Examples  
 L’option de l’exemple suivant <xref:System.Type.Attributes%2A> propriété.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type dont le <see cref="T:System.Type" /> actuel hérite directement.</summary>
        <value><see cref="T:System.Type" /> dont le <see cref="T:System.Type" /> actuel hérite directement ou <see langword="null" /> si le <see langword="Type" /> actuel représente la classe <see cref="T:System.Object" /> ou une interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de base est le type à partir duquel le type actuel hérite directement. <xref:System.Object> est le seul type qui n’a pas un type de base, par conséquent `null` est retourné en tant que type de base de <xref:System.Object>.  
  
 Les interfaces hériter de zéro ou plusieurs interfaces de base ; Par conséquent, cette propriété retourne `null` si le `Type` objet représente une interface. Les interfaces de base peuvent être déterminés avec <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.  
  
 Si actuel <xref:System.Type> représente un type générique construit, le type de base reflète les arguments génériques. Observez, par exemple, les déclarations suivantes :  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Pour le type construit `C<int>` (`C(Of Integer)` en Visual Basic), la <xref:System.Type.BaseType%2A> retourne de la propriété `B<int>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’une définition de type générique, <xref:System.Type.BaseType%2A> retourne la contrainte de classe, autrement dit, la classe que le paramètre de type doit hériter. S’il n’existe aucune contrainte de classe, <xref:System.Type.BaseType%2A> retourne <xref:System.Object?displayProperty=nameWithType>.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Type.BaseType%2A> propriété.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 L’exemple suivant utilise la récursivité pour afficher la hiérarchie d’héritage complète de chaque classe trouvé dans un assembly. L’exemple définit une classe nommée `C` qui dérive d’une classe nommée `B`, qui, à son tour, dérive une classe nommée `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'objet <see cref="T:System.Type" /> actuel a des paramètres de type qui n'ont pas été remplacés par des types spécifiques.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Type" /> est lui-même un paramètre de type générique ou a des paramètres de type pour lesquels les types spécifiques n'ont pas été fournis ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour créer une instance d’un type, il doit ne pas les définitions de type générique ou les types construits ouverts dans les arguments de type du type lui-même, dans les types génériques englobants, ou dans tous les éléments du type. Est une autre façon de dire ce que quand examinée de manière récursive, le type ne doit contenir aucun paramètre de type générique.  
  
 Dans la mesure où les types peuvent être arbitrairement complexes, il est difficile de cette décision. Pour plus de commodité et pour réduire le risque d’erreur, le <xref:System.Type.ContainsGenericParameters%2A> propriété offre un moyen standard de faire la distinction entre les types construits fermés, qui peuvent être instanciés, et open construit des types qui ne peuvent pas. Si le <xref:System.Type.ContainsGenericParameters%2A> retourne de la propriété `true`, le type ne peut pas être instancié.  
  
 Le <xref:System.Type.ContainsGenericParameters%2A> propriété recherche de manière récursive pour les paramètres de type. Par exemple, elle retourne `true` pour un tableau dont les éléments sont de type `A<T>` (`A(Of T)` en Visual Basic), même si le tableau n’est pas générique. Comparez ceci avec le comportement de la <xref:System.Type.IsGenericType%2A> propriété, qui retourne `false` pour les tableaux.  
  
 Pour un ensemble de classes d’exemple et un tableau indiquant les valeurs de la <xref:System.Type.ContainsGenericParameters%2A> propriété, consultez <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit une classe générique avec deux paramètres de type et définit ensuite une deuxième classe générique qui dérive de la première classe. Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32> et le second est un paramètre de type du type dérivé. L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Reflection.MethodBase" /> représentant la méthode de déclaration, si le <see cref="T:System.Type" /> actuel représente un paramètre de type d’une méthode générique.</summary>
        <value>Si le <see cref="T:System.Type" /> actuel représente un paramètre de type d’une méthode générique, <see cref="T:System.Reflection.MethodBase" /> qui représente la méthode de déclaration ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode de déclaration est une définition de méthode générique. Autrement dit, si <xref:System.Type.DeclaringMethod%2A> ne retourne pas `null`, puis `DeclaringMethod.IsGenericMethodDefinition` retourne `true`.  
  
 Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type générique ou la définition de méthode générique dans lequel le paramètre de type générique a été défini à l’origine :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> retourne de la propriété `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type de ce type générique définition.  
  
-   Obtention de la <xref:System.Type.DeclaringMethod%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété est `false` lève une <xref:System.InvalidOperationException>.  
  
 Le <xref:System.Reflection.MethodBase> qui est retourné par la <xref:System.Type.DeclaringMethod%2A> propriété est un <xref:System.Reflection.MethodInfo> dans le cas d’une méthode générique, ou un <xref:System.Reflection.ConstructorInfo> dans le cas d’un constructeur générique.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, les constructeurs génériques ne sont pas pris en charge.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit une classe qui possède une méthode générique, assigne un argument de type à la méthode et appelle la méthode générique construite résultante. Elle affiche également des informations sur la définition de méthode générique et la méthode construite. Lors de l’affichage d’informations sur les paramètres de type de la définition de méthode générique, dans le `DisplayGenericMethodInfo` (méthode), l’exemple de code affiche la valeur de la <xref:System.Type.DeclaringMethod%2A> propriété pour le paramètre de type générique de la méthode.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type qui déclare le type imbriqué ou paramètre de type générique actuel.</summary>
        <value>Objet <see cref="T:System.Type" /> représentant le type englobant, si le type actuel est un type imbriqué ; ou définition du type générique, si le type actuel est un paramètre de type d'un type générique ; ou type qui déclare la méthode générique, si le type actuel est un paramètre de type d'une méthode générique ; sinon, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> objet représente un paramètre de type d’un type générique, cette propriété retourne la définition de type générique.  
  
 Si actuel <xref:System.Type> objet représente un paramètre de type d’une méthode générique, cette propriété retourne le type qui contient la définition de méthode générique. Si le type est générique, la définition de type générique est retournée. Autrement dit, le code suivant retourne la définition de type générique de la <xref:System.Collections.Generic.List%601> classe générique, qui contient le <xref:System.Collections.Generic.List%601.ConvertAll%2A> méthode générique :  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, la <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type générique ou la définition de méthode générique où la paramètre de type générique a été initialement définie :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> retourne de la propriété `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type de ce type générique définition.  
  
-   Obtention de la <xref:System.Type.DeclaringType%2A> propriété sur un type dont <xref:System.Type.IsGenericParameter%2A> propriété est `false` lève une <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Cet exemple affiche le type déclarant d’une méthode dans une classe dérivée.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une référence au binder par défaut, qui implémente les règles internes pour la sélection des membres appropriés appelés par <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Référence au binder par défaut utilisé par le système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le binder par défaut fourni avec le common language runtime est applicable dans tous les cas plus spécifiques. Si vous avez besoin d’un binder qui applique des règles différentes de celles du binder par défaut fournie, qui définissent un type dérivé le <xref:System.Reflection.Binder> classe et passer une instance de ce type à l’aide de la `binder` paramètre d’un de la <xref:System.Type.InvokeMember%2A> surcharges.  
  
 La réflexion modélise les règles d’accessibilité du système de type commun. Par exemple, si l’appelant est dans le même assembly, l’appelant n’a besoin pas des autorisations spéciales pour les membres internes. Sinon, l’appelant doit <xref:System.Security.Permissions.ReflectionPermission>. Cela est cohérent avec la recherche de membres qui sont protégées, privées et ainsi de suite.  
  
 Le principe général est que <xref:System.Reflection.Binder.ChangeType%2A> doit effectuer que des conversions étendues, qui ne perdent jamais de données. La conversion d’une valeur qui est un entier signé 32 bits à une valeur qui est un entier signé 64 bits est un exemple de conversion étendue. Elle se distingue d’une conversion restrictive, ce qui peut perdre des données. Un exemple d’une conversion restrictive convertit un entier signé 64 bits à un entier signé 32 bits.  
  
 Le tableau suivant répertorie les conversions prises en charge par le binder par défaut.  
  
|Type de source|Type de cible|  
|-----------------|-----------------|  
|Tout type|Son type de base.|  
|Tout type|L’interface qu’elle implémente.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Non-reference|Par référence.|  
  
   
  
## Examples  
 L’exemple suivant obtient le binder par défaut à partir de la `DefaultBinder` propriété et appelle un membre de MyClass en passant la `DefaultBinder` valeur en tant que paramètre à <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sépare les noms dans l'espace de noms de <see cref="T:System.Type" />. Ce champ est en lecture seule.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente un tableau vide du type <see cref="T:System.Type" />. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant montre l’exemple le `EmptyTypes` champ utilisé dans un de le `GetConstructor` méthodes pour obtenir un constructeur qui n’accepte aucun paramètre.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le type de système sous-jacent du <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Object" /> ou <see cref="T:System.Type" /> spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objet dont le type de système sous-jacent doit être comparé au type de système sous-jacent du <see cref="T:System.Type" /> actuel. Pour que la comparaison puisse être effectuée, <paramref name="o" /> doit pouvoir être casté ou converti en un objet de type <see cref="T:System.Type" />.</param>
        <summary>Détermine si le type de système sous-jacent de l’objet <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Object" /> spécifié.</summary>
        <returns><see langword="true" /> si le type de système sous-jacent de <paramref name="o" /> est identique au type de système sous-jacent du <see cref="T:System.Type" /> actuel ; sinon, <see langword="false" />. Cette méthode retourne également <see langword="false" /> si :  
  
-   <paramref name="o" /> a la valeur <see langword="null" />.  
  
-   <paramref name="o" /> ne peut pas être casté ou converti en objet <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Elle convertit `o` à un objet de type <xref:System.Type> et appelle le <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Type.Equals%28System.Object%29> pour comparer différents <xref:System.Type> instances avec différents d’objet <xref:System.Object> instances.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Deux choses sont particulièrement important de noter à propos de l’exemple :  
  
-   La comparaison d’un <xref:System.Type> objet qui représente un entier avec une <xref:System.Reflection.TypeInfo> objet qui représente un entier retour `true` , car <xref:System.Reflection.TypeInfo> est dérivée de <xref:System.Type>.  
  
-   La comparaison d’un <xref:System.Type> objet qui représente un <xref:System.Collections.Generic.IList%601> objet (un type générique ouvert) avec un `List(Of String)` objet (un type générique fermé) retourne `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Objet dont le type de système sous-jacent doit être comparé au type de système sous-jacent du <see cref="T:System.Type" /> actuel.</param>
        <summary>Détermine si le type de système sous-jacent du <see cref="T:System.Type" /> actuel est identique au type de système sous-jacent du <see cref="T:System.Type" /> spécifié.</summary>
        <returns><see langword="true" /> si le type de système sous-jacent de <paramref name="o" /> est identique au type de système sous-jacent du <see cref="T:System.Type" /> actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant utilise `Equals` pour comparer deux types.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le filtre de membres utilisé avec les attributs. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` peut avoir la valeur de l’un des champs sur les classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.  
  
 Par exemple, le `Object` peut avoir la valeur d’un champ de `FieldAttributes` comme Public. Dans ce cas, lorsque le `FilterAttribute` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet est décoré avec l’attribut de champ public dans les métadonnées.  
  
   
  
## Examples  
 L’exemple suivant obtient le `FilterAttribute` le délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les membres spécifiés et leurs attributs.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le filtre de membres, avec respect de la casse, utilisé sur les noms. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` est affectée une valeur de chaîne, ce qui peut se terminer par un « * » caractère générique. Seule fin chaîne caractères génériques est prise en charge.  
  
 Par exemple, le `Object` peut avoir la valeur « Octets * ». Dans ce cas, lorsque le `FilterName` délégué est appelé, elle retournera `true` uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « Byte ».  
  
   
  
## Examples  
 L’exemple de code suivant obtient les méthodes associées défini par l’utilisateur `Application` type.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente le filtre de membres, sans respect de la casse, utilisé sur les noms. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce champ conserve une référence au délégué utilisé par le <xref:System.Type.FindMembers%2A> (méthode). La méthode encapsulée par ce délégué prend deux paramètres : le premier est un <xref:System.Reflection.MemberInfo> objet et le second est un `Object`. La méthode détermine si le `MemberInfo` objet correspond aux critères spécifiés par le `Object`. Le `Object` est affectée une valeur de chaîne, ce qui peut se terminer par un « * » caractère générique. Seule fin chaîne caractères génériques est prise en charge.  
  
 Par exemple, le `Object` peut avoir la valeur « Octets * ». Dans ce cas, lorsque le `FilterName` délégué est appelé, il retourne true uniquement si la méthode représentée par le `MemberInfo` objet a un nom qui commence par « byte », indépendamment de la casse.  
  
   
  
## Examples  
 L’exemple suivant obtient le `MemberFilter` le délégué, il passe en tant que paramètre à la <xref:System.Type.FindMembers%2A> (méthode) et affiche les méthodes et leurs attributs de la `String` classe qui commencent par la lettre « c », en ignorant la casse.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">Délégué qui compare les interfaces à <paramref name="filterCriteria" />.</param>
        <param name="filterCriteria">Critère de recherche qui détermine si une interface doit être incluse dans le tableau retourné.</param>
        <summary>Retourne un tableau d'objets <see cref="T:System.Type" /> représentant une liste filtrée d'interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.</summary>
        <returns>Un tableau d'objets <see cref="T:System.Type" /> qui représente une liste filtrée des interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel ou un tableau vide de type <see cref="T:System.Type" /> si aucune interface correspondant au filtre n'est implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Le <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> et <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> délégués fournie par le <xref:System.Reflection.Module?displayProperty=nameWithType> classe peut également être utilisée, à la place du <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> déléguer.  
  
 Toutes les interfaces implémentées par cette classe sont considérés comme lors de la recherche, si déclaré par une classe de base ou de cette classe lui-même.  
  
 Cette méthode recherche dans la hiérarchie de classe de base, retournant chacune des interfaces correspondantes de chaque classe implémente, ainsi que toutes les correspondances des interfaces chacun de ces implémente les interfaces (autrement dit, la fermeture transitive des interfaces correspondantes est retournée). Aucune interface en double n’est retournés.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces déclarées dans les contraintes sur le paramètre de type, et toutes les interfaces héritent via les interfaces déclarées dans les contraintes. Si actuel <xref:System.Type> représente un argument de type d’un type générique, <xref:System.Type.FindInterfaces%2A> recherche toutes les interfaces implémentées par le type, s’ils correspondent aux contraintes.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> peut retourner des interfaces génériques, même sur des types qui ne sont pas génériques. Par exemple, un type non générique peut implémenter `IEnumerable<int>` (`IEnumerable(Of Integer)` en Visual Basic).  
  
   
  
## Examples  
 L’exemple suivant recherche l’interface spécifiée implémentée ou héritée par le type spécifié, puis affiche les noms d’interface.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Objet qui indique le type du membre à rechercher.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="filter">Délégué qui effectue les comparaisons, retournant <see langword="true" /> si le membre en cours d'inspection correspond à <paramref name="filterCriteria" /> et <see langword="false" /> dans le cas contraire. Vous pouvez utiliser les délégués <see langword="FilterAttribute" />, <see langword="FilterName" /> et <see langword="FilterNameIgnoreCase" /> fournis par cette classe. Le premier délégué utilise les champs de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> et <see langword="MethodImplAttributes" /> comme critère de recherche et les deux autres utilisent les objets <see langword="String" />.</param>
        <param name="filterCriteria">Critère de recherche qui détermine si un membre est retourné dans le tableau d'objets <see langword="MemberInfo" />.  
  
Les champs de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> et <see langword="MethodImplAttributes" /> peuvent être utilisés conjointement au délégué <see langword="FilterAttribute" /> fourni par cette classe.</param>
        <summary>Retourne un tableau filtré d'objets <see cref="T:System.Reflection.MemberInfo" /> du type du membre spécifié.</summary>
        <returns>Tableau filtré d'objets <see cref="T:System.Reflection.MemberInfo" /> du type du membre spécifié.  
  
ou 
Tableau vide de type <see cref="T:System.Reflection.MemberInfo" />, si le <see cref="T:System.Type" /> actuel n'a pas de membres de type <paramref name="memberType" /> qui correspondent aux critères de filtre.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Instance` pour inclure les membres d’instance dans la recherche.  
  
-   Spécifiez `BindingFlags.Static` pour inclure les membres statiques dans la recherche.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Les valeurs valides pour <xref:System.Type.MemberType%2A> sont définis dans <xref:System.Reflection.MemberInfo>. Si aucun membre n’est trouvé, un tableau vide est retourné.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique ou une méthode générique, <xref:System.Type.FindMembers%2A> traite tous les membres déclarés par la contrainte de classe et les contraintes d’interface du paramètre de type.  
  
   
  
## Examples  
 L’exemple suivant recherche tous les membres dans une classe qui correspondent aux critères de recherche spécifiés, puis affiche les membres correspondants.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom qualifié complet du type, y compris son espace de noms, mais pas l'assembly.</summary>
        <value>Nom qualifié complet du type, y compris son espace de noms, mais sans l'assembly ; ou <see langword="null" /> si l'instance actuelle représente un paramètre de type générique, un type de tableau, un type pointeur, un type <see langword="byref" /> reposant sur un paramètre de type ou un type générique qui n'est pas une définition de type générique mais contient des paramètres de type non résolus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, le nom qualifié complet de le <xref:System.String> est de type `System.String`. Comparez ceci avec le nom qualifié d’assembly retourné par la <xref:System.Type.AssemblyQualifiedName%2A> propriété constitué du nom complet et le nom complet de l’assembly.  
  
 Si le type actuel représente un type générique fermé, les arguments de type dans la chaîne retournée par la <xref:System.Type.FullName%2A> propriété sont qualifiés par leur nom complet de l’assembly, même si la représentation sous forme de chaîne du type générique lui-même n’est pas qualifiée par son intégral nom de l’assembly. L’exemple suivant illustre la différence dans la propriété FullName de type qui représente la définition de type générique qui représente un type générique fermé.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Cette propriété retourne `null` si :  
  
-   Actuel <xref:System.Type> objet représente un paramètre de type d’un type générique.  
  
     L’exemple suivant récupère le paramètre de type de la <xref:System.Nullable%601> type et tente d’afficher son <xref:System.Type.FullName%2A> propriété.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Actuel <xref:System.Type> objet représente un type de tableau, un type pointeur, ou un `byref` type qui est basé sur un paramètre de type générique.  
  
     L’exemple suivant définit un type générique, `Generictype1<T>`, avec trois méthodes : `Display(T[])`, qui est transmis à un tableau de type T ; `HandleT(T)`, qui est transmis à un objet T ; et `ChangeValue(ref T)`, un objet de T qui est passé par référence. Étant donné que c# et Visual Basic ne permettent pas nous pouvons T en tant que pointeur dans la `HandleT` (méthode), nous devons appeler le <xref:System.Type.MakePointerType%2A> méthode sur le <xref:System.Type> objet qui représente le type de paramètre pour créer un pointeur vers un type générique. La sortie de l’exemple montre que dans les trois cas, le <xref:System.Type.FullName%2A> propriété est `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Le type actuel contient des paramètres de type générique qui n’ont pas été remplacés par des types spécifiques (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> retourne de la propriété `true`), mais le type n’est pas une définition de type générique (autrement dit, le <xref:System.Type.IsGenericTypeDefinition%2A> retourne de propriété `false`  
  
     Dans l’exemple suivant, `Derived<T>` hérite `Base<T>`. Le <xref:System.Type.BaseType%2A> propriété obtient le <xref:System.Type> objet qui représente le type de base de `Derived<T>`et son <xref:System.Type.FullName%2A> retourne de la propriété `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Pour obtenir un <xref:System.Type.FullName%2A> qui n’est pas `null`, vous pouvez utiliser la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir la définition de type générique, comme l’illustre l’exemple.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom complet du type spécifié.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une combinaison d'indicateurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrivent la covariance et des contraintes spéciales du paramètre de type générique actuel.</summary>
        <value>Combinaison d'opérations de bits de valeurs <see cref="T:System.Reflection.GenericParameterAttributes" /> qui décrit la covariance et les contraintes spéciales du paramètre de type générique actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété contient des indicateurs qui décrivent si le paramètre de type générique actuel est covariant et les indicateurs qui décrivent toutes les contraintes spéciales. Utiliser le <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> pour sélectionner les indicateurs de covariance et utilisez le <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valeur pour sélectionner les indicateurs de contrainte.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes. Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L’objet <see cref="T:System.Type" /> actuel n’est pas un paramètre de type générique. Autrement dit, la propriété <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la position du paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a déclaré le paramètre, quand l'objet <see cref="T:System.Type" /> représente un paramètre de type d'un type générique ou une méthode générique.</summary>
        <value>Position d'un paramètre de type dans la liste des paramètres de type du type générique ou de la méthode qui a défini le paramètre. La numérotation des positions commence à zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GenericParameterPosition%2A> propriété retourne la position d’un paramètre de type dans la liste des paramètres de la définition de type générique ou de la définition de méthode générique où le paramètre de type a été initialement défini. Le <xref:System.Type.DeclaringType%2A> et <xref:System.Type.DeclaringMethod%2A> propriétés identifient la définition de type ou de méthode générique :  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> propriété retourne un <xref:System.Reflection.MethodInfo>, qui <xref:System.Reflection.MethodInfo> représente une définition de méthode générique et en cours <xref:System.Type> objet représente un paramètre de type de cette définition de méthode générique.  
  
-   Si le <xref:System.Type.DeclaringMethod%2A> retourne de la propriété `null`, puis le <xref:System.Type.DeclaringType%2A> propriété retourne toujours un <xref:System.Type> objet représentant une définition de type générique et en cours <xref:System.Type> objet représente un paramètre de type de ce type générique définition.  
  
 Pour fournir le contexte correct pour la valeur de la <xref:System.Type.GenericParameterPosition%2A> propriété, il est nécessaire identifier le type générique ou la méthode un paramètre de type appartient. Par exemple, considérez la valeur de retour de la méthode générique `GetSomething` dans le code suivant :  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Le type retourné par `GetSomething` varie selon les arguments de type fournis à la classe `A` et `GetSomething` lui-même. Vous pouvez obtenir un <xref:System.Reflection.MethodInfo> pour `GetSomething`, et à partir de là, vous pouvez obtenir le type de retour. Lorsque vous examinez les paramètres de type du type de retour, <xref:System.Type.GenericParameterPosition%2A> retourne 0 pour les deux. La position de `V` est 0 car `V` est le premier paramètre de type dans la liste de paramètres de type pour la classe `A`. La position de `X` est 0 car `X` est le premier paramètre de type dans la liste de paramètres de type `GetSomething`.  
  
> [!NOTE]
>  Appel de la <xref:System.Type.GenericParameterPosition%2A> propriété provoque une exception si actuel <xref:System.Type> ne représente pas un paramètre de type. Lorsque vous examinez les arguments de type d’un type construit ouvert, utilisez la <xref:System.Type.IsGenericParameter%2A> propriété pour indiquer à qui sont des paramètres de type et les types. Le <xref:System.Type.IsGenericParameter%2A> retourne de la propriété `true` pour un paramètre de type ; vous pouvez ensuite utiliser le <xref:System.Type.GenericParameterPosition%2A> méthode permet d’obtenir sa position et la <xref:System.Type.DeclaringMethod%2A> et <xref:System.Type.DeclaringType%2A> propriétés pour déterminer la méthode générique ou de définition qui le définit de type .  
  
   
  
## Examples  
 L’exemple suivant définit une classe générique avec deux paramètres de type et une deuxième classe générique qui dérive de la première classe. Classe de base de la classe dérivée a deux arguments de type : le premier est <xref:System.Int32>, et le second est un paramètre de type du type dérivé. L’exemple affiche des informations sur ces classes génériques, y compris les positions rapportées par le <xref:System.Type.GenericParameterPosition%2A> propriété.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type actuel ne représente pas un paramètre de type. Autrement dit, <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un tableau des arguments de type générique pour ce type.</summary>
        <value>Tableau des arguments de type générique pour ce type.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété obtient uniquement les arguments de type générique ; Autrement dit, les types qui ont été spécifiées pour les paramètres de type générique du type actuel. Si le type actuel est une définition de type générique, cette propriété retourne un tableau vide.  
  
> [!NOTE]
>  Si un type générique est utilisé dans une méthode générique ou dans un autre type générique, certaines de ses arguments de type générique peuvent être des paramètres de type générique de la méthode ou le type englobant.  
  
 Pour obtenir les paramètres de type générique d’un type qui représente une définition de type générique, utilisez le <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriété. Pour obtenir un <xref:System.Reflection.TypeInfo> objet actif <xref:System.Type> de l’objet, utilisez le <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> méthode d’extension.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le nombre de dimensions dans un tableau.</summary>
        <returns>Entier comportant le nombre de dimensions figurant dans le type actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le nombre de dimensions dans un tableau.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La fonctionnalité de cette méthode n’est pas prise en charge dans la classe de base et doit être implémentée dans une classe dérivée à la place.</exception>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas un tableau.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.Attributes" /> et obtient un masque de bits indiquant les attributs associés à <see cref="T:System.Type" />.</summary>
        <returns>Objet <see cref="T:System.Reflection.TypeAttributes" /> qui représente l'ensemble des attributs de <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un constructeur spécifique du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur souhaité.  
  
ou 
Tableau vide d'objets <see cref="T:System.Type" /> pour obtenir un constructeur n'acceptant aucun paramètre. Un tel tableau vide est fourni par le champ <see langword="static" /><see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Recherche un constructeur d'instance public dont les paramètres correspondent aux types contenus dans le tableau spécifié.</summary>
        <returns>Objet représentant le constructeur d'instance public dont les paramètres correspondent aux types contenus dans le tableau de types de paramètres, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode recherche des constructeurs d’instance publics et ne peut pas être utilisée pour obtenir un initialiseur de classe (.cctor). Pour obtenir un initialiseur de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le constructeur demandé est non public, cette méthode retourne `null`.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de `MyClass`, obtient le <xref:System.Reflection.ConstructorInfo> de l’objet et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.  
  
ou 
Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.  
  
ou 
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau de types de paramètres. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche un constructeur dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 Le programme suivant obtient le type de `MyClass1` classe, obtient le <xref:System.Reflection.ConstructorInfo> de l’objet correspondant aux indicateurs de liaison spécifiées et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objet qui spécifie l’ensemble de règles à utiliser en ce qui concerne l’ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.  
  
ou 
Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche un constructeur dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d’appel indiquées.</summary>
        <returns>Objet représentant le constructeur qui correspond aux exigences spécifiées, s’il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.ConstructorInfo> avec les paramètres de type remplacés par les arguments de type approprié. Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode retourne toujours `null`.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de `MyClass1`, obtient le <xref:System.Reflection.ConstructorInfo> objet qui correspond aux indicateurs de liaison spécifiés et affiche la signature du constructeur.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objet qui spécifie l’ensemble de règles à utiliser en ce qui concerne l’ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres du constructeur à obtenir.  
  
ou 
Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir un constructeur qui ne prend aucun paramètre.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche un constructeur dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés, à l’aide des contraintes de liaison et de la convention d’appel spécifiées.</summary>
        <returns>Objet <see cref="T:System.Reflection.ConstructorInfo" /> qui représente le constructeur correspondant aux critères spécifiés, s'il existe ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Cette méthode implémente <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <exception cref="T:System.NotSupportedException">Le type actuel est <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les constructeurs du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les constructeurs publics définis pour le <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant tous les constructeurs d'instance publics définis pour le <see cref="T:System.Type" /> actuel, sans inclure l'initialiseur de type (constructeur statique). Si aucun constructeur d’instance public n’est défini pour le <see cref="T:System.Type" /> actuel ou si le <see cref="T:System.Type" /> actuel représente un paramètre de type d’une définition de type ou de méthode générique, un tableau vide de type <see cref="T:System.Reflection.ConstructorInfo" /> est retourné.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, comme l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Cette surcharge de méthode appelle la <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> en Visual Basic). Elle ne trouvera pas les initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si actuel <xref:System.Type> représente un paramètre de type générique, le <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.  
  
   
  
## Examples  
 Cet exemple montre la sortie de la <xref:System.Type.GetConstructors%2A> surcharger à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 La sortie de ce code est :  
  
 2  
  
 False  
  
 False  
  
 Étant donné que le <xref:System.Type.GetConstructors> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.  
  
 Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> surcharge et passez la combinaison (logique `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 La sortie est maintenant :  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les constructeurs définis pour le <see cref="T:System.Type" /> actuel, à l'aide du <see langword="BindingFlags" /> spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.ConstructorInfo" /> représentant tous les constructeurs définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées, y compris l'initialiseur de type s'il est défini. Retourne un tableau vide de type <see cref="T:System.Reflection.ConstructorInfo" /> si aucun constructeur n’est défini pour le <see cref="T:System.Type" /> actuel, si aucun des constructeurs définis ne correspond aux contraintes de liaison, ou si le <see cref="T:System.Type" /> actuel représente un paramètre de type d’une définition de type ou de méthode générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetConstructors%2A> méthode ne retourne pas les constructeurs dans un ordre particulier, comme l’ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les constructeurs sont retournés, car cet ordre varie.  
  
 `bindingAttr` peut être utilisé pour spécifier s’il faut retourner uniquement les constructeurs publics ou les constructeurs publics et non publics.  
  
 Si une correspondance exacte n’existe pas, le `binder` va tenter de forcer les types de paramètre spécifiés dans le `types` tableau afin de sélectionner une correspondance. Si le `binder` ne parvient pas à sélectionner une correspondance, puis `null` est retourné.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les constructeurs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les constructeurs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des constructeurs non publics (autrement dit, les constructeurs privés, internes et protégés) dans la recherche. Constructeurs de classes de base ne sont pas retournés.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.ConstructorInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` a un constructeur `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), l’appel <xref:System.Type.GetConstructors%2A> sur `C<int>` retourne un <xref:System.Reflection.ConstructorInfo> représentant `C(int t1)` en c# (`Sub New(ByVal t1 As Integer)` en Visual Basic).  
  
 Si actuel <xref:System.Type> représente un paramètre de type générique, le <xref:System.Type.GetConstructors%2A> méthode retourne un tableau vide.  
  
   
  
## Examples  
 Cet exemple montre la sortie de la <xref:System.Type.GetConstructors> surcharger à partir d’une classe qui possède deux constructeurs d’instance et un constructeur statique.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 La sortie de ce code est :  
  
 2  
  
 False  
  
 False  
  
 Étant donné que le <xref:System.Type.GetConstructors%2A> surcharge utilise uniquement <xref:System.Reflection.BindingFlags.Public> et <xref:System.Reflection.BindingFlags.Instance>, le constructeur statique n’est ni compté par le `for` expression ni évalué par `IsStatic`.  
  
 Pour rechercher des constructeurs statiques, utilisez le <xref:System.Type.GetConstructors%2A> surcharge et passez la combinaison (OR logique) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, comme illustré dans l’exemple de code suivant :  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 La sortie est maintenant :  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recherche les membres définis pour le <see cref="T:System.Type" /> actuel dont le <see cref="T:System.Reflection.DefaultMemberAttribute" /> est défini.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres par défaut du <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de membres par défaut.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetDefaultMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié. Par exemple, si classe `C<T>` possède une propriété `P` qui retourne `T`, l’appel <xref:System.Type.GetDefaultMembers%2A> sur `C<int>` retourne `int P` en c# (`Property P As Integer` en Visual Basic).  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient les informations de membre par défaut de `MyClass` et affiche les membres par défaut.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, retourne le <see cref="T:System.Type" /> de l'objet englobé ou de l'objet auquel le tableau, pointeur ou type référence actuel fait référence.</summary>
        <returns><see cref="T:System.Type" /> de l’objet englobé ou auquel le tableau, pointeur ou type référence actuel fait référence, ou <see langword="null" /> si le <see cref="T:System.Type" /> actuel n’est pas un tableau ou un pointeur, ou n’est pas passé par référence ou représente un type générique ou un paramètre de type dans la définition d’un type ou d’une méthode générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `null` pour la <xref:System.Array> classe.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `GetElementType` (méthode).  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur dont le nom doit être récupéré.</param>
        <summary>Retourne le nom de la constante qui a la valeur spécifiée, pour le type énumération actuel.</summary>
        <returns>Nom du membre du type énumération actuel qui a la valeur spécifiée, ou <see langword="null" /> si une telle constante est introuvable.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas une énumération.  
  
ou 
 <paramref name="value" /> n’est pas du type actuel et n’a pas le même type sous-jacent que le type actuel.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les noms des membres du type énumération actuel.</summary>
        <returns>Tableau qui contient les noms des membres de l'énumération.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments du tableau de valeur de retour sont triés par les valeurs binaires (autrement dit, les valeurs non signées) des constantes énumérées. Si le tableau contient des constantes énumérées avec la même valeur, l’ordre de leurs noms correspondants n’est pas spécifié.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas une énumération.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le type sous-jacent du type énumération actuel.</summary>
        <returns>Type sous-jacent de l'énumération actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, le type sous-jacent d’une énumération en c# et Visual Basic est <xref:System.Int32>. Autres types d’entiers peuvent être spécifiés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas une énumération.  
  
ou 
Le type d’énumération n’est pas valide, car il contient plusieurs champs d’instance.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau des valeurs des constantes dans le type énumération actuel.</summary>
        <returns>Tableau qui contient les valeurs. Les éléments du tableau sont triés en fonction des valeurs binaires (à savoir les valeurs non signées) des constantes de l'énumération.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas une énumération.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un événement spécifique déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom d'un événement déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</param>
        <summary>Retourne l'objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement public spécifié.</summary>
        <returns>Objet représentant l'événement public spécifié qui est déclaré ou hérité par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un événement est considérée comme publique à la réflexion s’il comporte au moins une méthode ou accesseurs est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut des événements d’instance publique de static et public.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant crée un <xref:System.Reflection.EventInfo> de l’objet et obtient l’événement pour une classe de bouton pour l’événement spécifié.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom d'un événement déclaré ou hérité par le <see cref="T:System.Type" /> actuel.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, retourne l'objet <see cref="T:System.Reflection.EventInfo" /> représentant l'événement spécifié, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet représentant l'événement spécifié qui est déclaré ou hérité par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (autrement dit, les événements privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un événement est considérée comme publique à la réflexion s’il comporte au moins une méthode ou accesseurs est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.EventInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> méthode pour rechercher un type pour un événement public ou non public nommé « Click » qui n’est pas `static` (`Shared` en Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les événements publics qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements publics qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.EventInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas d'événements publics.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un événement est considérée comme publique à la réflexion s’il comporte au moins une méthode ou accesseurs est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> des objets, tous les événements pour un `Button` classe et affiche les noms d’événements. Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.EventInfo" /> représentant tous les événements qui sont déclarés ou hérités par le <see cref="T:System.Type" /> actuel et correspondent aux contraintes de liaison spécifiées.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.EventInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas d'événements ou si aucun des événements ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetEvents%2A> méthode ne retourne pas les événements dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les événements sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les événements à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les événements publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les événements non publics (autrement dit, les événements privés, internes et protégés) dans la recherche. Seuls protégés et des événements internes sur les classes de base sont retournés ; événements privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les événements déclarés sur le <xref:System.Type>, pas les événements qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Un événement est considérée comme publique à la réflexion s’il comporte au moins une méthode ou accesseurs est public. Sinon, l’événement est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.EventInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les événements de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient un tableau de <xref:System.Reflection.EventInfo> objets qui correspondent aux indicateurs de liaison spécifiés, obtient tous les événements pour un `Button` classe et affiche les noms d’événements. Pour compiler l’exemple Visual Basic, utilisez la ligne de commande suivante :  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un champ spécifique du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du champ de données à obtenir.</param>
        <summary>Recherche le champ public portant le nom spécifié.</summary>
        <returns>Objet représentant le champ public avec le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des champs d’instance publics de static et public.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les champs de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient le `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ et affiche la valeur du champ.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Cet objet <see cref="T:System.Type" /> est un <see cref="T:System.Reflection.Emit.TypeBuilder" /> dont la méthode <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> n’a pas encore été appelée.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du champ de données à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>Recherche le champ spécifié, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet représentant le champ qui correspond aux exigences spécifiées, s’il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des champs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.FieldInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les champs de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant obtient le `Type` de l’objet pour la classe spécifiée, qui obtient le <xref:System.Reflection.FieldInfo> objet pour le champ qui correspond aux indicateurs de liaison spécifiés et affiche la valeur du champ.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les champs du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les champs publics du <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant tous les champs publics définis pour le <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.FieldInfo" /> si aucun champ public n'est défini pour le <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les champs publics de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `GetFields()` (méthode).  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les champs définis pour le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.FieldInfo" /> représentant tous les champs définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.FieldInfo" /> si aucun champ n'est défini pour le <see cref="T:System.Type" /> actuel ou si aucun des champs définis ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetFields%2A> méthode ne retourne pas les champs dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les champs sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les champs à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des champs publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les champs non publics (autrement dit, les champs privés, internes et protégés) dans la recherche. Seuls protégés et des champs internes sur les classes de base sont retournés ; les champs privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les champs déclarés sur le <xref:System.Type>, pas les champs qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.FieldInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les champs publics de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `GetFields(BindingFlags)` (méthode).  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau d’objets <see cref="T:System.Type" /> qui représentent les arguments de type d’un type générique fermé ou les paramètres de type d’une définition de type générique.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> qui représentent les arguments de type d'un type générique. Retourne un tableau vide si le type actuel n'est pas un type générique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments du tableau sont retournés dans l’ordre dans lequel ils apparaissent dans la liste d’arguments de type pour le type générique.  
  
-   Si le type actuel est un type construit fermé (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> retourne de la propriété `false`), le tableau retourné par la <xref:System.Type.GetGenericArguments%2A> méthode contient les types qui ont été affectées aux paramètres de type générique de la définition de type générique .  
  
-   Si le type actuel est une définition de type générique, le tableau contient les paramètres de type.  
  
-   Si le type actuel est un type construit ouvert (autrement dit, le <xref:System.Type.ContainsGenericParameters%2A> retourne de la propriété `true`) dans lequel des types spécifiques n’ont pas été assignés à tous les paramètres de type et les paramètres de type de types génériques ou méthodes englobants, le tableau contient les types et les paramètres de type. Utilisez le <xref:System.Type.IsGenericParameter%2A> propriété pour les distinguer. Pour une démonstration de ce scénario, consultez l’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetGenericArguments%2A> méthode pour afficher les arguments de type d’un type construit et les paramètres de type de sa définition de type générique.  
  
 Cet exemple de code fait partie d’un exemple plus complet fourni pour le <xref:System.Type.IsGenericTypeDefinition%2A> propriété. Consultez l’exemple plus complet pour l’exemple de sortie.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base. Les classes dérivées doivent fournir une implémentation.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau d'objets <see cref="T:System.Type" /> qui représentent les contraintes qui s'exercent sur le paramètre de type générique actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> qui représentent les contraintes qui s'exercent sur le paramètre de type générique actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque contrainte sur un paramètre de type générique est exprimée comme un <xref:System.Type> objet. Utilisez le <xref:System.Type.IsClass%2A> propriété afin de déterminer si une contrainte est la contrainte de classe de base ; si la propriété retourne `false`, la contrainte est une contrainte d’interface. Si un paramètre de type a aucune contrainte de classe et les contraintes d’interface, un tableau vide est retourné.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant définit un type générique `Test` avec deux paramètres de type qui possèdent des contraintes différentes. Lorsque le programme s’exécute, les contraintes sont examinées à l’aide de la <xref:System.Type.GenericParameterAttributes%2A> propriété et la <xref:System.Type.GetGenericParameterConstraints%2A> (méthode).  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">L’objet <see cref="T:System.Type" /> actuel n’est pas un paramètre de type générique. Autrement dit, la propriété <see cref="P:System.Type.IsGenericParameter" /> retourne <see langword="false" />.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente une définition de type générique à partir de laquelle le type générique actuel peut être construit.</summary>
        <returns>Objet <see cref="T:System.Type" /> représentant un type générique à partir duquel le type actuel peut être construit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits. Par exemple, à partir de la définition de type générique `G<T>` (exprimée en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic). Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode retourne la définition de type générique.  
  
 Si deux types construits sont créés à partir de la même définition de type générique, avec les mêmes arguments de type, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode renvoie le même type <xref:System.Type> objet pour les deux types.  
  
 Si vous appelez le <xref:System.Type.GetGenericTypeDefinition%2A> méthode sur un <xref:System.Type> objet qui représente déjà une définition de type générique, elle retourne actuel <xref:System.Type>.  
  
> [!IMPORTANT]
>  Un tableau de types génériques n’est pas générique lui-même. Dans le code c# `A<int>[] v;` ou le code Visual Basic `Dim v() As A(Of Integer)`, le type de variable `v` n’est pas générique. Utilisez <xref:System.Type.IsGenericType%2A> pour déterminer si un type est générique avant d’appeler <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant crée une instance d’un type construit à l’aide de la création d’instance ordinaire, puis utilise le <xref:System.Type.GetType%2A> et <xref:System.Type.GetGenericTypeDefinition%2A> méthodes pour récupérer le type construit et la définition de type générique. Cet exemple utilise le modèle générique <xref:System.Collections.Generic.Dictionary%602> type ; le type construit représente un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type actuel n’est pas un type générique.  Autrement dit, <see cref="P:System.Type.IsGenericType" /> retourne <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base. Les classes dérivées doivent fournir une implémentation.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage de cette instance.</summary>
        <returns>Code de hachage de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode se substitue à <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant affiche le code de hachage de la `System.Windows.Forms.Button` classe.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une interface spécifique implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de l'interface à obtenir. Pour les interfaces génériques, il s'agit du nom tronqué.</param>
        <summary>Recherche l'interface avec le nom spécifié.</summary>
        <returns>Objet qui représente l'interface ayant le nom spécifié, implémentée ou héritée par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
> [!NOTE]
>  Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type. Cela est vrai pour les définitions d’interface générique et les interfaces génériques construites. Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez ``"IExample`1"``.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetInterface%28System.String%29> méthode pour rechercher le <xref:System.Collections.Hashtable> classe pour le <xref:System.Runtime.Serialization.IDeserializationCallback> interface et répertorie les méthodes de l’interface.  
  
 L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Le <see cref="T:System.Type" /> actuel représente un type qui implémente la même interface générique avec des arguments de type différents.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de l'interface à obtenir. Pour les interfaces génériques, il s'agit du nom tronqué.</param>
        <param name="ignoreCase"><see langword="true" /> pour ignorer la casse de cette partie de <paramref name="name" /> qui spécifie le nom d'interface simple (la casse de la partie qui spécifie l'espace de noms doit être respectée).  
  
ou 
 <see langword="false" /> pour effectuer une recherche qui respecte la casse de toutes les parties de <paramref name="name" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche l'interface spécifiée, en indiquant s'il faut faire une recherche qui ne respecte pas la casse pour le nom de l'interface.</summary>
        <returns>Objet qui représente l'interface ayant le nom spécifié, implémentée ou héritée par le <see cref="T:System.Type" /> actuel, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `ignoreCase` paramètre s’applique uniquement au nom d’interface simple, pas à l’espace de noms. La partie de `name` qui spécifie l’espace de noms doit respecter la casse, ou l’interface ne sera pas trouvée. Par exemple, la chaîne « System.icomparable » recherche les <xref:System.IComparable> interface, la chaîne « system.icomparable » ne mais pas.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Type> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
> [!NOTE]
>  Pour les interfaces génériques, le `name` paramètre est le nom tronqué, se terminant par un accent grave (\`) et le nombre de paramètres de type. Cela est vrai pour les définitions d’interface générique et les interfaces génériques construites. Par exemple, pour rechercher `IExample<T>` (`IExample(Of T)` en Visual Basic) ou `IExample<string>` (`IExample(Of String)` en Visual Basic), recherchez `"IExample`1 » '.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> méthode pour effectuer une recherche respectant la casse de la <xref:System.Collections.Hashtable> classe pour le <xref:System.Collections.IEnumerable> interface.  
  
 L’exemple de code montre également le <xref:System.Type.GetInterface%28System.String%29> surcharge de méthode et la <xref:System.Type.GetInterfaceMap%2A> (méthode).  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Le <see cref="T:System.Type" /> actuel représente un type qui implémente la même interface générique avec des arguments de type différents.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Type d'interface pour lequel extraire un mappage.</param>
        <summary>Retourne un mappage d'interface pour le type interface spécifié.</summary>
        <returns>Objet qui représente le mappage d'interface pour <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mappage d’interface indique comment une interface est mis en correspondance les membres réels sur une classe qui implémente cette interface.  
  
 Si actuel <xref:System.Type> représente un type générique construit, type de paramètres sont remplacés par les arguments de type approprié dans les éléments de la <xref:System.Reflection.InterfaceMapping> retourné par cette méthode.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.Type.GetInterfaceMap%2A> méthode pour déterminer comment la <xref:System.IFormatProvider> interface mappe à <xref:System.Globalization.CultureInfo> méthodes et comment la <xref:System.IAppDomainSetup> interface mappe à <xref:System.AppDomainSetup> propriétés. Notez que, étant donné que le <xref:System.IAppDomainSetup> interface définit un ensemble de propriétés, retournés <xref:System.Reflection.InterfaceMapping> objet inclut distinct <xref:System.Reflection.MethodInfo> objets pour d’une propriété accesseurs get et set.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> n’est pas implémenté par le type courant.  
  
ou 
L’argument <paramref name="interfaceType" /> ne fait pas référence à une interface.  
  
ou

L’instance actuelle ou l’argument <paramref name="interfaceType" />est un type générique ouvert (autrement dit, la propriété <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).

ou


 <paramref name="interfaceType" /> est une interface générique, et le type actuel est un type tableau.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Type" /> actuel représente un paramètre de type générique ; autrement dit, <see cref="P:System.Type.IsGenericParameter" /> est <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base. Les classes dérivées doivent fournir une implémentation.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient toutes les interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> représentant toutes les interfaces implémentées ou héritées par le <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> si aucune interface n'est implémentée ou héritée par le <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetInterfaces%2A> méthode ne retourne pas les interfaces dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les interfaces sont retournées, car cet ordre varie.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Type> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les contraintes d’interface et toutes les interfaces héritées des contraintes de classe ou interface.  
  
   
  
## Examples  
 L’exemple suivant obtient le type de la classe spécifiée et affiche toutes les interfaces que le type implémente ou en hérite. Pour compiler l’exemple Visual Basic, utilisez les commandes de compilateur suivantes :  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les membres spécifiés du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom des membres publics à obtenir.</param>
        <summary>Recherche les membres publics portant le nom spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des membres d’instance publics de static et public.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette surcharge de méthode ne trouvera pas les initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les membres de la `String` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom des membres à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner un tableau vide.</param>
        <summary>Recherche les membres spécifiés, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) pour `bindingAttr`. Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche tous les membres statiques publics de la `myString` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom des membres à obtenir.</param>
        <param name="type">La valeur à rechercher.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner un tableau vide.</param>
        <summary>Recherche les membres spécifiés du type de membre spécifié, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant les membres publics portant le nom spécifié, si ces objets sont trouvés ; sinon, un tableau vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMember%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier « .cctor » pour `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> pour `type`, et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> dans Visual Basic) pour `bindingAttr`. Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MemberInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant affiche toutes les méthodes de la `myString` classe qui commencent par la lettre C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Une classe dérivée doit fournir une implémentation.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les membres (propriétés, méthodes, champs, événements, etc.) du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les membres publics du <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres publics du <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de membres publics.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Cette surcharge de méthode appelle la <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> surcharge de méthode, avec <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> en Visual Basic). Elle ne trouvera pas les initialiseurs de classe (.cctor). Pour rechercher des initialiseurs de classe, utilisez une surcharge qui accepte <xref:System.Reflection.BindingFlags>et spécifiez <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers> surcharge de méthode pour collecter des informations sur tous les membres publics d’une classe spécifiée.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro (<see cref="F:System.Reflection.BindingFlags.Default" />), pour retourner un tableau vide.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les membres définis pour le <see cref="T:System.Type" /> actuel, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MemberInfo" /> représentant tous les membres définis pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.MemberInfo" /> si aucun membre n'est défini pour le <see cref="T:System.Type" /> actuel ou si aucun des membres définis ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comprendre les propriétés, méthodes, champs, événements et ainsi de suite.  
  
 Le <xref:System.Type.GetMembers%2A> méthode ne retourne pas les membres dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les membres sont retournés, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche. Seuls protégés et des membres internes sur les classes de base sont retournés ; les membres privés sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Appel de cette méthode avec uniquement le `Public` indicateur ou uniquement le `NonPublic` indicateur retournera les membres spécifiés et ne nécessite pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Pour obtenir l’initialiseur de classe (.cctor) à l’aide de cette surcharge de méthode, vous devez spécifier <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic). Vous pouvez également obtenir l’initialiseur de classe à l’aide de la <xref:System.Type.TypeInitializer%2A> propriété.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MemberInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les membres de la contrainte de classe, ou les membres de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> surcharge de méthode pour collecter des informations sur tous les membres d’instance publics d’une classe spécifiée.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une méthode spécifique du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode publique à obtenir.</param>
        <summary>Recherche la méthode publique avec le nom spécifié.</summary>
        <returns>Objet qui représente la méthode publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
 Si une méthode est surchargée et a plus d’une méthode publique, la <xref:System.Type.GetMethod%28System.String%29> méthode lève un <xref:System.Reflection.AmbiguousMatchException> exception. Dans l’exemple suivant, une exception est levée, car il existe plusieurs surcharges publique de la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> (méthode).  Quant à eux, étant donné que le `Person.ToString` substitutions de méthode <xref:System.Object.ToString%2A?displayProperty=nameWithType> et par conséquent n’est pas surchargé, la <xref:System.Type.GetMethod%28System.String%29> méthode est en mesure de récupérer le <xref:System.Reflection.MethodInfo> objet.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :  
  
-   Appelez le <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> (méthode) et spécifiez un `bindingAttr` argument qui identifie de façon unique la méthode. Par exemple, si l’exception est levée, car un type a un statique et une surcharge de l’instance, vous pouvez spécifier un `bindingAttr` argument de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.  
  
-   Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.  
  
-   Appelez le <xref:System.Type.GetMethods> méthode pour récupérer un tableau contenant toutes les méthodes publiques qui appartiennent à un type. Vous pouvez ensuite itérer pour identifier les méthodes en double nommés `name`.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant obtient une méthode nommée `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes ont été trouvées avec le nom spécifié.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>Recherche la méthode spécifiée, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> afin d’obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure des méthodes publiques dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> pour ignorer la casse de `name`.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si une méthode est surchargée et plusieurs surcharges aux contraintes spécifiées par le `bindingAttr` argument, la méthode lève un <xref:System.Reflection.AmbiguousMatchException> exception. Dans l’exemple suivant, une exception est levée, car :  
  
-   Le `TestClass` type a deux surcharges d’instance publique de la `DisplayValue` (méthode), `DisplayValue(String)` et `DisplayValue(String, Object[])`.  
  
-   Le `TestClass` type a deux surcharges d’instance publique de la `Equals` méthode, un d'entre eux est hérité de <xref:System.Object>: `Equals(TestClass)` et `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Vous pouvez effectuer l’une des opérations suivantes pour récupérer une méthode spécifique :  
  
-   Modifiez les contraintes de liaison. Dans l’exemple précédent, d’essayer de récupérer une instance publique `Equals` récupère de la méthode qui est déclarée par le type et pas hérité avec succès `Equals(TestClass)`.  
  
-   Appelez une surcharge de la <xref:System.Type.GetMethod%2A> méthode inclut un `types` paramètre qui définit les types de paramètres de la méthode.  
  
-   Appelez le <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> méthode pour récupérer un tableau contenant toutes les méthodes appartenant à un type dont les attributs de liaison spécifiées. Vous pouvez ensuite itérer pour identifier les méthodes en double nommés `name`. Cette approche est illustrée dans le Gestionnaire de l’exemple précédent pour le <xref:System.Reflection.AmbiguousMatchException> exception.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant obtient la méthode qui correspond aux indicateurs de liaison spécifiés.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode publique à obtenir.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.  
  
ou 
Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</param>
        <summary>Recherche la méthode publique spécifiée dont les paramètres correspondent aux types d'arguments spécifiés.</summary>
        <returns>Objet représentant la méthode publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Le `name` paramètre ne peut pas inclure les arguments de type. Par exemple, le code c# `GetMethod("MyGenericMethod<int>")` recherche une méthode avec le nom de texte «`MyGenericMethod<int>`», plutôt que pour une méthode nommée `MyGenericMethod` qui possède un argument générique de type `int`. Au lieu de cela, utilisez `GetMethod("MyGenericMethod")` avec le paramètre approprié dans le `types` tableau.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant une variété de types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple requiert le `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 L’exemple suivant récupère <xref:System.Reflection.MethodInfo> des objets qui représentent le `Add` méthodes d’un type non générique (le <xref:System.Collections.ArrayList> classe), un type générique ouvert (le <xref:System.Collections.Generic.List%601> classe) et un type générique fermé (les `List(Of String)` type.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 L’exemple définit un `GetAddMethod` méthode qui Récupère le texte approprié <xref:System.Reflection.MethodInfo> objet. Pour fournir la `types` argument pour un type générique ouvert, il appelle le <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> (méthode). Pour fournir la `types` argument pour un type générique fermé, il récupère la valeur de la <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes ont été trouvées avec le nom et les paramètres spécifiés.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode publique à obtenir.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.  
  
ou 
Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche la méthode publique spécifiée dont les paramètres correspondent aux types d’arguments et modificateurs spécifiés.</summary>
        <returns>Objet qui représente la méthode publique correspondant aux exigences spécifiées, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 La recherche de `name` respecte la casse. La recherche inclut des méthodes d’instance publique de static et public.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMethod("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`. Au lieu de cela, utilisez `GetMethod("MyMethod")` avec le paramètre approprié dans le `types` tableau.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes ont été trouvées avec le nom et les paramètres spécifiés.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.  
  
ou 
Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche la méthode spécifiée dont les paramètres correspondent aux types d'arguments et modificateurs spécifiés, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant des contraintes de liaison et une variété de types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple requiert le `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objet qui spécifie l'ensemble de règles à utiliser en ce qui concerne l'ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et la manière dont la pile est nettoyée.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.  
  
ou 
Tableau vide d'objets <see cref="T:System.Type" /> (tels que le champ <see cref="F:System.Type.EmptyTypes" /> les fournit) pour obtenir une méthode qui ne prend aucun paramètre.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. À utiliser uniquement au moment d'un appel via COM Interop ; de plus, seuls sont gérés les paramètres passés par référence. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche la méthode spécifiée dont les paramètres correspondent aux types d'arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison et la convention d'appel indiquées.</summary>
        <returns>Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `GetXXX` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne la <xref:System.Reflection.MethodInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
> [!NOTE]
>  Pour les méthodes génériques, n’incluez pas les arguments de type dans `name`. Par exemple, le code c# `GetMember("MyMethod<int>")` recherche un membre portant le nom de texte «`MyMethod<int>`», plutôt que pour une méthode nommée `MyMethod` qui possède un argument générique de type `int`.  
  
   
  
## Examples  
 L’exemple suivant recherche des surcharges spécifiques de `MethodA`, en spécifiant des contraintes de liaison, les conventions d’appel et divers types d’arguments.  
  
> [!NOTE]
>  Le [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemple requiert le `/unsafe` option du compilateur.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la méthode à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">Objet qui spécifie l'ensemble de règles à utiliser en ce qui concerne l'ordre et la disposition des arguments, la manière dont la valeur de retour est passée, les registres utilisés pour les arguments et le processus de nettoyage de la pile.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la méthode à obtenir.  
  
ou 
Tableau vide de type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une méthode qui ne prend aucun paramètre.  
  
ou 
 <see langword="null" />. Si <paramref name="types" /> est <see langword="null" />, les arguments ne correspondent pas.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche la méthode spécifiée dont les paramètres correspondent aux types d'arguments et modificateurs spécifiés, à l'aide des contraintes de liaison et de la convention d'appel spécifiées.</summary>
        <returns>Objet qui représente la méthode correspondant aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Si `types` est `null`, les arguments ne correspondent pas.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux méthodes portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <exception cref="T:System.NotSupportedException">Le type actuel est <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les méthodes du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne toutes les méthodes publiques du <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes publiques définies pour le <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.MethodInfo" /> si aucune méthode publique n'est définie pour le <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.  
  
 Les constructeurs ne sont pas inclus dans le tableau de méthodes retourné par cet appel. Effectuer un appel distinct à `GetConstructors()` pour obtenir les méthodes de constructeur.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les méthodes définies pour le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.MethodInfo" /> représentant toutes les méthodes définies pour le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.MethodInfo" /> si aucune méthode n’est définie pour le <see cref="T:System.Type" /> actuel ou si aucune des méthodes définies ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetMethods%2A> méthode ne retourne pas les méthodes dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les méthodes sont retournées, car cet ordre varie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les méthodes à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure des méthodes publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure des méthodes non publiques (autrement dit, les méthodes privées, internes et protégés) dans la recherche. Seuls protégés et des méthodes internes sur les classes de base sont retournés ; méthodes privées sur les classes de base ne sont pas retournés.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les méthodes déclarées sur le <xref:System.Type>, pas les méthodes qui ont été simplement hérités.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Vous ne pouvez pas omettre les paramètres lors de la recherche les constructeurs et méthodes. Vous pouvez omettre les paramètres uniquement lors de l’appel.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.MethodInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode recherche les méthodes de la contrainte de classe, ou les méthodes de <xref:System.Object> s’il n’existe aucune contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant crée une classe avec deux méthodes publiques et une méthode protégée, crée un `Type` objet correspondant à `MyTypeClass`Obtient toutes les méthodes publiques et non publics et affiche leurs noms.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un type spécifique imbriqué dans le <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du type imbriqué à obtenir.</param>
        <summary>Recherche le type imbriqué public avec le nom spécifié.</summary>
        <returns>Objet représentant le type imbriqué public avec le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse.  
  
 Utilisez le nom simple de la classe imbriquée pour `name`. Ne la qualifiez pas avec le nom de la classe externe. Pour une classe imbriquée générique, utilisez le nom tronqué - c'est-à-dire, ajouter un accent grave et le nombre d’arguments génériques. Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic). N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si actuel <xref:System.Type> représente un type générique défini dans c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du type imbriqué à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche le type imbriqué spécifié, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet qui représente le type imbriqué correspondant aux critères spécifiés, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le nom simple de la classe imbriquée pour `name`. Ne la qualifiez pas avec le nom de la classe externe. Pour une classe imbriquée générique, utilisez le nom tronqué - c'est-à-dire, ajouter un accent grave et le nombre de paramètres génériques. Par exemple, utilisez la chaîne « interne\`1 » pour obtenir le générique de classe imbriquée `Inner<T>` (`Inner(Of T)` en Visual Basic). N’incluez pas de syntaxe spécifique au langage pour les paramètres de type.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir qui imbriquées types à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure des types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.  
  
 Cette méthode retourne uniquement les types imbriqués du type actuel. Il ne recherche pas les classes de base du type actuel. Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, l’appel <xref:System.Type.GetNestedType%2A> à chaque niveau.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.  
  
 Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement le <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> indicateur retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si actuel <xref:System.Type> représente un type générique défini dans c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les types imbriqués dans le <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les types publics imbriqués dans le <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> représentant les types publics imbriqués dans le <see cref="T:System.Type" /> actuel (la recherche n'est pas récursive), ou tableau vide de type <see cref="T:System.Type" /> si aucun type public n'est imbriqué dans le <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.  
  
 Seuls les types publics imbriqués immédiatement dans le type actuel sont retournés ; la recherche n’est pas récursive.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si actuel <xref:System.Type> représente un type générique défini dans c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant définit une classe imbriquée et un `struct` dans `MyClass`et puis obtient des objets des types imbriqués à l’aide du type de `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les types imbriqués dans le <see cref="T:System.Type" /> actuel, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> représentant tous les types imbriqués dans le <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées (la recherche n'est pas récursive), ou tableau vide de type <see cref="T:System.Type" /> si aucun type imbriqué correspondant aux contraintes de liaison n'est trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche pour les types imbriqués n’est pas récursive.  
  
 Le <xref:System.Type.GetNestedTypes%2A> méthode ne retourne pas les types dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les types sont retournés, car cet ordre varie.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir qui imbriquées types à inclure dans la recherche :  
  
-   Vous devez spécifier soit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour obtenir un retour.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> pour inclure les types imbriqués publics dans la recherche.  
  
-   Spécifiez <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> pour inclure des types imbriqués non publics (autrement dit, privés, internes et protégés types imbriqués) dans la recherche.  
  
 Cette méthode retourne uniquement les types imbriqués du type actuel. Il ne recherche pas les classes de base du type actuel. Pour rechercher des types qui sont imbriqués dans les classes de base, vous devez parcourir la hiérarchie d’héritage, l’appel <xref:System.Type.GetNestedTypes%2A> à chaque niveau.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> et <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> sont ignorés.  
  
 Appel de cette méthode avec uniquement le <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> indicateur ou uniquement le <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> indicateur retournera types l’imbriqués spécifiés et ne nécessitent pas de tous les autres indicateurs.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les types imbriqués de la contrainte de classe.  
  
 Si un type imbriqué est générique, cette méthode retourne sa définition de type générique. Cela est vrai même si le type générique englobant est un type construit fermé.  
  
> [!NOTE]
>  Si actuel <xref:System.Type> représente un type générique défini dans c#, Visual Basic ou C++, ses types imbriqués sont tous génériques même s’ils n’ont aucuns leurs propres paramètres génériques. Ce n’est pas nécessairement vrai pour les types imbriqués définis dans des assemblys dynamiques ou compilés avec le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Pour plus d’informations sur les types génériques imbriqués et sur la construction de types génériques imbriqués à partir de leurs définitions de type générique, consultez <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant crée deux classes publiques imbriquées et deux classes protégées imbriquées et affiche des informations pour les classes qui correspondent aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient les propriétés du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne toutes les propriétés publiques du <see cref="T:System.Type" /> actuel.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.PropertyInfo" /> représentant toutes les propriétés publiques du <see cref="T:System.Type" /> actuel.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.PropertyInfo" /> si le <see cref="T:System.Type" /> actuel n'a pas de propriétés publiques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette surcharge revient à appeler le <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> surcharge avec un `bindingAttr` argument égal à `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` en c# et `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` en Visual Basic. Elle retourne toutes les instances publiques et propriétés statiques, les deux ceux définis par le type représenté par l’actuel <xref:System.Type> objet ainsi que celles héritent de ses types de base.  
  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche les propriétés du <see cref="T:System.Type" /> actuel, à l’aide des contraintes de liaison spécifiées.</summary>
        <returns>Tableau d’objets <see cref="T:System.Reflection.PropertyInfo" /> représentant toutes les propriétés du <see cref="T:System.Type" /> actuel qui correspondent aux contraintes de liaison spécifiées.  
  
ou 
Tableau vide du type <see cref="T:System.Reflection.PropertyInfo" /> si le <see cref="T:System.Type" /> actuel n’a pas de propriétés ou si aucune des propriétés ne correspond aux contraintes de liaison.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Le <xref:System.Type.GetProperties%2A> méthode ne retourne pas les propriétés dans un ordre particulier, tel qu’alphabétique ou ordre de déclaration. Votre code ne doit pas dépendent l’ordre dans lequel les propriétés sont retournées, car cet ordre varie.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> filtre indicateurs peuvent être utilisés pour définir qui imbriquées types à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche. Seuls protégés et des propriétés internes sur les classes de base sont retournées ; les propriétés privées sur les classes de base ne sont pas retournées.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si le t : System.type actuel représente un type générique construit, cette méthode retourne le <xref:System.Reflection.PropertyInfo> objets avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
   
  
## Examples  
 L’exemple suivant définit une classe nommée `PropertyClass` qui inclut six propriétés : deux sont publics, une est privée, un est protégé, un est interne (`Friend` en Visual Basic), et une est protected internal (`Protected Friend` en Visual Basic). Il affiche ensuite des informations de propriété de base (le nom de propriété et le type, s’il est en lecture/écriture et la visibilité de ses `get` et `set` accesseurs) pour les propriétés qui correspondent aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient une propriété spécifique du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété publique à obtenir.</param>
        <summary>Recherche la propriété publique avec le nom spécifié.</summary>
        <returns>Objet représentant la propriété publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche de `name` respecte la casse. La recherche inclut des propriétés de l’instance publique de static et public.  
  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
 Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :  
  
-   Un type contienne deux propriétés indexées qui ont le même nom mais des nombres de paramètres. Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.  
  
-   Un type dérivé déclare une propriété qui masque une propriété héritée portant le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic). Pour résoudre l’ambiguïté, utilisez le <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> surcharge de méthode et ajoutez le <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> indicateur pour limiter la recherche aux membres qui ne sont pas hérités.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 En interne, cette propriété est référencée dans les métadonnées par le nom « Élément ». Toute tentative d’obtenir `PropertyInfo` à l’aide de la réflexion doit spécifier ce nom interne afin de retourner correctement les `PropertyInfo` propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plus d’une propriété a été trouvée avec le nom spécifié.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <summary>Recherche la propriété spécifiée, à l'aide des contraintes de liaison spécifiées.</summary>
        <returns>Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
 Situations dans lesquelles <xref:System.Reflection.AmbiguousMatchException> se produit incluent les éléments suivants :  
  
-   Un type contienne deux propriétés indexées qui ont le même nom mais des nombres de paramètres. Pour résoudre l’ambiguïté, utilisez une surcharge de la <xref:System.Type.GetProperty%2A> méthode qui spécifie les types de paramètres.  
  
-   Un type dérivé déclare une propriété qui masque une propriété héritée portant le même nom, à l’aide de la `new` modificateur (`Shadows` en Visual Basic). Pour résoudre l’ambiguïté, incluez <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> pour limiter la recherche aux membres qui ne sont pas hérités.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère le type d’une classe définie par l’utilisateur, récupère une propriété de cette classe et affiche le nom de propriété conformément aux contraintes de liaison spécifiées.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété publique à obtenir.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <summary>Recherche la propriété publique à l'aide du nom et du type de retour spécifiés.</summary>
        <returns>Objet représentant la propriété publique avec le nom spécifié, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut des propriétés de l’instance publique de static et public.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant définit une classe avec une propriété et récupère le nom et le type de la propriété.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plus d’une propriété a été trouvée avec le nom spécifié.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />, ou <paramref name="returnType" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété publique à obtenir.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</param>
        <summary>Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d’arguments spécifiés.</summary>
        <returns>Objet représentant la propriété publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut des propriétés de l’instance publique de static et public.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant récupère la `Type` objet d’une classe définie par l’utilisateur, récupère la propriété de cette classe et affiche le nom de propriété et le type de la propriété comme spécifié par les arguments passés à `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux types d’arguments spécifiés.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.</exception>
        <exception cref="T:System.NullReferenceException">Un élément de <paramref name="types" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété publique à obtenir.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</param>
        <summary>Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d’arguments spécifiés.</summary>
        <returns>Objet représentant la propriété publique dont les paramètres correspondent aux types d'arguments spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 La recherche de `name` respecte la casse. La recherche inclut des propriétés de l’instance publique de static et public.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux types d’arguments spécifiés.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.</exception>
        <exception cref="T:System.NullReferenceException">Un élément de <paramref name="types" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété publique à obtenir.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche la propriété publique spécifiée dont les paramètres correspondent aux types d'arguments et modificateurs spécifiés.</summary>
        <returns>Objet qui représente la propriété publique correspondant aux exigences spécifiées, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 La recherche de `name` respecte la casse. La recherche inclut des propriétés de l’instance publique de static et public.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
   
  
## Examples  
 L’exemple suivant obtient un `Type` objet correspondant à `MyPropertyClass`, et la propriété indexée de cette classe est récupérée en utilisant les arguments passés à la `GetProperty` (méthode).  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux types et modificateurs d’arguments spécifiés.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <exception cref="T:System.NullReferenceException">Un élément de <paramref name="types" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>Recherche la propriété spécifiée dont les paramètres correspondent aux types d’arguments et aux modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</summary>
        <returns>Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une propriété est considérée comme publique à la réflexion si elle a au moins un accesseur public. Sinon, la propriété est considérée comme privée, et vous devez utiliser <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combinez les valeurs à l’aide de `Or`) pour l’obtenir.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette méthode retourne la <xref:System.Reflection.PropertyInfo> avec les paramètres de type remplacés par les arguments de type approprié.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette méthode recherche les propriétés de la contrainte de classe.  
  
## <a name="indexers-and-default-properties"></a>Les indexeurs et les propriétés par défaut  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], et [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] ont une syntaxe simplifiée pour accéder aux propriétés indexées et permettent à une propriété indexée comme une valeur par défaut pour son type. Par exemple, si la variable `myList` fait référence à un <xref:System.Collections.ArrayList>, la syntaxe `myList[3]` (`myList(3)` en Visual Basic) récupère l’élément avec l’index égal à 3. Vous pouvez surcharger la propriété.  
  
 En c#, cette fonctionnalité est appelée un indexeur et ne peut pas être référencée par nom. Par défaut, un indexeur c# apparaît dans les métadonnées comme une propriété indexée nommée « Item ». Toutefois, un développeur de bibliothèque de classe peut utiliser le <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribut pour modifier le nom de l’indexeur dans les métadonnées. Par exemple, le <xref:System.String> classe possède un indexeur nommé <xref:System.String.Chars%2A>. Propriétés indexées créées à l’aide des langages autres que c# peuvent avoir des noms différents d’élément, ainsi.  
  
 Pour déterminer si un type a une propriété par défaut, utilisez le <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> méthode pour tester le <xref:System.Reflection.DefaultMemberAttribute> attribut. Si le type a <xref:System.Reflection.DefaultMemberAttribute>, le <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propriété retourne le nom de la propriété par défaut.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <exception cref="T:System.NullReferenceException">Un élément de <paramref name="types" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom de la propriété à obtenir.</param>
        <param name="bindingAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche.  
  
ou 
Zéro, pour retourner <see langword="null" />.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d’un membre surchargé, la contrainte de types d’arguments et l’appel d’un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">Type de retour de la propriété.</param>
        <param name="types">Tableau d'objets <see cref="T:System.Type" /> représentant le nombre, l'ordre et le type des paramètres de la propriété indexée à obtenir.  
  
ou 
Tableau vide du type <see cref="T:System.Type" /> (c'est-à-dire Type[] types = new Type[0]) pour obtenir une propriété qui n'est pas indexée.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="types" />. Le binder par défaut ne traite pas ce paramètre.</param>
        <summary>En cas de substitution dans une classe dérivée, recherche la propriété spécifiée dont les paramètres correspondent aux types d'arguments et modificateurs spécifiés, en utilisant les contraintes de liaison indiquées.</summary>
        <returns>Objet représentant la propriété qui correspond aux critères spécifiés, si elle est trouvée ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> (le `modifiers` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les propriétés à inclure dans la recherche :  
  
-   Vous devez spécifier soit `BindingFlags.Instance` ou `BindingFlags.Static` afin d’obtenir un retour.  
  
-   Spécifiez `BindingFlags.Public` pour inclure les propriétés publiques dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les propriétés non publiques (autrement dit, les propriétés privées, internes et protégées) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` à inclure `public` et `protected` des membres statiques dans la hiérarchie ; `private` membres statiques dans les classes héritées ne sont pas inclus.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les propriétés déclarées sur le <xref:System.Type>, pas les propriétés qui ont été simplement héritées.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Au moins deux propriétés portent le nom spécifié et correspondent aux contraintes de liaison spécifiées.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="types" /> est <see langword="null" />.  
  
ou 
Un des éléments de <paramref name="types" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> est multidimensionnel.  
  
ou 
 <paramref name="modifiers" /> est multidimensionnel.  
  
ou 
 <paramref name="types" /> et <paramref name="modifiers" /> n’ont pas la même longueur.</exception>
        <exception cref="T:System.NotSupportedException">Le type actuel est un <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Type" /> qui représente le type spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> actuel.</summary>
        <returns><see cref="T:System.Type" /> actuel.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom qualifié d'assembly du type à obtenir. Consultez <see cref="P:System.Type.AssemblyQualifiedName" />. Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</param>
        <summary>Obtient le <see cref="T:System.Type" /> avec le nom spécifié, effectuant une recherche qui respecte la casse.</summary>
        <returns>Type présentant le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet pour un type dans un autre assembly, si vous connaissez son nom qualifié d’assembly qui peut être obtenu à partir de <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou en C++.  
  
> [!NOTE]
>  Si `typeName` est introuvable, l’appel à la <xref:System.Type.GetType%28System.String%29> retourne de la méthode `null`. Il ne lève pas d’exception. Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.  
  
 <xref:System.Type.GetType%2A> fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez <xref:System.Type.GetType%2A> pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et a été écrite sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré pour le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly en mémoire.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Tableaux ou des types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type générique. Tous les compilateurs qui prennent en charge le common language runtime émettra le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogées, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger des types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (') | Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, située à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet pour une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour éviter qu’il soit interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Les noms de type peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces sont pertinents dans tous les composants de nom de type autre que le nom de l’assembly. Nom de l’assembly, espaces avant le séparateur ',', mais les espaces après le séparateur ',' sont ignorés.  
  
 Le nom d’un type générique se termine avec un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques avec le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` parmi les méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placée entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un générique <xref:System.Collections.Generic.Dictionary%602> a deux paramètres de type. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles de recherche d’assemblys pour les types qualifiés et non qualifiés dans les listes de paramètres de type sont les mêmes que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Types Nullable sont un cas spécial de types génériques. Par exemple, un nullable <xref:System.Int32> est représentée par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir les types nullable à l’aide des opérateurs de type. Par exemple, autorisant <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant présente la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyType[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyType[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un à trois dimensions `Object` tableau.|  
|Un tableau de tableaux unidimensionnels|`Type.GetType("MyType[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures sont inconnues|`Type.GetType("MyType[,]")`|  
|Un type générique avec un argument de type|``Type.GetType("MyGenericType`1[MyType]")``|  
|Un type générique avec deux arguments de type|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Un type générique avec deux arguments de type qualifié d’assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>  
  
 L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom qualifié d'assembly du type à obtenir. Consultez <see cref="P:System.Type.AssemblyQualifiedName" />. Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />. <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes. Consultez la section Exceptions.</param>
        <summary>Obtient le <see cref="T:System.Type" /> portant le nom spécifié, en effectuant une recherche respectant la casse et en spécifiant s'il faut lever une exception si le type est introuvable.</summary>
        <returns>Type portant le nom spécifié. Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée. Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />. Consultez la section Exceptions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet pour un type dans un autre assembly, si vous connaissez son nom qualifié d’assembly qui peut être obtenu à partir de <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.  
  
 `GetType` fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et a été écrite sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré pour le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly en mémoire.  
  
 Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées indépendamment de la valeur de `throwOnError`. Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Tableaux ou des types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments génériques. Tous les compilateurs qui prennent en charge le common language runtime émettra le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogées, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger des types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (') | Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, située à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet pour une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour éviter qu’il soit interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Les noms de type peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces sont pertinents dans tous les composants de nom de type autre que le nom de l’assembly. Nom de l’assembly, espaces avant le séparateur ',', mais les espaces après le séparateur ',' sont ignorés.  
  
 Le nom d’un type générique se termine avec un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques avec le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` parmi les méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placée entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un générique <xref:System.Collections.Generic.Dictionary%602> a deux paramètres de type. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles de recherche d’assemblys pour les types qualifiés et non qualifiés dans les listes de paramètres de type sont les mêmes que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Types Nullable sont un cas spécial de types génériques. Par exemple, un nullable <xref:System.Int32> est représentée par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir les types nullable à l’aide des opérateurs de type. Par exemple, autorisant <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant présente la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyArray[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyArray[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un à trois dimensions `Object` tableau.|  
|Un à deux dimensions un tableau|`Type.GetType("MyArray[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures sont inconnues|`Type.GetType("MyArray[,]")`|  
|Un type générique avec un argument de type|``Type.GetType("MyGenericType`1[MyType]")``|  
|Un type générique avec deux arguments de type|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Un type générique avec deux arguments de type qualifié d’assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 L’exemple suivant récupère le type de `System.Int32` et utilise cet objet de type pour afficher le <xref:System.Type.FullName%2A> propriété du `System.Int32`. Si un objet de type fait référence à un assembly qui n’existe pas, cet exemple lève une exception.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée. 
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.  
  
ou 
 <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide. Par exemple, « MyType [, *,] ».  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et l’assembly ou l’une de ses dépendances est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Dans <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET pour les applications du Windows Store</see> ou la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Bibliothèque de classes portable</see>, interceptez l’exception de la classe de base, <see cref="T:System.IO.IOException" />, à la place.  
  
</para>
          </block>  
  
 L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom qualifié d'assembly du type à obtenir. Consultez <see cref="P:System.Type.AssemblyQualifiedName" />. Si le type se trouve dans Mscorlib.dll ou l'assembly en cours d'exécution, il suffit de fournir le nom du type qualifié par son espace de noms.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />. <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes. Consultez la section Exceptions.</param>
        <param name="ignoreCase"><see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <paramref name="typeName" /> et <see langword="false" /> pour effectuer une recherche qui respecte la casse de <paramref name="typeName" />.</param>
        <summary>Obtient le <see cref="T:System.Type" /> portant le nom spécifié, indiquant s'il faut lever une exception si le type est introuvable et s'il faut effectuer une recherche respectant la casse.</summary>
        <returns>Type portant le nom spécifié. Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée. Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />. Consultez la section Exceptions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser la <xref:System.Type.GetType%2A> méthode pour obtenir un <xref:System.Type> de l’objet pour un type dans un autre assembly, si vous connaissez son nom qualifié d’assembly qui peut être obtenu à partir de <xref:System.Type.AssemblyQualifiedName>. <xref:System.Type.GetType%2A> provoque le chargement de l’assembly spécifié dans `typeName`. Vous pouvez également charger un assembly à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode), puis utiliser le <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> méthodes de la <xref:System.Reflection.Assembly> classe pour obtenir <xref:System.Type> objets. Si un type est dans un assembly connu de votre programme au moment de la compilation, il est plus efficace d’utiliser `typeof` en c#, <xref:System.Type.GetType%2A> en Visual Basic, ou `typeid` en C++.  
  
 `GetType` fonctionne uniquement sur les assemblys chargés à partir du disque. Si vous appelez `GetType` pour rechercher un type défini dans un assembly dynamique défini à l’aide de la <xref:System.Reflection.Emit> services, vous pouvez obtenir un comportement incohérent. Le comportement varie selon que l’assembly dynamique est persistant, autrement dit, créé à l’aide de la `RunAndSave` ou `Save` accéder aux modes de le <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> énumération. Si l’assembly dynamique est persistant et a été écrite sur le disque avant `GetType` est appelé, le chargeur recherche l’assembly enregistré sur le disque, charge l’assembly et récupère le type de cet assembly. Si l’assembly n’a pas été enregistré pour le disque lorsque `GetType` est appelée, la méthode retourne `null`. `GetType` ne comprend pas les assemblys dynamiques transitoires ; Par conséquent, l’appel `GetType` pour récupérer un type dans un temporaire assembly dynamique retourne `null`.  
  
 Pour utiliser `GetType` sur un module dynamique, vous abonner à la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> événements et les appels `GetType` avant l’enregistrement. Sinon, vous obtiendrez deux copies de l’assembly en mémoire.  
  
 Le `throwOnError` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées indépendamment de la valeur de `throwOnError`. Par exemple, si le type est trouvé mais ne peut pas être chargé, un <xref:System.TypeLoadException> est levée même si `throwOnError` est `false`.  
  
 Le tableau suivant présente les membres d’une classe de base sont retournés par la `Get` méthodes lors de la réflexion sur un type.  
  
|Type de membre|Statique|Non statique|  
|-----------------|------------|-----------------|  
|Constructeur|Non|Non|  
|Champ|Non|Oui. Un champ est toujours hide-by-nom-et-signature.|  
|événement|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
|Méthode|Non|Oui. Une méthode (virtuelle et non virtuel) peut être masquée par nom ou masquer-par-nom-et-signature.|  
|Type imbriqué|Non|Non|  
|Property|Non applicable|La règle de système de type commun est que l’héritage est identique à celle des méthodes qui implémentent la propriété. Réflexion traite les propriétés comme hide-by-nom-et-signature. Voir la Remarque 2 ci-dessous.|  
  
1.  Masquer-par-nom-et-signature prend en compte toutes les parties de la signature, y compris les modificateurs personnalisés, des conventions d’appel non managées, les types de paramètres, les sentinelles et les types de retour. Il s’agit d’une comparaison binaire.  
  
2.  Pour la réflexion, les propriétés et événements sont hide-by-nom-et-signature. Si vous avez une propriété avec une opération get et un accesseur set dans la classe de base, mais la classe dérivée possède uniquement un accesseur get, la propriété de la classe dérivée masque la propriété de classe de base, et vous ne serez pas en mesure d’accéder à l’accesseur Set sur la classe de base.  
  
3.  Attributs personnalisés ne font pas partie du système de type commun.  
  
 Tableaux ou des types COM ne sont pas recherchés, sauf si elles ont déjà été chargés dans la table des classes disponibles.  
  
 `typeName` le nom de type qualifié par son espace de noms ou un nom qualifié d’assembly qui inclut une spécification de nom d’assembly. Consultez <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Si `typeName` inclut l’espace de noms mais pas le nom de l’assembly, cette méthode recherche uniquement les assembly de l’objet appelant et dans Mscorlib.dll, dans cet ordre. Si typeName est qualifié avec le nom d’assembly partiel ou complet, cette méthode recherche dans l’assembly spécifié. Si l’assembly a un nom fort, un nom d’assembly complet est requis.  
  
 Le <xref:System.Type.AssemblyQualifiedName%2A> propriété retourne un nom de type qualifié complet, y compris les types imbriqués, le nom de l’assembly et les arguments de type. Tous les compilateurs qui prennent en charge le common language runtime émettra le nom simple d’une classe imbriquée et la réflexion construit un nom tronqué interrogées, conformément aux conventions suivantes.  
  
> [!NOTE]
>  Dans le .NET Framework version 2.0, architecture de processeur est ajoutée à l’identité de l’assembly et peut être spécifié en tant que partie de chaînes de nom d’assembly. Par exemple, « ProcessorArchitecture = msil ». Toutefois, il n’est pas inclus dans la chaîne retournée par la <xref:System.Type.AssemblyQualifiedName%2A> propriété, pour des raisons de compatibilité. Vous pouvez également charger des types en créant un <xref:System.Reflection.AssemblyName> objet et en le passant à la surcharge appropriée de la <xref:System.Reflection.Assembly.Load%2A> (méthode). Vous pouvez ensuite utiliser le <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> méthode pour charger des types à partir de l’assembly. Voir aussi <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Délimiteur|Signification|  
|---------------|-------------|  
|Barre oblique inverse (\\)|Caractère d’échappement.|  
|Accent grave (') | Précède un ou plusieurs chiffres représentant le nombre de paramètres de type, située à la fin du nom d’un type générique.|  
|Crochets ([])|Placez une liste d’arguments de type générique, pour un type générique construit ; dans une liste d’arguments de type, placez un type qualifié d’assembly.|  
|Virgule ()|Précède le nom de l’Assembly.|  
|Point (.)|Indique les identificateurs d’espace de noms.|  
|Signe plus (+)|Précède une classe imbriquée.|  
  
 Par exemple, le nom qualifié complet pour une classe peut ressembler à ceci :  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Si l’espace de noms ont été TopNamespace, la chaîne devrait faire précéder le signe plus (+) avec un caractère d’échappement (\\) pour éviter qu’il soit interprété comme un séparateur d’imbrication. La réflexion génère cette chaîne comme suit :  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Un « ++ » devient «\\+\\+ » et un «\\« devient »\\\\».  
  
 Ce nom qualifié peut être persistant et utilisé ultérieurement pour charger le <xref:System.Type>. Pour rechercher et charger un <xref:System.Type>, utilisez <xref:System.Type.GetType%2A> avec le type de nom uniquement ou avec le nom de type qualifié d’assembly. <xref:System.Type.GetType%2A> avec le type de nom uniquement recherchera le <xref:System.Type> dans l’assembly de l’appelant, puis dans l’assembly système. <xref:System.Type.GetType%2A> avec l’assembly de nom de type qualifié recherchera le <xref:System.Type> dans n’importe quel assembly.  
  
 Les noms de type peuvent inclure des caractères de fin qui indiquent des informations supplémentaires sur le type, par exemple si le type est un type référence, un type pointeur ou un type tableau. Pour récupérer le nom de type sans ces caractères de fin, utilisez `t.GetElementType().ToString()`, où `t` est le type.  
  
 Les espaces sont pertinents dans tous les composants de nom de type autre que le nom de l’assembly. Nom de l’assembly, espaces avant le séparateur ',', mais les espaces après le séparateur ',' sont ignorés.  
  
 Le nom d’un type générique se termine avec un accent grave (\`) suivi de chiffres représentant le nombre d’arguments de type générique. L’objectif de cette altération des noms est de permettre aux compilateurs prendre en charge des types génériques avec le même nom mais avec différents nombres de paramètres de type, qui se produisent dans la même portée. Par exemple, la réflexion retourne les noms tronqués `Tuple`1` and `Tuple`2` parmi les méthodes génériques `Tuple(Of T)` et `Tuple(Of T0, T1)` en Visual Basic, ou `Tuple<T>` et Tuple`\<T0, T1>` en Visual c#.  
  
 Pour les types génériques, la liste d’arguments de type est placée entre crochets et les arguments de type sont séparés par des virgules. Par exemple, un générique <xref:System.Collections.Generic.Dictionary%602> a deux paramètres de type. Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` avec des clés de type <xref:System.String> peut être représenté comme suit :  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Pour spécifier un type qualifié d’assembly dans une liste d’arguments de type, mettez le type qualifié d’assembly entre crochets. Sinon, les virgules qui séparent les parties du nom qualifié d’assembly sont interprétées comme délimitant les arguments de type supplémentaires. Par exemple, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` issu de MyAssembly.dll, avec des clés de type <xref:System.String>, peut être spécifiée comme suit :  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Un type qualifié d’assembly peut être placé entre crochets uniquement lorsqu’il apparaît dans une liste de paramètres de type. Les règles de recherche d’assemblys pour les types qualifiés et non qualifiés dans les listes de paramètres de type sont les mêmes que les règles pour les types non génériques qualifiés et non qualifiés.  
  
 Types Nullable sont un cas spécial de types génériques. Par exemple, un nullable <xref:System.Int32> est représentée par la chaîne « System.Nullable'1[System.Int32] ».  
  
> [!NOTE]
>  En c#, C++ et Visual Basic, vous pouvez également obtenir les types nullable à l’aide des opérateurs de type. Par exemple, autorisant <xref:System.Boolean> type renvoyé par `typeof(Nullable<bool>)` en c#, par `Nullable<Boolean>::typeid` en C++ et par `GetType(Nullable(Of Boolean))` en Visual Basic.  
  
 Le tableau suivant présente la syntaxe à utiliser avec `GetType` pour différents types.  
  
|Pour obtenir|Utilisez|  
|------------|---------|  
|Un nullable <xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Un pointeur non managé vers `MyType`|`Type.GetType("MyType*")`|  
|Un pointeur non managé vers un pointeur vers `MyType`|`Type.GetType("MyType**")`|  
|Un pointeur managé ou la référence à `MyType`|`Type.GetType("MyType&")`. Notez que contrairement aux pointeurs, les références sont limitées à un niveau.|  
|Une classe parente et une classe imbriquée|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Un tableau unidimensionnel avec une limite inférieure de 0|`Type.GetType("MyArray[]")`|  
|Un tableau unidimensionnel avec une limite inférieure est inconnue|`Type.GetType("MyArray[*]")`|  
|Un tableau à n dimensions|Une virgule (,) entre les crochets total de n-1 fois. Par exemple, `System.Object[,,]` représente un à trois dimensions `Object` tableau.|  
|Un à deux dimensions un tableau|`Type.GetType("MyArray[][]")`|  
|Un tableau rectangulaire à deux dimensions avec des limites inférieures sont inconnues|`Type.GetType("MyArray[,]")`|  
|Un type générique avec un argument de type|``Type.GetType("MyGenericType`1[MyType]")``|  
|Un type générique avec deux arguments de type|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Un type générique avec deux arguments de type qualifié d’assembly|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Un type générique qualifié d’assembly avec un argument de type qualifié d’assembly|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Un type générique dont l’argument de type est un type générique avec deux arguments de type|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée. 
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.  
  
ou 
 <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide. Par exemple, « MyType [, *,] ».  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée, et l’assembly a été compilé avec une version ultérieure.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type à obtenir. Si le paramètre <paramref name="typeResolver" /> est fourni, le nom de type peut être n'importe quelle chaîne pouvant être résolue par <paramref name="typeResolver" />. Si le paramètre <paramref name="assemblyResolver" /> est fourni ou si la résolution de type standard est utilisée, <paramref name="typeName" /> doit être un nom d'assembly complet (consultez <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l'assembly en cours d'exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</param>
        <param name="assemblyResolver">Méthode qui trouve et retourne l'assembly spécifié dans <paramref name="typeName" />. Le nom de l'assembly est passé à <paramref name="assemblyResolver" /> en tant qu'objet <see cref="T:System.Reflection.AssemblyName" />. Si <paramref name="typeName" /> ne contient pas le nom d'un assembly, <paramref name="assemblyResolver" /> n'est pas appelé. Si <paramref name="assemblyResolver" /> n'est pas fourni, une résolution d'assembly standard est effectuée.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables. Vous risqueriez d'élever les privilèges du code malveillant. Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</param>
        <param name="typeResolver">Méthode qui trouve et retourne le type spécifié par <paramref name="typeName" /> à partir de l'assembly retourné par <paramref name="assemblyResolver" /> ou par la résolution d'assembly standard. Si aucun assembly n'est fourni, la méthode <paramref name="typeResolver" /> peut en fournir un. La méthode prend également un paramètre qui spécifie s'il faut exécuter une recherche non sensible à la casse ; <see langword="false" /> est passé à ce paramètre.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</param>
        <summary>Obtient le type avec le nom spécifié et éventuellement des méthodes personnalisées permettant de résoudre l'assembly et le type.</summary>
        <returns>Type portant le nom spécifié, ou <see langword="null" /> si le type est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scénarios d’utilisation pour cette méthode et les détails sur la `assemblyResolver` et `typeResolver` paramètres se trouvent dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
> [!NOTE]
>  Si `typeName` est introuvable, l’appel à la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> retourne de la méthode `null`. Il ne lève pas d’exception. Pour contrôler si une exception est levée, appelez une surcharge de la <xref:System.Type.GetType%2A> méthode qui a un `throwOnError` paramètre.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour le `throwOnError` et `ignoreCase` paramètres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.ArgumentException">Une erreur se produit quand <paramref name="typeName" /> est analysé dans un nom de type et un nom d’assembly (par exemple, quand le nom de type simple inclut un caractère spécial sans séquence d’échappement).  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.  
  
ou 
 <paramref name="typeName" /> contient un nom d’assembly non valide.  
  
ou 
 <paramref name="typeName" /> est un nom d’assembly valide sans nom de type.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type à obtenir. Si le paramètre <paramref name="typeResolver" /> est fourni, le nom de type peut être n'importe quelle chaîne pouvant être résolue par <paramref name="typeResolver" />. Si le paramètre <paramref name="assemblyResolver" /> est fourni ou si la résolution de type standard est utilisée, <paramref name="typeName" /> doit être un nom d'assembly complet (consultez <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l'assembly en cours d'exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</param>
        <param name="assemblyResolver">Méthode qui trouve et retourne l'assembly spécifié dans <paramref name="typeName" />. Le nom de l'assembly est passé à <paramref name="assemblyResolver" /> en tant qu'objet <see cref="T:System.Reflection.AssemblyName" />. Si <paramref name="typeName" /> ne contient pas le nom d'un assembly, <paramref name="assemblyResolver" /> n'est pas appelé. Si <paramref name="assemblyResolver" /> n'est pas fourni, une résolution d'assembly standard est effectuée.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables. Vous risqueriez d'élever les privilèges du code malveillant. Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</param>
        <param name="typeResolver">Méthode qui trouve et retourne le type spécifié par <paramref name="typeName" /> à partir de l'assembly retourné par <paramref name="assemblyResolver" /> ou par la résolution d'assembly standard. Si aucun assembly n'est fourni, la méthode peut en fournir un. La méthode prend également un paramètre qui spécifie s'il faut exécuter une recherche non sensible à la casse ; <see langword="false" /> est passé à ce paramètre.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />. <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes. Consultez la section Exceptions.</param>
        <summary>Obtient le type portant le nom spécifié, en indiquant s'il faut lever une exception si le type est introuvable et, éventuellement, en fournissant des méthodes personnalisées qui permettent de résoudre l'assembly et le type.</summary>
        <returns>Type portant le nom spécifié. Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée. Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />. Consultez la section Exceptions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Scénarios d’utilisation pour cette méthode et les détails sur la `assemblyResolver` et `typeResolver` paramètres se trouvent dans le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
 Appel de cette surcharge de méthode est le même que si vous appelez le <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode et en spécifiant `false` pour le `ignoreCase` paramètre.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée. 
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.  
  
ou 
 <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Une erreur se produit quand <paramref name="typeName" /> est analysé dans un nom de type et un nom d’assembly (par exemple, quand le nom de type simple inclut un caractère spécial sans séquence d’échappement).  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide (par exemple, « MyType[,*,] »).  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et l’assembly ou l’une de ses dépendances est introuvable.  
  
ou 
 <paramref name="typeName" /> contient un nom d’assembly non valide.  
  
ou 
 <paramref name="typeName" /> est un nom d’assembly valide sans nom de type.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom du type à obtenir. Si le paramètre <paramref name="typeResolver" /> est fourni, le nom de type peut être n'importe quelle chaîne pouvant être résolue par <paramref name="typeResolver" />. Si le paramètre <paramref name="assemblyResolver" /> est fourni ou si la résolution de type standard est utilisée, <paramref name="typeName" /> doit être un nom d'assembly complet (consultez <see cref="P:System.Type.AssemblyQualifiedName" />), à moins que le type ne se trouve dans l'assembly en cours d'exécution ou dans Mscorlib.dll, cas dans lequel il suffit de fournir le nom de type qualifié par son espace de noms.</param>
        <param name="assemblyResolver">Méthode qui trouve et retourne l'assembly spécifié dans <paramref name="typeName" />. Le nom de l'assembly est passé à <paramref name="assemblyResolver" /> en tant qu'objet <see cref="T:System.Reflection.AssemblyName" />. Si <paramref name="typeName" /> ne contient pas le nom d'un assembly, <paramref name="assemblyResolver" /> n'est pas appelé. Si <paramref name="assemblyResolver" /> n'est pas fourni, une résolution d'assembly standard est effectuée.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables. Vous risqueriez d'élever les privilèges du code malveillant. Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.</param>
        <param name="typeResolver">Méthode qui trouve et retourne le type spécifié par <paramref name="typeName" /> à partir de l'assembly retourné par <paramref name="assemblyResolver" /> ou par la résolution d'assembly standard. Si aucun assembly n'est fourni, la méthode peut en fournir un. La méthode prend également un paramètre qui spécifie s'il faut exécuter une recherche non sensible à la casse ; la valeur de <paramref name="ignoreCase" /> est passée à ce paramètre.  
  
Attention   Ne passez pas de méthodes provenant d’appelants inconnus ou non fiables.</param>
        <param name="throwOnError"><see langword="true" /> pour lever une exception si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" />. <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes. Consultez la section Exceptions.</param>
        <param name="ignoreCase"><see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <paramref name="typeName" /> et <see langword="false" /> pour effectuer une recherche qui respecte la casse de <paramref name="typeName" />.</param>
        <summary>Obtient le type portant le nom spécifié, en indiquant s'il faut effectuer une recherche qui respecte la casse et si une exception doit être levée si le type est introuvable, et éventuellement, en fournissant des méthodes personnalisées qui permettent de résoudre l'assembly et le type.</summary>
        <returns>Type portant le nom spécifié. Si le type est introuvable, le paramètre <paramref name="throwOnError" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée. Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwOnError" />. Consultez la section Exceptions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode et ses surcharges associées (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> et <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) pour remplacer l’implémentation par défaut de la <xref:System.Type.GetType%2A> méthode avec des implémentations plus flexibles. En fournissant vos propres méthodes pour résoudre les noms de type et les noms des assemblys qui contiennent les, vous pouvez procédez comme suit :  
  
-   Contrôler la version d’un assembly d’un type est chargé à partir de.  
  
-   Fournir un autre emplacement pour rechercher un nom de type qui n’inclut pas un nom d’assembly.  
  
-   Charger des assemblys à l’aide de noms d’assemblys partiels.  
  
-   Retournez les sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le common language runtime (CLR).  
  
 Par exemple, sérialisation avec tolérance de version de cette méthode afin de pouvoir rechercher un assembly « best fit » à l’aide d’un nom partiel. Autres surcharges de la <xref:System.Type.GetType%2A> méthode requièrent un nom de type qualifié d’assembly, qui inclut le numéro de version.  
  
 Autres mises en œuvre du système de type devra peut-être retourner des sous-classes de <xref:System.Type?displayProperty=nameWithType> qui ne sont pas créés par le CLR ; tous les types qui sont retournées par les autres surcharges de la <xref:System.Type.GetType%2A> méthode sont des types de runtime.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Notes d’utilisation  
 Cette surcharge de méthode et ses surcharges associées analysent `typeName` dans le nom d’un type et le nom d’un assembly, puis de résoudre les noms. Résolution du nom de l’assembly se produit avant la résolution du nom de type, car un nom de type doit être résolu dans le contexte d’un assembly.  
  
> [!NOTE]
>  Si vous n’êtes pas familiarisé avec le concept de noms de type qualifié d’assembly, consultez le <xref:System.Type.AssemblyQualifiedName%2A> propriété.  
  
 Si `typeName` n’est pas un nom qualifié d’assembly, résolution d’assembly est ignorée. Les noms de type non qualifiés peuvent être résolus dans le contexte de Mscorlib.dll ou l’assembly en cours d’exécution, ou vous pouvez éventuellement fournir un assembly dans le `typeResolver` paramètre. Les effets d’inclure ou omettre le nom de l’assembly pour différents types de résolution de noms sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section.  
  
 Notes générales d’utilisation :  
  
-   Ne passez pas de méthodes à `assemblyResolver` ou `typeResolver` si elles proviennent d’appelants inconnus ou non approuvés. Utilisez uniquement les méthodes que vous fournissez ou avec lesquelles vous êtes familiarisé.  
  
    > [!CAUTION]
    >  À l’aide de méthodes provenant d’appelants inconnus ou non fiables peut entraîner une élévation de privilèges pour le code malveillant.  
  
-   Si vous omettez le `assemblyResolver` et/ou `typeResolver` paramètres, la valeur de la `throwOnError` paramètre est passé aux méthodes qui effectuent la résolution par défaut.  
  
-   Si `throwOnError` est `true`, cette méthode lève un <xref:System.TypeLoadException> lorsque `typeResolver` retourne `null`et un <xref:System.IO.FileNotFoundException> lorsque `assemblyResolver` retourne `null`.  
  
-   Cette méthode n’intercepte pas les exceptions levées par `assemblyResolver` et `typeResolver`. Vous êtes responsable de toutes les exceptions levées par les méthodes de résolution.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Résolution d’assemblys  
 Le `assemblyResolver` méthode reçoit un <xref:System.Reflection.AssemblyName> objet, qui est généré en analysant le nom d’assembly de chaîne qui est inclus dans `typeName`. Si `typeName` ne contient pas de nom d’assembly, `assemblyResolver` n’est pas appelée et `null` est passé à `typeResolver`.  
  
 Si `assemblyResolver` n’est pas fourni, standard assembly détection permet de localiser l’assembly. Si `assemblyResolver` est fourni, le <xref:System.Type.GetType%2A> méthode n’effectue pas la détection standard ; dans ce cas vous devez vous assurer que votre `assemblyResolver` peut gérer tous les assemblys que vous lui transmettez.  
  
 Le `assemblyResolver` méthode doit retourner `null` si l’assembly ne peut pas être résolu. Si `assemblyResolver` retourne `null`, `typeResolver` n’est pas appelée et qu’aucun traitement supplémentaire se produit ; en outre, si `throwOnError` est `true`, un <xref:System.IO.FileNotFoundException> est levée.  
  
 Si le <xref:System.Reflection.AssemblyName> qui est passé à `assemblyResolver` est un partiel nom, un ou plusieurs de ses parties sont `null`. Par exemple, si elle ne dispose d’aucune version, la <xref:System.Reflection.AssemblyName.Version%2A> propriété est `null`. Si le <xref:System.Reflection.AssemblyName.Version%2A> propriété, le <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriété et le <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> tout retour de la méthode `null`, puis uniquement le nom simple de l’assembly a été fourni. Le `assemblyResolver` méthode peut utiliser ou ignorer toutes les parties du nom de l’assembly.  
  
 Les effets des options de résolution d’assembly différentes sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Résolution des Types  
 Si `typeName` ne spécifie pas un nom d’assembly, `typeResolver` est toujours appelé. Si `typeName` spécifie un nom d’assembly, `typeResolver` est appelé uniquement lorsque le nom de l’assembly est résolu avec succès. Si `assemblyResolver` ou détection retourne d’assembly standard `null`, `typeResolver` n’est pas appelée.  
  
 Le `typeResolver` méthode reçoit trois arguments :  
  
-   L’assembly à rechercher ou `null` si `typeName` ne contient pas un nom d’assembly.  
  
-   Le nom simple du type. Dans le cas d’un type imbriqué, il s’agit du type de conteneur extérieur. Dans le cas d’un type générique, il est le nom simple du type générique.  
  
-   Valeur booléenne qui est `true` si la casse des noms de type doit être ignorée.  
  
 L’implémentation détermine la façon dont ces arguments sont utilisées. Le `typeResolver` méthode doit retourner `null` si elle ne peut pas résoudre le type. Si `typeResolver` retourne `null` et `throwOnError` est `true`, cette surcharge de <xref:System.Type.GetType%2A> lève un <xref:System.TypeLoadException>.  
  
 Les effets des options de résolution de type différent sont affichés sous la forme d’une table dans le [résolution des noms mixtes](#mixed_name_resolution) section, pour les noms de types simples et qualifiés d’assembly.  
  
#### <a name="resolving-nested-types"></a>Résolution des Types imbriqués  
 Si `typeName` est un type imbriqué, seul le nom de l’extérieur qui contient le type est passé à `typeResolver`. Lorsque `typeResolver` retourne ce type, le <xref:System.Type.GetNestedType%2A> méthode est appelée de manière récursive jusqu'à ce que le type imbriqué plus profond a été résolu.  
  
#### <a name="resolving-generic-types"></a>Résolution des Types génériques  
 Le <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre les types génériques : Tout d’abord pour résoudre le type générique proprement dit, puis pour résoudre ses arguments de type. Si un argument de type est générique, <xref:System.Type.GetType%2A> est appelée de manière récursive pour résoudre ses arguments de type et ainsi de suite.  
  
 La combinaison de `assemblyResolver` et `typeResolver` que vous fournissez doit être capable de résoudre tous les niveaux de cette récursivité. Par exemple, supposez que vous fournissez un `assemblyResolver` qui contrôle le chargement de `MyAssembly`. Supposons que vous souhaitez résoudre le type générique `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` en Visual Basic). Vous pouvez passer le nom de type générique suivant :  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Notez que `MyType` est l’argument de type qualifié d’assembly uniquement. Les noms de la <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String> classes ne sont pas qualifiés d’assembly. Votre `typeResolver` doit être en mesure de gérer un assembly ou `null`, car il recevra `null` pour <xref:System.Collections.Generic.Dictionary%602> et <xref:System.String>. Il peut gérer ce cas en appelant une surcharge de la <xref:System.Type.GetType%2A> méthode qui prend une chaîne, car les deux noms de type non qualifiés sont dans Mscorlib.dll :  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Le `assemblyResolver` (méthode) n’est pas appelée pour le type de dictionnaire et le type de chaîne, car ces noms de types ne sont pas qualifiés d’assembly.  
  
 Supposons maintenant qu’au lieu de `System.String`, le premier type d’argument générique est `YourType`, à partir de `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Étant donné que cet assembly n’est ni Mscorlib.dll, ni l’assembly en cours d’exécution, vous ne pouvez pas résoudre `YourType` sans un nom qualifié d’assembly. Étant donné que votre `assemblyResolve` sera appelée de manière récursive, il doit être en mesure de gérer ce cas. Au lieu de retourner `null` pour les assemblys autres que `MyAssembly`, il exécute maintenant un chargement d’assembly à l’aide de fourni <xref:System.Reflection.AssemblyName> objet.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Au [Notes d’utilisation](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Résolution de noms de Type avec des caractères spéciaux  
 Certains caractères ont des significations spéciales dans les noms qualifiés d’assembly. Si un nom de type simple contient ces caractères, les caractères provoquent des erreurs d’analyse lorsque le nom simple fait partie d’un nom qualifié d’assembly. Pour éviter les erreurs d’analyse, vous devez échapper les caractères spéciaux par une barre oblique inverse avant de pouvoir passer le nom qualifié d’assembly pour le <xref:System.Type.GetType%2A> (méthode). Par exemple, si un type est nommé `Strange]Type`, le caractère d’échappement doit être ajouté avant les crochets comme suit : `Strange\]Type`.  
  
> [!NOTE]
>  Les noms de ces caractères spéciaux ne peut pas être créés en Visual Basic ou c#, mais peuvent être créées à l’aide du langage intermédiaire Microsoft (MSIL) ou par l’émission d’assemblys dynamiques.  
  
 Le tableau suivant présente les caractères spéciaux pour les noms de type.  
  
|Caractère|Signification|  
|---------------|-------------|  
|`,` (comma)|Délimiteur pour les noms qualifiés d’assembly.|  
|`[]` (les crochets)|Comme une paire de suffixe, indique un type de tableau ; comme une paire de séparateurs, englobe les listes d’arguments génériques et les noms qualifiés d’assembly.|  
|`&` (esperluette)|En guise de suffixe, indique qu’un type est un type référence.|  
|`*` (astérisque)|En guise de suffixe, indique qu’un type est un type pointeur.|  
|`+` (plus)|Délimiteur pour les types imbriqués.|  
|`\` barre oblique inverse)|Caractère d’échappement.|  
  
 Propriétés, telles que <xref:System.Type.AssemblyQualifiedName%2A> retour correctement les chaînes d’échappement. Vous devez passer des chaînes correctement avec la séquence d’échappement pour le <xref:System.Type.GetType%2A> (méthode). À son tour, le <xref:System.Type.GetType%2A> méthode passe les noms correctement avec la séquence d’échappement à `typeResolver` et pour les méthodes de résolution de type par défaut. Si vous devez comparer un nom à un nom sans séquence d’échappement dans `typeResolver`, vous devez supprimer les caractères d’échappement.  
  
 Au [Notes d’utilisation](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Résolution de noms mixte  
 Le tableau suivant résume les interactions entre `assemblyResolver`, `typeResolver`et la résolution de noms par défaut, pour toutes les combinaisons de nom de type et nom de l’assembly dans `typeName`:  
  
|Contenu du nom de type|Méthode de programme de résolution d’assembly|Méthode de programme de résolution de type|Résultat|  
|---------------------------|------------------------------|--------------------------|------------|  
|type, l’assembly|null|null|Équivalent à l’appel le <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode.|  
|type, l’assembly|fourni|null|`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly. Si l’assembly est résolu, le <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode est utilisée pour charger le type à partir de l’assembly ; sinon, il n’existe aucune tentative de résoudre le type.|  
|type, l’assembly|null|fourni|Équivalent à la conversion du nom de l’assembly à un <xref:System.Reflection.AssemblyName> objet et en appelant le <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> surcharge de méthode pour obtenir de l’assembly. Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.|  
|type, l’assembly|fourni|fourni|`assemblyResolver` Retourne l’assembly ou `null` si elle ne peut pas résoudre l’assembly. Si l’assembly est résolu, il est passé à `typeResolver`; sinon, `typeResolver` n’est pas appelée et il n’existe aucune autre tentative de résoudre le type.|  
|type|NULL, fourni|null|Équivalent à l’appel le <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> surcharge de méthode. Étant donné que le nom de l’assembly n’est pas fourni, Mscorlib.dll et l’assembly en cours d’exécution sont recherchés. Si `assemblyResolver` est fourni, il est ignoré.|  
|type|NULL, fourni|fourni|`typeResolver` est appelée, et `null` est passé pour l’assembly. `typeResolver` peut fournir un type à partir de n’importe quel assembly, y compris les assemblys qu'il charge à cette fin. Si `assemblyResolver` est fourni, il est ignoré.|  
|assembly|NULL, fourni|NULL, fourni|Un <xref:System.IO.FileLoadException> est levée, car le nom de l’assembly est analysé comme s’il s’agissait d’un nom de type qualifié d’assembly. Cela entraîne un nom d’assembly non valide.|  
  
 Retour à : [Notes d’utilisation](#usage_notes), [résolution d’assemblys](#resolving_assemblies), [résolution des Types](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> a la valeur <see langword="true" /> et le type est introuvable.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée. 
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.  
  
ou 
 <paramref name="typeName" /> représente un tableau de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Une erreur se produit quand <paramref name="typeName" /> est analysé dans un nom de type et un nom d’assembly (par exemple, quand le nom de type simple inclut un caractère spécial sans séquence d’échappement).  
  
ou 
 <paramref name="throwOnError" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide (par exemple, « MyType[,*,] »).  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.  
  
ou 
 <paramref name="typeName" /> contient un nom d’assembly non valide.  
  
ou 
 <paramref name="typeName" /> est un nom d’assembly valide sans nom de type.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Tableau d'objets dont les types sont à déterminer.</param>
        <summary>Obtient les types des objets dans le tableau spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Type" /> représentant les types des éléments correspondants dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.Type.GetTypeArray%2A> méthode pour répertorier les types des éléments d’un tableau.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> est <see langword="null" />.  
  
ou 
Au moins un des éléments de <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Les initialiseurs de classe sont appelés et au moins l’un d’eux lève une exception.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Type dont le code de type sous-jacent doit être obtenu.</param>
        <summary>Obtient le code du type sous-jacent du <see cref="T:System.Type" /> spécifié.</summary>
        <returns>Code du type sous-jacent ou <see cref="F:System.TypeCode.Empty" /> si <paramref name="type" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous héritez de <xref:System.Type>, vous pouvez modifier le comportement de cette méthode en substituant le <xref:System.Type.GetTypeCodeImpl%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment la <xref:System.TypeCode> énumération peut être utilisée. Dans un bloc de décision le `WriteObjectInfo` (méthode), le <xref:System.TypeCode> d’un <xref:System.Object> paramètre est examiné, et un message approprié est écrite dans la console.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code du type sous-jacent de cette instance <see cref="T:System.Type" />.</summary>
        <returns>Code du type sous-jacent.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode fournit l’implémentation pour le `static` (en c#) ou `Shared` (en Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> (méthode). Lorsque vous héritez de <xref:System.Type>, vous pouvez substituer cette méthode pour fournir votre propre implémentation de <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le type associé à l'identificateur de classe (CLSID) spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID du type à obtenir.</param>
        <summary>Obtient le type associé à l'identificateur de classe (CLSID) spécifié.</summary>
        <returns><see langword="System.__ComObject" /> que le CLSID soit valide ou non.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété afin de déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le`__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Consultez l’exemple pour obtenir une illustration.  
  
 Le <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> surcharge ignore toute exception qui peut se produire lorsque vous instanciez un <xref:System.Type> objet basé sur le `clsid` argument. Notez qu’aucune exception n’est levée si `clsid` est introuvable dans le Registre.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de Microsoft Word [objet Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) pour récupérer un type COM qui représente l’application Microsoft Word. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et se ferme en appelant le [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (méthode).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leur <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID de .NET Framework des objets, vous ne pouvez pas utiliser qui <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet qui est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID du type à obtenir.</param>
        <param name="throwOnError"><see langword="true" /> pour lever toute exception qui se produit.  
  
ou 
 <see langword="false" /> pour ignorer toute exception qui se produit.</param>
        <summary>Obtient le type associé à l'identificateur de classe (CLSID) spécifié, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</summary>
        <returns><see langword="System.__ComObject" /> que le CLSID soit valide ou non.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété afin de déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Consultez l’exemple pour obtenir une illustration.  
  
 Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais n’échouera pas du CLSID non inscrit.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de Microsoft Word [objet Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) pour récupérer un type COM qui représente l’application Microsoft Word. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et se ferme en appelant le [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (méthode). Une exception est levée si une erreur se produit pendant le chargement du type.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leur <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID de .NET Framework des objets, vous ne pouvez pas utiliser qui <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet qui est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID du type à obtenir.</param>
        <param name="server">Serveur à partir duquel le type doit être chargé. Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</param>
        <summary>Obtient le type associé à l'identificateur de classe (CLSID) spécifié à partir du serveur défini.</summary>
        <returns><see langword="System.__ComObject" /> que le CLSID soit valide ou non.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété afin de déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de Microsoft Word [objet Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et se ferme en appelant le [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (méthode).  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leur <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que la méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID de .NET Framework des objets, vous ne pouvez pas utiliser qui <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme le montre l’exemple suivant.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet qui est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">CLSID du type à obtenir.</param>
        <param name="server">Serveur à partir duquel le type doit être chargé. Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</param>
        <param name="throwOnError"><see langword="true" /> pour lever toute exception qui se produit.  
  
ou 
 <see langword="false" /> pour ignorer toute exception qui se produit.</param>
        <summary>Obtient le type associé à l'identificateur de classe (CLSID) spécifié à partir du serveur défini, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</summary>
        <returns><see langword="System.__ComObject" /> que le CLSID soit valide ou non.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.GetTypeFromCLSID%2A> méthode prend en charge l’accès à liaison tardive aux objets COM non managés à partir d’applications .NET Framework lorsque vous connaissez l’identificateur de classe de l’objet COM (CLSID).  L’identificateur de classe pour les classes COM est défini dans la clé HKEY_CLASSES_ROOT\CLSID du Registre. Vous pouvez récupérer la valeur de la <xref:System.Type.IsCOMObject%2A> propriété afin de déterminer si le type retourné par cette méthode est un objet COM.  
  
> [!TIP]
>  Vous pouvez appeler la <xref:System.Type.GetTypeFromProgID%2A> méthode pour l’accès à liaison tardive à COM objets dont identificateur programmatique (ProgID) que vous connaissez.  
  
 Instanciation d’un objet COM non managé à partir de son CLSID est un processus en deux étapes :  
  
1.  Obtenir un <xref:System.Type> objet qui représente le `__ComObject` qui correspond au CLSID en appelant le <xref:System.Type.GetTypeFromCLSID%2A> (méthode).  
  
2.  Appelez le <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> pour instancier l’objet COM (méthode).  
  
 Exceptions telles que <xref:System.OutOfMemoryException> sera levée lors de la spécification `true` pour `throwOnError`, mais n’échouera pas du CLSID non inscrit.  
  
   
  
## Examples  
 L’exemple suivant utilise le CLSID de Microsoft Word [objet Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) pour récupérer un type COM qui représente l’application Microsoft Word à partir d’un serveur nommé computer17.central.contoso.com. Il instancie ensuite le type en appelant le <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> (méthode) et se ferme en appelant le [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) (méthode). Une exception est levée si une erreur se produit pendant le chargement du type.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Cette méthode est destinée à utiliser lorsque vous travaillez avec des objets COM, pas avec les objets .NET Framework. Tous les objets, y compris ceux qui sont visibles par COM gérés par (autrement dit, leur <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribut est <see langword="true" />) ont un GUID qui est retourné par la <see cref="P:System.Type.GUID" /> propriété. Bien que le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> méthode retourne un <see cref="T:System.Type" /> objet qui correspond au GUID d’un objet managé particulier, vous ne pouvez pas utiliser qui <see cref="T:System.Type" /> objet pour créer une instance de type en appelant le <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode, comme dans l’exemple suivant montre.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Au lieu de cela, le <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> doit uniquement être utilisé pour récupérer le GUID d’un objet COM non managé et résultant <see cref="T:System.Type" /> objet qui est passé à la <see cref="M:System.Activator.CreateInstance(System.Type)" /> méthode doit représenter un objet COM non managé.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Objet qui fait référence au type.</param>
        <summary>Obtient le type référencé par le handle de type spécifié.</summary>
        <returns>Le type référencé par le <see cref="T:System.RuntimeTypeHandle" /> spécifié, ou <see langword="null" /> si la propriété <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les handles sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.GetTypeFromHandle%2A> méthode pour obtenir un <xref:System.Type> de l’objet à partir d’un <xref:System.RuntimeTypeHandle> fournies par le <xref:System.Type.GetTypeHandle%2A> (méthode).  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le type associé à l'identificateur de programme (ProgID) spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Identificateur de programme (ProgID) du type à obtenir.</param>
        <summary>Obtient le type associé à l'identificateur de programme (ProgID) spécifié, retournant null en cas d'erreur pendant le chargement de <see cref="T:System.Type" />.</summary>
        <returns>Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ProgID ne sont pas utilisés dans le Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Identificateur de programme (ProgID) du type à obtenir.</param>
        <param name="throwOnError"><see langword="true" /> pour lever toute exception qui se produit.  
  
ou 
 <see langword="false" /> pour ignorer toute exception qui se produit.</param>
        <summary>Obtient le type associé à l'identificateur de programme (ProgID) spécifié, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</summary>
        <returns>Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID, indiquant s’il faut lever une exception si le ProgID n’est pas valide. L’exemple affiche ensuite le ClassID associé au ProgID, ainsi que n’importe quel message d’exception approprié.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Le progID spécifié n’est pas inscrit.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">Identificateur de programme (ProgID) du type à obtenir.</param>
        <param name="server">Serveur à partir duquel le type doit être chargé. Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</param>
        <summary>Obtient le type associé à l'identificateur de programme (ProgID) spécifié à partir du serveur défini, retournant null en cas d'erreur pendant le chargement du type.</summary>
        <returns>Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID et nom de serveur. L’exemple puis affiche le ClassID associé au ProgID, ou lève une exception si le ProgID ou le nom du serveur n’est pas valide.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">Identificateur de programme (ProgID) du <see cref="T:System.Type" /> à obtenir.</param>
        <param name="server">Serveur à partir duquel le type doit être chargé. Si le nom de serveur est <see langword="null" />, cette méthode revient automatiquement à la machine locale.</param>
        <param name="throwOnError"><see langword="true" /> pour lever toute exception qui se produit.  
  
ou 
 <see langword="false" /> pour ignorer toute exception qui se produit.</param>
        <summary>Obtient le type associé à l'identificateur de programme (ProgID) spécifié à partir du serveur défini, indiquant s'il faut lever une exception en cas d'erreur pendant le chargement du type.</summary>
        <returns>Type associé à l'identificateur de programme (ProgID) spécifié si <paramref name="progID" /> est une entrée valide dans le Registre et qu'un type lui est associé ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour la prise en charge COM. ID de programme ne sont pas utilisés dans Microsoft .NET Framework, car ils ont été remplacés par le concept d’espace de noms.  
  
   
  
## Examples  
 L’exemple suivant récupère un type en passant un ProgID et nom de serveur. L’exemple affiche ensuite le ClassID associé au ProgID, en spécifiant s’il faut lever une exception si le ProgID ou le nom du serveur n’est pas valide.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Le progID spécifié n’est pas inscrit.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objet dont il faut obtenir le handle de type.</param>
        <summary>Obtient le handle pour le <see cref="T:System.Type" /> d'un objet spécifié.</summary>
        <returns>Handle pour le <see cref="T:System.Type" /> de l'objet <see cref="T:System.Object" /> spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les handles sont valides uniquement dans le domaine d’application dans lequel ils ont été obtenus.  
  
   
  
## Examples  
 L’exemple suivant définit la classe `MyClass1`, obtient une instance de celui-ci et récupère le handle de runtime de l’objet.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> est <see langword="null" />.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le GUID associé à <see cref="T:System.Type" />.</summary>
        <value>GUID associé à <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un GUID est associé à un type en utilisant la <xref:System.Runtime.InteropServices.GuidAttribute> attribut.  
  
   
  
## Examples  
 L’exemple suivant crée la classe `MyClass1` avec une méthode publique, crée un `Type` objet correspondant à `MyClass1`et obtient le <xref:System.Guid> structure à l’aide de la `GUID` propriété de la `Type` classe.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel englobe ou se réfère à un autre type, c'est-à-dire si le <see cref="T:System.Type" /> actuel est un tableau ou un pointeur ou encore s'il est passé par référence.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est un tableau ou un pointeur ou encore s'il est passé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, Type.GetType("Int32[]"). HasElementType retourne `true`, mais Type.GetType("Int32"). HasElementType retourne `false`. HasElementType retourne également `true` pour « Int32 * » et « Int32 & ».  
  
 Si actuel <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant retourne `true` ou `false` selon ou non l’objet est un tableau, un type référence ou un pointeur.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.HasElementType" /> et détermine si le <see cref="T:System.Type" /> actuel englobe ou se réfère à un autre type ; c'est-à-dire si le <see cref="T:System.Type" /> actuel est un tableau ou un pointeur ou encore s'il est passé par référence.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est un tableau ou un pointeur ou encore s'il est passé par référence ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, Type.GetType("Int32[]"). HasElementTypeImpl retourne `true`, mais Type.GetType("Int32"). HasElementTypeImpl retourne `false`. HasElementTypeImpl retourne également `true` pour « Int32 * » et « Int32 & ».  
  
   
  
## Examples  
 L’exemple suivant définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode). La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Appelle un membre spécifique du <see cref="T:System.Type" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.  
  
ou 
Une chaîne vide ("") pour appeler le membre par défaut.  
  
ou 
Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</param>
        <param name="invokeAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche. L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. Il n'est pas nécessaire de spécifier le type de recherche. Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />. Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</param>
        <param name="target">Objet sur lequel appeler le membre spécifié.</param>
        <param name="args">Tableau contenant les arguments à passer au membre à appeler.</param>
        <summary>Appelle le membre défini, à l'aide des contraintes de liaison spécifiées et correspondant à la liste d'arguments spécifiée.</summary>
        <returns>Objet représentant la valeur de retour du membre appelé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le classeur vers le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont disponibles en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un jeu de modificateurs de recherche définis dans le classeur.  
  
 Une fois la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes sont recherchés en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est responsable de la sélection de la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 Restrictions d’accès sont ignorées pour le code totalement approuvé ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par le biais <xref:System.Reflection> chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante à l’aide de code semblable au suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve à la chaîne « b ».  
  
 Lorsque vous appelez un `IDispatch` membre, vous pouvez spécifier le DispID au lieu du nom de membre, en utilisant le format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que Rechercher par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
   
  
## Examples  
 L’exemple suivant utilise `InvokeMember` pour accéder aux membres d’un type.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.  
  
ou 
 <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.  
  
ou 
Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
ou 
L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Le membre spécifié est un initialiseur de classe.</exception>
        <exception cref="T:System.MissingFieldException">Le champ ou la propriété est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.  
  
ou 
L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondent aux critères de liaison.</exception>
        <exception cref="T:System.NotSupportedException">Le .NET Compact Framework ne prend pas en charge cette méthode.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés. Autrement dit, la propriété <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quel que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.  
  
ou 
Une chaîne vide ("") pour appeler le membre par défaut.  
  
ou 
Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</param>
        <param name="invokeAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche. L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. Il n'est pas nécessaire de spécifier le type de recherche. Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />. Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</param>
        <param name="target">Objet sur lequel appeler le membre spécifié.</param>
        <param name="args">Tableau contenant les arguments à passer au membre à appeler.</param>
        <param name="culture">Objet représentant le paramètre régional de globalisation à utiliser si nécessaire, notamment pour les conversions spécifiques aux paramètres régionaux telles que la conversion d'un type numérique <see cref="T:System.String" /> en type <see cref="T:System.Double" />.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel.</param>
        <summary>Appelle le membre spécifié, à l'aide des contraintes de liaison spécifiées et correspondant à la liste d'arguments et à la culture spécifiées.</summary>
        <returns>Objet représentant la valeur de retour du membre appelé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bien que le binder par défaut ne traite pas <xref:System.Globalization.CultureInfo> (le `culture` paramètre), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `culture`.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le classeur vers le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont disponibles en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un jeu de modificateurs de recherche définis dans le classeur.  
  
 Une fois la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes sont recherchés en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est responsable de la sélection de la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 Restrictions d’accès sont ignorées pour le code totalement approuvé ; Autrement dit, les propriétés, méthodes, champs et constructeurs privés sont accessibles et peuvent être appelées via la réflexion chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String` vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante à l’aide de code semblable au suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve à la chaîne « b ».  
  
 Lorsque vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID au lieu du nom de membre, en utilisant le format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que Rechercher par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.  
  
ou 
 <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.  
  
ou 
Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
ou 
L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Le membre spécifié est un initialiseur de classe.</exception>
        <exception cref="T:System.MissingFieldException">Le champ ou la propriété est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.  
  
ou 
L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondent aux critères de liaison.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés. Autrement dit, la propriété <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quel que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant le nom du membre de constructeur, de méthode, de propriété ou de champ à appeler.  
  
ou 
Une chaîne vide ("") pour appeler le membre par défaut.  
  
ou 
Pour les membres <see langword="IDispatch" />, chaîne représentant le DispID, par exemple "[DispID=3]".</param>
        <param name="invokeAttr">Masque de bits constitué d'un ou de plusieurs <see cref="T:System.Reflection.BindingFlags" /> spécifiant le mode d'exécution de la recherche. L'accès peut être fourni par l'un des <see langword="BindingFlags" />, par exemple <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc. Il n'est pas nécessaire de spécifier le type de recherche. Si le type de recherche est omis, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> sont utilisés.</param>
        <param name="binder">Objet qui définit un ensemble de propriétés et permet la liaison, ce qui peut impliquer la sélection d'une méthode surchargée, la contrainte de types d'arguments et l'appel d'un membre par la réflexion.  
  
ou 
Référence null (Nothing en Visual Basic) pour utiliser <see cref="P:System.Type.DefaultBinder" />. Notez que la définition explicite d'un objet <see cref="T:System.Reflection.Binder" /> peut être nécessaire pour appeler correctement des surcharges de méthode avec des arguments variables.</param>
        <param name="target">Objet sur lequel appeler le membre spécifié.</param>
        <param name="args">Tableau contenant les arguments à passer au membre à appeler.</param>
        <param name="modifiers">Tableau d'objets <see cref="T:System.Reflection.ParameterModifier" /> représentant les attributs associés à l'élément correspondant dans le tableau <paramref name="args" />. Les attributs associés d'un paramètre sont stockés dans la signature du membre.  
  
Le binder par défaut traite ce paramètre uniquement au moment de l'appel d'un composant COM.</param>
        <param name="culture">Objet <see cref="T:System.Globalization.CultureInfo" /> représentant le paramètre régional de globalisation à utiliser si nécessaire, notamment pour les conversions spécifiques aux paramètres régionaux comme la conversion d'un type numérique String en type Double.  
  
ou 
Référence null (<see langword="Nothing" /> en Visual Basic) pour utiliser le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel.</param>
        <param name="namedParameters">Tableau contenant les noms des paramètres auxquels les valeurs du tableau <paramref name="args" /> sont passées.</param>
        <summary>En cas de substitution dans une classe dérivée, appelle le membre défini, à l'aide des contraintes de liaison spécifiées et correspondant à la liste d'arguments, aux modificateurs et à la culture spécifiés.</summary>
        <returns>Objet représentant la valeur de retour du membre appelé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` appelle un membre de constructeur ou un membre de méthode, obtient ou définit un membre de propriété, obtient ou définit un membre de champ de données, ou obtient ou définit un élément d’un membre du groupe.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser <xref:System.Type.InvokeMember%2A> pour appeler une méthode générique.  
  
 Lorsque vous appelez un `IDispatch` membre que vous pouvez spécifier le DispID au lieu du nom de membre, en utilisant le format de chaîne « [DispID = ##] ». Par exemple, si le DispID de MyComMethod est 3, vous pouvez spécifier la chaîne « [DispID = 3] » au lieu de « MyComMethod ». L’appel d’un membre par DispID est plus rapide que Rechercher par nom. Dans les scénarios d’agrégation complexes, le DispID est parfois la seule façon d’appeler le membre souhaité.  
  
 Bien que le binder par défaut ne traite pas <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (le `modifiers` et `culture` paramètres), vous pouvez utiliser l’abstraite <xref:System.Reflection.Binder?displayProperty=nameWithType> classe permettant d’écrire un binder personnalisé qui traite `modifiers` et `culture`. `ParameterModifier` est utilisé uniquement lors de l’appel via COM interop, et seuls les paramètres qui sont passés par référence sont gérées.  
  
 Chaque paramètre dans le tableau `namedParameters` obtient la valeur de l’élément correspondant dans le tableau `args`. Si la longueur de `args` est supérieure à la longueur de `namedParameters`, les valeurs d’argument restantes sont passées dans l’ordre.  
  
 Le `namedParameters` tableau peut être utilisé pour modifier l’ordre des arguments dans un tableau d’entrée. Par exemple, étant donné la méthode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` en Visual Basic) et le tableau d’entrée `{ 42, "x" }`, le tableau d’entrée peut être passé sans modification vers `args` si le tableau `{ "b", "a" }` est fourni pour `namedParameters`.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de filtre peuvent être utilisés pour définir les membres à inclure dans la recherche :  
  
-   Spécifiez `BindingFlags.Public` pour inclure les membres publics dans la recherche.  
  
-   Spécifiez `BindingFlags.NonPublic` pour inclure les membres non publics (autrement dit, les membres privés, internes et protégés) dans la recherche.  
  
-   Spécifiez `BindingFlags.FlattenHierarchy` pour inclure les membres statiques dans la hiérarchie.  
  
 Les éléments suivants <xref:System.Reflection.BindingFlags> les indicateurs de modificateur peuvent être utilisés pour modifier le fonctionnement de la recherche :  
  
-   `BindingFlags.IgnoreCase` pour ignorer la casse de `name`.  
  
-   `BindingFlags.DeclaredOnly` Pour rechercher uniquement les membres déclarés sur le <xref:System.Type>, pas les membres qui ont été simplement hérités.  
  
 Ce qui suit <xref:System.Reflection.BindingFlags> indicateurs d’appel peuvent être utilisés pour désigner l’action à effectuer sur le membre :  
  
-   `CreateInstance` pour appeler un constructeur. `name` est ignoré. Non valide avec d’autres indicateurs d’appel.  
  
-   `InvokeMethod` pour appeler une méthode, mais pas un constructeur ou un initialiseur de type. Non valide avec `SetField` ou `SetProperty`. Si `InvokeMethod` est spécifié par lui-même, `BindingFlags.Public`, `BindingFlags.Instance`, et `BindingFlags.Static` sont automatiquement inclus.  
  
-   `GetField` Pour obtenir la valeur d’un champ. Non valide avec `SetField`.  
  
-   `SetField` Pour définir la valeur d’un champ. Non valide avec `GetField`.  
  
-   `GetProperty` Pour obtenir une propriété. Non valide avec `SetProperty`.  
  
-   `SetProperty` Pour définir une propriété. Non valide avec `GetProperty`.  
  
 Pour plus d'informations, voir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Une méthode est appelée si les deux conditions suivantes sont remplies :  
  
-   Le nombre de paramètres dans la déclaration de méthode est égal au nombre d’arguments dans le `args` tableau (à moins que les arguments par défaut sont définis sur le membre et `BindingFlags.OptionalParamBinding` est spécifié).  
  
-   Le type de chaque argument peut être converti par le classeur vers le type du paramètre.  
  
 Le binder va trouver toutes les méthodes correspondantes. Ces méthodes sont disponibles en fonction du type de liaison demandé (<xref:System.Reflection.BindingFlags> valeurs `InvokeMethod`, `GetProperty`, et ainsi de suite). L’ensemble de méthodes est filtré par le nom, nombre d’arguments et un jeu de modificateurs de recherche définis dans le classeur.  
  
 Une fois la méthode est sélectionnée, elle est appelée. Accessibilité est vérifiée à ce stade. La recherche peut contrôler quel ensemble de méthodes sont recherchés en fonction de l’attribut d’accessibilité associé à la méthode. Le <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> méthode de la <xref:System.Reflection.Binder> classe est responsable de la sélection de la méthode à appeler. Le binder par défaut sélectionne la correspondance la plus spécifique.  
  
 `InvokeMember` peut être utilisé pour appeler des méthodes avec des paramètres qui ont des valeurs par défaut. Pour lier ces méthodes, la réflexion requiert <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> être spécifié. Pour un paramètre qui a comme valeur par défaut, vous pouvez fournir une valeur différente, ou fournir <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> à utiliser la valeur par défaut.  
  
 Par exemple, considérez une méthode telle que MyMethod (int x, float y = 2.0). Pour appeler cette méthode avec uniquement le premier argument en tant que MyMethod (4), passez un des indicateurs de liaison ci-dessus et passez deux arguments, à savoir 4 pour le premier argument et `Missing.Value` pour le deuxième argument. Sauf si vous utilisez `Missing.Value`, vous ne pouvez pas omettre les paramètres facultatifs avec le `Invoke` (méthode). Si vous devez le faire, utilisez `InvokeMember` à la place.  
  
 Restrictions d’accès sont ignorées pour le code totalement approuvé ; Autrement dit, propriétés, méthodes, champs et constructeurs privés peuvent être accessibles et appelées par le biais <xref:System.Reflection> chaque fois que le code est entièrement fiable.  
  
 Vous pouvez utiliser `Type.InvokeMember` pour définir un champ à une valeur particulière en spécifiant <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>. Par exemple, si vous souhaitez définir un champ d’instance public nommé F sur la classe C et F est un `String`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Si F est un `String[]`, vous pouvez utiliser le code :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 ce qui initialisera le champ F à ce nouveau tableau. Vous pouvez également utiliser `Type.InvokeMember` pour définir une position dans un tableau en fournissant l’index de la valeur, puis la valeur suivante à l’aide de code semblable au suivant :  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Cela modifie la chaîne « z » dans le tableau F conserve à la chaîne « b ».  
  
> [!NOTE]
>  En commençant par le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], cette méthode peut être utilisée pour accéder aux membres non publics si l’appelant a été accordé <xref:System.Security.Permissions.ReflectionPermission> avec la <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> indicateur et si le jeu d’autorisations des membres non publics est limité à l’appelant accorder ensemble ou un sous-ensemble son. (Consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Pour utiliser cette fonctionnalité, votre application doit cibler [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou version ultérieure.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> ne contient pas <see langword="CreateInstance" /> et <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> et <paramref name="modifiers" /> n’ont pas la même longueur.  
  
ou 
 <paramref name="invokeAttr" /> n’est pas un attribut <see cref="T:System.Reflection.BindingFlags" /> valide.  
  
ou 
 <paramref name="invokeAttr" /> ne contient pas l’un des indicateurs de liaison suivants : <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="CreateInstance" /> combiné avec <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetField" /> et <see langword="SetField" />.  
  
ou 
 <paramref name="invokeAttr" /> contient à la fois <see langword="GetProperty" /> et <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="InvokeMethod" /> combiné avec <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
ou 
 <paramref name="invokeAttr" /> contient <see langword="SetField" /> et <paramref name="args" /> a plusieurs éléments.  
  
ou 
Le tableau de paramètres nommé est supérieur à un tableau d’arguments.  
  
ou 
Cette méthode est appelée sur un objet COM et l’un des indicateurs de liaisons suivants n’a pas été passé : <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
ou 
L’un des tableaux de paramètres nommés contient une chaîne qui est <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">Le membre spécifié est un initialiseur de classe.</exception>
        <exception cref="T:System.MissingFieldException">Le champ ou la propriété est introuvable.</exception>
        <exception cref="T:System.MissingMethodException">Aucune méthode ne peut être trouvée qui correspond aux arguments de <paramref name="args" />.  
  
ou 
Aucun membre ne peut être trouvé avec les noms des arguments fournis dans <paramref name="namedParameters" />.  
  
ou 
L’objet <see cref="T:System.Type" /> actuel représente un type qui contient les paramètres de type ouverts, à savoir, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">Le membre spécifié ne peut pas être appelé sur <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Plusieurs méthodes correspondent aux critères de liaison.</exception>
        <exception cref="T:System.InvalidOperationException">La méthode représentée par <paramref name="name" /> a un ou plusieurs paramètres de type générique non spécifiés. Autrement dit, la propriété <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> de la méthode retourne <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Pour accéder aux membres non publics, quel que soit leur allocation définie. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est abstrait et doit être substitué.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est abstrait ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsAbstract%2A> retourne de la propriété `true` dans les cas suivants :  
  
-   Le type actuel est abstrait ; Autrement dit, il ne peut pas être instanciée, mais peut servir uniquement à la classe de base pour les classes dérivées. En c#, les classes abstraites sont marquées avec le [abstraite](~/docs/csharp/language-reference/keywords/abstract.md) mot-clé ; en Visual Basic, elles sont marquées avec le [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) mot clé.  
  
-   Le type actuel est une interface.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de <xref:System.Type> objets qui représentent les types suivants : contient des retours de type `true` si l’objet spécifié est `abstract`; sinon, elle retourne `false`.  
  
-   `AbstractClass`, une classe abstraite (une classe marquée en tant que `abstract` en c# et `MustInherit` en Visual Basic).  
  
-   `DerivedClass`, une classe qui hérite de `AbstractClass`.  
  
-   `SingleClass`, une classe non héritable. Il est défini comme `sealed` en c# et `NotInheritable` en Visual Basic.  
  
-   `ITypeInfo`, une interface.  
  
-   `ImplementingClass`, une classe qui implémente le `ITypeInfo` interface.  
  
 La méthode retourne `true` uniquement pour `AbstractClass`, la classe abstraite, et `ITypeInfo`, l’interface.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="AnsiClass" /> est sélectionné pour <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> si l'attribut de format de chaîne <see langword="AnsiClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la façon dont les chaînes doivent être interprétées.  
  
 Si actuel <xref:System.Type> représente un type générique, cette propriété se rapporte à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant obtient les informations de champ et vérifie le `AnsiClass` attribut.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type est un tableau.</summary>
        <value><see langword="true" /> si le type actuel est un tableau ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsArray%2A> retourne de la propriété `false` pour la <xref:System.Array> classe. Elle retourne également `false` si l’instance actuelle est un <xref:System.Type> objet qui représente un type de collection ou une interface conçue pour fonctionner avec les collections, telles que <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Pour vérifier un tableau, utilisez le code tel que :  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Si le type actuel représente un type générique ou un paramètre de type dans la définition d’un type générique ou de méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Type.IsArray%2A> propriété.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsArray" /> et détermine si <see cref="T:System.Type" /> est un tableau.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est un tableau ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une instance de la <xref:System.Array> classe doit retourner `false` s’agissant d’un objet, pas un tableau.  
  
   
  
## Examples  
 L’exemple suivant remplace le `IsArrayImpl` méthode dans la `MyTypeDelegator` classe, vérifie si une variable est un tableau et affiche le résultat.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Type à comparer avec le type actuel.</param>
        <summary>Détermine si une instance d’un type spécifié peut être affectée à une instance du type actuel.</summary>
        <returns><see langword="true" /> si l'une ou plusieurs des conditions suivantes sont remplies : 
-   <paramref name="c" /> et l’instance actuelle représentent le même type.  
  
-   <paramref name="c" /> est dérivé directement ou indirectement de l’instance actuelle. <paramref name="c" /> est dérivé directement de l’instance actuelle s’il hérite de l’instance actuelle ; <paramref name="c" /> est dérivé indirectement de l’instance actuelle s’il hérite d’une succession d’une ou plusieurs classes qui héritent de l’instance actuelle.  
  
L’instance actuelle est une interface implémentée par <paramref name="c" />.  
  
-   <paramref name="c" /> est un paramètre de type générique et l’instance actuelle représente l’une des contraintes de <paramref name="c" />.  
  
Dans l’exemple suivant, l’instance actuelle est un objet <see cref="T:System.Type" /> qui représente la classe <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> est un type générique dont le paramètre de type générique doit être de type <see cref="T:System.IO.Stream" />. Le fait de passer son paramètre de type générique à <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indique qu’une instance du paramètre de type générique peut être affectée à un objet <see cref="T:System.IO.Stream" />.  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> représente un type valeur et l’instance actuelle représente <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> en Visual Basic).  
  
 <see langword="false" /> si aucune de ces conditions n'a la valeur true, ou si <paramref name="c" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsAssignableFrom%2A> méthode peut être utilisée pour déterminer si une instance de `c` peut être affectée à une instance du type actuel, la méthode est particulièrement utile lorsque vous gérez les objets dont les types ne sont pas connus au moment du design et permet de conditional assignation, comme dans l’exemple suivant montre.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Cette méthode qui garantit ainsi une ligne de code comme celui-ci s’exécute lors de l’exécution sans lever une <xref:System.InvalidCastException> exception ou une exception semblable :  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
> [!NOTE]
>  Une définition de type générique n’est pas attribuable à partir d’un type construit fermé. Autrement dit, vous ne pouvez pas affecter le type construit fermé `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) à une variable de type `MyGenericList<T>`.  
  
 Si le `c` paramètre est de type <xref:System.Reflection.Emit.TypeBuilder>, le résultat est basé sur le type doit être créé. L’exemple de code suivant illustre cela : à l’aide d’un type construit nommé `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre le `IsAssignableFrom` à l’aide de la méthode définie par les classes, des tableaux d’entiers et des génériques.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="AutoClass" /> est sélectionné pour <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> si l'attribut de format de chaîne <see langword="AutoClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> sélectionne les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la façon dont les chaînes doivent être interprétées.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les champs du type actuel sont placés automatiquement par le Common Language Runtime.</summary>
        <value><see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de disposition de type et puis effectuer des tests si <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valeur d’énumération pour le type, pour permettre l’exécution de déterminer la méthode appropriée pour disposer de la classe.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance du type et affiche le <xref:System.Type.IsAutoLayout%2A> propriété.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Métadonnées et composants autodescriptifs</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est passé par référence.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour obtenir le type réel, déréférencer le type qui a été passé par référence, puis appelez <xref:System.Type.GetElementType%2A> sur ce type.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `IsByRef` propriété pour vérifier si un type spécifié est passé par référence. L’exemple définit la classe `MyTypeDelegator`, qui remplace le `HasElementTypeImpl` (méthode). La classe principale vérifie la `HasElementType` propriété et affiche le type d’élément.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsByRef" /> et détermine si le <see cref="T:System.Type" /> est passé par référence.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est passé par référence ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est une classe ou un délégué, c'est-à-dire ni un type valeur ni une interface.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est une classe ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `true` pour les classes, ainsi que des délégués. Elle retourne `false` pour les types valeur (pour les structures et énumérations) même si elles sont boxed.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `true`. Si actuel <xref:System.Type> représente un type générique construit, cette propriété retourne `true` si la définition de type générique est une définition de classe ; autrement dit, il ne définit pas une interface ou un type valeur.  
  
> [!NOTE]
>  Cette propriété retourne `true` pour `Type` instances qui représentent le <xref:System.Enum> et <xref:System.ValueType> classes. Ces deux classes sont les types de base pour les énumérations et les types de valeur, respectivement, mais ils ne sont pas des énumérations ou des types de valeur eux-mêmes. Pour plus d’informations, consultez le <xref:System.Type.IsValueType%2A> et <xref:System.Type.IsEnum%2A> propriétés.  
  
 Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur d’énumération distingue une déclaration de type en tant que classe ou interface. Toutefois, les classes et types valeur sont marqués avec le <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribut. Si vous récupérez la valeur de propriété des attributs et l’utilisation d’un type la <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valeur pour déterminer si un type est une classe au lieu d’un type valeur, vous devez également appeler le <xref:System.Type.IsValueType%2A> propriété. L’exemple pour la <xref:System.Reflection.TypeAttributes> énumération contient des informations supplémentaires, ainsi qu’Unexemple.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un type et indique si le type est une classe.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est un objet COM.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets. Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.  
  
 Vous pouvez également charger une classe COM et obtenir un `Type` objet pour cette classe COM à l’aide de la [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) outil.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int`> (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsCOMObject" /> et détermine si le <see cref="T:System.Type" /> est un objet COM.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est un objet COM ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne `false` pour les interfaces COM, car ils ne sont pas des objets. Interfaces COM peuvent être implémentées par des objets Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si cet objet représente un type générique construit. Vous pouvez créer des instances d'un type générique construit.</summary>
        <value><see langword="true" /> si cet objet représente un type générique construit ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un type générique construit a été fournies pour tous ses paramètres de type générique des types explicites. Il est également appelé un type générique fermé.  
  
 Lorsque cette propriété a `true`, vous pouvez créer des instances du type actuel ; lorsqu’il est `false`, vous ne pouvez pas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> peut être hébergé dans un contexte.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> peut être hébergé dans un contexte ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un contexte intercepte les appels aux membres de classe et applique les stratégies sont appliquées à la classe, telles que la synchronisation. Pour plus d’informations sur les contextes de communication à distance, consultez <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant montre le `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implémente la propriété <see cref="P:System.Type.IsContextful" /> et détermine si <see cref="T:System.Type" /> peut être hébergé dans un contexte.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> peut être hébergé dans un contexte ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
 Un contexte intercepte les appels aux membres de classe et appliquer des stratégies qui sont appliquées à la classe, telles que la synchronisation.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `IsContextfulImpl` (méthode).  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel représente une énumération.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> actuel représente une énumération ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `true` pour une énumération, mais pas pour le <xref:System.Enum> type lui-même.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le `IsEnum` propriété.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valeur à tester.</param>
        <summary>Retourne une valeur qui indique si la valeur spécifiée existe dans le type énumération actuel.</summary>
        <returns><see langword="true" /> si la valeur spécifiée est un membre du type énumération actuel ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Le type actuel n’est pas une énumération.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> est d’un type qui ne peut pas être le type sous-jacent d’une énumération.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">Type COM testé pour l'équivalence avec le type actuel.</param>
        <summary>Détermine si deux types COM ont la même identité et prennent en charge l'équivalence de type.</summary>
        <returns><see langword="true" /> si les types COM sont équivalents ; sinon, <see langword="false" />. Cette méthode retourne également la valeur <see langword="false" /> si un type est dans un assembly chargé pour l'exécution et que l'autre est dans un assembly chargé dans le contexte de réflexion uniquement.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le common language runtime prend en charge l’incorporation des informations de type pour les types COM directement dans des assemblys managés, au lieu de demander les assemblys managés obtenir des informations de type pour les types COM interop assemblys. Étant donné que les informations de type incorporées incluent uniquement les types et les membres qui sont réellement utilisés par un assembly managé, deux assemblys managés peuvent présenter des affichages très différents du même type COM. Chaque assembly managé a un objet <xref:System.Type> différent pour représenter son affichage du type COM. Le Common Language Runtime prend en charge l’équivalence des types entre ces différents affichages pour les interfaces, les structures, les énumérations et les délégués.  
  
 Avec l’équivalence des types, un objet COM qui est passé d’un assembly managé à un autre peut être casté en type managé approprié dans l’assembly de réception. Le <xref:System.Type.IsEquivalentTo%2A> méthode permet à un assembly de déterminer qu’un objet COM obtenu à partir d’un autre assembly a la même identité COM en tant qu’un des types interop du premier assembly incorporé et peut donc être casté en ce type.  
  
 Pour plus d’informations, consultez [équivalence des types et Types Interop incorporés](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les champs du type actuel sont placés aux offsets explicitement spécifiés.</summary>
        <value><see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de disposition de type et puis effectuer des tests si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que les décalages de début en les champs sont explicitement spécifiés.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un type et affiche la valeur de son <xref:System.Type.IsExplicitLayout%2A> propriété. Il utilise le `MySystemTime` (classe), qui se trouve également dans l’exemple de code pour <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Métadonnées et composants autodescriptifs</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> actuel représente un paramètre de type d'une définition de type ou de méthode générique.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Type" /> représente un paramètre de type d'une définition de type générique ou de méthode générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> objets qui représentent les paramètres de type générique peuvent être obtenus en appelant le <xref:System.Type.GetGenericArguments%2A> méthode d’un <xref:System.Type> objet qui représente une définition de type générique, ou la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> méthode d’un <xref:System.Reflection.MethodInfo> objet qui représente une méthode générique définition.  
  
-   Pour un type générique ou la définition de méthode, le <xref:System.Type.IsGenericParameter%2A> retourne de la propriété `true` pour chaque élément du tableau résultant.  
  
-   Pour un type construit fermé ou une méthode, le <xref:System.Type.IsGenericParameter%2A> retourne de la propriété `false` pour chaque élément du tableau retourné par la <xref:System.Type.GetGenericArguments%2A> (méthode).  
  
-   Pour une méthode ou un type construit ouvert, certains éléments du tableau peuvent être des types spécifiques et d’autres peuvent être des paramètres de type. <xref:System.Type.IsGenericParameter%2A> Retourne `false` pour les types et `true` pour les paramètres de type. L’exemple de code pour le <xref:System.Type.ContainsGenericParameters%2A> propriété montre une classe générique avec un mélange de types et les paramètres de type.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.IsGenericParameter%2A> propriété pour tester les paramètres de type générique dans un type générique.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le type actuel est un type générique.</summary>
        <value><see langword="true" /> Si le type actuel est un type générique ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Type.IsGenericType%2A> propriété afin de déterminer si un <xref:System.Type> objet représente un type générique. Utilisez le <xref:System.Type.ContainsGenericParameters%2A> propriété afin de déterminer si un <xref:System.Type> objet représente un type construit ouvert ou un type construit fermé.  
  
> [!NOTE]
>  Le <xref:System.Type.IsGenericType%2A> retourne de la propriété `false` si le type immédiat n’est pas générique. Par exemple, un tableau dont les éléments sont de type `A<int>` (`A(Of Integer)` en Visual Basic) n’est pas lui-même un type générique.  
  
 Le tableau suivant résume les conditions invariables des termes courants utilisés dans la réflexion générique.  
  
|Terme|Invariant|  
|----------|---------------|  
|définition de type générique|La propriété <xref:System.Type.IsGenericTypeDefinition%2A> est `true`.<br /><br /> Définit un type générique. Un type construit est créé en appelant le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> de l’objet qui représente une définition de type générique et en spécifiant un tableau d’arguments de type.<br /><br /> <xref:System.Type.MakeGenericType%2A> peut être appelée uniquement sur les définitions de type générique.<br /><br /> Toute définition de type générique est un type générique (la <xref:System.Type.IsGenericType%2A> propriété est `true`), mais l’inverse n’est pas vrai.|  
|type générique|La propriété <xref:System.Type.IsGenericType%2A> est `true`.<br /><br /> Peut être une définition de type générique, un type construit ouvert ou un type construit fermé.<br /><br /> Notez qu’un type tableau dont le type élément est générique n’est pas lui-même un type générique. Vaut également d’un <xref:System.Type> objet représentant un pointeur vers un type générique.|  
|type construit ouvert|La propriété <xref:System.Type.ContainsGenericParameters%2A> est `true`.<br /><br /> Les exemples sont un type générique qui a des paramètres de type non assignés, un type qui est imbriqué dans une définition de type générique ou dans un type construit ouvert ou un type générique qui a un argument de type pour lequel le <xref:System.Type.ContainsGenericParameters%2A> propriété est `true`.<br /><br /> Il n’est pas possible de créer une instance d’un type construit ouvert.<br /><br /> Notez que les types construits ouverts pas sont génériques. Par exemple, un tableau dont le type élément est une définition de type générique n’est pas générique, et un pointeur vers un type construit ouvert n’est pas générique.|  
|type construit fermé|La propriété <xref:System.Type.ContainsGenericParameters%2A> est `false`.<br /><br /> Lorsque examinées de manière récursive, le type n’a aucun paramètre de générique non assignés.|  
|paramètre de type générique|La propriété <xref:System.Type.IsGenericParameter%2A> est `true`.<br /><br /> La propriété <xref:System.Type.ContainsGenericParameters%2A> est `true`.<br /><br /> Dans une définition de type générique, un espace réservé pour un type qui sera affecté ultérieurement.|  
|argument de type générique|Peut être n’importe quel type, y compris un paramètre de type générique.<br /><br /> Arguments de type sont spécifiés sous forme de tableau de <xref:System.Type> objets passés à la <xref:System.Type.MakeGenericType%2A> méthode lors de la création d’un type générique construit. Si les instances du type résultant doivent être créés, le <xref:System.Type.ContainsGenericParameters%2A> propriété doit être `false` pour tous les arguments de type.|  
  
 L’exemple de code et le tableau suivants illustrent certains de ces termes et les invariants. Le `Derived` classe présente un intérêt particulier, car son type de base est un type construit qui possède un mélange de types et les paramètres de type dans sa liste d’arguments de type.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 Le tableau suivant montre des exemples qui utilisent et générer les classes `Base`, `Derived`, et `G`. Lorsque le code C++ et c# est le même, qu’une seule entrée est indiquée.  
  
|Exemple|Invariants|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Pour ce type :<br /><br /> <xref:System.Type.IsGenericType%2A> est `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Pour ce type :<br /><br /> <xref:System.Type.IsGenericType%2A> est `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Pour le type de variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> est `false` car `d` est un tableau.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `false`.|  
|`T`, `U`, et `V` (partout où ils apparaissent)|<xref:System.Type.IsGenericParameter%2A> est `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> est `false` , car il n’existe aucun moyen de contraindre un paramètre de type aux types génériques.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` car `T`, `U`, et `V` sont eux-mêmes des paramètres de type générique. Cela n’indique rien sur les arguments de type qui leur sont attribuées ultérieurement.|  
|Le type de champ `F`|<xref:System.Type.IsGenericType%2A> est `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `false` , car un type a été affecté au paramètre de type de `G`. Notez que cela équivaut à appeler le <xref:System.Type.MakeGenericType%2A> (méthode).<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type de champ `F` a un argument de type est un type construit ouvert. Le type construit est ouvert, car son argument de type (autrement dit, `Base`) est une définition de type générique. Cela illustre la nature récursive de la <xref:System.Type.IsGenericType%2A> propriété.|  
|La classe imbriquée `Nested`|<xref:System.Type.IsGenericType%2A> est `true`, même si le `Nested` classe n’a aucun paramètre de type générique de son propre, car elle est imbriquée dans un type générique.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> est `true`. Autrement dit, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode et fournir le paramètre de type du type englobant, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> est `true` , car le type englobant, `Derived`, a des paramètres de type générique. Cela illustre la nature récursive de la <xref:System.Type.ContainsGenericParameters%2A> propriété.|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur de la <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, et <xref:System.Type.ContainsGenericParameters%2A> propriétés pour les types décrits dans la section Notes. Pour obtenir des explications sur les valeurs de propriété, consultez le tableau qui accompagne cet article dans la section Notes.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le <see cref="T:System.Type" /> actuel représente une définition de type générique, à partir de laquelle d'autres types génériques peuvent être construits.</summary>
        <value><see langword="true" /> si l'objet <see cref="T:System.Type" /> représente une définition de type générique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une définition de type générique est un modèle à partir de laquelle d’autres types peuvent être construits. Par exemple, à partir de la définition de type générique `G<T>` (exprimée en syntaxe c# ; `G(Of T)` en Visual Basic ou `generic <typename T> ref class G` en C++) vous pouvez construire et instancier le type `G<int>` (`G(Of Integer)` en Visual Basic), en appelant le <xref:System.Type.MakeGenericType%2A> méthode avec une liste d’argument générique contenant le <xref:System.Int32> type. Étant donné un <xref:System.Type> objet représentant ce type construit, le <xref:System.Type.GetGenericTypeDefinition%2A> méthode récupère la définition de type générique à nouveau.  
  
 Utilisez le <xref:System.Type.IsGenericTypeDefinition%2A> propriété afin de déterminer si vous pouvez créer de nouveaux types à partir du type actuel. Si le <xref:System.Type.IsGenericTypeDefinition%2A> retourne de la propriété `true`, vous pouvez appeler la <xref:System.Type.MakeGenericType%2A> méthode pour créer des types génériques.  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 L’exemple suivant affiche des informations sur un type, y compris si elle est une définition de type générique ou non. Informations s’affichent pour un type construit, pour sa définition de type générique et un type ordinaire.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le <see cref="T:System.Type" /> a un attribut appliqué <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, indiquant qu'il a été importé d'une bibliothèque de types COM.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>.`  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Objet à comparer au type actuel.</param>
        <summary>Détermine si l'objet spécifié est une instance du <see cref="T:System.Type" /> actuel.</summary>
        <returns><see langword="true" /> si le <see langword="Type" /> actuel se trouve dans la hiérarchie d'héritage de l'objet représenté par <paramref name="o" /> ou si le <see langword="Type" /> actuel est une interface que <paramref name="o" /> implémente. <see langword="false" /> si aucune de ces conditions n'est respectée, si <paramref name="o" /> est <see langword="null" /> ou si le <see langword="Type" /> actuel est un type générique ouvert (autrement dit, <see cref="P:System.Type.ContainsGenericParameters" /> retourne <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
> [!NOTE]
>  Un type construit n’est pas une instance de sa définition de type générique. Autrement dit, `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) n’est pas une instance de `MyGenericList<T>` (`MyGenericList(Of T)` en Visual Basic).  
  
   
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est une interface, c'est-à-dire ni une classe ni un type valeur.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est une interface ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue une déclaration de type en tant que classe, interface ou un type valeur.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une interface, vérifie le type d’interface et indique si une classe a le `IsInterface` jeu de propriétés.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les champs du type actuel sont placés séquentiellement, en respectant l'ordre dans lequel ils ont été définis ou émis aux métadonnées.</summary>
        <value><see langword="true" /> si la propriété <see cref="P:System.Type.Attributes" /> du type actuel comprend <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété est fournie pour des raisons pratiques. Vous pouvez également utiliser le <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valeur d’énumération pour sélectionner les attributs de disposition de type et puis effectuer des tests si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> est défini. Le <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, et <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valeurs d’énumération indiquent la façon des champs du type sont disposés en mémoire.  
  
 Pour les types dynamiques, vous pouvez spécifier <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> lorsque vous créez le type. Dans le code, vous devez appliquer le <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribut avec le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération pour le type, pour spécifier que la disposition est séquentielle.  
  
> [!NOTE]
>  Vous ne pouvez pas utiliser le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> méthode pour déterminer si le <xref:System.Runtime.InteropServices.StructLayoutAttribute> a été appliqué à un type.  
  
 Pour plus d’informations, consultez la section 9.1.2 de la spécification pour la documentation du Common Language Infrastructure (CLI), « Partition II : Metadata Definition and Semantics ». La documentation est disponible en ligne. Consultez [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) sur MSDN et [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) sur le site web d’Ecma International.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’une classe pour laquelle le <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valeur d’énumération dans le <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe a été défini, les contrôles pour le <xref:System.Type.IsLayoutSequential%2A> propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">Métadonnées et composants autodescriptifs</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est marshalé par référence.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est marshalé par référence ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre le `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implémente la propriété <see cref="P:System.Type.IsMarshalByRef" /> et détermine si le <see cref="T:System.Type" /> est marshalé par référence.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est marshalé par référence ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut être substituée par une classe dérivée.  
  
   
  
## Examples  
 L’exemple suivant détermine si le type donné est marshalé par référence et affiche le résultat.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'objet <see cref="T:System.Type" /> actuel représente un type dont la définition est imbriquée dans la définition d'un autre type.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué dans un autre type ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsNested%2A> retourne de la propriété `true` pour tous les types imbriqués, quelle que soit la visibilité. Pour tester l’imbrication et la visibilité en même temps, utilisez les propriétés connexes <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  Le <xref:System.Reflection.TypeAttributes.VisibilityMask> membre d’énumération sélectionne les attributs de visibilité pour un type.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans son propre assembly.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à la fois à sa propre famille et à son propre assembly.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à la fois à sa propre famille et à son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
> [!NOTE]
>  Les langages c# et Visual Basic n’incluent pas de sémantique qui vous permettent de définir un type imbriqué qui est uniquement visible pour les types protégés dans son propre assembly. `protected internal` visibilité en c# et `Protected Friend` visibilité dans Visual Basic définissent un type imbriqué qui est visible pour les types protégés et pour les types dans le même assembly.  
  
 Un <xref:System.Type> famille de l’objet est défini en tant que tous les objets du même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans sa propre famille.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement dans sa propre famille ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
 Un <xref:System.Type> famille de l’objet est défini en tant que tous les objets d’exactement le même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à sa propre famille ou à son propre assembly.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et visible uniquement par rapport aux classes qui appartiennent à sa propre famille ou à son propre assembly ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la visibilité d’un type est `protected internal` en c# ou `Protected Friend` en Visual Basic, le <xref:System.Type.IsNestedFamORAssem%2A> retourne de la propriété `true`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
 Un <xref:System.Type> famille de l’objet est défini en tant que tous les objets d’exactement le même <xref:System.Type> et de ses sous-types.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est imbriqué et déclaré privé.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est imbriqué et déclaré privé ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si une classe est imbriquée et déclarée publique.</summary>
        <value><see langword="true" /> si la classe est imbriquée et déclarée publique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `false`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une classe externe avec un nombre de classes imbriquées qui ont différents types de visibilité. Il récupère ensuite la valeur d’un nombre de liés à la visibilité <xref:System.Type> propriétés pour le type de parent et chacun de ses types imbriqués.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> n'est pas déclaré public.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> n'est pas déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’utilisez pas cette propriété avec les types imbriqués ; utiliser le <xref:System.Type.IsNestedPublic%2A> propriété à la place.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `false`.  
  
   
  
## Examples  
 Cet exemple montre comment l’option `IsNotPublic` propriété à obtenir la visibilité du type.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 L’exemple de code suivant montre pourquoi vous ne pouvez pas utiliser `IsPublic` et `IsNotPublic` pour les classes imbriquées.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement avec les résultats d’une attention `IsNestedPublic` et `IsNestedPrivate`. La sortie de la réflexion pour ce fragment de code se présente comme suit :  
  
|Classe|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|A|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est un pointeur.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `IsPointer` propriété.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsPointer" /> et détermine si le <see cref="T:System.Type" /> est un pointeur.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est un pointeur ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est l'un des types primitifs.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.  
  
 Si actuel <xref:System.Type> représente un type générique ou un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant montre le `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, et <xref:System.Type.IsPrimitive%2A> propriétés de la <xref:System.Type> classe. Il vérifie si le type donné peut être hébergé dans le contexte, si elle peut être marshalée par référence, et si le type est un type de données primitif.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, implémente la propriété <see cref="P:System.Type.IsPrimitive" /> et détermine si <see cref="T:System.Type" /> est l'un des types primitifs.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est l'un des types primitifs ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types primitifs sont <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, et <xref:System.Single>.  
  
   
  
## Examples  
 L’exemple suivant détermine si le type donné est un type primitif et affiche le résultat.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est déclaré public.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est déclaré public et n'est pas un type imbriqué ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 N’utilisez pas avec les types imbriqués ; Utilisez <xref:System.Type.IsNestedPublic%2A> à la place.  
  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne `true`.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Sélectionne les attributs de visibilité.  
  
   
  
## Examples  
 L’exemple suivant crée une instance de `MyTestClass`, vérifie le `IsPublic` propriété et affiche le résultat.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Pour les classes imbriquées, ignorez les résultats de `IsPublic` et `IsNotPublic` et uniquement avec les résultats d’une attention <xref:System.Type.IsNestedPublic%2A> et <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Type" /> est déclaré sealed.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est déclaré sealed ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un paramètre de type d’un type générique, cette propriété retourne toujours `true`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance d’un `sealed` classe, vérifie le `IsSealed` propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est critique de sécurité (security-critical) ou critique sécurisé (security-safe-critical) au niveau de confiance actuel et peut donc exécuter des opérations critiques.</summary>
        <value><see langword="true" /> si le type actuel est critique de sécurité ou critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont affichées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique de sécurité|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété varie selon le niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quel que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuel de domaines d’application et des assemblys à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et la transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considérations sur la sécurité de la réflexion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifications de sécurité dans le .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est critique sécurisé au niveau de confiance actuel, autrement dit s'il peut exécuter des opérations critiques et être accessible par du code transparent.</summary>
        <value><see langword="true" /> si le type actuel est critique sécurisé au niveau de confiance actuel ; <see langword="false" /> s'il est critique de sécurité ou transparent.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). Les combinaisons de ces propriétés sont affichées dans le tableau suivant :  
  
|Niveau de sécurité|EstCritiqueDeSécurité|EstCritiqueSécurisé|EstTransparentDeSécurité|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Critique|`true`|`false`|`false`|  
|Critique de sécurité|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété varie selon le niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quel que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuel de domaines d’application et des assemblys à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et la transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considérations sur la sécurité de la réflexion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifications de sécurité dans le .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le type actuel est transparent au niveau de confiance actuel et ne peut donc pas exécuter d'opérations critiques.</summary>
        <value><see langword="true" /> si le type est transparent de sécurité au niveau de confiance actuel ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si cette propriété retourne `true`, le <xref:System.Type.IsSecurityCritical%2A> et <xref:System.Type.IsSecuritySafeCritical%2A> propriétés retour `false`.  
  
 Le <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, et <xref:System.Type.IsSecurityTransparent%2A> propriétés signalent le niveau de transparence du type à son niveau de confiance actuel, tel que déterminé par le common language runtime (CLR). L'utilisation de ces propriétés est beaucoup plus simple que d'examiner les annotations de sécurité d'un assembly et ses types, de vérifier le niveau de confiance actuel et de tenter de dupliquer les règles du runtime.  
  
> [!IMPORTANT]
>  Pour les assemblys de confiance partielle, la valeur de cette propriété varie selon le niveau de confiance actuel de l’assembly. Si l’assembly est chargé dans un domaine d’application partiellement fiable (par exemple, dans un domaine d’application sandbox), le runtime ignore les annotations de sécurité de l’assembly. L’assembly et tous ses types sont traités comme étant transparent. Le runtime tient compte des annotations de sécurité d’un assembly de confiance partielle uniquement lorsque cet assembly est chargé dans un domaine d’application de confiance totale (par exemple, dans le domaine d’application par défaut d’une application de bureau). En revanche, un assembly de confiance (autrement dit, un assembly avec nom fort qui est installé dans le global assembly cache) est toujours chargé avec une confiance totale, quel que soit le niveau de confiance du domaine d’application, son niveau de confiance actuel est toujours entièrement fiable. Vous pouvez déterminer les niveaux de confiance actuel de domaines d’application et des assemblys à l’aide de la <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> et <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propriétés.  
  
 Pour plus d’informations sur la réflexion et la transparence, consultez [considérations de sécurité pour la réflexion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Pour plus d’informations sur la transparence, consultez [modifications de sécurité](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">Considérations sur la sécurité de la réflexion</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">Modifications de sécurité dans le .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est sérialisable.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> est sérialisable ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Types qui sont définis dans .NET Standard ne sont pas marqués avec <xref:System.SerializableAttribute>. Au lieu de cela, chaque implémentation .NET détermine si un type est sérialisable. Au moment de l’exécution, vous pouvez utiliser le <xref:System.Type.IsSerializable%2A> propriété afin de déterminer si cette implémentation prend en charge la sérialisation d’une instance du type. Pour plus d’informations et un exemple, consultez [comment déterminer si un objet .NET Standard est sérialisable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
   
  
## Examples  
 L’exemple suivant crée une instance de `MyTestClass` classe, définit l’attribut [Serializable] et vérifie le `IsSerializable` propriété pour `true` ou `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le type a un nom qui nécessite un traitement spécial.</summary>
        <value><see langword="true" /> si le type a un nom qui nécessite un traitement spécial ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms commencent par ou un caractère de soulignement (_), les accesseurs de propriété et les méthodes de surcharge d’opérateur sont des exemples de types pouvant nécessiter un traitement spécial par certains compilateurs.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Type à comparer avec le type actuel.</param>
        <summary>Détermine si le <see cref="T:System.Type" /> actuel dérive du <see cref="T:System.Type" /> spécifié.</summary>
        <returns><see langword="true" /> si le <see langword="Type" /> actuel dérive de <paramref name="c" /> ; sinon <see langword="false" />. Cette méthode retourne également <see langword="false" /> si <paramref name="c" /> et le <see langword="Type" /> actuel sont égaux.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez appeler la <xref:System.Type.IsSubclassOf%2A> méthode pour déterminer les éléments suivants :  
  
-   Si une classe dérive d’un autre.  
  
-   Si un type dérive de <xref:System.ValueType>. Toutefois, le <xref:System.Type.IsValueType%2A> est un moyen plus efficace pour déterminer si un type est un type valeur.  
  
-   Si un type dérive de <xref:System.Enum>. Toutefois, le <xref:System.Type.IsEnum%2A> méthode est un moyen plus efficace pour déterminer si un type est une énumération.  
  
-   Si un type est un délégué, autrement dit, si elle dérive <xref:System.Delegate> ou <xref:System.MulticastDelegate>.  
  
 Le <xref:System.Type.IsSubclassOf%2A> méthode ne peut pas être utilisée pour déterminer si une interface dérive d’une autre interface ou si une classe implémente une interface. Utilisez le <xref:System.Type.IsAssignableFrom%2A> méthode pour ce faire, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, il dérive de sa contrainte de classe ou de <xref:System.Object?displayProperty=nameWithType> si elle n’a aucune contrainte de classe.  
  
> [!NOTE]
>  Sauf lorsqu’il est utilisé avec les interfaces, <xref:System.Type.IsSubclassOf%2A> est l’inverse de <xref:System.Type.IsAssignableFrom%2A>. Autrement dit, si `t1.IsSubclassOf(t2)` est `true`, puis `t2.IsAssignableFrom(t1)` est également `true`.  
  
 Cette méthode peut être substituée par une classe dérivée.  
  
   
  
## Examples  
 L’exemple suivant crée une classe nommée `Class1` et une classe dérivée nommée `DerivedC1`. Il appelle le <xref:System.Type.IsSubclassOf%2A> méthode pour indiquer que `DerivedC1` est une sous-classe de `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> est <see langword="null" />.</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'attribut de format de chaîne <see langword="UnicodeClass" /> est sélectionné pour <see cref="T:System.Type" />.</summary>
        <value><see langword="true" /> si l'attribut de format de chaîne <see langword="UnicodeClass" /> est sélectionné pour le <see cref="T:System.Type" /> ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Reflection.TypeAttributes.StringFormatMask> est utilisé pour sélectionner les attributs de format de chaîne. Les attributs de format de chaîne améliorent l’interopérabilité en définissant la façon dont les chaînes doivent être interprétées.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le <see cref="T:System.Type" /> est un type valeur.</summary>
        <value><see langword="true" /> si <see cref="T:System.Type" /> est un type valeur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les types valeur sont des types qui sont représentés comme des séquences de bits ; types valeur ne sont pas des classes ou interfaces. Les types valeur sont appelées « structs » dans certains langages de programmation. Les enums sont un cas spécial de types valeur.  
  
 Cette propriété retourne `false` pour le <xref:System.ValueType> classe, car <xref:System.ValueType> n’est pas un type valeur lui-même. Il est la classe de base pour tous les types de valeur, et par conséquent n’importe quel type de valeur peut être affectée à ce dernier. Cela ne serait pas possible si <xref:System.ValueType> lui-même a un type valeur. Types valeur sont boxed lorsqu’ils sont attribués à un champ de type <xref:System.ValueType>.  
  
 Cette propriété retourne `true` pour les énumérations, mais pas pour le <xref:System.Enum> type lui-même. Pour obtenir un exemple qui illustre ce comportement, consultez <xref:System.Type.IsEnum%2A>.  
  
 Cette propriété est en lecture seule.  
  
   
  
## Examples  
 L’exemple suivant crée une variable de type `MyEnum`, vérifie le `IsValueType` propriété et affiche le résultat.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implémente la propriété <see cref="P:System.Type.IsValueType" /> et détermine si le <see cref="T:System.Type" /> est un type valeur, c'est-à-dire ni une classe ni une interface.</summary>
        <returns><see langword="true" /> si <see cref="T:System.Type" /> est un type valeur ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est fournie pour activer l’implémentation d’autres systèmes de type. En règle générale, il n’est pas utilisé dans le code d’application.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Type" /> est accessible par code à l'extérieur de l'assembly.</summary>
        <value><see langword="true" /> si le <see cref="T:System.Type" /> actuel est un type public ou un type imbriqué public rendant publics tous les types englobants ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette propriété pour déterminer si un type fait partie de l’interface publique d’un assembly de composant.  
  
   
  
## Examples  
 L’exemple de code suivant teste deux classes, qu’un seul d'entre eux est visible en dehors de l’assembly.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente un tableau unidimensionnel du type actuel, avec une limite inférieure de zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen pour générer des types tableau dont les types d’élément sont calculés au moment de l’exécution.  
  
 **Remarque** le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels. Un vecteur, qui a toujours qu’une seule dimension, n’est pas identique à un tableau multidimensionnel qui n’a qu’une seule dimension. Cette surcharge de méthode peut uniquement être utilisée pour créer des types de vecteurs, et c’est le seul moyen pour créer un type de vecteur. Utilisez le <xref:System.Type.MakeArrayType%28System.Int32%29> surcharge de méthode pour créer des types de tableaux multidimensionnels.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour le `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base. Les classes dérivées doivent fournir une implémentation.</exception>
        <exception cref="T:System.TypeLoadException">Le type actuel est <see cref="T:System.TypedReference" />.  
  
ou 
Le type actuel est un type <see langword="ByRef" />. Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">Nombre de dimensions pour le tableau. Ce nombre doit être inférieur ou égal à 32.</param>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</summary>
        <returns>Objet qui représente un tableau du type actuel, avec le nombre spécifié de dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeArrayType%2A> méthode fournit un moyen pour générer des types tableau dont les types d’élément sont calculés au moment de l’exécution.  
  
> [!NOTE]
>  Le common language runtime établit une distinction entre les vecteurs (autrement dit, les tableaux unidimensionnels qui sont toujours de base zéro) et les tableaux multidimensionnels. Un vecteur, qui a toujours qu’une seule dimension, n’est pas identique à un tableau multidimensionnel qui n’a qu’une seule dimension. Vous ne pouvez pas utiliser cette surcharge de méthode pour créer un type vectoriel ; Si `rank` est 1, cette surcharge de méthode retourne un type de tableau multidimensionnel qui possède une seule dimension. Utilisez le <xref:System.Type.MakeArrayType> surcharge de méthode pour créer des types de vecteurs.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour le `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> n'est pas valide. Par exemple, 0 ou un nombre négatif.</exception>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
        <exception cref="T:System.TypeLoadException">Le type actuel est <see cref="T:System.TypedReference" />.  
  
ou 
Le type actuel est un type <see langword="ByRef" />. Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.  
  
ou 
 <paramref name="rank" /> est supérieur à 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (paramètre <see langword="ByRef" /> en Visual Basic).</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente le type actuel quand il est passé en tant que paramètre <see langword="ref" /> (paramètre <see langword="ByRef" /> en Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeByRefType%2A> méthode fournit un moyen de générer `ref` types (`ByRef` en Visual Basic) pour le paramètre répertorie.  
  
 À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32&`.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour le `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
        <exception cref="T:System.TypeLoadException">Le type actuel est <see cref="T:System.TypedReference" />.  
  
ou 
Le type actuel est un type <see langword="ByRef" />. Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">To be added.</param>
        <param name="typeArguments">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Tableau de types à remplacer pour les paramètres de type du type générique actuel.</param>
        <summary>Substitue les éléments d'un tableau de types aux paramètres de type de la définition du type générique actuel et retourne un objet <see cref="T:System.Type" /> qui représente le type construit résultant.</summary>
        <returns><see cref="T:System.Type" /> représentant le type construit formé en substituant les éléments de <paramref name="typeArguments" /> pour les paramètres de type du type générique actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakeGenericType%2A> méthode vous permet d’écrire du code qui assigne des types spécifiques aux paramètres de type d’une définition de type générique, créant ainsi un <xref:System.Type> objet qui représente un type construit particulier. Vous pouvez utiliser cette <xref:System.Type> objet à créer des instances d’exécution du type construit.  
  
 Types construits avec <xref:System.Type.MakeGenericType%2A> peut être ouvert, autrement dit, certaines de leurs arguments de type peuvent être des paramètres de type caractères entourant les méthodes génériques ou les types. Vous pouvez utiliser ces types construits ouverts lorsque vous émettez des assemblys dynamiques. Par exemple, considérez les classes `Base` et `Derived` dans le code suivant.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Pour générer `Derived` dans un assembly dynamique, il est nécessaire de construire son type de base. Pour ce faire, appelez le <xref:System.Type.MakeGenericType%2A> méthode sur un <xref:System.Type> objet représentant la classe `Base`, en utilisant les arguments de type générique <xref:System.Int32> et le paramètre de type `V` de `Derived`. Étant donné que les types et les paramètres de type générique sont représentés par <xref:System.Type> objets, un tableau contenant les deux peut être passé à la <xref:System.Type.MakeGenericType%2A> (méthode).  
  
> [!NOTE]
>  Un type construit, tel que `Base<int, V>` est utile lorsque émission de code, mais vous ne pouvez pas appeler la <xref:System.Type.MakeGenericType%2A> méthode sur ce type, car il n’est pas une définition de type générique. Pour créer un type construit fermé qui peut être instancié, appelez d’abord la <xref:System.Type.GetGenericTypeDefinition%2A> méthode pour obtenir un <xref:System.Type> de l’objet qui représente la définition de type générique, puis appelez <xref:System.Type.MakeGenericType%2A> avec les arguments de type souhaité.  
  
 Le <xref:System.Type> objet retourné par <xref:System.Type.MakeGenericType%2A> est identique à la <xref:System.Type> obtenu en appelant le <xref:System.Object.GetType%2A> méthode des résultats de type construit, ou le <xref:System.Object.GetType%2A> méthode de n’importe quel type qui a été créé à partir de la même générique de construit définition de type à l’aide des mêmes arguments de type.  
  
> [!NOTE]
>  Un tableau de types génériques n’est pas lui-même un type générique. Vous ne pouvez pas appeler <xref:System.Type.MakeGenericType%2A> sur un type tableau tel que `C<T>[]` (`Dim ac() As C(Of T)` en Visual Basic). Pour construire un type générique fermé de `C<T>[]`, appelez <xref:System.Type.GetElementType%2A> pour obtenir la définition de type générique `C<T>`; appelez <xref:System.Type.MakeGenericType%2A> sur la définition de type générique pour créer le type construit ; et enfin appeler la <xref:System.Type.MakeArrayType%2A> méthode sur le type construit pour créer le type de tableau. Cela vaut de types pointeur et `ref` types (`ByRef` en Visual Basic).  
  
 Pour obtenir la liste des conditions indifférentes pour les termes utilisés dans la réflexion générique, consultez les notes sur la propriété <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Types imbriqués  
 Si un type générique est défini à l’aide de c#, C++ ou Visual Basic, ses types imbriqués sont tous génériques. Cela est vrai même si les types imbriqués n’ont aucun paramètre de type propre, car les trois langages incluent les paramètres de type de types englobants dans les listes de paramètres de type des types imbriqués. Prenez en compte les classes suivantes :  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 La liste de paramètres de type de la classe imbriquée `Inner` a deux paramètres de type, `T` et `U`, le premier d'entre eux est le paramètre de type de sa classe englobante. De même, la liste de paramètres de type de la classe imbriquée `Innermost1` a trois paramètres de type, `T`, `U`, et `V`, avec `T` et `U` provenant de ses classes englobantes. La classe imbriquée `Innermost2` a deux paramètres de type, `T` et `U`, qui proviennent de ses classes englobantes.  
  
 Si la liste des paramètres du type englobant comporte plus d’un paramètre de type, tous les paramètres de type dans l’ordre sont inclus dans la liste de paramètres de type du type imbriqué.  
  
 Pour construire un type générique à partir de la définition de type générique pour un type imbriqué, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec le tableau formé en concaténant les tableaux d’argument de type des tous les types englobants, à compter de type générique à l’extérieur et se terminant par le type de tableau d’arguments du type imbriqué lui-même, s’il a des paramètres de type de son propre. Pour créer une instance de `Innermost1`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant trois types à assigner à T, U et V. Pour créer une instance de `Innermost2`, appelez le <xref:System.Type.MakeGenericType%2A> méthode avec un tableau contenant les deux types, à assigner à T et U.  
  
 Les langages de propagent les paramètres de type de types englobants de cette façon afin de pouvoir utiliser les paramètres de type d’un type englobant pour définir les champs des types imbriqués. Sinon, les paramètres de type ne serait pas dans la portée au sein des instances des types imbriqués. Il est possible de définir des types imbriqués sans propager les paramètres de type de types englobants, en émettant le code dans des assemblys dynamiques ou en utilisant le [Ilasm.exe (assembleur IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Prenons le code suivant pour l’assembleur MSIL :  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 Dans cet exemple, il n’est pas possible de définir un champ de type `T` ou `U` dans la classe `Innermost`, car ces paramètres de type ne sont pas dans la portée. Le code assembleur suivant définit les classes imbriquées qui se comportent comme si elles étaient définies en C++, Visual Basic et c# :  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Vous pouvez utiliser la [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner les classes imbriquées définies dans les langages de haut niveau et observer ce schéma d’affectation de noms.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Type.MakeGenericType%2A> méthode pour créer un type construit à partir de la définition de type générique pour le <xref:System.Collections.Generic.Dictionary%602> type. Représente le type construit un <xref:System.Collections.Generic.Dictionary%602> de `Test` objets avec des clés de chaîne.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le type actuel ne représente pas une définition de type générique. Autrement dit, <see cref="P:System.Type.IsGenericTypeDefinition" /> retourne <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> est <see langword="null" />.  
  
ou 
Tout élément de <paramref name="typeArguments" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre d’éléments de <paramref name="typeArguments" /> n’est pas le même que le nombre de paramètres de type de la définition de type générique actuelle.  
  
ou 
Un élément de <paramref name="typeArguments" /> ne répond pas aux contraintes spécifiées pour le paramètre de type correspondant du type générique actuel.  
  
ou 
 <paramref name="typeArguments" /> contient un élément qui est un type pointeur (<see cref="P:System.Type.IsPointer" /> retourne <see langword="true" />), un type by-ref (<see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />) ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base. Les classes dérivées doivent fournir une implémentation.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">Réflexion et types génériques</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">Guide pratique pour examiner et instancier des types génériques avec la réflexion</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</summary>
        <returns>Objet <see cref="T:System.Type" /> qui représente un pointeur vers le type actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Type.MakePointerType%2A> méthode fournit un moyen pour générer des types pointeur pour les listes de paramètres.  
  
 À l’aide de la syntaxe de langage intermédiaire Microsoft (MSIL), si actuel <xref:System.Type> représente l’objet <xref:System.Int32>, cette méthode retourne un <xref:System.Type> objet représentant `Int32*`.  
  
   
  
## Examples  
 L’exemple de code suivant crée le tableau, `ref` (`ByRef` en Visual Basic) et les types de pointeur pour le `Test` classe.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
        <exception cref="T:System.TypeLoadException">Le type actuel est <see cref="T:System.TypedReference" />.  
  
ou 
Le type actuel est un type <see langword="ByRef" />. Autrement dit, <see cref="P:System.Type.IsByRef" /> retourne <see langword="true" />.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur <see cref="T:System.Reflection.MemberTypes" /> qui indique que ce membre est un type ou un type imbriqué.</summary>
        <value>Valeur <see cref="T:System.Reflection.MemberTypes" /> qui indique que ce membre est un type ou un type imbriqué.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété remplace <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Par conséquent, lorsque vous examinez un ensemble de <xref:System.Reflection.MemberInfo> objets - par exemple, le tableau retourné par <xref:System.Type.GetMembers%2A> - le <xref:System.Reflection.MemberInfo.MemberType%2A> propriété retourne <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> quand un membre donné est un type imbriqué.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété s’applique à la définition de type générique à partir de laquelle le type a été construit. Par exemple, si actuel <xref:System.Type> représente `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), la valeur de cette propriété est déterminée par `MyGenericType<T>`.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne toujours <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Le code suivant montre l’exemple le `MemberType` champ en tant que paramètre à la `GetMember` méthode :  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente une valeur manquante dans les informations <see cref="T:System.Type" />. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le `Missing` field pour un appel par la réflexion pour obtenir la valeur par défaut d’un paramètre. Si le `Missing` champ est passé pour une valeur de paramètre et il n’existe aucune valeur par défaut pour ce paramètre, un <xref:System.ArgumentException> est levée.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la `Missing` champ à appeler une méthode avec ses arguments par défaut.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Ce code génère la sortie suivante :  
  
 un = 10 b = 55.3 c = 12  
  
 un = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le module (la DLL) dans lequel le <see cref="T:System.Type" /> actuel est défini.</summary>
        <value>Module dans lequel le <see cref="T:System.Type" /> actuel est défini.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété retourne le module dans lequel la définition de type générique a été définie. Par exemple, si vous créez une instance de `MyGenericStack<int>`, le <xref:System.Type.Module%2A> propriété pour le type construit retourne le module dans lequel `MyGenericStack<T>` est défini.  
  
 De même, si actuel <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’assembly qui contient le type générique qui définit `T`.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la <xref:System.Type.Namespace%2A> et `Module` propriétés et le <xref:System.Type.ToString%2A> méthode de <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>En cas de substitution dans une classe dérivée, obtient le nom du type actuel.</summary>
        <value>Le nom du type actuel.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'espace de noms de l'objet <see cref="T:System.Type" />.</summary>
        <value>Espace de noms du <see cref="T:System.Type" /> ; <see langword="null" /> si l'instance actuelle n'a pas d'espace de noms ou représente un paramètre générique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace de noms est une logique au moment du design d’affectation de noms plus de commodité, principalement utilisé pour définir l’étendue dans une application et organiser des classes et autres types dans une structure hiérarchique unique. Du point de vue du runtime, il n’existe aucun espace de noms.  
  
 Si actuel <xref:System.Type> représente un type générique construit, cette propriété retourne l’espace de noms qui contient la définition de type générique. De même, si actuel <xref:System.Type> représente un paramètre générique `T`, cette propriété retourne l’espace de noms qui contient la définition de type générique qui définit `T`.  
  
 Si actuel <xref:System.Type> objet représente un paramètre générique, cette propriété retourne `null`.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la `Namespace` et <xref:System.Type.Module%2A> propriétés et le <xref:System.Type.ToString%2A> méthode de <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Premier objet à comparer.</param>
        <param name="right">Deuxième objet à comparer.</param>
        <summary>Indique si deux objets <see cref="T:System.Type" /> sont égaux.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> est égal à <paramref name="right" /> ; sinon <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">Premier objet à comparer.</param>
        <param name="right">Deuxième objet à comparer.</param>
        <summary>Indique si deux objets <see cref="T:System.Type" /> ne sont pas égaux.</summary>
        <returns><see langword="true" /> si <paramref name="left" /> n'est pas égal à <paramref name="right" /> ; sinon, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'objet de la classe qui a été utilisé pour obtenir ce membre.</summary>
        <value>Objet <see langword="Type" /> via lequel cet objet <see cref="T:System.Type" /> a été obtenu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour <xref:System.Type> objets, la valeur de cette propriété est toujours identique à la valeur de la <xref:System.Type.DeclaringType%2A> propriété.  
  
   
  
## Examples  
 Cet exemple affiche le type réfléchi d’une classe imbriquée.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Nom complet de l'assembly du <see cref="T:System.Type" /> à obtenir.</param>
        <param name="throwIfNotFound"><see langword="true" /> pour lever une <see cref="T:System.TypeLoadException" /> si le type est introuvable ; <see langword="false" /> pour retourner <see langword="null" /> si le type est introuvable. <see langword="false" /> supprime également d'autres conditions d'exception, mais pas toutes. Consultez la section Exceptions.</param>
        <param name="ignoreCase"><see langword="true" /> pour effectuer une recherche qui ne respecte pas la casse de <paramref name="typeName" /> et <see langword="false" /> pour effectuer une recherche qui respecte la casse de <paramref name="typeName" />.</param>
        <summary>Obtient le <see cref="T:System.Type" /> portant le nom spécifié, indiquant s'il faut effectuer une recherche respectant la casse et lever une exception si le type est introuvable. Le type est chargé dans un contexte de réflexion, et non d'exécution.</summary>
        <returns>Type présentant le nom spécifié, s'il est trouvé ; sinon, <see langword="null" />. Si le type est introuvable, le paramètre <paramref name="throwIfNotFound" /> spécifie si <see langword="null" /> est retourné ou bien une exception est levée. Dans certains cas, une exception est levée indépendamment de la valeur de <paramref name="throwIfNotFound" />. Consultez la section Exceptions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’assembly contenant le type n’est pas déjà chargé dans le contexte de réflexion uniquement, à l’aide du <xref:System.Type.ReflectionOnlyGetType%2A> méthode est équivalent au premier chargement de l’assembly pour la réflexion uniquement, à l’aide de la <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> (méthode), puis le chargement du type en appelant le l’assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> (méthode). Pour plus d’informations sur les noms qualifiés d’assembly, consultez le <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriété. Pour plus d’informations sur la spécification des noms de types, consultez le <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> surcharge de méthode.  
  
 Si l’assembly est déjà chargé pour l’exécution, une autre copie est chargée dans le contexte de réflexion uniquement.  
  
 Le `throwIfNotFound` paramètre spécifie que se passe-t-il lorsque le type est introuvable et supprime également certaines autres conditions d’exception, comme décrit dans la section Exceptions. Certaines exceptions sont levées indépendamment de la valeur de `throwIfNotFound`. Par exemple, si l’assembly n’est pas valide, un <xref:System.BadImageFormatException> est levée même si `throwIfNotFound` est `false`.  
  
 Pour plus d’informations sur le contexte de réflexion uniquement, consultez [Comment : charger des assemblys dans le contexte de réflexion uniquement](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Un initialiseur de classe est appelé et lève une exception.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et le type est introuvable.  
  
ou 
 <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient des caractères non valides, tels qu’une tabulation incorporée. 
ou 
 <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> est une chaîne vide.  
  
ou 
 <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> représente un type de tableau avec une taille non valide.  
  
ou 
 <paramref name="typeName" /> représente un tableau d’objets <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> n’inclut pas le nom de l’assembly.  
  
ou 
 <paramref name="throwIfNotFound" /> a la valeur <see langword="true" /> et <paramref name="typeName" /> contient une syntaxe non valide ; par exemple, « MyType[,*,] ».  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un type pointeur, un type <see langword="ByRef" /> ou <see cref="T:System.Void" /> comme l’un de ses arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique qui a un nombre incorrect d’arguments de type.  
  
ou 
 <paramref name="typeName" /> représente un type générique, et un de ses arguments de type ne satisfait pas aux contraintes pour le paramètre de type correspondant.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> a la valeur <see langword="true" />, et l’assembly ou l’une de ses dépendances est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly ou une de ses dépendances a été trouvé, mais n’a pas pu être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly ou une de ses dépendances n’est pas valide.  
  
ou 
L’assembly a été compilé avec une version du Common Language Runtime postérieure à la version actuellement chargée.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">Spécification des noms de types qualifiés complets</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">Guide pratique pour charger des assemblys dans le contexte de réflexion uniquement</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> qui décrit la disposition du type actuel.</summary>
        <value>Obtient un <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> qui décrit les fonctionnalités de disposition brutes du type actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> n’est pas retournée par le <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> (méthode). Au lieu de cela, utilisez cette propriété pour l’obtenir.  
  
   
  
## Examples  
 L’exemple de code suivant définit tout d’abord une classe, une structure et une structure avec des attributs de disposition spécial (les structures sont imbriquées dans la classe). L’exemple utilise ensuite la <xref:System.Type.StructLayoutAttribute%2A> propriété pour obtenir un <xref:System.Runtime.InteropServices.StructLayoutAttribute> pour chaque type et affiche les propriétés des attributs.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">La méthode appelée n’est pas prise en charge dans la classe de base.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Compte des noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d'arguments, un tableau d'arguments DISPID pour les arguments nommés et le nombre d'éléments de chaque tableau.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne <see langword="String" /> représentant le nom du <see langword="Type" /> actuel.</summary>
        <returns><see cref="T:System.String" /> représentant le nom du <see cref="T:System.Type" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne le common language runtime espace de noms complet et le nom de tous les types primitifs. Par exemple, l’instruction c# `(long)0.Type().ToString()` retourne « System.Int64 » au lieu de simplement « Int64 ».  
  
 Si actuel <xref:System.Type> représente un type générique, le type et ses arguments de type sont qualifiés par espace de noms et par un type imbriqué, mais pas par un assembly. Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou de méthode générique, cette méthode retourne le nom non qualifié du paramètre de type.  
  
   
  
## Examples  
 L’exemple suivant montre une utilisation de la <xref:System.Type.Namespace%2A> et <xref:System.Type.Module%2A> propriétés et le `ToString` méthode de <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 L’exemple suivant compare les chaînes retournées par la <xref:System.Type.ToString%2A> (méthode) et le `Name`, <xref:System.Type.FullName%2A>, et <xref:System.Type.AssemblyQualifiedName%2A> propriétés.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle pour le <see cref="T:System.Type" /> actuel.</summary>
        <value>Handle pour le <see cref="T:System.Type" /> actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` encapsule un pointeur vers une structure de données interne qui représente le type. Ce handle est unique pendant la durée de vie du processus. Le handle est valide uniquement dans le domaine d’application dans lequel elles ont été obtenues.  
  
   
  
## Examples  
 L’exemple suivant retourne le handle du type correspondant et passe le handle à une méthode qui obtient le type à partir du handle et l’affiche.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le .NET Compact Framework ne prend pas en charge cette propriété.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'initialiseur du type.</summary>
        <value>Objet contenant le nom du constructeur de classe pour <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Initialiseurs de classe sont également disponibles via le <xref:System.Type.FindMembers%2A> (méthode), ou via les surcharges de la <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, et <xref:System.Type.GetConstructors%2A> méthodes qui prennent <xref:System.Reflection.BindingFlags> en tant que paramètre.  
  
 Si actuel <xref:System.Type> représente un paramètre de type dans la définition d’un type générique ou une méthode générique, cette propriété retourne `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indique le type fourni par le Common Language Runtime qui représente ce type.</summary>
        <value>Type de système sous-jacent pour <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>