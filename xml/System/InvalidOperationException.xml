<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="810fe50283e801c3e7dde603475dc30ccd6ad1c8" /><Meta Name="ms.sourcegitcommit" Value="7845f124909a0999a19cc65f40feab5e75cd9b8d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/06/2019" /><Meta Name="ms.locfileid" Value="65064620" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exception levée en cas d'appel de méthode non valide pour l'état actuel de l'objet.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException> est utilisé lorsque l’échec pour appeler une méthode est dû à des raisons autres que des arguments non valides. En règle générale, elle est levée lorsque l’état d’un objet ne peut pas prendre en charge l’appel de méthode. Par exemple, un <xref:System.InvalidOperationException> exception est levée par les méthodes telles que :  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> Si les objets d’une collection sont modifiés après la création de l’énumérateur. Pour plus d’informations, consultez [modification d’une collection lors de l’itération il](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> Si le jeu de ressources est fermé avant l’appel de méthode est effectué.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, si l’ou les objets à ajouter entraînerait un document XML structuré de manière incorrecte.  
  
-   Une méthode qui tente de manipuler l’interface utilisateur à partir d’un thread qui n’est pas le principal ou le thread d’interface utilisateur.  
  
> [!IMPORTANT]
>  Étant donné que le <xref:System.InvalidOperationException> exception peut être levée dans un large éventail de circonstances, il est important de lire le message d’exception retourné par la <xref:System.Exception.Message%2A> propriété.  
  
 Dans cette section :  
  
 [Certaines causes courantes des exceptions de InvalidOperationException](#Causes)   
 [La mise à jour d’un thread d’interface utilisateur à partir d’un thread non-interface utilisateur](#UI)  
 [Modification d’une collection lors de l’itération il](#Iterating)  
 [Tri d’un tableau ou une collection dont les objets ne peuvent pas être comparées.](#Sorting)  
 [Conversion d’un type Nullable&lt;T&gt; qui a la valeur null en son type sous-jacent](#Nullable)   
 [Appeler une méthode System.Linq.Enumerable sur une collection vide](#Empty)  
 [L’appel Enumerable.Single ou Enumerable.SingleOrDefault sur une séquence sans un seul élément](#Single)  
 [Accès aux champs de domaine d’applications croisées dynamiques](#Emit)  
[Lever une exception InvalidOperationException](#Throwing)  
[Informations diverses](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Certaines causes courantes des exceptions de InvalidOperationException  
 Les sections suivantes montrent comment certaines les cas courants dans lesquels dans <xref:System.InvalidOperationException> exception est levée dans une application. Façon dont vous gérez le problème dépend de la situation spécifique. En règle générale, toutefois, l’exception résulte de l’erreur de développement et le <xref:System.InvalidOperationException> exception peut être anticipée et évitée.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>La mise à jour d’un thread d’interface utilisateur à partir d’un thread non-interface utilisateur  
 Souvent, les threads de travail sont utilisés pour exécuter des tâches en arrière-plan qui implique la collecte de données à afficher dans l’interface utilisateur d’une application. Toutefois. la plupart des infrastructures d’application (l’interface graphique utilisateur) pour le .NET Framework, tels que Windows Forms et Windows Presentation Foundation (WPF), vous permettent d’accéder aux objets de l’interface graphique utilisateur uniquement à partir du thread qui crée et gère l’interface utilisateur (le thread principal ou de l’interface utilisateur). Un <xref:System.InvalidOperationException> est levée lorsque vous essayez d’accéder à un élément d’interface utilisateur à partir d’un thread autre que le thread d’interface utilisateur.  Le texte du message d’exception est affiché dans le tableau suivant.  
  
|Type d’application|Message|  
|----------------------|-------------|  
|Application WPF|**Le thread appelant ne peut pas accéder à cet objet, car un autre thread est propriétaire.**|  
|Application UWP|**L’application pour un autre thread a appelé une interface qui a été marshalée.**|  
|Application de Windows Forms|**Opération inter-threads non valide : Contrôle 'TextBox1' accédé à partir d’un thread autre que le thread de création.**|  
  
 Infrastructures d’interface utilisateur pour le .NET Framework implémentent un *répartiteur* modèle qui inclut une méthode pour vérifier si un appel à un membre d’un élément d’interface utilisateur est en cours d’exécution sur le thread d’interface utilisateur et autres méthodes permettant de planifier l’appel sur le thread d’interface utilisateur :  
  
-   Dans les applications WPF, appelez le <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> méthode pour déterminer si une méthode est en cours d’exécution sur un thread non-interface utilisateur. Elle retourne `true` si la méthode s’exécute sur le thread d’interface utilisateur et `false` dans le cas contraire. Appelez une des surcharges de la <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> méthode permettant de planifier l’appel sur le thread d’interface utilisateur.  
  
-   Dans les applications UWP, appelez le [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) méthode pour déterminer si une méthode est en cours d’exécution sur un thread non-interface utilisateur. Appelez le [CoreDispatcher.RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) méthode à exécuter un délégué qui met à jour le thread d’interface utilisateur. Utilisez la commande  
  
-   Dans les applications Windows Forms, utilisez le <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> propriété afin de déterminer si une méthode est en cours d’exécution sur un thread non-interface utilisateur. Appelez une des surcharges de la <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> méthode à exécuter un délégué qui met à jour le thread d’interface utilisateur.  
  
 Les exemples suivants illustrent le <xref:System.InvalidOperationException> exception qui est levée lorsque vous tentez de mettre à jour un élément d’interface utilisateur à partir d’un thread autre que le thread qui l’a créée.  Chaque exemple nécessite que vous créez deux contrôles :  
  
-   Un contrôle de zone de texte nommé `textBox1`.  Dans une application Windows Forms, vous devez définir ses <xref:System.Windows.Forms.TextBox.Multiline%2A> propriété `true`.  
  
-   Un contrôle bouton nommé `threadExampleBtn`. L’exemple fournit un gestionnaire, `ThreadsExampleBtn_Click`, pour le bouton `Click` événement.  
  
 Dans chaque cas, le `threadExampleBtn_Click` Gestionnaire d’événements appelle la `DoSomeWork` méthode deux fois. Le premier appel s’exécute de façon synchrone et réussit. Mais le deuxième appel, car il s’exécute en mode asynchrone sur un thread de pool, essaie de mettre à jour de l’interface utilisateur à partir d’un thread non-interface utilisateur. Il en résulte un <xref:System.InvalidOperationException> exception.  
  
 Applications WPF et UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 La version suivante de la `DoSomeWork` méthode élimine l’exception dans une application WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 La version suivante de la `DoSomeWork` méthode élimine l’exception dans une application UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Applications Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 La version suivante de la `DoSomeWork` méthode élimine l’exception dans une application Windows Forms.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Modification d’une collection lors de l’itération il  
 Le `foreach` instruction en c# ou `For Each` instruction en Visual Basic est utilisée pour parcourir les membres d’une collection et pour lire ou modifier ses éléments individuels. Toutefois, il ne peut pas être utilisé pour ajouter ou supprimer des éléments de la collection. Cela lèverait une <xref:System.InvalidOperationException> exception avec un message qui est similaire, «**Collection a été modifiée ; opération d’énumération ne peut pas s’exécuter.** "  
  
 L’exemple suivant itère qu'une collection d’entiers tente d’ajouter le carré de chaque entier à la collection. L’exemple lève une <xref:System.InvalidOperationException> avec le premier appel à la <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> (méthode).  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Vous pouvez éliminer l’exception de deux manières, selon votre logique d’application :  
  
-   Si les éléments doivent être ajoutés à la collection lors de l’itération à elle, vous pouvez le parcourir à l’aide des index le `for` instruction au lieu de `foreach` ou `For Each`. L’exemple suivant utilise la pour instruction à ajouter le carré des nombres dans la collection à la collection.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Notez que vous devez établir le nombre d’itérations avant d’itérer la collection à l’aide d’un compteur à l’intérieur de la boucle qui abandonnera la boucle de manière appropriée, en effectuant une itération vers l’arrière, à partir de `Count` - 1 à 0, ou, comme dans l’exemple, en assignant le nombre d’éléments dans le tableau à une variable et l’utiliser pour établir la limite supérieure de la boucle. Sinon, si un élément est ajouté à la collection à chaque itération, une boucle sans fin les résultats.  
  
-   Si elle n’est pas nécessaire d’ajouter des éléments à la collection pendant l’itération il, vous pouvez stocker les éléments à ajouter dans un regroupement temporaire que vous ajoutez lors de l’itération de la collection est terminée.  L’exemple suivant utilise cette approche pour ajouter le carré des nombres dans une collection à un regroupement temporaire, puis pour combiner les collections dans un objet tableau unique.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>Tri d’un tableau ou une collection dont les objets ne peuvent pas être comparées.  
 À usage général tri des méthodes, telles que la <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> (méthode) ou le <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> (méthode), nécessitent généralement qu’au moins un des objets à trier implémenter le <xref:System.IComparable%601> ou le <xref:System.IComparable> interface. Si non, la collection ou un tableau ne peuvent pas être trié, et la méthode lève un <xref:System.InvalidOperationException> exception. L’exemple suivant définit un `Person` classe stocke deux `Person` objets dans un modèle générique <xref:System.Collections.Generic.List%601> objet et tente de les trier. Comme la sortie de l’exemple, l’appel à la <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> méthode lève un <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Vous pouvez éliminer l’exception dans une des trois manières :  
  
-   Si vous pouvez être propriétaire du type que vous essayez de trier (autrement dit, si vous contrôler son code source), vous pouvez le modifier pour implémenter le <xref:System.IComparable%601> ou <xref:System.IComparable> interface. Cela nécessite que vous implémentez soit le <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> ou le <xref:System.IComparable.CompareTo%2A> (méthode). Ajout d’une implémentation d’interface à un type existant n’est pas une modification avec rupture.  
  
     L’exemple suivant utilise cette approche pour fournir un <xref:System.IComparable%601> implémentation pour la `Person` classe. Vous pouvez toujours appeler la méthode de tri générales du tableau ou de la collection et, comme le montre la sortie de l’exemple, la collection trie avec succès.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Si vous ne pouvez pas modifier le code source pour le type que vous voulez trier, vous pouvez définir une classe de tri à usage spécial qui implémente le <xref:System.Collections.Generic.IComparer%601> interface.  Vous pouvez appeler une surcharge de la `Sort` méthode inclut un <xref:System.Collections.Generic.IComparer%601> paramètre. Cette approche est particulièrement utile si vous souhaitez développer une classe spécialisée trie peut trier les objets selon plusieurs critères.  
  
     L’exemple suivant utilise l’approche en développant un personnalisé `PersonComparer` classe qui sert à trier `Person` collections.  Il passe ensuite une instance de cette classe pour le <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> (méthode).  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Si vous ne pouvez pas modifier le code source pour le type que vous voulez trier, vous pouvez créer un <xref:System.Comparison%601> délégué pour effectuer le tri. La signature du délégué est  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     L’exemple suivant utilise l’approche en définissant un `PersonComparison` méthode qui correspond à la <xref:System.Comparison%601> signature du délégué.  Il passe ensuite ce délégué à la <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> (méthode).  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Conversion d’un type Nullable\<T > qui a la valeur null en son type sous-jacent  
 Tentative de cast un <xref:System.Nullable%601> valeur qui est `null` à son type sous-jacent lève une <xref:System.InvalidOperationException> exception et affiche le message d’erreur «**objet Nullable doit avoir une valeur.**  
  
 L’exemple suivant lève une <xref:System.InvalidOperationException> exception lorsqu’il tente d’effectuer une itération d’un tableau qui inclut un `Nullable(Of Integer)` valeur.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Pour empêcher l’exception :  
  
-   Utilisez le <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> propriété pour sélectionner uniquement les éléments qui ne sont pas `null`.  
  
-   Appelez une de la <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> surcharges pour fournir une valeur par défaut pour un `null` valeur.  
  
 L’exemple suivant effectue les deux pour éviter le <xref:System.InvalidOperationException> exception.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Appeler une méthode System.Linq.Enumerable sur une collection vide  
 Le <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, et <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> méthodes effectuer des opérations sur une séquence et retourner un résultat unique.   Certaines surcharges de ces méthodes lèvent une <xref:System.InvalidOperationException> exception lorsque la séquence est vide, alors que les autres surcharges retournent `null`. Le <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> méthode lève également une <xref:System.InvalidOperationException> exception lorsque la séquence contient plusieurs éléments.  
  
> [!NOTE]
>  La plupart des méthodes qui lèvent une <xref:System.InvalidOperationException> exception sont des surcharges. N’oubliez pas que vous comprenez le comportement de la surcharge que vous choisissez.  
  
 Le tableau suivant répertorie les messages d’exception à partir de la <xref:System.InvalidOperationException> objets d’exception levées par les appels à certaines <xref:System.Linq.Enumerable?displayProperty=nameWithType> méthodes.  
  
|Méthode|Message|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Séquence ne contient aucun élément**|  
|`First`|**Séquence ne contient aucun élément correspondant**|  
|`Single` <br /> `SingleOrDefault`|**Séquence contient plusieurs éléments correspondants**|  
  
 Comment supprimer ou gérer l’exception dépend les hypothèses de votre application et de la méthode particulière, que vous appelez.  
  
-   Lorsque vous appelez délibérément une de ces méthodes sans vérifier pour une séquence vide, vous supposez que la séquence n’est pas vide et qu’une séquence vide est un événement inattendu. Dans ce cas, l’interception ou de nouveau l’exception est approprié.  
  
-   Si votre manquement à vérifier pour une séquence vide a été par inadvertance, vous pouvez appeler une des surcharges de la <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> surcharge pour déterminer si une séquence contient des éléments.  
  
    > [!TIP]
    >  Appelant le <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> avant de générer une séquence peut améliorer les performances si les données de traitement peuvent contenir un grand nombre d’éléments ou si l’opération qui génère la séquence est coûteuse.  
  
-   Si vous avez appelé une méthode comme <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, ou <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, vous pouvez remplacer par une autre méthode, tel que <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, ou <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, qui retourne une valeur par défaut au lieu d’un membre de la séquence.  
  
 Les exemples fournissent des détails supplémentaires.  
  
 L’exemple suivant utilise la <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> méthode pour calculer la moyenne d’une séquence dont les valeurs sont supérieures à 4. Dans la mesure où aucune valeur à partir du tableau d’origine ne dépasse 4, aucune valeur n’est inclus dans la séquence, et la méthode lève un <xref:System.InvalidOperationException> exception.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 L’exception peut être éliminée en appelant le <xref:System.Linq.Enumerable.Any%2A> méthode pour déterminer si la séquence contient des éléments avant d’appeler la méthode qui traite la séquence, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 Le <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> méthode retourne le premier élément dans une séquence ou le premier élément dans une séquence qui satisfait à une condition spécifiée. Si la séquence est vide et n’a donc pas un premier élément, elle lève une <xref:System.InvalidOperationException> exception.  
  
 Dans l’exemple suivant, le <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> méthode lève un <xref:System.InvalidOperationException> exception, car le tableau de dbQueryResults ne contient aucun élément supérieur à 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Vous pouvez appeler la <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> méthode au lieu de <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> pour retourner un spécifié ou la valeur par défaut. Si la méthode ne trouve pas un premier élément dans la séquence, elle retourne la valeur par défaut pour ce type de données.  La valeur par défaut est `null` pour un type référence, zéro pour un type de données numérique et <xref:System.DateTime.MinValue?displayProperty=nameWithType> pour la <xref:System.DateTime> type.  
  
> [!NOTE]
>  Interprétation de la valeur retournée par la <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> méthode est souvent compliquée par le fait que la valeur par défaut du type peut être une valeur valide dans la séquence. Dans ce cas, vous un appel de la <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> méthode pour déterminer si la séquence a des membres valides avant d’appeler le <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> (méthode).  
  
 L’exemple suivant appelle la <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> méthode pour empêcher le <xref:System.InvalidOperationException> exception levée dans l’exemple précédent.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>L’appel Enumerable.Single ou Enumerable.SingleOrDefault sur une séquence sans un seul élément  
 Le <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> méthode retourne le seul élément d’une séquence ou le seul élément d’une séquence qui répond à une condition spécifiée.    Si aucun élément dans la séquence, ou s’il existe plusieurs éléments, la méthode lève un <xref:System.InvalidOperationException> exception.  
  
 Vous pouvez utiliser la <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> méthode pour retourner une valeur par défaut au lieu de lever une exception lorsque la séquence ne contient aucun élément. Toutefois, le <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> méthode lève toujours une <xref:System.InvalidOperationException> exception lorsque la séquence contient plusieurs éléments.  
  
 Le tableau suivant répertorie les messages d’exception à partir de la <xref:System.InvalidOperationException> objets d’exception levées par les appels à la <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> et <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> méthodes.  
  
|Méthode|Message|  
|------------|-------------|  
|`Single`|**Séquence ne contient aucun élément correspondant**|  
|`Single` <br /> `SingleOrDefault`|**Séquence contient plusieurs éléments correspondants**|  
  
 Dans l’exemple suivant, l’appel à la <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> méthode lève un <xref:System.InvalidOperationException> exception parce que la séquence ne contient aucun élément supérieur à 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 L’exemple suivant tente d’empêcher la <xref:System.InvalidOperationException> exception levée lorsqu’une séquence est vide en appelant à la place le <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> (méthode). Toutefois, étant donné que cette séquence retourne plusieurs éléments dont la valeur est supérieure à 2, elle lève également une <xref:System.InvalidOperationException> exception.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Appel de la <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> méthode part du principe qu’une séquence ou la séquence qui répond aux critères spécifiés ne contient qu’un seul élément.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> suppose une séquence avec zéro ou un résultat, mais pas plus. Si cette hypothèse est délibérée de votre part et que ces conditions ne sont pas remplies, nouvelle levée ou l’interception résultant <xref:System.InvalidOperationException> est appropriée. Dans le cas contraire, ou si vous prévoyez que les conditions non valides seront produit à une certaine fréquence, vous devez envisager d’utiliser un autre <xref:System.Linq.Enumerable> (méthode), tel que <xref:System.Linq.Enumerable.FirstOrDefault%2A> ou <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Accès aux champs de domaine d’applications croisées dynamiques  
 Le <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft intermediate language (MSIL) instruction lève une <xref:System.InvalidOperationException> exception si l’objet qui contient le champ dont vous essayez de récupérer l’adresse n’est pas dans le domaine d’application dans lequel votre code s’exécute. L’adresse d’un champ est uniquement accessible à partir du domaine d’application dans lequel il réside.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Lever une exception InvalidOperationException  
 Vous devez lever une <xref:System.InvalidOperationException> exception uniquement lorsque l’état de votre objet pour une raison quelconque ne prend pas en charge un appel de méthode particulier. Autrement dit, l’appel de méthode n’est valide que dans certaines circonstances ou des contextes, mais n’est pas valide dans d’autres.  
  
 Si l’échec d’appel de méthode est en raison d’arguments non valides, puis <xref:System.ArgumentException> ou l’une de ses classes dérivées, <xref:System.ArgumentNullException> ou <xref:System.ArgumentOutOfRangeException>, doit être levée à la place.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Informations diverses  
 <xref:System.InvalidOperationException> utilise le HRESULT COR_E_INVALIDOPERATION dont la valeur est 0 x 80131509.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de <xref:System.InvalidOperationException>, consultez le <xref:System.InvalidOperationException.%23ctor%2A> constructeurs.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">Gestion et levée des exceptions</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.InvalidOperationException" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.InvalidOperationException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise la <xref:System.Exception.Message%2A> propriété de la nouvelle instance à un message fourni par le système qui décrit l’erreur, tel que « l’opération demandée ne peut pas être effectuée. » Ce message prend en compte la culture système en cours.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.InvalidOperationException>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Référence Null (`Nothing` en Visual Basic).|  
|<xref:System.Exception.Message%2A>|Chaîne du message d'erreur localisé.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Message décrivant l'erreur.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.InvalidOperationException" /> avec un message d'erreur spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur initialise la <xref:System.Exception.Message%2A?displayProperty=nameWithType> propriété de l’exception à l’aide du `message` paramètre. Le contenu de `message` doit être compréhensible par les utilisateurs. L'appelant de ce constructeur doit vérifier que cette chaîne a été localisée pour la culture en cours du système.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.InvalidOperationException>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Référence Null (`Nothing` en Visual Basic).|  
|<xref:System.Exception.Message%2A>|Chaîne du message d'erreur.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Objet qui contient les données sérialisées de l'objet.</param>
        <param name="context">Informations contextuelles sur la source ou la destination.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.InvalidOperationException" /> avec des données sérialisées.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé lors de la désérialisation pour reconstituer l’objet exception transmis sur un flux. Pour plus d’informations, consultez [sérialisation XML et SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">Sérialisation XML et SOAP</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Message d'erreur qui explique la raison de l'exception.</param>
        <param name="innerException">Exception ayant provoqué l'exception actuelle. Si le paramètre <paramref name="innerException" /> n'est pas une référence null (<see langword="Nothing" /> en Visual Basic), l'exception actuelle est levée dans un bloc <see langword="catch" /> qui gère l'exception interne.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.InvalidOperationException" /> avec un message d'erreur spécifié et une référence à l'exception interne ayant provoqué cette exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une exception levée en conséquence directe d'une exception précédente doit contenir une référence à celle-ci dans la propriété <xref:System.Exception.InnerException%2A>. La propriété <xref:System.Exception.InnerException%2A> retourne la même valeur que celle qui a été passée dans le constructeur ou une référence Null (`Nothing` en Visual Basic), si la propriété <xref:System.Exception.InnerException%2A> ne fournit pas la valeur de l'exception interne au constructeur.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d'une instance de <xref:System.InvalidOperationException>.  
  
|Property|Value|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|La référence à l'exception interne.|  
|<xref:System.Exception.Message%2A>|Chaîne du message d'erreur.|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">Gestion et levée des exceptions</related>
      </Docs>
    </Member>
  </Members>
</Type>