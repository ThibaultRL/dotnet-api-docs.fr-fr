<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d25436086f9e3033aa184eea75f303fbc6d4a03" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52608897" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente le texte en tant que séquence d’unités de code UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Une chaîne est une collection séquentielle de caractères qui est utilisée pour représenter du texte. Un <xref:System.String> objet est une collection séquentielle de <xref:System.Char?displayProperty=nameWithType> des objets qui représentent une chaîne ; un <xref:System.Char?displayProperty=nameWithType> objet correspond à une unité de code UTF-16. La valeur de la <xref:System.String> objet correspond au contenu de la collection séquentielle de <xref:System.Char?displayProperty=nameWithType> objets, et que la valeur est immuable (autrement dit, il est en lecture seule). Pour plus d’informations sur l’immuabilité des chaînes, consultez le [immuabilité et la classe StringBuilder](#Immutability) section plus loin dans cette rubrique. La taille maximale d’un <xref:System.String> objet en mémoire est de 2 Go ou environ 1 milliard de caractères.  
  
 Dans cette section :  
  
 [Instanciation d’un objet de chaîne](#Instantiation)   
 [Objets char et caractères Unicode](#Characters)   
 [Chaînes et la norme Unicode](#Unicode)   
 [Chaînes et caractères null incorporés](#EmbeddedNulls)   
 [Chaînes et des index](#Indexes)   
 [Chaînes null et chaînes vides](#Nulls)   
 [Immuabilité et la classe StringBuilder](#Immutability)   
 [Ordinal et les opérations dépendantes de la culture](#CultureSensitive)   
 [Normalisation](#Normalization)   
 [Opérations de chaîne par catégorie](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Instanciation d’un objet de chaîne  
 Vous pouvez instancier un <xref:System.String> objet comme suit :  
  
-   En assignant un littéral de chaîne à un <xref:System.String> variable. Il s’agit de la méthode la plus couramment utilisée pour la création d’une chaîne. L’exemple suivant utilise l’attribution pour créer plusieurs chaînes. Notez que dans c#, étant donné que la barre oblique inverse (\\) est un caractère d’échappement, une barre oblique inverse littérale dans une chaîne doit être échappé ou la chaîne entière doit être @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   En appelant un <xref:System.String> constructeur de classe. L’exemple suivant instancie des chaînes en appelant plusieurs constructeurs de classe. Notez que certains constructeurs incluent des pointeurs vers des tableaux de caractères ou des tableaux d’octets signés en tant que paramètres. Visual Basic ne prend pas en charge les appels à ces constructeurs. Pour plus d’informations sur <xref:System.String> constructeurs, consultez le <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   À l’aide de l’opérateur de concaténation de chaînes (+ en c# et & ou + en Visual Basic) pour créer une chaîne unique à partir de n’importe quelle combinaison de <xref:System.String> instances et les littéraux de chaîne. L’exemple suivant illustre l’utilisation de l’opérateur de concaténation de chaîne.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   En extrayant une propriété ou en appelant une méthode qui retourne une chaîne. L’exemple suivant utilise les méthodes de la <xref:System.String> classe pour extraire une sous-chaîne d’une chaîne plus grande.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   En appelant une méthode de mise en forme pour convertir une valeur ou un objet en sa représentation sous forme de chaîne. L’exemple suivant utilise le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité pour incorporer la représentation sous forme de chaîne de deux objets dans une chaîne.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Objets char et caractères Unicode  
 Chaque caractère dans une chaîne est défini par une valeur scalaire Unicode, également appelée point de code Unicode ou la valeur ordinale (numérique) du caractère Unicode. Chaque point de code est encodé en UTF-16 et la valeur numérique de chaque élément de l’encodage est représentée par un <xref:System.Char> objet.  
  
> [!NOTE]
>  Notez que, comme un <xref:System.String> instance se compose d’une collection séquentielle d’unités de code UTF-16, il est possible de créer un <xref:System.String> objet qui n’est pas une chaîne Unicode bien formée. Par exemple, il est possible de créer une chaîne comportant un caractère de substitution faible sans un substitut correspondant. Bien que certaines méthodes, telles que les méthodes de codage et décodage des objets dans le <xref:System.Text> espace de noms, effectue des vérifications pour vous assurer que les chaînes sont bien formées, <xref:System.String> membres de classe ne garantissent pas qu’une chaîne est bien formée.  
  
 Un seul <xref:System.Char> objet représente généralement un seul point de code, autrement dit, la valeur numérique de la <xref:System.Char> est égale au point de code. Par exemple, le point de code pour le caractère « a » est U + 0061. Toutefois, un point de code peut nécessiter plusieurs éléments encodés (plusieurs <xref:System.Char> objet). La norme Unicode définit deux types de caractères qui correspondent à plusieurs <xref:System.Char> objets : graphèmes et les points de code supplémentaires Unicode qui correspondent aux caractères dans les plans supplémentaires Unicode.  
  
-   Un groupes de graphèmes est représenté par un caractère de base suivi d’un ou plusieurs caractères d’association. Par exemple, le caractère ä est représenté par un <xref:System.Char> objet dont le point de code est U + 0061, suivi par un <xref:System.Char> objet dont le point de code est U + 0308. Ce caractère peut également être défini par un seul <xref:System.Char> objet qui a un point de code de U + 00E4. Comme le montre l’exemple suivant, une comparaison dépendante de la culture d’égalité indique que ces deux représentations sont égales, bien que n’est pas le cas d’une comparaison ordinale ordinaire. Toutefois, si les deux chaînes sont normalisées, une comparaison ordinale indique également qu’ils sont égaux. (Pour plus d’informations sur la normalisation de chaînes, consultez le [normalisation](#Normalization) section.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode point de code supplémentaire (une paire de substitution) est représenté par un <xref:System.Char> objet dont le point de code est un substitut étendu suivi par un <xref:System.Char> objet dont le point de code est un substitut faible. Les unités de code de substituts étendus comprise entre U + D800 et U + DBFF. Les unités de code de substituts faibles comprise entre U + DC00 et U + DFFF. Les paires de substitution sont utilisés pour représenter des caractères dans les plans supplémentaires Unicode 16. L’exemple suivant crée un caractère de substitution et passe à la <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> méthode pour déterminer s’il s’agit d’une paire de substitution.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Chaînes et la norme Unicode  
 Caractères dans une chaîne sont représentés par les unités de code encodée en UTF-16, qui correspondent à des <xref:System.Char> valeurs.  
  
 Chaque caractère dans une chaîne a une catégorie de caractère Unicode associée, qui est représentée dans .NET par le <xref:System.Globalization.UnicodeCategory> énumération. La catégorie d’un caractère ou une paire de substitution peut être déterminée en appelant le <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> (méthode).  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 En outre, .NET prend en charge la comparaison de chaînes et de tri selon la norme Unicode. Dans les versions du .NET Framework via la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le .NET Framework gère sa propre table de données de chaîne. Cela vaut également des versions du .NET Framework en commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] s’exécutant sur Windows 7. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] s’exécutant sur Windows 8 et versions ultérieures du système d’exploitation Windows, les délégués de runtime chaîne comparaison et tri des opérations du système d’exploitation. Sur .NET Core, la comparaison de chaînes et des informations de tri sont fournie par [International Components for Unicode](http://site.icu-project.org/) bibliothèques. Le tableau suivant répertorie les versions de .NET et les versions de la norme Unicode sur le caractère de comparaison et de tri sont basées.  
  
|Version de .NET|Version de la norme Unicode Standard|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[The Unicode Standard, version 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|Le .NET Framework 2.0|[The Unicode Standard, version 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[The Unicode Standard, version 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[The Unicode Standard, version 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures sur Windows 7|[The Unicode Standard, version 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures sur Windows 8 et Windows versions ultérieures|[The Unicode Standard, version 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (toutes les versions)|Dépend de la version de la norme Unicode prises en charge par le système d’exploitation sous-jacent.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Chaînes et caractères null incorporés  
 Dans .NET, un <xref:System.String> objet peut inclure des caractères null incorporés, qui comptent dans la longueur de chaîne. Toutefois, dans certains langages tels que C et C++, un caractère null indique la fin d’une chaîne ; Il n’est pas considéré comme une partie de la chaîne et n’est pas compté dans le cadre de la longueur de chaîne. Cela signifie que les hypothèses courantes suivantes, les programmeurs C et C++ ou des bibliothèques écrites en C ou C++ peuvent effectuer sur les chaînes ne sont pas nécessairement valides lorsqu’il est appliqué à <xref:System.String> objets :  
  
-   La valeur retournée par la `strlen` ou `wcslen` fonctions n’est pas nécessairement égal <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   La chaîne créée par le `strcpy_s` ou `wcscpy_s` fonctions n’est pas nécessairement identique à la chaîne créée par le <xref:System.String.Copy%2A?displayProperty=nameWithType> (méthode).  
  
 Vous devez vous assurer que code C et C++ natif qui instancie <xref:System.String> objets et le code qui est passé <xref:System.String> objets via platform invoke, ne supposez pas qu’un caractère null incorporé marque la fin de la chaîne.  
  
 Les caractères null incorporés dans une chaîne sont également traités différemment lorsqu’une chaîne est triée (ou comparée) et lorsque la recherche d’une chaîne. Les caractères null sont ignorés lorsque vous effectuez des comparaisons dépendantes de la culture entre deux chaînes, notamment des comparaisons à l’aide de la culture dite indifférente. Ils sont considérés uniquement pour les comparaisons ordinales ordinales ou non la casse. En revanche, les caractères null incorporés sont toujours considérées comme lors de la recherche d’une chaîne avec des méthodes telles que <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, et <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Chaînes et des index  
 Un index est la position d’un <xref:System.Char> objet (pas un caractère Unicode) dans un <xref:System.String>. Un index est un nombre non négatif de base zéro qui démarre à partir de la première position dans la chaîne, qui est la position d’index zéro. Un nombre de méthodes de recherche, tel que <xref:System.String.IndexOf%2A> et <xref:System.String.LastIndexOf%2A>, retourner l’index d’un caractère ou d’une sous-chaîne dans l’instance de chaîne.  
  
 Le <xref:System.String.Chars%2A> propriété vous permet d’accéder à individuels <xref:System.Char> les objets par leur position d’index dans la chaîne. Étant donné que le <xref:System.String.Chars%2A> propriété est la propriété par défaut (en Visual Basic) ou l’indexeur (en c#), vous pouvez accéder à la personne <xref:System.Char> objets dans une chaîne à l’aide de code semblable au suivant. Ce code recherche des espaces blancs ou des caractères de ponctuation dans une chaîne pour déterminer le nombre de mots contient la chaîne.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Étant donné que le <xref:System.String> la classe implémente le <xref:System.Collections.IEnumerable> interface, vous pouvez également itérer au sein la <xref:System.Char> objets dans une chaîne à l’aide un `foreach` construction, comme le montre l’exemple suivant.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Valeurs d’index consécutives peuvent ne pas correspondant à des caractères Unicode consécutifs, car un caractère peut être encodé en Unicode comme plusieurs <xref:System.Char> objet. En particulier, une chaîne peut contenir des caractères multiples d’unités de texte sont formées par un caractère de base suivi par un ou plusieurs caractères d’association ou par paires de substitution. Pour travailler avec des caractères Unicode à la place de <xref:System.Char> objets, utiliser le <xref:System.Globalization.StringInfo?displayProperty=nameWithType> et <xref:System.Globalization.TextElementEnumerator> classes. L’exemple suivant illustre la différence entre le code qui fonctionne avec <xref:System.Char> objets et du code qui fonctionne avec des caractères Unicode. Il compare le nombre de caractères ou des éléments de texte de chaque mot d’une phrase. La chaîne inclut deux séquences d’un caractère de base suivie d’un caractère d’association.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Cet exemple fonctionne avec les éléments de texte à l’aide de la <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> (méthode) et le <xref:System.Globalization.TextElementEnumerator> classe pour énumérer tous les éléments de texte dans une chaîne. Vous pouvez également récupérer un tableau qui contient l’index de départ de chaque élément de texte en appelant le <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> (méthode).  
  
 Pour plus d’informations sur l’utilisation des unités de texte plutôt que personne <xref:System.Char> valeurs, consultez la <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Chaînes null et chaînes vides  
 Est une chaîne qui a été déclarée mais n’a pas été affectée une valeur `null`. Une tentative d’appel des méthodes sur cette chaîne lève un <xref:System.NullReferenceException>. Une chaîne null est différente d’une chaîne vide, ce qui est une chaîne dont la valeur est « » ou <xref:System.String.Empty?displayProperty=nameWithType>. Dans certains cas, en passant une chaîne null ou une chaîne vide en tant qu’argument dans un appel de méthode lève une exception. Par exemple, en passant une chaîne null pour le <xref:System.Int32.Parse%2A?displayProperty=nameWithType> méthode lève un <xref:System.ArgumentNullException>et en passant une chaîne vide lève un <xref:System.FormatException>. Dans d’autres cas, un argument de méthode peut être une chaîne null ou une chaîne vide. Par exemple, si vous fournissez un <xref:System.IFormattable> implémentation pour une classe, que vous souhaitez être équivalente à la fois une chaîne null et une chaîne vide avec le spécificateur de format général (« G »).  
  
 Le <xref:System.String> classe inclut les deux méthodes pratiques suivantes qui vous permettent de tester si une chaîne est `null` ou vide :  
  
-   <xref:System.String.IsNullOrEmpty%2A>, qui indique si une chaîne est soit `null` ou est égale à <xref:System.String.Empty?displayProperty=nameWithType>. Cette méthode élimine la nécessité d’utiliser le code suivant :  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, qui indique si une chaîne est `null`, est égal à <xref:System.String.Empty?displayProperty=nameWithType>, ou est composé exclusivement d’espaces blancs. Cette méthode élimine la nécessité d’utiliser le code suivant :  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 L’exemple suivant utilise le <xref:System.String.IsNullOrEmpty%2A> méthode dans le <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implémentation de personnalisé `Temperature` classe. La méthode prend en charge les chaînes de format « G », « C », « F » et « K ». Si une chaîne de format vide ou un format de chaîne dont la valeur est `null` est passé à la méthode, sa valeur est remplacée par la chaîne de format « G ».  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Immuabilité et la classe StringBuilder  
 Un <xref:System.String> objet est appelé immuable (en lecture seule), car sa valeur ne peut pas être modifiée après qu’il a été créé. Les méthodes qui semblent modifier une <xref:System.String> objet retournent en fait un nouvel <xref:System.String> objet qui contient la modification.  
  
 Étant donné que les chaînes sont immuables, les routines de manipulation de chaîne qui effectuent répété ajouts ou suppressions à ce qui semble être qu'une chaîne unique peut peser sensiblement les performances. Par exemple, le code suivant utilise un générateur de nombres aléatoires pour créer une chaîne contenant 1000 caractères dans la plage 0 x 0001 à 0x052F. Bien que le code semble utiliser la concaténation de chaînes à ajouter un nouveau caractère à la chaîne existante nommée `str`, elle crée réellement un <xref:System.String> objet pour chaque opération de concaténation.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Vous pouvez utiliser la <xref:System.Text.StringBuilder> classe au lieu du <xref:System.String> classe pour les opérations que vous apportez plusieurs modifications à la valeur d’une chaîne. Contrairement aux instances de la <xref:System.String> classe, <xref:System.Text.StringBuilder> objets sont mutables ; lorsque vous concaténez, ajoutez ou supprimez des sous-chaînes d’une chaîne, les opérations sont effectuées sur une seule chaîne. Lorsque vous avez terminé de modifier la valeur d’un <xref:System.Text.StringBuilder> de l’objet, vous pouvez appeler son <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> méthode pour le convertir en une chaîne. L’exemple suivant remplace le <xref:System.String> utilisé dans l’exemple précédent pour concaténer des caractères aléatoires de 1000 dans la plage 0 x 0001 à 0x052F avec un <xref:System.Text.StringBuilder> objet.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal et les opérations dépendantes de la culture  
 Membres de la <xref:System.String> classe opérations ordinales ou dépendantes de la culture (linguistique) sur un <xref:System.String> objet. Une opération ordinale agit sur la valeur numérique de chaque <xref:System.Char> objet. Une opération dépendante de la culture agit sur la valeur de la <xref:System.String> objet et prend une casse propres à la culture, le tri, de mise en forme et règles d’analyse en compte. Exécutent des opérations dépendantes de la culture dans le contexte d’une culture déclarée de manière explicite ou de la culture actuelle implicite. Les deux types d’opérations peuvent produire des résultats très différents lorsqu’elles sont exécutées sur la même chaîne.  
  
.NET prend également en charge les opérations de chaînes linguistique indépendante de la culture à l’aide de la culture dite indifférente (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), qui est faiblement basé sur les paramètres de culture de la langue anglaise indépendante de la région. Contrairement à d’autres <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> sont garantis que les paramètres, les paramètres de la culture dite indifférente, restent cohérentes sur un seul ordinateur, à partir du système au système et entre les versions de .NET. La culture dite indifférente peut être considéré comme étant un type de boîte noire qui garantit la stabilité de comparaisons de chaînes et de classement dans toutes les cultures.  
  
> [!IMPORTANT]
>  Si votre application prend une décision de sécurité sur un identificateur symbolique tel qu’un nom de fichier ou canal nommé, ou des données rendues persistantes telles que les données textuelles dans un fichier XML, l’opération doit utiliser une comparaison ordinale au lieu d’une comparaison dépendante de la culture. Il s’agit, car une comparaison dépendante de la culture peut produire des résultats différents selon la culture en vigueur, alors qu’une comparaison ordinale dépend uniquement de la valeur binaire des caractères comparés.  
  
> [!IMPORTANT]
>  La plupart des méthodes qui effectuent des opérations de chaîne incluent une surcharge qui a un paramètre de type <xref:System.StringComparison>, ce qui vous permet de spécifier si la méthode exécute une opération ordinale ou dépendante de la culture. En règle générale, vous devez appeler cette surcharge pour appeler l’intention de votre méthode clair. Pour les meilleures pratiques et conseils d’utilisation des opérations ordinales et dépendantes de la culture sur les chaînes, consultez [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Opérations pour [casse](#casing), [l’analyse et de mise en forme](#parsing), [comparaison et tri](#comparison), et [test d’égalité](#equality) peut être soit ordinal ou respect de la culture. Les sections suivantes décrivent chaque catégorie d’opération.  
  
> [!TIP]
>  Vous devez toujours appeler une surcharge de méthode qui effectue à l’intention de votre méthode d’appel clair. Par exemple, au lieu d’appeler le <xref:System.String.Compare%28System.String%2CSystem.String%29> méthode pour effectuer une comparaison dépendante de la culture de deux chaînes en utilisant les conventions de la culture actuelle, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> méthode avec la valeur <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> pour le `comparisonType` argument. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  

Vous pouvez télécharger les [Sorting Weight Tables](https://www.microsoft.com/en-us/download/details.aspx?id=10921), un ensemble de fichiers texte qui contiennent des informations sur les poids des caractères utilisés dans les opérations de tri et de comparaison pour les systèmes d’exploitation Windows et la [Default Unicode Collation Element Table](https://www.unicode.org/Public/UCA/latest/allkeys.txt), la table de pondération de tri pour Linux et macOS.

<a name="casing"></a>   
### <a name="casing"></a>Casse  
 Règles de casse déterminent comment modifier la mise en majuscules d’un caractère Unicode ; par exemple, de minuscules en majuscules. Souvent, une opération de casse est effectuée avant une comparaison de chaînes. Par exemple, une chaîne peut être convertie en majuscules afin qu’elle peut être comparée avec une autre chaîne en majuscules. Vous pouvez convertir les caractères dans une chaîne en minuscules en appelant le <xref:System.String.ToLower%2A> ou <xref:System.String.ToLowerInvariant%2A> (méthode) et vous pouvez les convertir en majuscules en appelant le <xref:System.String.ToUpper%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). En outre, vous pouvez utiliser la <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> méthode pour convertir une chaîne en majuscules.  
  
 Opérations de casse peuvent être basées sur les règles de la culture actuelle, une culture spécifiée ou la culture dite indifférente. Étant donné que les mappages de casse peuvent varier en fonction de la culture utilisée, le résultat des opérations de casse peut varier en fonction de la culture. Il existe trois types de réelles différences de casse :  
  
-   Différences dans le mappage de casse de la lettre majuscule de LATIN I (U + 0049), petite lettre I LATIN (U + 0069), LATIN MAJUSCULE I point ci-dessus (U + 0130), et LATIN petite lettre sans point I (U + 0131). Dans les cultures de az-Latn-AZ (Azerbaïdjan, Latin) et le tr-TR (turc (Turquie)), tr, az, les cultures neutres az-Latn, l’équivalent en minuscule de lettre majuscule latine I est LATIN petite lettre sans point I, et est l’équivalent en majuscule latine de petite lettre i LETTRE MAJUSCULE LATINE I POINT CI-DESSUS. Dans toutes les autres cultures, y compris la culture dite indifférente, LATIN petite lettre I et la MAJUSCULE LATIN I sont équivalents majuscules et minuscules.  
  
     L’exemple suivant montre comment une comparaison de chaînes conçue pour empêcher l’accès au système de fichiers peut échouer si elle s’appuie sur une comparaison de la casse de la culture. (Les conventions de casse de la culture dite indifférente doivent avoir été utilisées.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Différences dans les mappages de casse entre tous les autres cultures et de la culture dite indifférente. Dans ce cas, à l’aide des règles de casse de la culture dite indifférente pour modifier un caractère en majuscules ou minuscules retourne le même caractère. Pour toutes les autres cultures, elle retourne un caractère différent. Certains caractères concernés sont répertoriés dans le tableau suivant.  
  
    |Caractère|Si vous en|Returns (Retours)|  
    |---------------|-------------------|-------------|  
    |CONNEXION TECHNIQUE (U + 00B5)|Majuscules|LETTRE MAJUSCULE GRECQUE MU (U +-39C)|  
    |LETTRE MAJUSCULE LATINE I POINT CI-DESSUS (U + 0130)|Minuscules|LETTRE MINUSCULE LATINE I (U + 0069)|  
    |LETTRE MINUSCULE LATINE SANS POINT JE (U + 0131)|Majuscules|LETTRE MAJUSCULE LATINE I (U + 0049)|  
    |LETTRE MINUSCULE LATINE LONG S (U + 017F)|Majuscules|LETTRE MAJUSCULE LATINE S (U + 0053)|  
    |D LETTRE MAJUSCULE LATINE Z LETTRE MINUSCULE CARON (U + 01C 5)|Minuscules|LETTRE MINUSCULE LATINE DZ CARON (U + 01C 6)|  
    |COMBINAISON GREC IOTA SOUSCRIT (U + 0345)|Majuscules|LETTRE MAJUSCULE GRECQUE IOTA (U + 0399)|  
  
-   Différences dans les mappages de casse de deux lettres minuscules paires dans la plage de caractères ASCII. Dans la plupart des cultures, une paire de casse mixte de deux lettres est égale à la paire de caractères majuscule ou minuscule équivalente à deux lettres. Cela n’est pas vrai pour les paires de deux lettres suivantes dans les cultures suivantes, car dans chaque cas, elles sont comparées à un digramme :  
  
    -   « lJ » et « New Jersey » dans la culture hr-HR (croate (Croatie)).  
  
    -   « cH » dans le cs-CZ (tchèque (République tchèque)) et les cultures sk-SK (slovaque (Slovaquie)).  
  
    -   « aA » dans la culture da-DK (Danois (Danemark)).  
  
    -   « cS », « dZ », « dZS », « nY », « sZ », « tY » et « zS » dans la culture hu-HU (hongrois (Hongrie)).  
  
    -   « cH » et « lL » dans la culture es-ES_tradnl (espagnol (Espagne, traditionnel)).  
  
    -   « cH », « gI », « kH », « nG » « nH », « pH », « qU », « tH » et « tR » dans la culture vi-VN (vietnamien (Vietnam)).  
  
     Toutefois, il est rare de rencontrer une situation dans laquelle une comparaison dépendante de la culture de ces paires crée des problèmes, étant donné que ces paires sont rares dans les chaînes fixes ou des identificateurs.  
  
 L’exemple suivant illustre certaines des différences dans les règles de casse entre les cultures lors de la conversion de chaînes en majuscules.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>L’analyse et mise en forme  
 Mise en forme et l’analyse sont des opérations inverses. Règles de mise en forme déterminent comment convertir une valeur, comme une date et heure ou un nombre, en sa représentation sous forme de chaîne, tandis que les règles d’analyse déterminent comment convertir une représentation de chaîne en une valeur telle qu’une date et une heure. Mise en forme et de règles d’analyse sont dépendantes des conventions culturelles. L’exemple suivant illustre l’ambiguïté pouvant survenir lors de l’interprétation d’une chaîne de date spécifique à la culture. Sans connaître les conventions de la culture qui a été utilisée pour générer une chaîne de date, il n’est pas possible de savoir si 03/01/2011, 3/1/2011 et 01/03/2011 représentent le 3 janvier 2011 ou le 1er mars 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 De même, comme le montre l’exemple suivant, une chaîne unique peut produire des dates différentes selon la culture dont les conventions sont utilisées dans l’opération d’analyse.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Comparaison de chaînes et le tri  
 Conventions pour comparer et trier des chaînes varient d’une culture. Par exemple, l’ordre de tri peut être basé sur la phonétique ou sur la représentation visuelle des caractères. Dans les langues d'Asie orientale, les caractères sont classés en fonction du trait et de la clé des idéogrammes. Le tri peut aussi varier en fonction de l'ordre fondamental utilisé par la langue ou la culture pour l'alphabet. Par exemple, la langue danoise emploie un caractère "Æ" qu'elle place après "Z" dans l'alphabet. En outre, les comparaisons peuvent respecter la casse, et dans certains cas, les règles de casse diffèrent également selon la culture. Comparaison ordinale, utilise en revanche, les points de code Unicode des caractères individuels dans une chaîne lors de la comparaison et tri des chaînes.  
  
 Les règles de tri déterminent que l’ordre alphabétique des caractères Unicode et la manière dont deux chaînes comparer entre eux. Par exemple, le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> méthode compare deux chaînes selon la <xref:System.StringComparison> paramètre. Si la valeur du paramètre est <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, la méthode effectue une comparaison linguistique qui utilise les conventions de la culture actuelle ; si la valeur du paramètre est <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, la méthode effectue une comparaison ordinale. Par conséquent, comme dans l’exemple suivant, si la culture actuelle est anglais Anglais, le premier appel à la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> (méthode) (à l’aide de la comparaison dépendante de la culture) considère « a » inférieur à « A », mais le deuxième appel à la même méthode (à l’aide de la comparaison ordinale) considère « a » comme supérieur à « A ».  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET prend en charge les mots, des chaînes et des règles de tri ordinal :  
  
-   Un tri word effectue une comparaison dépendante de la culture de chaînes dans lequel certains caractères Unicode non alphanumériques peuvent avoir une pondération spéciale pour les. Par exemple, le trait d’union (-) peut avoir une très petite pondération pour afin que « coop » et « co-op » apparaissent en regard de chacun des autres dans une liste triée. Pour obtenir la liste de la <xref:System.String> les méthodes qui permettent de comparer deux chaînes à l’aide de règles de tri de word, consultez le [opérations de chaîne par catégorie](#ByCategory) section.  
  
-   Un triage de chaînes effectue également une comparaison dépendante de la culture. Il est similaire au tri par mot, sauf qu’il existe des cas spéciaux, et tous les symboles non alphanumériques sont avant tous les caractères Unicode alphanumériques. Deux chaînes peuvent être comparées à l’aide de règles de tri de chaîne en appelant le <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> des surcharges de méthode qui ont un `options` paramètre est fourni une valeur de <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Notez qu’il s’agit de la seule méthode .NET fournit pour comparer deux chaînes à l’aide de règles de tri de chaîne.  
  
-   Tri ordinal compare des chaînes en fonction de la valeur numérique de chaque <xref:System.Char> objet dans la chaîne. Une comparaison ordinale est automatiquement la casse, car les versions en minuscules et majuscules d’un caractère ont des points de code différents. Toutefois, si la casse n’est pas importante, vous pouvez spécifier une comparaison ordinale qui ignore la casse. Cela équivaut à convertir la chaîne en majuscules à l’aide de la culture dite indifférente et effectuer une comparaison ordinale du résultat. Pour obtenir la liste de la <xref:System.String> les méthodes qui permettent de comparer deux chaînes à l’aide de règles de tri ordinal, consultez le [opérations de chaîne par catégorie](#ByCategory) section.  
  
 Une comparaison dépendante de la culture est une comparaison qui utilise explicitement ou implicitement un <xref:System.Globalization.CultureInfo> objet, y compris la culture dite indifférente est spécifiée par le <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propriété. La culture implicite est la culture actuelle, qui est spécifiée par le <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> et <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriétés. Il existe des variations considérables dans l’ordre de tri des caractères alphabétiques (autrement dit, les caractères pour lequel le <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> retourne de la propriété `true`) dans toutes les cultures. Vous pouvez spécifier une comparaison dépendante de la culture qui utilise les conventions d’une culture spécifique en fournissant un <xref:System.Globalization.CultureInfo> d’objet à une méthode de comparaison de chaîne comme <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Vous pouvez spécifier une comparaison dépendante de la culture qui utilise les conventions de la culture actuelle, vous devez fournir <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, ou un membre de la <xref:System.Globalization.CompareOptions> énumération autre que <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> ou <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> un appropriés surcharge de la <xref:System.String.Compare%2A> (méthode). Une comparaison dépendante de la culture est généralement appropriée pour le tri tandis que ce qui n’est pas une comparaison ordinale. Une comparaison ordinale est généralement appropriée pour déterminer si deux chaînes sont égales (autrement dit, pour déterminer l’identité) qu’une comparaison dépendante de la culture n’est pas.  
  
 L’exemple suivant illustre la différence entre la comparaison ordinale et de la culture. L’exemple évalue les trois chaînes « Apple », « Æble » et « AEble », à l’aide de la comparaison ordinale et les conventions des cultures da-DK et en-US (chacun d’eux est la culture par défaut au moment où le <xref:System.String.Compare%2A> méthode est appelée). Étant donné que la langue danoise traite le caractère « Æ » comme une seule lettre et trie après « Z » dans l’alphabet, la chaîne « Æble » est supérieure à « Apple ». Toutefois, « Æble » n’est pas considéré équivalent à « AEble », donc « Æble » est également supérieure à « AEble ». La culture en-US n’inclut pas la lettre « Æ », mais la traite comme équivalent à « AE », ce qui explique pourquoi « Æble » est inférieure à « Apple » mais égal à « AEble ». Comparaison ordinale, quant à eux, estime que « Apple » est inférieure à « Æble » et « Æble » est supérieure à « AEble ».  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Utilisez les directives générales suivantes pour choisir une méthode de comparaison de tri ou de chaîne appropriée :  
  
-   Si vous souhaitez les chaînes doivent être classés en fonction de la culture, vous devez classer les selon les conventions de la culture actuelle. Si la culture de l’utilisateur change, l’ordre des chaînes de tri modifiera également en conséquence. Par exemple, une application de dictionnaire des synonymes doit toujours trier les mots en se basant sur la culture de l’utilisateur.  
  
-   Si vous souhaitez les chaînes doivent être classés selon les conventions d’une culture spécifique, vous devez les classer en fournissant un <xref:System.Globalization.CultureInfo> objet qui représente cette culture à une méthode de comparaison. Par exemple, dans une application conçue pour enseigner aux étudiants un langage particulier, vous souhaitez les chaînes doivent être classés selon les conventions d’une des cultures qui parle cette langue.  
  
-   Si vous souhaitez que l’ordre de chaînes restent inchangés dans toutes les cultures, dans l’ordre selon les conventions de la culture dite indifférente ou si vous utilisez une comparaison ordinale. Par exemple, vous utiliseriez un tri ordinal pour organiser les noms de fichiers, les processus, les mutex ou canaux nommés.  
  
-   Pour obtenir une comparaison qui implique une décision de sécurité (par exemple, si un nom d’utilisateur est valide), vous devez toujours effectuer un test ordinal pour l’égalité en appelant une surcharge de la <xref:System.String.Equals%2A> (méthode).  
  
> [!NOTE]
>  Le tri de la culture et la casse des règles utilisées dans la comparaison de chaînes dépendent de la version du .NET Framework. Dans le .NET Framework 4.5 et versions ultérieures s’exécutant sur le [!INCLUDE[win8](~/includes/win8-md.md)] système d’exploitation, de tri, casse, normalisation et informations sur les caractères Unicode est conforme à la norme Unicode 6.0. Sur d’autres systèmes d’exploitation Windows, il est conforme à la norme Unicode 5.0. .NET Core, elle dépend de la version de la norme Unicode prises en charge par le système d’exploitation sous-jacent. 
  
 Pour plus d’informations sur les mots, des chaînes et des règles de tri ordinal, consultez le <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> rubrique. Pour obtenir des recommandations supplémentaires sur quand utiliser chaque règle, consultez [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 En règle générale, vous n’appelez pas chaîne les méthodes de comparaison telles que <xref:System.String.Compare%2A> directement pour déterminer l’ordre de tri de chaînes. Au lieu de cela, les méthodes de comparaison sont appelées par les méthodes de tri comme <xref:System.Array.Sort%2A?displayProperty=nameWithType> ou <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. L’exemple suivant effectue quatre opérations de tri différentes (tri de word à l’aide de la culture actuelle, tri de word à l’aide de la culture dite indifférente, tri ordinal et tri des chaînes à l’aide de la culture dite indifférente) sans appeler explicitement une méthode de comparaison de chaîne Bien qu’ils spécifient le type de comparaison à utiliser. Notez que chaque type de tri produit un classement unique des chaînes dans son tableau.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  En interne, .NET utilise des clés de tri pour prendre en charge la comparaison de chaînes de culture. Chaque caractère d'une chaîne se voit attribuer plusieurs pondérations de tri, notamment les pondérations alphabétiques, de casse et diacritiques. Une clé de tri, représenté par le <xref:System.Globalization.SortKey> class, fournit un référentiel de ces pondérations pour une chaîne particulière. Si votre application effectue un grand nombre d’opérations sur le même ensemble de chaînes de tri ou de recherche, vous pouvez améliorer ses performances en générant et en stockant des clés de tri pour toutes les chaînes qu’il utilise. Lorsqu’une opération de tri ou de comparaison est requise, vous utilisez les clés de tri au lieu des chaînes. Pour plus d'informations, consultez la classe <xref:System.Globalization.SortKey>.  
  
 Si vous ne spécifiez pas une convention de comparaison de chaîne, les méthodes de tri comme <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> effectuer un tri de la culture et respectant la casse sur les chaînes. L’exemple suivant illustre comment modifier la culture actuelle affecte l’ordre des chaînes de tri dans un tableau. Il crée un tableau de trois chaînes. D'abord, cela définit la propriété `System.Threading.Thread.CurrentThread.CurrentCulture` sur la valeur en-US, et appelle la méthode <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>. L’ordre de tri qui en résulte est basée sur le tri des conventions pour la culture anglais (États-Unis). Ensuite, l'exemple définit la propriété `System.Threading.Thread.CurrentThread.CurrentCulture` sur da-DK et appelle à nouveau la méthode <xref:System.Array.Sort%2A?displayProperty=nameWithType>. Notez la façon dont l'utilisation des conventions de tri définies pour la culture danoise (Danemark) aboutit à un ordre de tri différent de celui obtenu pour la culture en-US.  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Si votre objectif principal dans la comparaison de chaînes consiste à déterminer si elles sont égales, vous devez appeler la <xref:System.String.Equals%2A?displayProperty=nameWithType> (méthode). En règle générale, vous devez utiliser <xref:System.String.Equals%2A> pour effectuer une comparaison ordinale. Le <xref:System.String.Compare%2A?displayProperty=nameWithType> méthode est principalement destinée à trier les chaînes.  
  
 Chaîne des méthodes de recherche, tels que <xref:System.String.StartsWith%2A?displayProperty=nameWithType> et <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, vous pouvez également effectuer des comparaisons de chaînes dépendantes de la culture ou ordinales. L’exemple suivant illustre les différences entre les comparaisons ordinales et dépendantes de la culture à l’aide du <xref:System.String.IndexOf%2A> (méthode). Une recherche dépendante de la culture dans laquelle la culture actuelle est anglais (États-Unis) prend en compte la sous-chaîne « l’Explorateur d’objets » pour faire correspondre la ligature « section ». Un trait d’union conditionnel (U + 00AD) étant un caractère de largeur nulle, la recherche traite le trait d’union conditionnel comme équivalent à <xref:System.String.Empty> et trouve une correspondance au début de la chaîne. Une recherche ordinale, quant à eux, ne trouve pas de correspondance dans les deux cas.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Recherche de chaînes  
 Chaîne des méthodes de recherche, tels que <xref:System.String.StartsWith%2A?displayProperty=nameWithType> et <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, vous pouvez également effectuer la culture ou les comparaisons de chaînes ordinales pour déterminer si un caractère ou une sous-chaîne se trouve dans une chaîne spécifiée.  
  
 Les méthodes de recherche dans les <xref:System.String> classe rechercher un caractère individuel, tel que le <xref:System.String.IndexOf%2A> (méthode), ou partie d’un jeu de caractères, tels que le <xref:System.String.IndexOfAny%2A> (méthode), tous effectuent une recherche ordinale. Pour effectuer une recherche dépendante de la culture d’un caractère, vous devez appeler un <xref:System.Globalization.CompareInfo> méthode telle que <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> ou <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Notez que les résultats de recherche d’un caractère à l’aide de la comparaison ordinale et la culture peuvent être très différentes. Par exemple, une recherche d’un caractère Unicode précomposé telles que la ligature « Æ » (U + 00C 6) peut correspondre à n’importe quelle occurrence de ses composants dans l’ordre approprié, tel que « AE » (U + 041U + 0045), en fonction de la culture. L’exemple suivant illustre la différence entre la <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> et <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> méthodes lorsque vous recherchez un caractère individuel. La ligature « æ » (U + 00E6) se trouve dans la chaîne « aérienne » lorsque vous utilisez les conventions de la culture en-US, mais ne pas lorsque vous utilisez les conventions de la culture da-DK ou lorsque vous effectuez une comparaison ordinale.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 En revanche, <xref:System.String> méthodes recherchez une chaîne au lieu d’un caractère effectuer une recherche dépendante de la culture si les options de recherche ne sont pas explicitement spécifiées par un paramètre de type de la classe <xref:System.StringComparison>. La seule exception est <xref:System.String.Contains%2A>, qui effectue une recherche ordinale.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Test d’égalité  
 Utilisez le <xref:System.String.Compare%2A?displayProperty=nameWithType> méthode pour déterminer la relation entre deux chaînes dans l’ordre de tri. En règle générale, il s’agit d’une opération dépendante de la culture. En revanche, appelez le <xref:System.String.Equals%2A?displayProperty=nameWithType> méthode pour tester l’égalité. Étant donné que le test d’égalité compare généralement l’entrée utilisateur avec une chaîne connue, comme un nom d’utilisateur valide, un mot de passe ou un chemin d’accès de système de fichiers, il est généralement une opération ordinale.  
  
> [!WARNING]
>  Il est possible de tester l’égalité en appelant le <xref:System.String.Compare%2A?displayProperty=nameWithType> méthode et déterminer si la valeur de retour est zéro. Toutefois, cette pratique n’est pas recommandée. Pour déterminer si deux chaînes sont égales, vous devez appeler une des surcharges de la <xref:System.String.Equals%2A?displayProperty=nameWithType> (méthode). La surcharge par défaut à appeler est l’instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> méthode ou la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), étant donné que les deux méthodes incluent un <xref:System.StringComparison?displayProperty=nameWithType> paramètre qui spécifie explicitement le type de comparaison.  
  
 L’exemple suivant illustre le risque d’effectuer une comparaison dépendante de la culture pour l’égalité lorsqu’un ordinal une doit être utilisée à la place. Dans ce cas, l’objectif du code consiste à interdire l’accès au système de fichiers à partir des URL qui commencent par « FILE:// » ou « file:// » en effectuant une comparaison respectant la casse du début d’une URL avec la chaîne « FILE:// ». Toutefois, si une comparaison dépendante de la culture est effectuée à l’aide de la culture turc (Turquie) sur une URL qui commence par « file:// », la comparaison d’égalité échoue, car l’équivalent en majuscule turque de la minuscule « i » est « » au lieu de « I ». Par conséquent, les accès au système de fichiers est autorisée par inadvertance. En revanche, si une comparaison ordinale est effectuée, la comparaison d’égalité réussit et accès au système de fichiers est refusé.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalisation  
 Certains caractères Unicode ont plusieurs représentations. Par exemple, un des points de code suivant peut représenter la lettre « ắ » :  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Plusieurs représentations pour un seul caractère compliquent la recherche, le tri, la mise en correspondance et les autres opérations de chaînes.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire d’un caractère Unicode pour sa représentation binaire équivalente. La normalisation peut utiliser plusieurs algorithmes, appelés formulaires de normalisation, qui suivent des règles différentes. .NET prend en charge les formulaires de normalisation Unicode C, D, KC et KD. Lorsque les chaînes ont été normalisées selon le même formulaire de normalisation, ils peuvent être comparés à l’aide d’une comparaison ordinale.  
  
 Une comparaison ordinale est une comparaison binaire de la valeur scalaire Unicode correspondant <xref:System.Char> objets dans chaque chaîne. Le <xref:System.String> classe inclut un nombre de méthodes qui peuvent effectuer une comparaison ordinale, y compris les éléments suivants :  
  
-   Aucune surcharge de la <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, et <xref:System.String.LastIndexOf%2A> méthodes qui inclut un <xref:System.StringComparison> paramètre. La méthode effectue une comparaison ordinale, si vous fournissez une valeur de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase> pour ce paramètre.  
  
-   Les surcharges de la <xref:System.String.CompareOrdinal%2A> (méthode).  
  
-   Les méthodes qui utilisent une comparaison ordinale par défaut, tels que <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, et <xref:System.String.Split%2A>.  
  
-   Les méthodes qui recherchent un <xref:System.Char> valeur ou pour les éléments dans un <xref:System.Char> tableau dans une instance de chaîne. Ces méthodes incluent <xref:System.String.IndexOf%28System.Char%29> et <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Vous pouvez déterminer si une chaîne est normalisée à un formulaire de normalisation C en appelant le <xref:System.String.IsNormalized?displayProperty=nameWithType> (méthode), ou vous pouvez appeler la <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> méthode pour déterminer si une chaîne est normalisée à un formulaire de normalisation spécifié. Vous pouvez également appeler le <xref:System.String.Normalize?displayProperty=nameWithType> méthode pour convertir une chaîne en un formulaire de normalisation C, ou vous pouvez appeler la <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> méthode pour convertir une chaîne à un formulaire de normalisation spécifié. Pour obtenir des informations détaillées sur la normalisation et la comparaison de chaînes, consultez le <xref:System.String.Normalize> et <xref:System.String.Normalize%28System.Text.NormalizationForm%29> méthodes.  
  
 L’exemple simple suivant illustre la normalisation des chaînes. Il définit la lettre « ố » de trois façons différentes dans trois chaînes différentes et utilise une comparaison ordinale d’égalité pour déterminer que chaque chaîne diffère des deux autres chaînes. Il convertit ensuite chaque chaîne pour les formulaires de normalisation pris en charge et à nouveau effectue une comparaison ordinale de chaque chaîne dans un formulaire de normalisation spécifié. Dans chaque cas, le deuxième test d’égalité montre que les chaînes sont égales.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Pour plus d’informations sur la normalisation et les formulaires de normalisation, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, ainsi que [Unicode Standard l’annexe 15 : formulaires de normalisation Unicode](https://unicode.org/reports/tr15/) et [FAQ de normalisation](https://www.unicode.org/faq/normalization.html) sur le site Web Unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Opérations de chaîne par catégorie  
 Le <xref:System.String> classe fournit des membres pour comparer des chaînes, de tester l’égalité, recherche des caractères ou des sous-chaînes dans une chaîne, la modification d’une chaîne, extraire des sous-chaînes d’une chaîne, la combinaison de chaînes, de valeurs, la copie d’une chaîne, de mise en forme de chaînes et normalisation d’une chaîne.  
  
### <a name="comparing-strings"></a>Comparaison de chaînes  
 Vous pouvez comparer des chaînes pour déterminer leur position relative dans l’ordre de tri à l’aide de ce qui suit <xref:System.String> méthodes :  
  
-   <xref:System.String.Compare%2A> Retourne un entier qui indique la relation entre une chaîne et une deuxième chaîne dans l’ordre de tri.  
  
-   <xref:System.String.CompareOrdinal%2A> Retourne un entier qui indique la relation entre une chaîne et une deuxième chaîne basée sur une comparaison de leurs points de code.  
  
-   <xref:System.String.CompareTo%2A> Retourne un entier qui indique la relation de l’instance actuelle de la chaîne et une deuxième chaîne dans l’ordre de tri. Le <xref:System.String.CompareTo%28System.String%29> méthode fournit le <xref:System.IComparable> et <xref:System.IComparable%601> implémentations pour les <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Tester l’égalité de chaînes  
 Vous appelez le <xref:System.String.Equals%2A> méthode pour déterminer si deux chaînes sont égales. L’instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> et statiques <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> surcharges vous permettent de spécifier si la comparaison est dépendante de la culture ou ordinale, et si la casse est considéré comme ou ignorée. La plupart des tests d’égalité sont ordinales et les comparaisons d’égalité qui déterminent l’accès à une ressource système (par exemple, un objet de système de fichiers) doivent toujours être ordinales.  
  
### <a name="finding-characters-in-a-string"></a>Recherche de caractères dans une chaîne  
 Le <xref:System.String> classe inclut deux types de méthodes de recherche :  
  
-   Les méthodes qui retournent un <xref:System.Boolean> valeur pour indiquer si une sous-chaîne spécifique est présente dans une instance de chaîne. Ceux-ci incluent le <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, et <xref:System.String.StartsWith%2A> méthodes.  
  
-   Méthodes qui indiquent la position de départ d’une sous-chaîne dans une instance de chaîne. Ceux-ci incluent le <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, et <xref:System.String.LastIndexOfAny%2A> méthodes.  
  
> [!WARNING]
>  Si vous souhaitez rechercher une chaîne pour un modèle particulier plutôt que d’une sous-chaîne spécifique, vous devez utiliser des expressions régulières. Pour plus d’informations, consultez [Expressions régulières .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modification d’une chaîne  
 Le <xref:System.String> classe comprend les méthodes suivantes qui semblent modifier la valeur d’une chaîne :  
  
-   <xref:System.String.Insert%2A> Insère une chaîne dans l’actuel <xref:System.String> instance.  
  
-   <xref:System.String.PadLeft%2A> Insère une ou plusieurs occurrences d’un caractère spécifié au début d’une chaîne.  
  
-   <xref:System.String.PadRight%2A> Insère une ou plusieurs occurrences d’un caractère spécifié à la fin d’une chaîne.  
  
-   <xref:System.String.Remove%2A> Supprime une sous-chaîne actuel <xref:System.String> instance.  
  
-   <xref:System.String.Replace%2A> remplace une sous-chaîne par une autre sous-chaîne en cours <xref:System.String> instance.  
  
-   <xref:System.String.ToLower%2A> et <xref:System.String.ToLowerInvariant%2A> convertir tous les caractères dans une chaîne en minuscules.  
  
-   <xref:System.String.ToUpper%2A> et <xref:System.String.ToUpperInvariant%2A> convertir tous les caractères dans une chaîne en majuscules.  
  
-   <xref:System.String.Trim%2A> Supprime toutes les occurrences d’un caractère de début et de fin d’une chaîne.  
  
-   <xref:System.String.TrimEnd%2A> Supprime toutes les occurrences d’un caractère de la fin d’une chaîne.  
  
-   <xref:System.String.TrimStart%2A> Supprime toutes les occurrences d’un caractère de début d’une chaîne.  
  
> [!IMPORTANT]
>  Toutes les méthodes de modification de chaîne retournent un nouvel <xref:System.String> objet. Ils ne modifiez pas la valeur de l’instance actuelle.  
  
### <a name="extracting-substrings-from-a-string"></a>Extraire des sous-chaînes d’une chaîne  
 Le <xref:System.String.Split%2A?displayProperty=nameWithType> méthode sépare une chaîne unique en plusieurs chaînes. Surcharges de la méthode permettent de spécifier plusieurs délimiteurs, pour déterminer le nombre maximal de sous-chaînes qui extrait la méthode et pour déterminer si les chaînes vides (qui se produisent lorsque les délimiteurs sont adjacents) sont inclus dans les chaînes retournées.  
  
### <a name="combining-strings"></a>Chaînes de combinaison  
 Ce qui suit <xref:System.String> méthodes peuvent être utilisées pour la concaténation de chaîne :  
  
-   <xref:System.String.Concat%2A> combine une ou plusieurs sous-chaînes dans une chaîne unique.  
  
-   <xref:System.String.Join%2A> Concatène une ou plusieurs sous-chaînes dans un seul élément et ajoute un séparateur entre chaque sous-chaîne.  
  
### <a name="formatting-values"></a>Mise en forme de valeurs  
 Le <xref:System.String.Format%2A?displayProperty=nameWithType> méthode utilise la fonctionnalité de mise en forme composite pour remplacer une ou plusieurs des espaces réservés dans une chaîne par la représentation sous forme de chaîne d’un objet ou une valeur. Le <xref:System.String.Format%2A> méthode est souvent utilisée pour effectuer les opérations suivantes :  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur numérique dans une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur de date et d’heure dans une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’une valeur d’énumération dans une chaîne.  
  
-   Pour incorporer la représentation sous forme de chaîne d’un objet qui prend en charge la <xref:System.IFormattable> interface dans une chaîne.  
  
-   Pour justifier à droite ou à gauche une sous-chaîne dans un champ dans une chaîne plus grande.  
  
 Pour obtenir des informations détaillées sur la mise en forme des opérations et des exemples, consultez la <xref:System.String.Format%2A> résumé de surcharge.  
  
### <a name="copying-a-string"></a>Copie d’une chaîne  
 Vous pouvez appeler ce qui suit <xref:System.String> méthodes pour effectuer une copie d’une chaîne :  
  
-   <xref:System.String.Clone%2A> Retourne une référence à un existant <xref:System.String> objet.  
  
-   <xref:System.String.Copy%2A> Crée une copie d’une chaîne existante.  
  
-   <xref:System.String.CopyTo%2A> copie une partie d’une chaîne dans un tableau de caractères.  
  
### <a name="normalizing-a-string"></a>Normalisation d’une chaîne  
 Au format Unicode, un caractère unique peut avoir plusieurs points de code. Normalisation convertit ces caractères équivalents dans la même représentation binaire. Le <xref:System.String.Normalize%2A?displayProperty=nameWithType> méthode effectue la normalisation et le <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> méthode détermine si une chaîne est normalisée.  
  
 Pour plus d’informations et un exemple, consultez le [normalisation](#Normalization) section plus haut dans cette rubrique.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Tri des systèmes d’exploitation de Tables de poids pour Windows</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Elemeent Table classement par défaut Unicode, pour Linux et macOS</related>
    <threadsafe>Ce type est thread-safe.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Meilleures pratiques pour l'utilisation de chaînes dans le .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans cette section :  
  
 [Syntaxe de constructeur surchargé](#Syntax)   
 [Paramètres](#Params)   
 [Exceptions](#Exceptions)   
 [Quelle méthode appeler ?](#Tasks)   
 [Création de chaînes](#Creating_Strings)   
 [Gestion des chaînes répétitives](#Repetitive)   
 Exemples de chaînes lors de l’instanciation :   
 [Utilisation de l’attribution de la chaîne](#Ctor1_Example)  
 [À l’aide d’un tableau de caractères](#Ctor2_Example)  
 [À l’aide d’une partie d’un tableau de caractères et en répétant un caractère unique](#Ctor3_Example)  
 [À l’aide d’un pointeur vers un tableau de caractères](#Ctor4_Example)  
 [À l’aide d’un pointeur et une plage d’un tableau](#Ctor5_Example)  
 [À l’aide d’un pointeur vers un tableau d’octets signés](#Ctor6_Example)  
[Informations de version](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Syntaxe de constructeur surchargé  
 Constructeurs de la chaîne se répartissent en deux catégories : ceux sans paramètres de pointeur et ceux avec des paramètres de pointeur. Les constructeurs qui utilisent des pointeurs ne sont pas conformes CLS. En outre, Visual Basic ne prend pas en charge l’utilisation des pointeurs et c# nécessite du code qui utilise des pointeurs pour s’exécuter dans un contexte unsafe. Pour plus d’informations, consultez [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Pour plus d’informations sur le choix d’une surcharge, consultez [quelle méthode appeler ?](#Tasks)  
  
 `String(Char[] value)`  
 Initialise la nouvelle instance à la valeur indiquée par un tableau de caractères Unicode. Ce constructeur copie les caractères Unicode ([exemple](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Initialise la nouvelle instance à la valeur indiquée par un tableau de caractères Unicode, une position de caractère de départ dans ce tableau et une longueur ([exemple](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Initialise la nouvelle instance à la valeur indiquée par un caractère Unicode spécifié répété un certain nombre de fois ([exemple](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Pas conforme CLS)**  Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau de caractères Unicode terminée par un caractère null (U + 0000 ou '\0'). ([exemple](#Ctor4_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Pas conforme CLS)**  Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau de caractères Unicode, une position de caractère de départ dans ce tableau et une longueur. Le constructeur copie les caractères Unicode à partir de `value` en commençant à l’index `startIndex` et en terminant à l’index `startIndex`  +  `length` – 1 ([exemple](#Ctor5_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value)`  
 **(Pas conforme CLS)**  Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits. Le tableau est supposé pour représenter une chaîne encodée à l’aide de la page de codes système actuel (autrement dit, l’encodage spécifié par <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Le constructeur traite les caractères de `value` à partir de l’emplacement spécifié par le pointeur jusqu'à ce qu’un caractère null (0 x 00) est atteinte ([exemple](#Ctor6_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Pas conforme CLS)**  Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits, une position de départ dans ce tableau et une longueur.  Le tableau est supposé pour représenter une chaîne encodée à l’aide de la page de codes système actuel (autrement dit, l’encodage spécifié par <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). Le constructeur traite les caractères à partir de la valeur en commençant à `startIndex` et en terminant à `startIndex`  +  `length` – 1 ([exemple](#Ctor6_Example)).  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Pas conforme CLS)**  Initialise la nouvelle instance à la valeur indiquée par un pointeur vers un tableau d’entiers signés 8 bits, une position de départ dans ce tableau, une longueur et un <xref:System.Text.Encoding> objet.  
  
 Autorisation : <xref:System.Security.SecurityCriticalAttribute>, requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Paramètres  
 Voici une liste complète des paramètres utilisés par <xref:System.String> constructeurs qui n’incluent pas un paramètre de pointeur. Pour les paramètres utilisés par chaque surcharge, consultez la syntaxe de la surcharge.  
  
|Paramètre|Type|Description |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Tableau de caractères Unicode.|  
|`c`|<xref:System.Char>|Caractère Unicode.|  
|`startIndex`|<xref:System.Int32>|Position de départ dans `value` du premier caractère dans la nouvelle chaîne.<br /><br /> Valeur par défaut : 0|  
|`length`|<xref:System.Int32>|Le nombre de caractères dans `value` à inclure dans la nouvelle chaîne.<br /><br /> Valeur par défaut : <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|Nombre de fois le caractère `c` est répétée dans la nouvelle chaîne. Si `count` est égal à zéro, la valeur du nouvel objet est <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Voici une liste complète des paramètres utilisés par <xref:System.String> constructeurs qui incluent un paramètre de pointeur. Pour les paramètres utilisés par chaque surcharge, consultez la syntaxe de la surcharge.  
  
|Paramètre|Type|Description |  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - ou -<br /><br /> <xref:System.SByte>\*|Pointeur vers un tableau se terminant par null de caractères Unicode ou un tableau d’entiers signés 8 bits. Si `value` est `null` ou un tableau vide, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|Index de l’élément de tableau qui définit le premier caractère dans la nouvelle chaîne.<br /><br /> Valeur par défaut : 0|  
|`length`|<xref:System.Int32>|Le nombre d’éléments de tableau à utiliser pour créer la nouvelle chaîne. Si la longueur est égale à zéro, le constructeur crée une chaîne dont la valeur est <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valeur par défaut : <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Objet qui spécifie comment la `value` est encodé.<br /><br /> Valeur par défaut : <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, ou page de codes ANSI actuelle du système|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Exceptions  
 Voici une liste d’exceptions levées par les constructeurs qui n’incluent pas les paramètres de pointeur.  
  
|Exception|Condition|Levée par|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` a la valeur `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, ou `count` est inférieur à zéro.<br /><br /> - ou -<br /><br /> La somme de `startIndex` et `length` est supérieure au nombre d’éléments de `value`.<br /><br /> - ou -<br /><br /> `count` est inférieur à zéro.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Voici une liste d’exceptions levées par des constructeurs qui incluent des paramètres de pointeur.  
  
|Exception|Condition|Levée par|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Spécifie un tableau qui contient un caractère Unicode non valide.<br /><br /> - ou -<br /><br /> `value` ou `value`  +  `startIndex` spécifie une adresse qui est inférieure à 64 Ko.<br /><br /> - ou -<br /><br /> Un nouveau <xref:System.String> instance n’a pas pu être initialisée à partir de la `value` tableau d’octets, car `value` n’utilise pas l’encodage de page de code par défaut.|Tous les constructeurs avec des pointeurs.|  
|<xref:System.ArgumentNullException>|`value` a la valeur null.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|Le processus actuel n’a pas d’accès en lecture à tous les caractères adressés.<br /><br /> - ou -<br /><br /> `startIndex` ou `length` est inférieur à zéro, `value` + `startIndex` entraîne un dépassement de capacité de pointeur ou le processus en cours n’a pas accès en lecture à tous les caractères identifiés par l’adresse.<br /><br /> - ou -<br /><br /> La longueur de la nouvelle chaîne est trop grande à allouer.|Tous les constructeurs avec des pointeurs.|  
|<xref:System.AccessViolationException>|`value`, ou `value`  +  `startIndex`  +  `length` – 1, spécifie une adresse non valide.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Quelle méthode appeler ?  
  
|À|Appel ou l’utilisation|  
|--------|-----------------|  
|Créer une chaîne.|Affectation à partir d’un littéral de chaîne ou une chaîne existante ([exemple](#Ctor1_Example))|  
|Créer une chaîne à partir d’un tableau de caractères entière.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([exemple](#Ctor2_Example))|  
|Créer une chaîne à partir d’une partie d’un tableau de caractères.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([exemple](#Ctor3_Example))|  
|Créer une chaîne qui se répète le même caractère plusieurs fois.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([exemple](#Ctor3_Example))|  
|Créer une chaîne à partir d’un pointeur vers une Unicode ou un tableau de caractères larges.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Créer une chaîne à partir d’une partie d’un tableau de caractères larges ou d’Unicode en utilisant son pointeur.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Créer une chaîne à partir de C++ `char` tableau.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - ou -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Créer une chaîne de caractères ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Création de chaînes  
 Les plus couramment utilisés technique pour créer par programme des chaînes est une assignation simple, comme illustré dans [cet exemple](#Ctor1_Example). Le <xref:System.String> classe inclut également les quatre types de surcharges de constructeur qui vous permettent de créer des chaînes à partir des valeurs suivantes :  
  
-   Tableau de caractères (il s’agit d’un tableau de caractères encodée en UTF-16). Vous pouvez créer un nouveau <xref:System.String> objet à partir des caractères dans l’intégralité du tableau ou une partie de celui-ci. Le <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructeur copie tous les caractères dans le tableau à la nouvelle chaîne. Le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur copie les caractères à partir de l’index `startIndex` à index `startIndex`  +  `length` – 1 pour la nouvelle chaîne. Si `length` est égal à zéro, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Si votre code instancie à plusieurs reprises les chaînes qui ont la même valeur, vous pouvez améliorer les performances de l’application à l’aide d’un autre moyen de la création de chaînes. Pour plus d’informations, consultez [gestion des chaînes répétitives](#Repetitive).  
  
-   À partir d’un seul caractère zéro en double, une ou plusieurs fois, à l’aide de la <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructeur. Si `count` est égal à zéro, la valeur de la nouvelle chaîne est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   À partir d’un pointeur vers un tableau de caractères se terminant par null, en utilisant le <xref:System.String.%23ctor%28System.Char%2A%29> ou <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructeur. L’intégralité du tableau ou une plage spécifiée peut être utilisée pour initialiser la chaîne. Le constructeur de copie d’une séquence de caractères Unicode commençant à partir du pointeur spécifié ou à partir du pointeur spécifié plu `startIndex` et en continuant à la fin du tableau ou pour `length` caractères. Si `value` est un pointeur null ou `length` est égal à zéro, le constructeur crée une chaîne dont la valeur est <xref:System.String.Empty?displayProperty=nameWithType>. Si l’opération de copie continue à la fin du tableau et le tableau n’est pas nul, le comportement du constructeur dépend du système. Cette condition peut provoquer une violation d’accès.  
  
     Si le tableau contient des caractères null incorporés (U + 0000 ou '\0') et le <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée, l’instance de chaîne contient `length` caractères, y compris ceux des nulls intégrés. L’exemple suivant montre ce qui se passe quand un pointeur vers un tableau de 10 éléments qui inclut deux caractères null est passé à la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> (méthode). Étant donné que l’adresse est le début du tableau, et tous les éléments du tableau doivent être ajoutés à la chaîne, le constructeur instancie une chaîne avec dix caractères, y compris les deux valeurs null incorporées. En revanche, si le même tableau est passé à la <xref:System.String.%23ctor%28System.Char%2A%29> constructeur, le résultat est une chaîne de quatre caractères qui n’inclut pas le premier caractère null.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     Le tableau doit contenir des caractères Unicode. En C++, cela signifie que le tableau de caractères doit être défini comme managé <xref:System.Char>type [] ou non managé`wchar_t`type [].  
  
     Si le <xref:System.String.%23ctor%28System.Char%2A%29> surcharge est appelée et le tableau n’est pas nul, ou si le <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée et `startIndex`  +  `length`-1 inclut une plage qui elle en dehors de la mémoire allouée pour la séquence de caractères, le comportement du constructeur est dépendante du système, et une violation d’accès peut se produire. En outre, sur le processeur Intel Itanium, les appels à la <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructeur peut lever une <xref:System.DataMisalignedException> exception. Si cela se produit, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> à la place.  
  
-   À partir d’un pointeur vers un tableau d’octets signés. L’intégralité du tableau ou une plage spécifiée peut être utilisée pour initialiser la chaîne. La séquence d’octets peut être interprétée à l’aide de la page de codes par défaut d’encodage ou un codage peut être spécifié dans l’appel de constructeur. Si le constructeur essaie d’instancier une chaîne à partir d’un tableau entier qui n’est pas nul, ou si la plage du tableau à partir de `value`  +  `startIndex` à `value`  +  `startIndex`  +  `length` -1 est en dehors de la mémoire allouée pour le tableau, le comportement de ce constructeur est dépendante du système, et une violation d’accès peut se produire.  
  
     Les trois constructeurs qui incluent un tableau d’octets signés en tant que paramètre sont principalement conçues pour convertir un C++ `char` tableau vers une chaîne, comme illustré dans cet exemple :  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Si le tableau contient des caractères null ('\0') ou des octets dont la valeur est 0 et le <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> surcharge est appelée, l’instance de chaîne contient `length` caractères, y compris ceux des nulls intégrés. L’exemple suivant montre ce qui se passe quand un pointeur vers un tableau de 10 éléments qui inclut deux caractères null est passé à la <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> (méthode). Étant donné que l’adresse est le début du tableau, et tous les éléments du tableau doivent être ajoutés à la chaîne, le constructeur instancie une chaîne avec dix caractères, y compris les deux valeurs null incorporées. En revanche, si le même tableau est passé à la <xref:System.String.%23ctor%28System.SByte%2A%29> constructeur, le résultat est une chaîne de quatre caractères qui n’inclut pas le premier caractère null.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Étant donné que le <xref:System.String.%23ctor%28System.SByte%2A%29> et <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructeurs interprètent `value` à l’aide de la page de codes ANSI par défaut, ces constructeurs avec des tableaux d’octets identiques peut créer des chaînes qui ont des valeurs différentes sur des systèmes différents.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Gestion des chaînes répétitives  
 Utilisent des applications qui analysent ou décodent le flux de texte souvent la <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur ou la <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour convertir des séquences de caractères en une chaîne. Création à plusieurs reprises de chaînes avec la même valeur au lieu de créer et réutiliser une seule chaîne gaspille de la mémoire. Si vous êtes susceptible de créer la même valeur de chaîne à plusieurs reprises en appelant le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur, même si vous ne savez pas dans ce que ces valeurs de chaîne identiques peuvent être d’avance, vous pouvez utiliser une table de recherche à la place.  
  
 Par exemple, supposons que vous lire et analysez un flux de caractères à partir d’un fichier qui contient des balises et attributs XML. Lorsque vous analysez le flux, vous rencontrez à plusieurs reprises certains jetons (autrement dit, les séquences de caractères qui ont une signification symbolique). Jetons équivalentes aux chaînes « 0 », « 1 », « true » et « false » sont susceptibles de se produire fréquemment dans un flux XML.  
  
 Au lieu de convertir chaque jeton dans une nouvelle chaîne, vous pouvez créer un <xref:System.Xml.NameTable?displayProperty=nameWithType> objet pour contenir les chaînes courantes. Le <xref:System.Xml.NameTable> objet améliore les performances, car il récupère les chaînes stockées sans allouer de mémoire temporaire. Lorsque vous rencontrez un jeton, utilisez la <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour récupérer le jeton à partir de la table. Si le jeton existe, la méthode retourne la chaîne correspondante. Si le jeton n’existe pas, utilisez le <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> méthode pour insérer le jeton dans la table et pour obtenir la chaîne correspondante.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Exemple 1 : Utilisation d’affectation de la chaîne  
 L’exemple suivant crée une nouvelle chaîne en lui assignant un littéral de chaîne. Il crée une deuxième chaîne en lui assignant la valeur de la première chaîne. Deux méthodes courantes pour instancier un nouvel <xref:System.String> objet.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Exemple 2 : Utilisation d’un tableau de caractères  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’un tableau de caractères.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Exemple 3 : À l’aide d’une partie d’un tableau de caractères et en répétant un caractère unique  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’une partie d’un tableau de caractères et comment créer un nouveau <xref:System.String> objet qui contient plusieurs occurrences d’un seul caractère.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Exemple 4 : Utilisation d’un pointeur vers un tableau de caractères  
 L’exemple suivant montre comment créer un nouveau <xref:System.String> objet à partir d’un pointeur vers un tableau de caractères. L’exemple c# doit être compilé à l’aide de la `/unsafe` commutateur de compilateur.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Exemple 5 : L’instanciation d’une chaîne à partir d’un pointeur et une plage d’un tableau  
 L’exemple suivant examine les éléments d’un tableau de caractères pour une période ou un point d’exclamation. S’il existe, il instancie une chaîne à partir des caractères dans le tableau qui précèdent le signe de ponctuation. Si ce n’est pas le cas, il instancie une chaîne avec tout le contenu du tableau. L’exemple c# doit être compilé à l’aide de la `/unsafe` commutateur de compilateur.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Exemple 6 : L’instanciation d’une chaîne à partir d’un pointeur vers un tableau d’octets signés  
 L’exemple suivant montre comment vous pouvez créer une instance de la <xref:System.String> classe avec le <xref:System.String.%23ctor%28System.SByte%2A%29> constructeur.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informations de version  
 .NET Framework  
 Toutes les surcharges sont pris en charge dans : 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Toutes les surcharges sont pris en charge dans : 4, 3.5 SP1  
  
 Bibliothèque de classes portable  
 Toutes les surcharges sans un <xref:System.SByte> `*` paramètre sont pris en charge  
  
 .NET pour les applications du Windows Store  
 Toutes les surcharges sans un <xref:System.SByte> `*` paramètre sont pris en charge dans : Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau de caractères Unicode terminé par un caractère null.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le processus actuel n’a pas d’accès en lecture à tous les caractères adressés.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> spécifie un tableau qui contient un caractère Unicode non valide ou <paramref name="value" /> spécifie une adresse inférieure à 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères Unicode.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits terminé par le caractère null. Les entiers sont interprétés à l’aide de l’encodage de page de codes système actuel (autrement dit, l’encodage spécifié par <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur vers un tableau d'entiers signés 8 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Une nouvelle instance de <see cref="T:System.String" /> n’a pas pu être initialisée à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé au format ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La longueur de la nouvelle chaîne à initialiser, déterminée par le caractère de fin Null de <paramref name="value" />, est trop grande à allouer.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> spécifie une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Caractère Unicode.</param>
        <param name="count">Nombre de fois où <paramref name="c" /> se produit.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un caractère Unicode spécifié et répété un certain nombre de fois.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau de caractères Unicode.</param>
        <param name="startIndex">Position de départ dans <paramref name="value" />.</param>
        <param name="length">Nombre de caractères dans <paramref name="value" /> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau de caractères Unicode, un point de départ pour le caractère dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro, <paramref name="value" /> + <paramref name="startIndex" /> entraîne un dépassement de capacité de pointeur ou le processus en cours n’a pas accès en lecture à tous les caractères identifiés par l’adresse.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> spécifie un tableau qui contient un caractère Unicode non valide ou <paramref name="value" /> + <paramref name="startIndex" /> spécifie une adresse inférieure à 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Tableau de caractères Unicode.</param>
        <param name="startIndex">Position de départ dans <paramref name="value" />.</param>
        <param name="length">Nombre de caractères dans <paramref name="value" /> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un tableau de caractères Unicode, une position de départ pour le caractère dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  
  
- ou - 
La somme de <paramref name="startIndex" /> et <paramref name="length" /> est supérieure au nombre d’éléments de <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits. Les entiers sont interprétés à l’aide de l’encodage de page de codes système actuel (autrement dit, l’encodage spécifié par <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">Position de départ dans <paramref name="value" />.</param>
        <param name="length">Nombre de caractères dans <paramref name="value" /> à utiliser.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau d'entiers signés 8 bits, une position de départ dans ce tableau et une longueur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  
  
- ou - 
L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est trop grande pour la plateforme actuelle ; autrement dit, le calcul d’adresse a été l’objet d’un dépassement de capacité.  
  
- ou - 
La longueur de la nouvelle chaîne à initialiser est trop grande à allouer.</exception>
        <exception cref="T:System.ArgumentException">L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est inférieure à 64 Ko.  
  
- ou - 
Une nouvelle instance de <see cref="T:System.String" /> n’a pas pu être initialisée à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé au format ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> et <paramref name="length" /> spécifient collectivement une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Pointeur vers un tableau d'entiers signés 8 bits.</param>
        <param name="startIndex">Position de départ dans <paramref name="value" />.</param>
        <param name="length">Nombre de caractères dans <paramref name="value" /> à utiliser.</param>
        <param name="enc">Objet qui spécifie la façon dont le tableau référencé par <paramref name="value" /> est encodé. Si <paramref name="enc" /> est <see langword="null" />, l'encodage ANSI est utilisé par défaut.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.String" /> à la valeur indiquée par un pointeur spécifié vers un tableau d'entiers signés 8 bits, une position de départ dans ce tableau, une longueur et un objet <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Pour obtenir des exemples et informations d’utilisation complètes sur cela et d’autres `String` surcharges de constructeur, consultez la <xref:System.String.%23ctor%2A> résumé du constructeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  
  
- ou - 
L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est trop grande pour la plateforme actuelle ; autrement dit, le calcul d’adresse a été l’objet d’un dépassement de capacité.  
  
- ou - 
La longueur de la nouvelle chaîne à initialiser est trop grande à allouer.</exception>
        <exception cref="T:System.ArgumentException">L’adresse spécifiée par <paramref name="value" /> + <paramref name="startIndex" /> est inférieure à 64 Ko.  
  
- ou - 
Nous n’avons pas pu initialiser une nouvelle instance de <see cref="T:System.String" /> à l’aide de <paramref name="value" />, en supposant que <paramref name="value" /> est encodé comme indiqué par <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> et <paramref name="length" /> spécifient collectivement une adresse non valide.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Position dans la chaîne actuelle.</param>
        <summary>Obtient l'objet <see cref="T:System.Char" /> à une position de caractère spécifiée dans l'objet <see cref="T:System.String" /> actuel.</summary>
        <value>Objet à la position <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `index` paramètre est de base zéro.  
  
 Cette propriété retourne le <xref:System.Char> objet à la position spécifiée par le `index` paramètre. Toutefois, un caractère Unicode peut être représenté par plusieurs <xref:System.Char>. Utilisez le <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe fonctionne avec Unicode caractères au lieu de <xref:System.Char> objets. Pour plus d’informations, consultez la section « Objets Char et caractères Unicode » dans le <xref:System.String> vue d’ensemble de la classe.  
  
 En c#, le <xref:System.String.Chars%2A> propriété est un indexeur. Dans Visual Basic, il est la propriété par défaut de la <xref:System.String> classe. Chaque <xref:System.Char> objet dans la chaîne est accessible à l’aide de code semblable au suivant.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser cet indexeur dans une routine de valider une chaîne.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> est supérieur ou égal à la longueur de cet objet ou inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une référence à cette instance de <see cref="T:System.String" />.</summary>
        <returns>Instance de <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de retour n’est pas une copie indépendante de cette instance ; Il est simplement une autre vue des mêmes données. Utilisez le <xref:System.String.Copy%2A> ou <xref:System.String.CopyTo%2A> méthode pour créer un distinct <xref:System.String> objet avec la même valeur que cette instance.  
  
 Étant donné que le <xref:System.String.Clone%2A> méthode retourne simplement l’instance existante de la chaîne, il est recommandé d’appeler directement.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Toutes les surcharges de la méthode <xref:System.String.Compare%2A> retournent un entier signé sur 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
|Value|Condition|  
|-----------|---------------|  
|Inférieure à zéro|La première sous-chaîne précède la deuxième sous-chaîne dans l’ordre de tri.|  
|Zéro|Les sous-chaînes ont la même position dans l’ordre de tri, ou `length` a pour valeur zéro.|  
|Supérieure à zéro|La première sous-chaîne suit la deuxième sous-chaîne dans l’ordre de tri.|  
  
> [!WARNING]
>  Si possible, vous devez appeler une surcharge de la <xref:System.String.Compare%2A> méthode inclut un <xref:System.StringComparison> paramètre. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Meilleures pratiques pour l'utilisation de chaînes dans le .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise la culture actuelle pour obtenir des informations de culture spécifiques telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Lorsque vous comparez des chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.Compare%28System.String%2CSystem.String%29> méthode pour comparer trois ensembles de chaînes.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 Dans l’exemple suivant, le `ReverseStringComparer` classe montre comment vous pouvez évaluer les deux chaînes avec le <xref:System.String.Compare%2A> (méthode).  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, une comparaison dépendante de la culture de « animal » avec « ani dans Outlook » (à l’aide d’un trait d’union conditionnel, ou U + 00AD) indique que les deux chaînes sont équivalentes.  
  
[ ! code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [ ! code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le `comparisonType` paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise la culture actuelle pour obtenir des informations de culture spécifiques telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Lorsque vous comparez des chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 L’exemple suivant montre que le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> méthode est équivalente à l’utilisation de <xref:System.String.ToUpper%2A> ou <xref:System.String.ToLower%2A> lors de la comparaison de chaînes.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, une comparaison dépendante de la culture, non-respect de la casse de « animal » avec « Ani dans Outlook » (à l’aide d’un trait d’union conditionnel, ou U + 00AD) indique que les deux chaînes sont équivalentes.  
  
[ ! code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [ ! code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles à utiliser dans la comparaison.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés à l'aide des règles désignées et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> se trouve à la même position que <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou invariante, respecter ou ignorer la casse des comparateurs ou utiliser des mots (dépendantes de la culture) ou des règles de tri (indépendantes de la culture) ordinal.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 L’exemple suivant compare les trois versions de la lettre « I ». Les résultats sont affectés par le choix de la culture, si la casse est ignorée, et si une comparaison ordinale est effectuée.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> n'est pas pris en charge.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournir une valeur <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> pour le <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse et en utilisant les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 L’exemple suivant montre comment la culture peut affecter une comparaison. En tchèque - culture de la République tchèque, « ch » est un caractère unique qui est supérieur à « d ». Toutefois, en anglais - États-Unis, culture, « ch » se compose de deux caractères, et « c » est inférieure à « d ».  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, une comparaison respectant la casse de « animal » avec « Ani dans Outlook » (à l’aide d’un trait d’union conditionnel, ou U + 00AD) à l’aide de l’invariant culture indique que les deux chaînes sont équivalentes.  
  
[ ! code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [ ! code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <param name="culture">Culture qui fournit les informations de comparaison propres à la culture.</param>
        <param name="options">Options à utiliser pour effectuer la comparaison (par exemple, ignorer la casse ou les symboles).</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés en utilisant les options de comparaison spécifiées et les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique la relation entre ces deux chaînes dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre <paramref name="strA" /> et <paramref name="strB" />, comme indiqué dans le tableau suivant. 
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> précède <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> se produit à la même position que <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> suit <paramref name="strB" /> dans l'ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture, tels que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture particulière peut spécifier que certaines combinaisons de caractères traitée comme un caractère unique, de comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui Faites précéder ou suivre.  
  
> [!CAUTION]
>  Le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode est conçue principalement pour une utilisation dans le tri ou le tri alphabétique des opérations. Elle ne doit pas être utilisée lors de l’objectif principal de l’appel de méthode consiste à déterminer si deux chaînes sont équivalentes (autrement dit, lorsque l’objectif de l’appel de méthode consiste à tester pour une valeur de retour de zéro). Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 La comparaison peut être spécifiée ultérieurement par le `options` paramètre, qui se compose d’un ou plusieurs membres de la <xref:System.Globalization.CompareOptions> énumération. Toutefois, étant donné que l’objectif de cette méthode est d’effectuer une comparaison de chaînes dépendantes de la culture, le <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> et <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valeurs n’ont aucun effet.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris <xref:System.String.Empty?displayProperty=nameWithType>, est supérieure à une référence null et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux chaînes comparées. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, la chaîne avec les autres caractères est considéré comme supérieure.  
  
   
  
## Examples  
 L’exemple suivant compare deux chaînes de trois façons différentes : à l’aide de la comparaison linguistique pour la culture en-US ; à l’aide d’une comparaison respectant la casse linguistique pour la culture en-US ; et à l’aide d’une comparaison ordinale. Il illustre la façon dont les trois méthodes de comparaison produisent trois résultats différents.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> n’est pas une valeur <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Le <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes ont la même position dans l’ordre de tri, ou <paramref name="length" /> a pour valeur zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne dans <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA` et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise la culture actuelle pour obtenir des informations de culture spécifiques telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Lorsque vous comparez des chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant compare les sous-chaînes de deux.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.  
  
- ou - 
<paramref name="indexA" /> ou <paramref name="indexB" /> a pour valeur <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> (méthode) et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes ont la même position dans l’ordre de tri, ou <paramref name="length" /> a pour valeur zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne dans <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA`et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise la culture actuelle pour obtenir des informations de culture spécifiques telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Lorsque vous comparez des chaînes, vous devez appeler la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> (méthode), ce qui nécessite que vous spécifiez explicitement le type de comparaison de chaînes qui utilise la méthode. Pour plus d’informations, consultez [Bonnes pratiques l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md).  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 Le nom de chemin d’accès doit être comparée d’une manière invariante. Voici le code correct pour ce faire.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 L’exemple suivant effectue deux comparaisons de deux sous-chaînes qui diffèrent uniquement dans les cas. La première comparaison ignore la casse et la deuxième prend en compte.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.  
  
- ou - 
<paramref name="indexA" /> ou <paramref name="indexB" /> a pour valeur <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> (méthode) et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles à utiliser dans la comparaison.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés à l'aide des règles désignées et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes se produisent à la même position dans l’ordre de tri, ou le paramètre <paramref name="length" /> a la valeur zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA` et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro, ne placez pas une. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou invariante, respecter ou ignorer la casse des comparateurs ou utiliser des mots (dépendantes de la culture) ou des règles de tri (indépendantes de la culture) ordinal.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 L’exemple suivant compare les sous-chaînes de deux.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.  
  
- ou - 
<paramref name="indexA" /> ou <paramref name="indexB" /> a pour valeur <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournir une valeur <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> pour le <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés, en ignorant ou en respectant leur casse et en utilisant les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique leur position relative dans l'ordre de tri.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes ont la même position dans l’ordre de tri, ou <paramref name="length" /> a pour valeur zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne dans <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à `indexA`et dans `strB` à `indexB`. Les deux `indexA` et `indexB` sont de base zéro, c'est-à-dire le premier caractère dans `strA` et `strB` est à la position zéro, ne placez pas une. La longueur de la première sous-chaîne est égale à la longueur de `strA` moins `indexA` plus un. La longueur de la deuxième sous-chaîne est égale à la longueur de `strB` moins `indexB` plus un.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture telles que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture peut spécifier que certaines combinaisons de caractères être traitées comme un caractère unique, ou comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui précèdent ou faire suivre.  
  
 La comparaison est effectuée à l’aide de règles de tri de word. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Un ou les deux comparateurs peuvent être `null`. Par définition, toute chaîne, y compris la chaîne vide (" »), est supérieure à une référence null ; et deux références null sont égales entre elles.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, puis la chaîne de caractères restants est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
 Résultats inattendus peuvent se produire lorsque les comparaisons sont affectées par les règles de casse propres à la culture. Par exemple, en turc, l’exemple suivant donne des résultats erronés parce que le système de fichiers en turc n’utilise pas les règles de casse linguistique pour la lettre « i » dans « fichier ».  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Comparer le nom de chemin d’accès « file » à l’aide d’une comparaison ordinale. Le code correct pour ce faire est comme suit :  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 L’exemple suivant compare les sous-chaînes de deux à l’aide de différentes cultures et en ignorant la casse des sous-chaînes. Le choix de culture affecte la façon dont la lettre « I » est comparé.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.  
  
- ou - 
<paramref name="strA" /> ou <paramref name="strB" /> a pour valeur <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, appelez le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> (méthode) et fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Position de départ de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Position de départ de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <param name="culture">Objet qui fournit des informations de comparaison propres à la culture.</param>
        <param name="options">Options à utiliser pour effectuer la comparaison (par exemple, ignorer la casse ou les symboles).</param>
        <summary>Compare des sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés en utilisant les options de comparaison spécifiées et les informations propres à la culture pour influencer la comparaison, et retourne un entier qui indique la relation entre ces deux sous-chaînes dans l'ordre de tri.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux sous-chaînes, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> précède la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes ont la même position dans l’ordre de tri, ou <paramref name="length" /> a pour valeur zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne dans <paramref name="strA" /> suit la sous-chaîne de <paramref name="strB" /> dans l’ordre de tri.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les sous-chaînes à comparer commencent `strA` à la position `indexA` et dans `strB` à la position `indexB`. La longueur de la première sous-chaîne est la longueur de `strA` moins `indexA`. La longueur de la deuxième sous-chaîne est la longueur de `strB` moins `indexB`.  
  
 Le nombre de caractères à comparer est le plus petit des longueurs des deux sous-chaînes, et `length`. Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 La comparaison utilise le `culture` paramètre pour obtenir des informations spécifiques à la culture, tels que les règles de casse et l’ordre alphabétique des caractères individuels. Par exemple, une culture particulière peut spécifier que certaines combinaisons de caractères traitée comme un caractère unique, de comparer les caractères majuscules et minuscules d’une façon particulière, ou que l’ordre de tri d’un caractère varie selon les caractères qui Faites précéder ou suivre.  
  
> [!CAUTION]
>  Le <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode est conçue principalement pour une utilisation dans le tri ou le tri alphabétique des opérations. Elle ne doit pas être utilisée lors de la principal de l’appel de méthode vise à déterminer si les deux sous-chaînes sont équivalentes (autrement dit, lorsque l’objectif de l’appel de méthode consiste à tester pour une valeur de retour de zéro). Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Une ou les deux `strA` et `strB` peut être `null`. Par définition, toute chaîne, y compris <xref:System.String.Empty?displayProperty=nameWithType>, est supérieure à une référence null et deux références null sont égales entre elles.  
  
 La comparaison peut être spécifiée ultérieurement par le `options` paramètre, qui se compose d’un ou plusieurs membres de la <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération. Toutefois, étant donné que l’objectif de cette méthode est d’effectuer une comparaison de chaînes dépendantes de la culture, le <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> et <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valeurs n’ont aucun effet.  
  
 La comparaison se termine lorsqu’une inégalité est trouvée, ou les deux sous-chaînes ont été comparés. Toutefois, si les deux chaînes sont équivalentes à la fin d’une chaîne, et l’autre chaîne caractères restants, la chaîne avec les autres caractères est considéré comme supérieure. La valeur de retour est le résultat de la dernière comparaison effectuée.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> méthode pour comparer les noms de deux personnes. Elle les affiche ensuite dans l’ordre alphabétique.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> n’est pas une valeur <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see langword=".Length" />.  
  
- ou - 
 <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see langword=".Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.  
  
- ou - 
<paramref name="strA" /> ou <paramref name="strB" /> a pour valeur <see langword="null" />, et <paramref name="length" /> est supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison linguistique ou dépendante de la culture. Pour qu’il reconnaisse les caractères ignorables dans votre comparaison, fournir une valeur <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> pour le <paramref name="options" /> paramètre.</para>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare deux objets <see cref="T:System.String" /> en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants dans chaque chaîne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à comparer.</param>
        <param name="strB">Deuxième chaîne à comparer.</param>
        <summary>Compare deux objets <see cref="T:System.String" /> spécifiés en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants dans chaque chaîne.</summary>
        <returns>Entier qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description><paramref name="strA" /> est inférieur à <paramref name="strB" />.  
  
 </description></item><item><term> Zéro 
 </term><description><paramref name="strA" /> et <paramref name="strB" /> sont égaux.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description><paramref name="strA" /> est supérieur à <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison respectant la casse à l’aide de règles de tri ordinal. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Pour effectuer une comparaison respectant la casse à l’aide de règles de tri ordinal, appelez le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> méthode avec le `comparisonType` affectée à l’argument <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Étant donné que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> est une méthode statique, `strA` et `strB` peut être `null`. Si les deux valeurs sont `null`, la méthode retourne 0 (zéro), ce qui indique que `strA` et `strB` sont égaux. Si seule une des valeurs est `null`, la méthode considère que la valeur non null est supérieure.  
  
   
  
## Examples  
 L’exemple suivant effectue et une comparaison ordinale de deux chaînes qui diffèrent uniquement par la casse.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">Première chaîne à utiliser dans la comparaison.</param>
        <param name="indexA">Index de départ de la sous-chaîne dans <paramref name="strA" />.</param>
        <param name="strB">Seconde chaîne à utiliser dans la comparaison.</param>
        <param name="indexB">Index de départ de la sous-chaîne dans <paramref name="strB" />.</param>
        <param name="length">Nombre maximal de caractères dans les sous-chaînes à comparer.</param>
        <summary>Compare les sous-chaînes de deux objets <see cref="T:System.String" /> spécifiés en évaluant les valeurs numériques des objets <see cref="T:System.Char" /> correspondants de chaque sous-chaîne.</summary>
        <returns>Entier signé 32 bits qui indique la relation lexicale entre les deux comparateurs.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> est inférieure à la sous-chaîne de <paramref name="strB" />.  
  
 </description></item><item><term> Zéro 
 </term><description> Les sous-chaînes sont égales ou <paramref name="length" /> est égal à zéro.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> La sous-chaîne de <paramref name="strA" /> est supérieure à la sous-chaîne de <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `indexA`, `indexB`, et `length` paramètres doivent être non négatifs.  
  
 Le nombre de caractères comparés est le plus petit de la longueur du `strA` moins `indexA`, la longueur de `strB` moins `indexB`, et `length`.  
  
 Cette méthode effectue une comparaison respectant la casse à l’aide de règles de tri ordinal. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Pour effectuer une comparaison respectant la casse à l’aide de règles de tri ordinal, appelez le <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> méthode avec le `comparisonType` affectée à l’argument <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Étant donné que <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> est une méthode statique, `strA` et `strB` peut être `null`. Si les deux valeurs sont `null`, la méthode retourne 0 (zéro), ce qui indique que `strA` et `strB` sont égaux. Si seule une des valeurs est `null`, la méthode considère que la valeur non null est supérieure.  
  
   
  
## Examples  
 L’exemple suivant montre que <xref:System.String.CompareOrdinal%2A> et <xref:System.String.Compare%2A> utiliser différents ordres de tri.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" /> n’est pas <see langword="null" /> et <paramref name="indexA" /> est supérieur à <paramref name="strA" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="strB" /> n’est pas <see langword="null" /> et <paramref name="indexB" /> est supérieur à <paramref name="strB" /><see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> est un nombre négatif.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compare cette instance à un objet spécifié ou <see cref="T:System.String" /> et retourne un entier qui indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que l'objet spécifié ou <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les deux surcharges de la <xref:System.String.CompareTo%2A> méthode effectuer la comparaison dépendante de la culture et respectant la casse. Vous ne pouvez pas utiliser cette méthode pour effectuer des comparaisons indépendantes de la culture ou ordinales. Pour la clarté du code, nous vous recommandons d’éviter le <xref:System.String.CompareTo%2A> (méthode) et appelez le <xref:System.String.Compare%2A> méthode à la place.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet qui prend pour valeur <see cref="T:System.String" />.</param>
        <summary>Compare cette instance avec un <see cref="T:System.Object" /> spécifié et indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que le <see cref="T:System.Object" /> spécifié.</summary>
        <returns>Entier signé 32 bits qui indique si cette instance précède, suit ou apparaît dans la même position dans l'ordre de tri que le paramètre <paramref name="value" />.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> Cette instance précède <paramref name="value" />.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance a la même position dans l'ordre de tri que <paramref name="value" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> Cette instance suit <paramref name="value" />.  
  
- ou - 
 <paramref name="value" /> a la valeur <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` doit être un <xref:System.String> objet.  
  
> [!CAUTION]
>  Le <xref:System.String.CompareTo%2A> méthode a été conçue principalement pour une utilisation dans le tri ou le tri alphabétique des opérations. Elle ne doit pas être utilisée lors de l’objectif principal de l’appel de méthode consiste à déterminer si deux chaînes sont équivalentes. Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur le comportement de cette méthode, consultez la section Notes de la <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.String.CompareTo%2A> méthode avec un <xref:System.Object>. Car elle tente de comparer un <xref:System.String> l’instance à un `TestClass` de l’objet, la méthode lève un <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> n'est pas un <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.CompareTo(System.Object)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, une comparaison de « animal » avec « ani dans Outlook » (à l’aide d’un trait d’union conditionnel, ou U + 00AD) indique que les deux chaînes sont équivalentes.  
  
[ ! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [ ! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (méthode).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">Chaîne à comparer à cette instance.</param>
        <summary>Compare cette instance avec un objet <see cref="T:System.String" /> spécifié et indique si cette instance précède, suit ou apparaît à la même position dans l'ordre de tri que la chaîne spécifiée.</summary>
        <returns>Entier signé 32 bits qui indique si cette instance précède, suit ou apparaît dans la même position dans l'ordre de tri que le paramètre <paramref name="strB" />.  
  
 <list type="table"><listheader><term> Value 
 </term><description> Condition 
 </description></listheader><item><term> Inférieure à zéro 
 </term><description> Cette instance précède <paramref name="strB" />.  
  
 </description></item><item><term> Zéro 
 </term><description> Cette instance a la même position dans l'ordre de tri que <paramref name="strB" />.  
  
 </description></item><item><term> Supérieure à zéro 
 </term><description> Cette instance suit <paramref name="strB" />.  
  
- ou - 
 <paramref name="strB" /> a la valeur <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Le <xref:System.String.CompareTo%2A> méthode a été conçue principalement pour une utilisation dans le tri ou le tri alphabétique des opérations. Elle ne doit pas être utilisée lors de l’objectif principal de l’appel de méthode consiste à déterminer si deux chaînes sont équivalentes. Pour déterminer si deux chaînes sont équivalentes, appelez le <xref:System.String.Equals%2A> (méthode).  
  
 Pour plus d’informations sur le comportement de cette méthode, consultez la section Notes de la <xref:System.String.Compare%28System.String%2CSystem.String%29> (méthode).  
  
 Cette méthode implémente le <xref:System.IComparable%601?displayProperty=nameWithType> interface et effectue légèrement meilleures que le <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> (méthode), car il n’a pas déterminer si le `strB` argument est un type valeur mutable qui doit être converti (boxed), et il n’a pas d’effectuer un cast son paramètre à partir d’un <xref:System.Object> à un <xref:System.String>.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.CompareTo%2A> méthode pour comparer l’instance actuelle de la chaîne par une autre chaîne.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 L’exemple suivant montre des versions génériques et non génériques de la méthode CompareTo pour plusieurs types valeur et référence.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables. Le <see cref="M:System.String.CompareTo(System.String)" /> méthode ne considère pas ces caractères lorsqu’elle effectue une comparaison dépendante de la culture. Par exemple, si le code suivant est exécuté sur le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, une comparaison de « animal » avec « ani dans Outlook » (à l’aide d’un trait d’union conditionnel, ou U + 00AD) indique que les deux chaînes sont équivalentes.  
  
[ ! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [ ! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Pour qu’il reconnaisse les caractères ignorables dans une comparaison de chaînes, appeler le <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> (méthode).</para>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatène une ou plusieurs instances de <see cref="T:System.String" /> ou les représentations <see cref="T:System.String" /> des valeurs d'une ou de plusieurs instances de <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Collection d'objets qui implémente <see cref="T:System.Collections.Generic.IEnumerable`1" /> et dont l'argument de type générique est <see cref="T:System.String" />.</param>
        <summary>Concatène les membres d'une collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> construite de type <see cref="T:System.String" />.</summary>
        <returns>Chaînes concaténées dans <paramref name="values" /> ou <see cref="F:System.String.Empty" /> si <paramref name="values" /> est un <see langword="IEnumerable(Of String)" /> vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; elle n’ajoute pas de délimiteurs. Pour spécifier un délimiteur entre chaque membre de `values`, appelez le <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de n’importe quel élément null dans `values`.  
  
 Si `values` est vide `IEnumerable(Of String)`, la méthode retourne <xref:System.String.Empty?displayProperty=nameWithType>. Si `values` est `null`, la méthode lève un <xref:System.ArgumentNullException> exception.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un `IEnumerable(Of String)` collection sans avoir à convertir les éléments dans un tableau de chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). L’exemple suivant passe un `List(Of String)` objet qui contient les lettres majuscules ou minuscules de l’alphabet à une expression lambda qui sélectionne des lettres qui sont égales ou supérieures à une lettre particulière (c'est-à-dire, dans l’exemple, « M »). Le `IEnumerable(Of String)` collection retournée par la <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> est passé à la méthode le <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> méthode pour afficher le résultat sous forme de chaîne unique.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieures ou égales à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type <xref:System.String>, qu’il passe ensuite à la <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Objet à représenter, ou <see langword="null" />.</param>
        <summary>Crée la représentation sous forme de chaîne d'un objet spécifié.</summary>
        <returns>Représentation sous forme de chaîne de la valeur de <paramref name="arg0" />, ou <see cref="F:System.String.Empty" /> si <paramref name="arg0" /> est <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Concat%28System.Object%29> méthode représente `arg0` sous forme de chaîne en appelant sa `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Tableau d'objets qui contient les éléments à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne des éléments dans un tableau <see cref="T:System.Object" /> spécifié.</summary>
        <returns>Représentations sous forme de chaînes concaténées des valeurs des éléments dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `args` en appelant sans paramètre `ToString` méthode de cet objet ; elle n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%2A> méthode avec un <xref:System.Object> tableau.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <block subset="none" type="usage">
          <para>Cette méthode n’est pas appelée par du code C++. Le compilateur C++ résout les appels à <see cref="Overload:System.String.Concat" /> qui ont des paramètres d’objet de quatre ou plus comme un appel à <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Tableau d'instances de chaîne.</param>
        <summary>Concatène les éléments d'un tableau <see cref="T:System.String" /> spécifié.</summary>
        <returns>Éléments concaténés de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; elle n’ajoute pas de délimiteurs.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%2A> méthode avec un <xref:System.String> tableau.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de deux objets spécifiés.</summary>
        <returns>Représentations sous forme de chaîne concaténées des valeurs des paramètres <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `arg0` et `arg1` en appelant sans paramètre `ToString` méthode de `arg0` et `arg1`; elle n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
 Si un des arguments est une référence de tableau, la méthode concatène une chaîne qui représente ce tableau, au lieu de ses membres (par exemple, « System.String[]").  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <summary>Concatène deux instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" /> et <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0` et `str1`; elle n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaînes de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant concatène le nom du premier, deuxième prénom et d’une personne.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <param name="arg2">Troisième objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de trois objets spécifiés.</summary>
        <returns>Représentations sous forme de chaîne concaténées des valeurs des paramètres <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `arg0`, `arg1`, et `arg2` en appelant sans paramètre `ToString` méthode de chaque objet ; elle n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Concat%2A> (méthode).  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <param name="str2">Troisième chaîne à concaténer.</param>
        <summary>Concatène trois instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" />, <paramref name="str1" /> et <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0`, `str1`, et `str2`; elle n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaînes de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Concat%2A> méthode permettant de concaténer trois chaînes et affiche le résultat.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">Premier objet à concaténer.</param>
        <param name="arg1">Second objet à concaténer.</param>
        <param name="arg2">Troisième objet à concaténer.</param>
        <param name="arg3">Quatrième objet à concaténer.</param>
        <summary>Concatène les représentations sous forme de chaîne de quatre objets spécifiés et de tous les objets spécifiés dans une liste facultative de paramètres de longueur variable.</summary>
        <returns>Représentation sous forme de chaîne concaténée de chaque valeur de la liste de paramètres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Cette API n'est pas conforme CLS. L’alternative conforme CLS est <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Les compilateurs c# et Visual Basic résoudre automatiquement un appel à cette méthode comme un appel à <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 La méthode concatène chaque objet dans la liste de paramètres en appelant sa `ToString` méthode ; il n’ajoute pas de délimiteurs.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> est utilisé à la place de tout argument null.  
  
> [!NOTE]
>  Le dernier paramètre de la <xref:System.String.Concat%2A> méthode est une liste facultative délimitée par des virgules d’un ou plusieurs objets supplémentaires à concaténer.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode permettant de concaténer une liste de paramètres de variables. Dans ce cas, la méthode est appelée avec neuf paramètres.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Cette méthode est marquée avec le <see langword="vararg" /> mot clé, ce qui signifie qu’il prend en charge un nombre variable de paramètres. La méthode peut être appelée à partir de Visual C++, mais il ne peut pas être appelée à partir du code c# ou Visual Basic. Les compilateurs c# et Visual Basic résolvent les appels aux <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> comme des appels à <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">Première chaîne à concaténer.</param>
        <param name="str1">Seconde chaîne à concaténer.</param>
        <param name="str2">Troisième chaîne à concaténer.</param>
        <param name="str3">Quatrième chaîne à concaténer.</param>
        <summary>Concatène quatre instances spécifiées de <see cref="T:System.String" />.</summary>
        <returns>Concaténation de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> et <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène `str0`, `str1`, `str2`, et `str3`; elle n’ajoute pas de délimiteurs.  
  
> [!NOTE]
>  Vous pouvez également utiliser d’opérateur de concaténation de chaînes de votre langage, tel que `+` en c#, ou `&` et `+` en Visual Basic)  
>   
>  , pour concaténer des chaînes.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout objet null dans le tableau.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de mots de quatre lettres et stocke leurs lettres individuelles dans un tableau de chaînes pour les mélanger. Il appelle ensuite la <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> méthode pour réassembler les mots mélangés.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Types des membres de <paramref name="values" />.</typeparam>
        <param name="values">Objet de collection qui implémente l'interface <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatène les membres d'une implémentation <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Membres concaténés dans <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode concatène chaque objet dans `values`; elle n’ajoute pas de délimiteurs.  
  
 Un <xref:System.String.Empty> chaîne est utilisée à la place de tout argument null.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un <xref:System.Collections.Generic.IEnumerable%601> collection sans avoir à convertir les éléments en chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ), comme l’illustre l’exemple. La représentation sous forme de chaîne de chaque objet dans le <xref:System.Collections.Generic.IEnumerable%601> collection est dérivée en appelant l’objet `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant définit un très simple `Animal` classe qui contient le nom d’un animal et l’ordre auquel il appartient. Il définit ensuite un <xref:System.Collections.Generic.List%601> objet destiné à contenir un nombre de `Animal` objets. Le <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> méthode d’extension est appelée pour extraire le `Animal` objets dont la propriété `Order` propriété correspond à « Rongeur ». Le résultat est passé à la <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> méthode et affichée dans la console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Retourne une valeur qui indique si la sous-chaîne spécifiée apparaît dans cette chaîne.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> apparaît dans cette chaîne, ou si <paramref name="value" /> est la chaîne vide ("") ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale (respectant la casse et indépendantes de la culture). La recherche commence à la première position de caractère de cette chaîne et continue jusqu'à la dernière position de caractère.  
  
 Pour déterminer si une chaîne contient une sous-chaîne spécifiée à l’aide d’autre chose qu’une comparaison ordinale (par exemple, la comparaison dépendante de la culture, ou une comparaison ordinale de non-respect de la casse), vous pouvez créer une méthode personnalisée. L’exemple suivant illustre une telle approche. Il définit un <xref:System.String> méthode d’extension qui inclut un <xref:System.StringComparison> paramètre et indique si une chaîne contient une sous-chaîne lors de l’utilisation de la forme spécifiée de comparaison de chaînes.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 L’exemple suivant appelle ensuite la `Contains` méthode d’extension pour déterminer si une sous-chaîne a été trouvée dans une chaîne lors de l’utilisation de la comparaison ordinale et la comparaison ordinale respectant la casse.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Si vous êtes intéressé par la position de la sous-chaîne `value` dans l’instance actuelle, vous pouvez appeler la <xref:System.String.IndexOf%2A> méthode pour obtenir la position de départ de sa première occurrence, ou vous pouvez appeler la <xref:System.String.LastIndexOf%2A> méthode pour obtenir le démarrage de la position de son dernière occurrence. L’exemple inclut un appel à la <xref:System.String.IndexOf%28System.String%29> méthode si une sous-chaîne se trouve dans une instance de chaîne.  
  
   
  
## Examples  
 L’exemple suivant détermine si la chaîne « fox » est une sous-chaîne d’une citation connue. Si « renard » se trouve dans la chaîne, elle affiche également sa position de départ.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à copier.</param>
        <summary>Crée une instance de <see cref="T:System.String" /> ayant la même valeur qu'un <see cref="T:System.String" /> spécifié.</summary>
        <returns>Nouvelle chaîne ayant la même valeur que <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Copy%2A> méthode retourne un <xref:System.String> objet qui a la même valeur que la chaîne d’origine, mais représente une référence d’objet différent. Il diffère d’une opération d’assignation, qui affecte une référence de chaîne existante à une variable objet supplémentaires. L’exemple illustre la différence.  
  
   
  
## Examples  
 L’exemple suivant crée deux objets string avec des valeurs différentes. Lorsqu’il appelle le <xref:System.String.Copy%2A> méthode pour attribuer la première valeur à la deuxième chaîne, la sortie indique que les chaînes représentent des références d’objet différentes bien que leurs valeurs sont maintenant égaux. En revanche, lorsque la première chaîne est affectée à la deuxième chaîne, les deux chaînes ont des valeurs identiques, car elles représentent la même référence d’objet.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">Index du premier caractère de cette instance à copier.</param>
        <param name="destination">Tableau de caractères Unicode dans lequel les caractères de cette instance sont copiés.</param>
        <param name="destinationIndex">Index de <paramref name="destination" /> au niveau duquel commence l'opération de copie.</param>
        <param name="count">Nombre de caractères dans cette instance à copier vers <paramref name="destination" />.</param>
        <summary>Copie un nombre spécifié de caractères à partir d'une position spécifiée dans cette instance vers une position spécifiée dans un tableau de caractères Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie `count` caractères à partir de la `sourceIndex` position de cette instance à la `destinationIndex` position de `destination` tableau de caractères. Cette méthode n’est pas redimensionné le `destination` tableau de caractères ; il doit avoir un nombre suffisant d’éléments à prendre en charge les caractères copiés ou la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` et `destinationIndex` sont de base zéro.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.CopyTo%2A> (méthode).  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> est un nombre négatif. 
- ou - 
 <paramref name="sourceIndex" /> n’identifie pas une position dans l’instance actuelle.  
  
- ou - 
 <paramref name="destinationIndex" /> n’identifie pas un index valide dans le tableau <paramref name="destination" />.  
  
- ou - 
 <paramref name="count" /> est supérieur à la longueur de la sous-chaîne de <paramref name="sourceIndex" /> jusqu’à la fin de cette instance. 
- ou - 
 <paramref name="count" /> est supérieur à la longueur du sous-tableau de <paramref name="destinationIndex" /> jusqu’à la fin du tableau <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Représente la chaîne vide. Ce champ est en lecture seule.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de ce champ est la chaîne de longueur nulle, « ».  
  
 Dans le code d’application, ce champ est plus couramment utilisé dans les attributions pour initialiser une variable de chaîne à une chaîne vide. Pour tester si la valeur d’une chaîne est soit `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, utilisez le <xref:System.String.IsNullOrEmpty%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si la fin de cette instance de chaîne correspond à une chaîne spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare `value` à la sous-chaîne à la fin de cette instance est la même longueur que `value`et retourne une indication précisant si elles sont égales. Pour être égale, `value` doit être une référence à cette même instance ou correspondre à la fin de cette instance.  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant indique si chaque chaîne dans un tableau se termine par un point («. »).  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 L’exemple suivant définit un `StripEndTags` méthode qui utilise le <xref:System.String.EndsWith%28System.String%29> méthode pour supprimer les balises de fin HTML à partir de la fin d’une ligne. Notez que le `StripEndTags` méthode est appelée de manière récursive pour vous assurer que plusieurs balises de fin HTML à la fin de la ligne sont supprimés.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour déterminer si une chaîne se termine par une sous-chaîne spécifique en utilisant les règles de comparaison de chaîne de la culture actuelle, appelez le <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui détermine le mode de comparaison entre cette chaîne et <paramref name="value" />.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de l'option spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.EndsWith%2A> méthode compare le `value` paramètre à la sous-chaîne à la fin de cette chaîne et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même chaîne, doit être une chaîne vide (« »), ou doit correspondre à la fin de cette chaîne. Le type de comparaison effectuée par le <xref:System.String.EndsWith%2A> méthode varie selon la valeur de la `comparisonType` paramètre.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se termine par une sous-chaîne particulière. Les résultats sont affectés par le choix de la culture, si la casse est ignorée, et si une comparaison ordinale est effectuée.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à la sous-chaîne à la fin de cette instance.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Informations culturelles déterminant comment cette instance et <paramref name="value" /> sont comparées. Si <paramref name="culture" /> est <see langword="null" />, la culture actuelle est utilisée.</param>
        <summary>Détermine si la fin de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de la culture spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond à la fin de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare le `value` paramètre à la sous-chaîne à la fin de cette chaîne est la même longueur que `value`et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même instance ou correspondre à la fin de cette chaîne.  
  
 Cette méthode effectue une comparaison de (dépendante de la culture) de word à l’aide de la casse spécifiée et la culture.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se produit à la fin d’une autre chaîne. Le <xref:System.String.EndsWith%2A> méthode est appelée plusieurs fois à l’aide de la casse, casse et différentes cultures qui influencent les résultats de la recherche.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux objets <see cref="T:System.String" /> ont la même valeur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Chaîne à comparer à cette instance.</param>
        <summary>Détermine si cette instance et un objet spécifié, qui doit aussi être un objet <see cref="T:System.String" />, ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si <paramref name="obj" /> est <see cref="T:System.String" /> et possède la même valeur que cette instance ; sinon, <see langword="false" />.  Si <paramref name="obj" /> est <see langword="null" />, la méthode retourne <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Equals%2A> (méthode).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à cette instance.</param>
        <summary>Détermine si cette instance et un autre objet <see cref="T:System.String" /> spécifié ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="value" /> est la même que celle de cette instance ; sinon, <see langword="false" />. Si <paramref name="value" /> est <see langword="null" />, la méthode retourne <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Equals%2A> (méthode). Il compare le mot en minuscules titre « Fichier » avec un mot équivalent, son équivalent en minuscules, son équivalent en majuscule et un mot qui contient des caractères latins petite lettre sans point I (U + 0131) au lieu de LATIN petite lettre I (U + 0069). Étant donné que le <xref:System.String.Equals%28System.String%29> méthode effectue une comparaison ordinale, uniquement la comparaison avec une word identiques retourne `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux objets <see cref="T:System.String" /> spécifiés ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est égale à la valeur de <paramref name="b" /> ; sinon <see langword="false" />. Si <paramref name="a" /> et <paramref name="b" /> ont la valeur <see langword="null" />, la méthode retourne <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une comparaison ordinale (respectant la casse et indépendantes de la culture).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Equals%2A> (méthode).  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer à cette instance.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie le mode de comparaison des chaînes.</param>
        <summary>Détermine si cette chaîne et un objet <see cref="T:System.String" /> spécifié ont la même valeur. Un paramètre spécifie la culture, la casse et les règles de tri utilisées dans la comparaison.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="value" /> est la même que cette chaîne ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou dite indifférente, respecter ou ignorer la casse de deux chaînes comparées ou utiliser word ou des règles de tri ordinal.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de chaînes qui se compose d’une majuscule « I », « i » minuscule et un « ı » sans point. Il appelle ensuite la <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> méthode pour les comparer à l’aide de chaque possible <xref:System.StringComparison> valeur d’énumération.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 L’exemple suivant compare les quatre jeux de mots à l’aide de chaque membre de la <xref:System.StringComparison> énumération.  Les comparaisons utilisent les conventions de l’anglais (États-Unis) et les cultures Same (Suède supérieure). Notez que les chaînes « encyclopædia » et « Encyclopédie » sont considérés comme équivalents dans la culture en-US, mais pas dans la culture Same (Suède du Nord).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui spécifie les règles de la comparaison.</param>
        <summary>Détermine si deux objets <see cref="T:System.String" /> spécifiés ont la même valeur. Un paramètre spécifie la culture, la casse et les règles de tri utilisées dans la comparaison.</summary>
        <returns>
          <see langword="true" /> si la valeur du paramètre <paramref name="a" /> est égale à la valeur du paramètre <paramref name="b" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `comparisonType` paramètre indique si la comparaison doit utiliser la culture actuelle ou dite indifférente, respecter ou ignorer la casse de deux chaînes comparées ou utiliser word ou des règles de tri ordinal.  
  
   
  
## Examples  
 L’exemple suivant compare les quatre jeux de mots à l’aide de chaque membre de la <xref:System.StringComparison> énumération.  Les comparaisons utilisent les conventions de l’anglais (États-Unis) et les cultures Same (Suède supérieure). Notez que les chaînes « encyclopædia » et « Encyclopédie » sont considérés comme équivalents dans la culture en-US, mais pas dans la culture Same (Suède du Nord).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur des objets en chaînes selon les formats spécifiés et les insère dans une autre chaîne.  
  
Si vous découvrez la méthode `String.Format`, consultez la section [Bien démarrer avec la méthode String.Format](#Starting) pour afficher une présentation rapide.  
  
Consultez la section [Notes](#remarks-top) afin d’obtenir une documentation générale sur la méthode `String.Format`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Dans cette section :  
  
 [Bien démarrer avec la méthode String.Format](#Starting)   
 [Quelle méthode appeler ?](#FTaskList)   
 [La méthode Format en bref](#Format_Brief)   
 [L’élément de Format](#FormatItem)   
 [Le format des arguments](#HowFormatted)   
 [Éléments de format qui ont le même index](#SameIndex)   
 [Mise en forme et la culture](#Format_Culture)   
 [Opérations de mise en forme personnalisée](#Format_Custom)   
 [String.Format Q & r](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Bien démarrer avec la méthode String.Format  
 Utilisez <xref:System.String.Format%2A?displayProperty=nameWithType> si vous devez insérer la valeur d’un objet, une variable ou une expression dans une autre chaîne. Par exemple, vous pouvez insérer la valeur d’un <xref:System.Decimal> valeur en une chaîne pour l’afficher à l’utilisateur sous forme de chaîne unique :  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 Et vous pouvez contrôler la mise en forme de cette valeur :  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Outre la mise en forme, vous pouvez également contrôler l’alignement et espacement.  
  
 ### <a name="inserting-a-string"></a>Insertion d’une chaîne  

 <xref:System.String.Format%2A?displayProperty=nameWithType> commence par une chaîne de format, suivie d’un ou plusieurs objets ou des expressions qui seront converties en chaînes et insérées à un emplacement spécifié dans la chaîne de format. Exemple :  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 Le `{0}` dans le format de chaîne est un élément de format. `0` est l’index de l’objet dont la valeur chaîne sera insérée à cette position. (Les index commencent à 0.) Si l’objet à insérer n’est pas une chaîne, son `ToString` méthode est appelée pour convertir un avant de l’insérer dans la chaîne de résultat.  
  
 Voici un autre exemple qui utilise deux éléments de format et les deux objets dans la liste d’objets :  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Vous pouvez avoir autant d’éléments format et autant d’objets dans la liste d’objets comme vous le souhaitez, tant que l’index de chaque élément de format a un objet correspondant dans la liste d’objets. Vous n’avez à vous soucier sur quelle surcharge, vous appelez ; le compilateur sélectionne celui qui convient à votre place.  
  
 ### <a name="controlling-formatting"></a>Contrôle de mise en forme  
 Vous pouvez suivre l’index dans un élément de format avec une chaîne de format pour contrôler la façon dont un objet est mis en forme. Par exemple, `{0:d}` s’applique la chaîne de format « d » pour le premier objet dans la liste d’objets. Voici un exemple avec un seul objet et deux éléments de format :  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Un numéro de prise en charge des types de chaînes de format, y compris tous les types numériques (les deux [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-numeric-format-strings.md) chaînes de format), toutes les dates et heures (à la fois [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-date-and-time-format-strings.md) chaînes de format) et les intervalles de temps (les deux [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [personnalisé](~/docs/standard/base-types/custom-timespan-format-strings.md) chaînes de format), tous les types énumération [types énumération ](~/docs/standard/base-types/enumeration-format-strings.md), et [GUID](https://msdn.microsoft.com/library/97af8hh4.aspx). Vous pouvez également ajouter la prise en charge des chaînes de format pour vos propres types.  
  
 ### <a name="controlling-spacing"></a>Contrôle de l’espacement  
 Vous pouvez définir la largeur de la chaîne qui est insérée dans la chaîne de résultat à l’aide de syntaxe comme `{0,12}`, ce qui insère une chaîne de 12 caractères. Dans ce cas, la représentation sous forme de chaîne du premier objet est aligné à droite dans le champ de 12 caractères.  (Si la représentation sous forme de chaîne du premier objet est plus de 12 caractères, cependant, la largeur préférée du champ est ignorée, et la chaîne entière est insérée dans la chaîne de résultat.)  
  
 L’exemple suivant définit un champ de 6 caractères pour contenir la chaîne « Année » et certaines chaînes de l’année, ainsi un champ de 15 caractères pour contenir la chaîne « Remplissage » et des données de la population. Notez que les caractères sont alignés à droite dans le champ.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Contrôle de l’alignement  
 Par défaut, les chaînes sont alignés à droite dans leur champ si vous spécifiez une largeur de champ. Pour aligner à gauche les chaînes dans un champ, vous faites précéder la largeur du champ avec un signe négatif, tel que `{0,-12}` pour définir un champ alignée à gauche de 12 caractères.  
  
 L’exemple suivant est similaire au précédent, sauf qu’il aligne à gauche les étiquettes et les données.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> utilise la fonctionnalité de mise en forme composite. Pour plus d’informations, consultez [Mise en forme composite](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Quelle méthode appeler ?  
  
|À|Call|  
|--------|----------|  
|Mettre en forme un ou plusieurs objets en utilisant les conventions de la culture actuelle.|À l’exception des surcharges qui incluent un `provider` paramètre, les autres <xref:System.String.Format%2A> surcharges incluent un <xref:System.String> paramètre suivie d’un ou plusieurs paramètres d’objet. Pour cette raison, vous n’êtes pas obligé de déterminer quel <xref:System.String.Format%2A> surcharge que vous voulez appeler. Votre compilateur de langage sélectionne la surcharge appropriée parmi les surcharges qui n’ont pas un `provider` paramètre, en fonction de votre liste d’arguments. Par exemple, si votre liste d’arguments a cinq arguments, le compilateur appelle le <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (méthode).|  
|Mettre en forme un ou plusieurs objets en utilisant les conventions d’une culture spécifique.|Chaque <xref:System.String.Format%2A> surcharge qui commence par un `provider` paramètre est suivi d’un <xref:System.String> paramètre et la valeur d’un ou plusieurs paramètres de l’objet. Pour cette raison, vous n’êtes pas obligé de déterminer quel <xref:System.String.Format%2A> surcharge que vous voulez appeler. Votre compilateur de langage sélectionne la surcharge appropriée parmi les surcharges qui ont un `provider` paramètre, en fonction de votre liste d’arguments. Par exemple, si votre liste d’arguments a cinq arguments, le compilateur appelle le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> (méthode).|  
|Effectuer une opération de mise en forme personnalisée avec un <xref:System.ICustomFormatter> implémentation ou une <xref:System.IFormattable> implémentation.|Un des quatre surcharges avec un `provider` paramètre. Le compilateur sélectionne la surcharge appropriée parmi les surcharges qui ont un `provider` paramètre, en fonction de votre liste d’arguments.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>La méthode Format en bref 

 Chaque surcharge de la <xref:System.String.Format%2A> méthode utilise le [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) à inclure de base zéro des espaces réservés indexés, appelés *mettre en forme des éléments*, dans une chaîne de format composite. Au moment de l’exécution, chaque élément de format est remplacé par la représentation sous forme de chaîne de l’argument correspondant dans une liste de paramètres. Si la valeur de l’argument est `null`, l’élément de format est remplacé par <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, l’appel suivant à la <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode inclut une chaîne de format avec trois éléments de format {0}, {1}, et {2}et une liste d’arguments avec trois éléments.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>L’élément de format  
 Un élément de format a cette syntaxe :  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Crochets indiquent des éléments facultatifs. Les accolades ouvrantes et fermantes sont requises. (Pour inclure un littéral ouvrante ou fermante dans la chaîne de format, consultez la [accolades d’échappement](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section dans le [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md) article.)  
  
 Par exemple, un élément de format pour mettre en forme une valeur de devise peut apparaître comme suit :  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Un élément de format comporte les éléments suivants :  
  
 *index*  
 Index de base zéro de l’argument dont la représentation chaîne doit être inclus dans cette position dans la chaîne. Si cet argument est `null`, une chaîne vide sera incluse à cette position dans la chaîne.  
  
 *Alignement*  
 Optionnel. Entier signé qui indique la longueur totale du champ dans lequel l’argument est inséré et si elle est alignée à droite (un entier positif) ou aligné à gauche (un entier négatif). Si vous omettez *alignement*, la représentation sous forme de chaîne de l’argument correspondant est insérée dans un champ sans espaces de début ou de fin.  
  
 Si la valeur de *alignement* est inférieure à la longueur de l’argument doit être inséré, *alignement* est ignoré et la longueur de la représentation sous forme de chaîne de l’argument est utilisée comme largeur de champ.  
  
 *formatString*  
 Optionnel. Chaîne qui spécifie le format de chaîne de résultat de l’argument correspondant. Si vous omettez *formatString*, sans paramètre de l’argument correspondant le `ToString` méthode est appelée pour produire sa représentation sous forme de chaîne. Si vous spécifiez *formatString*, l’argument référencé par l’élément de format doit implémenter le <xref:System.IFormattable> interface. Les types qui prennent en charge les chaînes de format sont les suivantes :  
  
-   Tous les types intégraux et à virgule flottante. (Consultez [chaînes de Format numériques Standard](~/docs/standard/base-types/standard-numeric-format-strings.md) et [chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   Voir <xref:System.DateTime> et <xref:System.DateTimeOffset>. (Consultez [chaînes de Format de Date et heure Standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [chaînes de Format de Date et heure](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Tous les types d’énumération. (Consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   des valeurs <xref:System.TimeSpan>. (Consultez [chaînes de Format TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [les chaînes de Format TimeSpan personnalisées](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUID. (Consultez le <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> méthode.)  
  
 Toutefois, notez que tout type personnalisé peut implémenter <xref:System.IFormattable> ou étendre un type existant <xref:System.IFormattable> implémentation.  
  
 L’exemple suivant utilise le `alignment` et `formatString` arguments pour produire la sortie mise en forme.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Le format des arguments  
 Éléments de format sont traitées de manière séquentielle à partir du début de la chaîne. Chaque élément de format a un index qui correspond à un objet dans la liste d’arguments de la méthode. Le <xref:System.String.Format%2A> récupère l’argument de méthode et dérive de sa représentation sous forme de chaîne comme suit :  
  
-   Si l’argument est `null`, la méthode insère <xref:System.String.Empty?displayProperty=nameWithType> dans la chaîne de résultat. Vous n’êtes pas obligé de se préoccuper de la gestion d’un <xref:System.NullReferenceException> pour les arguments null. 
  
-   Si vous appelez le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> de surcharge et la `provider` l’objet <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implémentation retourne une valeur non null <xref:System.ICustomFormatter> implémentation, l’argument est passé à son <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode). Si l’élément de format contient un *formatString* argument, elle est passée comme premier argument à la méthode. Si le <xref:System.ICustomFormatter> implémentation est disponible et produit une chaîne non null, cette chaîne est retournée en tant que la représentation sous forme de chaîne de l’argument ; sinon, l’étape suivante s’exécute.  
  
-   Si l’argument implémente le <xref:System.IFormattable> interface, son <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implémentation est appelée.  
  
-   Sans paramètre de l’argument `ToString` (méthode), qui remplace ou hérite d’une implémentation de classe de base, est appelée.  
  
 Pour obtenir un exemple qui intercepte les appels à la <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> (méthode) et vous permet de voir les informations le <xref:System.String.Format%2A> méthode passe à une méthode de mise en forme pour chaque élément de format dans une chaîne de format composite, consultez [exemple : un fournisseur d’interception et Chiffre romain formateur](#Format7_Example).  

 Pour plus d’informations, consultez le [l’ordre de traitement](~/docs/standard/base-types/composite-formatting.md##processing-order) section dans le [mise en forme Composite](~/docs/standard/base-types/composite-formatting.md) article.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Éléments de format qui ont le même index  
 Le <xref:System.String.Format%2A> méthode lève un <xref:System.FormatException> exception si l’index d’un élément de l’index est supérieur ou égal au nombre d’arguments dans la liste d’arguments. Toutefois, `format` peut inclure plusieurs éléments de format qu’il ne sont a des arguments, tant que plusieurs éléments de format ont le même index. Dans l’appel à la <xref:System.String.Format%28System.String%2CSystem.Object%29> méthode dans l’exemple suivant, la liste d’arguments a un seul argument, mais la chaîne de format inclut deux éléments de format : une affiche la valeur décimale d’un nombre, et l’autre affiche sa valeur hexadécimale.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Mise en forme et la culture  
 En règle générale, les objets dans la liste d’arguments sont convertis en leurs représentations sous forme de chaîne en utilisant les conventions de la culture actuelle, qui est retourné par la <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriété. Vous pouvez contrôler ce comportement en appelant une des surcharges de <xref:System.String.Format%2A> qui inclut un `provider` paramètre. Le `provider` paramètre est un <xref:System.IFormatProvider> traiter d’implémentation qui fournit des informations de mise en forme propres à la culture et personnalisées qui servant à contrôler la mise en forme.  
  
 Le <xref:System.IFormatProvider> interface comprend un seul membre, <xref:System.IFormatProvider.GetFormat%2A>, qui est chargé de retourner l’objet qui fournit des informations de mise en forme. .NET propose trois <xref:System.IFormatProvider> implémentations qui fournissent la mise en forme propres à la culture :  
  
-   <xref:System.Globalization.CultureInfo>. Son <xref:System.Globalization.CultureInfo.GetFormat%2A> méthode retourne un spécifiques à la culture <xref:System.Globalization.NumberFormatInfo> objet pour mettre en forme des valeurs numériques et spécifiques à la culture <xref:System.Globalization.DateTimeFormatInfo> objet pour mettre en forme des valeurs de date et d’heure.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, qui est utilisé pour mettre en forme des propres à la culture des valeurs de date et d’heure. Son <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> méthode est retournée.  
  
-   <xref:System.Globalization.NumberFormatInfo>, qui est utilisé pour la mise en forme propres à la culture des valeurs numériques. Son <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propriété retourne lui-même. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Opérations de mise en forme personnalisée  
 Vous pouvez également appeler l’une des surcharges de la <xref:System.String.Format%2A> méthode ayant un `provider` paramètre de type <xref:System.IFormatProvider> pour effectuer des opérations de mise en forme personnalisées. Par exemple, vous pourrez mettre en forme un entier comme un numéro d’identification ou comme un numéro de téléphone. Pour effectuer une mise en forme personnalisée, votre `provider` argument doit implémenter les deux le <xref:System.IFormatProvider> et <xref:System.ICustomFormatter> interfaces. Lorsque le <xref:System.String.Format%2A> est transmis à la méthode un <xref:System.ICustomFormatter> mise en œuvre en tant que le `provider` argument, le <xref:System.String.Format%2A> les appels de méthode son <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implémentation et demande un objet de type <xref:System.ICustomFormatter>. Il appelle ensuite retourné <xref:System.ICustomFormatter> l’objet <xref:System.ICustomFormatter.Format%2A> transmis à la méthode pour mettre en forme chaque élément de format dans la chaîne composite à celui-ci.  
  
 Pour plus d’informations sur la fourniture de solutions de mise en forme personnalisées, consultez [Comment : définir et fournisseurs de Format numérique personnalisé utilisation](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) et <xref:System.ICustomFormatter>. Pour obtenir un exemple qui convertit des entiers en nombres personnalisé mis en forme, consultez [exemple : une opération de mise en forme personnalisée](#Format6_Example). Pour obtenir un exemple qui convertit les octets non signés en chiffres romains, consultez [exemple : un fournisseur de l’interception et d’un chiffre romain formateur](#Format7_Example).  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a>Exemple : Une opération mise en forme personnalisée  
 Cet exemple définit un fournisseur de format qui met en forme une valeur entière en tant qu’un numéro de compte client au format x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Exemple : Un fournisseur de l’interception et chiffre romain formateur  
 Cet exemple définit un fournisseur de format personnalisé qui implémente le <xref:System.ICustomFormatter> et <xref:System.IFormatProvider> interfaces pour faire deux choses :  
  
-   Il affiche les paramètres passés à son <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implémentation. Cela nous permet de voir quels paramètres la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode passe à l’implémentation de mise en forme personnalisée pour chaque objet qu’il tente de mettre en forme. Cela peut être utile lorsque vous déboguez votre application.  
  
-   Si l’objet à mettre en forme est une valeur d’octet non signé qui est à mettre en forme en utilisant la chaîne de format standard « R », le formateur personnalisé met en forme la valeur numérique en tant qu’un chiffre romain.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format Q & r  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Pourquoi recommandez-vous interpolation de chaîne au fil des appels à la `String.Format` méthode ?

Interpolation de chaîne est :

- Plus flexible. Il peut être utilisé dans n’importe quelle chaîne sans nécessiter un appel à une méthode qui prend en charge la mise en forme composite. Sinon, vous devez appeler la <xref:System.String.Format%2A> méthode ou une autre méthode qui prend en charge la mise en forme composite, telles que <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Plus lisible. Étant donné que l’expression à insérer dans une chaîne apparaît dans l’expression interpolée plutôt que dans une liste d’arguments, chaînes interpolées sont beaucoup plus faciles au code et à lire. En raison de leur lisibilité supérieure, les chaînes interpolées peuvent remplacer les non seulement les appels aux méthodes de mise en forme composite, mais ils peuvent également servir dans les opérations de concaténation de chaîne pour produire un code plus concis et plus clair. 

Une comparaison suivant deux exemples de code illustre la supériorité de chaînes interpolées sur la concaténation de chaînes et les appels aux méthodes de mise en forme composite. L’utilisation de plusieurs opérations de concaténation de chaînes dans l’exemple suivant génère du code détaillé et difficile à lire.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

En revanche, l’utilisation de chaînes interpolées dans l’exemple suivant produire du code beaucoup plus clair et plus concis à l’instruction de concaténation de chaîne et l’appel à la <xref:System.String.Format%2A> méthode dans l’exemple précédent.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Où puis-je trouver une liste des chaînes de format prédéfini qui peut être utilisé avec les éléments de format ?  
  
-   Pour tous les types intégraux et à virgule flottante, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Pour les valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Pour les valeurs d’énumération, consultez [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Pour <xref:System.TimeSpan> valeurs, consultez [des chaînes de Format TimeSpan Standard](~/docs/standard/base-types/standard-timespan-format-strings.md) et [chaînes de Format TimeSpan personnalisées](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Pour <xref:System.Guid> valeurs, consultez la section Notes de la <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> page de référence.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Comment contrôler l’alignement des chaînes de résultat qui remplacent les éléments de format ?  
 La syntaxe générale d’un élément de format est :  
  
```  
{index[,alignment][: formatString]}  
```  
  
 où *alignement* est un entier signé qui définit la largeur du champ. Si cette valeur est négative, le texte dans le champ est aligné à gauche. S’il est positif, texte est aligné à droite.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Comment contrôler le nombre de chiffres après le séparateur décimal ?  
 Tous les [chaînes de format numériques standard](~/docs/standard/base-types/standard-numeric-format-strings.md) à l’exception de « D » (qui est utilisé avec des entiers uniquement), « G », « R » et « X » permettre un spécificateur de précision qui définit le nombre de chiffres décimaux dans la chaîne de résultat. L’exemple suivant utilise des chaînes de format numériques standard pour contrôler le nombre de chiffres décimaux dans la chaîne de résultat.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Si vous utilisez un [chaîne de format numérique personnalisée](~/docs/standard/base-types/custom-numeric-format-strings.md), utilisez le spécificateur de format « 0 » pour contrôler le nombre de chiffres décimaux dans la chaîne de résultat, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Comment contrôler le nombre de chiffres intégraux ?  
 Par défaut, les opérations de mise en forme affichent uniquement les chiffres intégraux différente de zéro. Si vous mettez en forme des nombres entiers, vous pouvez utiliser un spécificateur de précision avec le « D » et « X » de chaînes de format standard pour contrôler le nombre de chiffres.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Vous pouvez remplir un entier ou un nombre à virgule flottante avec des zéros non significatifs pour produire une chaîne de résultat avec un nombre spécifié de chiffres intégraux en utilisant le « 0 » [spécificateur de format numérique personnalisé](~/docs/standard/base-types/custom-numeric-format-strings.md), comme illustré dans l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Combien d’éléments puis-je inclure dans la liste de formats ?  
 Il n’existe aucune limite pratique. Le deuxième paramètre de la <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode est marquée avec le <xref:System.ParamArrayAttribute> attribut, qui vous permet d’inclure une liste délimitée ou un tableau d’objets en tant que votre liste de format.  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Comment inclure les accolades littérales (« { » et «} ») dans la chaîne de résultat ?  
 Par exemple, comment empêchez-vous l’appel de méthode suivant de lever un <xref:System.FormatException> exception ?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Une seule accolade ouvrante ou fermante est toujours interprétée comme le début ou la fin d’un élément de format. Pour être interprété littéralement, il doit être échappé. Vous échapper une accolade en ajoutant un autre accolade (« {{ » et «}} » au lieu de » { » et «} »), comme dans l’appel de méthode suivant :  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 Toutefois, les accolades même avec la séquence d’échappement sont facilement mal interprétés. Nous vous recommandons d’inclure les accolades dans la liste de formats et d’utiliser des éléments de format pour les insérer dans la chaîne de résultat, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Pourquoi mon appel à la méthode String.Format lève une exception FormatException ?  
 La cause la plus courante de l’exception est que l’index d’un élément de format ne correspond pas à un objet dans la liste de formats. Cela indique généralement que vous avez misnumbered les index des éléments de format, ou vous avez oublié d’inclure un objet dans la liste de formats. Essaie d’inclure une accolade gauche ou droite sans séquence d’échappement de caractères également lève un <xref:System.FormatException>. Parfois, l’exception est le résultat d’une faute de frappe ; par exemple, une erreur typique consiste à écrire de façon erronée « [ » (le crochet gauche) au lieu de « { » (l’accolade gauche).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Si la méthode Format(System.IFormatProvider,System.String,System.Object[]) prend en charge les tableaux de paramètres, pourquoi mon code lève une exception lorsque j’utilise un tableau ?  
 Par exemple, le code suivant lève un <xref:System.FormatException> exception :  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Il s’agit d’un problème de résolution de surcharge du compilateur. Étant donné que le compilateur ne peut pas convertir un tableau d’entiers en tableau d’objets, il traite le tableau d’entiers comme un seul argument, afin qu’elle appelle le <xref:System.String.Format%28System.String%2CSystem.Object%29> (méthode). L’exception est levée, car il existe quatre éléments de format, mais un seul élément dans la liste de formats.  
  
 Étant donné que Visual Basic ni c# peut convertir un tableau d’entiers en tableau d’objets, vous devez effectuer la conversion avant d’appeler le <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> (méthode). L’exemple suivant fournit une implémentation.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Nombreux exemples qui appellent le <xref:System.String.Format%2A> méthode sont intercalés via le [notes](#remarks) section de cet article.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Vous pouvez également télécharger un ensemble complet de `String.Format` obtenir des exemples, qui sont inclus un [projet .NET Core 2.0 pour c#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) et un [projet .NET Core 2.0 pour Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), à partir de la [dotnet / référentiel GitHub d’exemples](https://github.com/dotnet/samples).

Voici quelques exemples inclus dans l’article :

### <a name="create-a-format-string"></a>Créer une chaîne de format

[Insertion d’une chaîne](#inserting-a-string)  
[L’élément de format](#the-format-item)  
[Éléments de format qui ont le même index](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Sortie de mise en forme de contrôle

[Contrôle de mise en forme](#controlling-formatting)  
[Contrôle de l’espacement](#controlling-spacing)  
[Contrôle de l’alignement](#controlling-alignment)  
[Contrôle du nombre de chiffres intégraux](#how-do-i-control-the-number-of-integral-digits)  
[Contrôle du nombre de chiffres après le séparateur décimal](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Y compris les accolades littérales dans une chaîne de résultat](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Rendre les chaînes de format de la culture

[Mise en forme dépendante de la culture](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personnaliser l’opération de mise en forme

[Une opération de mise en forme personnalisée](#example-a-custom-formatting-operation)  
[Un fournisseur de l’interception et d’un chiffre romain formateur](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Remplace un ou plusieurs éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne d’un objet spécifié.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle tous les éléments de mise en forme sont remplacés par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur d’une expression en sa représentation sous forme de chaîne et pour incorporer cette représentation dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Exemple : Mise en forme d’un argument unique  
 
 L’exemple suivant utilise la <xref:System.String.Format%28System.String%2CSystem.Object%29> méthode pour incorporer l’âge d’un individu au milieu d’une chaîne.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">L’élément de format dans <paramref name="format" /> n’est pas valide.  
  
- ou - 
L’index d’un élément de format n’est pas zéro.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Remplace l'élément de mise en forme d'une chaîne spécifiée par la représentation sous forme de chaîne d'un objet correspondant dans un tableau spécifié.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par la représentation sous forme de chaîne des objets correspondants dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur de quatre ou plusieurs expressions leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Dans la mesure où le `args` paramètre est marqué avec le <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribut, vous pouvez passer les objets à la méthode en tant qu’arguments individuels ou un <xref:System.Object> tableau. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Exemple : Mise en forme de plus de trois arguments  
 
 Cet exemple crée une chaîne qui contient des données sur la température haute et basse à une date particulière. La chaîne de format composite a cinq éléments de format dans l’exemple c# et six dans l’exemple Visual Basic. Deux des éléments de format de définir la largeur de la représentation sous forme de chaîne de leur valeur correspondante, et le premier élément de format inclut également un standard de date et d’une chaîne de format d’heure.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Vous pouvez également passer les objets à mettre en forme sous forme de tableau et non une liste d’arguments.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à zéro, ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Objet à mettre en forme.</param>
        <summary>Remplace le ou les éléments de mise en forme d'une chaîne spécifiée par la représentation sous forme de chaîne de l'objet correspondant. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle le ou les éléments de mise en forme sont remplacés par la représentation sous forme de chaîne de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur d’une expression en sa représentation sous forme de chaîne et pour incorporer cette représentation dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou mise en forme dépendante de la culture. La méthode convertit `arg0` à sa représentation sous forme de chaîne en appelant son **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString ( String, IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format n’est pas zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Tableau d'objets contenant aucun ou plusieurs objets à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par les représentations sous forme de chaîne des objets correspondants dans un tableau spécifié. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par la représentation sous forme de chaîne des objets correspondants dans <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir les expressions de quatre ou plus à leur représentation sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou mise en forme dépendante de la culture. La méthode convertit chacun <xref:System.Object> argument à sa représentation sous forme de chaîne en appelant son **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Exemple : La Culture de mise en forme  
 Cet exemple utilise le <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> méthode pour afficher la représentation sous forme de chaîne de certaines valeurs de date et d’heure et les valeurs numériques à l’aide de plusieurs cultures différentes.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à zéro, ou supérieur ou égal à la longueur du tableau <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme dans une chaîne par la représentation sous forme de chaîne de deux objets spécifiés.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme sont remplacés par les représentations sous forme de chaîne de <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur de deux expressions en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Exemple : Mise en forme de deux arguments  
 
 Cet exemple utilise le <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> méthode pour afficher les données de temps et de température stockées dans un générique <xref:System.Collections.Generic.Dictionary%602> objet. Notez que la chaîne de format a trois éléments de format, bien qu’il existe seulement deux objets à mettre en forme. Il s’agit, car le premier objet dans la liste (une valeur de date et heure) est utilisé par les deux éléments de format : le premier affichage des éléments de format l’heure et la seconde affiche la date.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format n’est pas zéro ou un.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Chaînes de format de date et d'heure standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Chaînes de format de date et d'heure personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Chaînes de format numériques standard</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Chaînes de format numériques personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Chaînes de format TimeSpan standard.</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Chaînes de format TimeSpan personnalisées</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Chaînes de format d'énumération</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme dans une chaîne par la représentation sous forme de chaîne de deux objets spécifiés. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme sont remplacés par les représentations sous forme de chaîne de <paramref name="arg0" /> et <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir des deux expressions en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou mise en forme dépendante de la culture. La méthode convertit chacun <xref:System.Object> argument à sa représentation sous forme de chaîne en appelant son **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format n’est pas zéro ou un.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne de trois objets spécifiés.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par les représentations sous forme de chaîne de <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir la valeur des trois expressions leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Exemple : Mise en forme de trois arguments  
 
 Cet exemple utilise le <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> méthode pour créer une chaîne qui illustre le résultat d’une valeur booléenne `And` opération avec deux valeurs entières. Notez que la chaîne de format inclut six éléments, mais la méthode a uniquement trois éléments dans sa liste de paramètres, étant donné que chaque élément est mis en forme de deux manières différentes.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à zéro, ou supérieur à deux.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Mise en forme composite</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <param name="format">[Chaîne de format composite](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">Premier objet à mettre en forme.</param>
        <param name="arg1">Deuxième objet à mettre en forme.</param>
        <param name="arg2">Troisième objet à mettre en forme.</param>
        <summary>Remplace les éléments de mise en forme d’une chaîne par la représentation sous forme de chaîne de trois objets spécifiés. Un paramètre fournit des informations de mise en forme propres à la culture.</summary>
        <returns>Copie de <paramref name="format" /> dans laquelle les éléments de mise en forme ont été remplacés par les représentations sous forme de chaîne de <paramref name="arg0" />, <paramref name="arg1" /> et <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Cette méthode utilise la [fonctionnalité de mise en forme composite](~/docs/standard/base-types/composite-formatting.md) pour convertir des trois expressions en leurs représentations sous forme de chaîne et pour incorporer ces représentations dans une chaîne. Lors de la conversion, la méthode utilise un formateur personnalisé ou mise en forme dépendante de la culture. La méthode convertit chacun <xref:System.Object> argument à sa représentation sous forme de chaîne en appelant son **ToString (IFormatProvider)** méthode ou, si correspondant de l’objet d’élément de format inclut une chaîne de format, en appelant ses **ToString(String,IFormatProvider)** (méthode). Si ces méthodes n’existent pas, elle appelle l’objet sans paramètre **ToString** (méthode).  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> n'est pas valide.  
  
- ou - 
L’index d’un élément de format est inférieur à zéro, ou supérieur à deux.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère un objet qui peut itérer au sein des caractères individuels de cette chaîne.</summary>
        <returns>Objet énumérateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Au lieu d’appeler le <xref:System.String.GetEnumerator%2A> méthode pour récupérer un <xref:System.CharEnumerator> que vous ensuite utiliser pour énumérer une chaîne, vous devez utiliser à la place de construction d’itération de votre langage de l’objet (en c#, en C++ / c++ / CLR et en Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) en c#, [pour chaque](/cpp/dotnet/for-each-in) en C / c++ / CLR, et [pour chaque](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) en Visual Basic).
  
 Cette méthode vous permet d’itérer les caractères individuels dans une chaîne. Par exemple, Visual Basic `For Each` et C# `foreach` instructions appellent cette méthode pour retourner un <xref:System.CharEnumerator> objet qui peut fournir un accès en lecture seule aux caractères dans cette instance de chaîne.  
  
   
  
## Examples  
 L’exemple suivant itère les caractères dans plusieurs chaînes et affiche des informations sur leurs caractères individuels. Il utilise la construction d’itération de langage plutôt que d’un appel à la <xref:System.String.GetEnumerator%2A> (méthode).  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne le code de hachage pour cette chaîne.</summary>
        <returns>Code de hachage d'un entier signé 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le comportement de <xref:System.String.GetHashCode%2A> dépend de son implémentation, ce qui peut changer d’une version du common language runtime à un autre. Une raison pourquoi cela peut se produire consiste à améliorer les performances de <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Si deux objets string sont égaux, la <xref:System.String.GetHashCode%2A> méthode retourne des valeurs identiques. Toutefois, il y n'est pas une valeur de code de hachage unique pour chaque valeur de chaîne unique. Différentes chaînes peuvent retourner le même code de hachage.  
>   
>  Le code de hachage lui-même n’est pas garanti pour être stable. Codes de hachage de chaînes identiques peuvent différer entre les implémentations de .NET, entre les versions de .NET et sur plusieurs plateformes .NET (par exemple, 32 bits et 64 bits) pour une seule version de .NET. Dans certains cas, ils peuvent même différer par domaine d’application. Cela implique que les deux exécutions ultérieures du même programme peuvent retourner différents codes de hachage.  
>   
>  Par conséquent, hachage codes ne doivent jamais être utilisés en dehors du domaine d’application dans lequel ils ont été créés, ils ne doivent jamais être utilisés en tant que champs de clé dans une collection, et s’ils ne doivent jamais être persistants.  
>   
>  Enfin, n’utilisez pas le code de hachage au lieu d’une valeur renvoyée par une fonction de hachage cryptographique, si vous avez besoin d’un hachage de chiffrement fort. Pour les hachages de chiffrement, utilisez une classe dérivée de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Pour plus d’informations sur les codes de hachage, consultez <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Dans les applications de bureau, vous pouvez utiliser la [ \<UseRandomizedStringHashAlgorithm > élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) pour générer des codes de hachage unique sur un par domaine d’application. Cela peut réduire le nombre de collisions et améliorer les performances globales des insertions et des recherches qui utilisent des tables de hachage. L’exemple suivant montre comment utiliser le [ \<UseRandomizedStringHashAlgorithm > élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Il définit un pour générer des codes de hachage unique sur un domaine d’application par application. Cela peut réduire le nombre de collisions et améliorer les performances globales des insertions et des recherches qui utilisent des tables de hachage. L’exemple suivant montre comment utiliser le. Il définit un `DisplayString` classe qui inclut une constante de chaîne privée, `s`, dont la valeur est « Il s’agit d’une chaîne. » Il inclut également une méthode `ShowStringHashCode` qui affiche la valeur de chaîne et son code de hachage avec le nom du domaine d'application dans lequel la méthode est exécutée.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Lorsque vous exécutez l'exemple sans fournir un fichier de configuration, il affiche une sortie similaire à la suivante. Notez que les codes de hachage pour la chaîne sont identiques dans les deux domaines d'application.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Toutefois, si vous ajoutez le fichier de configuration suivant au répertoire de l'exemple, puis exécutez l'exemple, les codes de hachage pour la même chaîne diffèrent par domaine d'application.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Lorsque le fichier de configuration est présent, l'exemple affiche la sortie suivante :  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Codes de hachage sont utilisées pour insérer et extraire efficacement des objets à clé à partir des tables de hachage. Toutefois, les codes de hachage n’identifient les chaînes. Chaînes identiques ont des codes de hachage égale, mais le common language runtime peut également affecter le même code de hachage de chaînes différentes. En outre, les codes de hachage peuvent varier par version de .NET, par plateforme au sein d’une seule version et par domaine d’application. Pour cette raison, vous ne devez pas sérialiser ou conserver les valeurs de code de hachage, ni faut-il les utiliser en tant que clés dans une table de hachage ou un dictionnaire.  
  
 Pour plus d’informations sur l’utilisation des codes de hachage et le `GetHashCode` (méthode), consultez <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.GetHashCode%2A> méthode à l’aide de différents des chaînes d’entrée.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>La valeur retournée par <see cref="M:System.String.GetHashCode" /> est dépendante de la plateforme. Elle diffère sur les versions 32 bits et 64 bits du .NET Framework. Il peut différer entre les versions du .NET Framework et .NET Core.</para>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; élément</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne <see cref="T:System.TypeCode" /> pour la classe <see cref="T:System.String" />.</summary>
        <returns>Constante énumérée, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche le <xref:System.TypeCode> constante énumérée pour la <xref:System.String> type.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale l'index de base zéro de la première occurrence d'un caractère ou d'une chaîne Unicode spécifiés dans cette instance. La méthode retourne -1 si le caractère ou la chaîne est introuvable dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère Unicode spécifié dans cette chaîne.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est disponible ou -1 s'il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez rechercher un <xref:System.String> d’un caractère en utilisant la <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à la première position de caractère de cette instance et continue jusqu'à la dernière position de caractère.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.IndexOf%28System.String%29> méthode retourne toujours 0 (zéro) pour indiquer que la correspondance est trouvée au début de l’instance actuelle. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%29> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union conditionnel (U + 00AD), un trait d’union conditionnel suivi par « n » et un trait d’union conditionnel suivi par « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, dans chaque cas, étant donné que le trait d’union conditionnel est un caractère ignorable, le résultat est le même comme si le trait d’union conditionnel n’avait pas été inclus dans `value`. Lorsque vous recherchez un trait d’union conditionnel uniquement, la méthode retourne 0 (zéro) pour indiquer qu’il a trouvé une correspondance au début de la chaîne.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 L’exemple suivant recherche la valeur « n » dans « animal ». Étant donné que les index de chaîne commencent à zéro au lieu, le <xref:System.String.IndexOf%28System.String%29> méthode indique que le « n » est à la position 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 L’exemple suivant utilise la <xref:System.String.IndexOf%2A> méthode pour déterminer la position de départ d’un nom d’animal dans une phrase. Il utilise ensuite cette position pour insérer un adjectif qui décrit l’animal dans la phrase.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour rechercher le premier index d’une sous-chaîne dans une instance de chaîne en utilisant les règles de comparaison de la culture actuelle, appelez le <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son `comparisonType` paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère Unicode spécifié dans cette chaîne. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la chaîne si ce caractère est trouvé, ou -1 s’il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 La recherche s’étend de `startIndex` à la fin de la chaîne.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à 0 (zéro) ou supérieur à la longueur de la chaîne.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Caractère à rechercher.</param>
        <param name="comparisonType">Une valeur d’énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l’index de base zéro de la première occurrence du caractère Unicode spécifié dans cette chaîne. Un paramètre spécifie le type de recherche à utiliser pour le caractère spécifié.</summary>
        <returns>Index de base zéro de <paramref name="value" /> si ce caractère est trouvé, ou -1 s’il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Numérotation de l’index commence à partir de zéro.  
  
Le `comparisonType` paramètre est un <xref:System.StringComparison> membre d’énumération qui spécifie si la recherche de la `value` argument utilise la culture actuelle ou invariante, est la casse ou word ou des règles de comparaison ordinale.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la instance actuelle si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à la `startIndex` position de cette instance de caractère et continue jusqu'à la dernière position de caractère.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m » dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 L’exemple suivant recherche toutes les occurrences d’une chaîne spécifiée dans une chaîne cible.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à 0 (zéro) ou supérieur à la longueur de cette chaîne.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour rechercher le premier index d’une sous-chaîne qui se produit après une position de caractère particulier en utilisant les règles de comparaison de la culture actuelle, appelez le <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son `comparisonType` paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Un paramètre spécifie le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d'index du paramètre <paramref name="value" /> si cette chaîne est trouvée ; sinon, -1. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
   
  
## Examples  
 L’exemple suivant illustre trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> méthode retourne toujours 0 (zéro) pour indiquer que la correspondance est trouvée au début de l’instance actuelle.  
  
Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union conditionnel (U + 00AD), un trait d’union conditionnel suivi par « n » et un trait d’union conditionnel suivi par « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, étant donné que le trait d’union conditionnel est un caractère ignorable, une recherche dépendante de la culture retourne la même valeur que renverrait si le trait d’union conditionnel ne figuraient pas dans la chaîne de recherche. Une recherche ordinale, toutefois, recherche le trait d’union conditionnel dans une chaîne avec succès et signale qu’il est absent de la deuxième chaîne.  
  
[ ! code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [ ! code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence du caractère spécifié dans cette instance. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la chaîne si ce caractère est trouvé, ou -1 s’il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Index numérotation commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.IndexOf%2A> (méthode).  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
 <paramref name="startIndex" /> est supérieur à la longueur de cette chaîne.  
  
- ou - 
 <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d’index de base zéro de <paramref name="value" /> à partir du début de la instance actuelle si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numérotation commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle. La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m » à partir de la troisième à la sixième position de caractère dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences de la chaîne « he » dans une sous-chaîne d’une autre chaîne. Notez que le nombre de caractères à rechercher doit être recalculé, pour chaque itération de la recherche.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
 <paramref name="startIndex" /> est supérieur à la longueur de cette chaîne.  
  
- ou - 
 <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour utiliser les règles de comparaison de la culture actuelle pour effectuer cette opération, appelez le <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son `comparisonType` paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Les paramètres spécifient la position de départ de la recherche dans la chaîne actuelle et le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d’index de base zéro du paramètre <paramref name="value" /> à partir du début de l’instance active si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à 0. Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne. Si `startIndex` est égal à la longueur de l’instance de chaîne, la méthode retourne -1.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à 0 (zéro) ou supérieur à la longueur de cette chaîne.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  
  
Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m » en commençant par la troisième position de caractère dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ». La méthode retourne l'index du trait d'union conditionnel dans la première chaîne uniquement lorsqu'elle effectue une comparaison ordinale.  
  
[ ! code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [ ! code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence de la chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Les paramètres spécifient le point de départ de la recherche dans la chaîne actuelle, le nombre de caractères de la chaîne dans laquelle effectuer la recherche et le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d’index de base zéro du paramètre <paramref name="value" /> à partir du début de l’instance active si cette chaîne est trouvée, ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Index numérotation commence à 0 (zéro). Le paramètre `startIndex` peut varier entre 0 et la longueur de l'instance de chaîne.  
  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.IndexOf%2A> méthode qui recherche la première occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
 <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  
  
- ou - 
 <paramref name="count" /> est supérieur à la longueur de cette chaîne moins <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  
  
Dans l’exemple suivant, la <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m » à partir de la troisième à la sixième position de caractère dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Lorsqu’elle effectue une comparaison ordinale, toutefois, il recherche la sous-chaîne uniquement dans la première chaîne. Notez que dans le cas de la première chaîne, ce qui inclut le trait d’union conditionnel suivi d’un « m », la méthode ne parvient pas à retourner l’index du trait d’union, mais au lieu de cela retourne l’index du « m » lorsqu’il effectue une comparaison dépendante de la culture. La méthode retourne l'index du trait d'union conditionnel dans la première chaîne uniquement lorsqu'elle effectue une comparaison ordinale.  
  
[ ! code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [ ! code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale l'index de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La méthode retourne -1 si les caractères du tableau sont introuvables dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 La recherche de `anyOf` respecte la casse. Si `anyOf` est un tableau vide, la méthode recherche une correspondance au début de la chaîne (autrement dit, à l’index zéro).  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche la première VOYELLE dans une chaîne.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La recherche commence à une position de caractère spécifiée.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Le `startIndex` paramètre peut aller de 0 à un de moins que la longueur de l’instance de chaîne.  
  
 La recherche s’étend de `startIndex` à la fin de la chaîne.  
  
 La recherche de `anyOf` respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de l’occurrence de n’importe quel caractère de la chaîne « est » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
 <paramref name="startIndex" /> est supérieur au nombre de caractères dans cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale l'index de base zéro de la première occurrence dans cette instance de tout caractère d'un tableau de caractères Unicode spécifié. La recherche commence à une position de caractère spécifiée et examine un nombre spécifié de positions de caractère.</summary>
        <returns>Position d'index de base zéro de la première occurrence dans cette instance où un caractère quelconque dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La recherche commence à `startIndex` et continue à `startIndex`  +  `count` -1. Le caractère situé à `startIndex`  +  `count` n’est pas inclus dans la recherche.  
  
 Numérotation de l’index commence à partir de zéro. Le `startIndex` paramètre peut aller de 0 à un de moins que la longueur de l’instance de chaîne.  
  
 La recherche de `anyOf` respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de l’occurrence de n’importe quel caractère de la chaîne « aid » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
 <paramref name="count" /> + <paramref name="startIndex" /> est supérieur au nombre de caractères dans cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position d'index de base zéro de l'insertion.</param>
        <param name="value">Chaîne à insérer.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle une chaîne spécifiée est insérée dans cette instance à une position d'index spécifiée.</summary>
        <returns>Nouvelle chaîne qui est équivalente à cette instance, mais avec <paramref name="value" /> inséré à la position <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `startIndex` est égal à la longueur de cette instance, `value` est ajouté à la fin de cette instance.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle `value` est insérée dans l’instance actuelle.  
  
 Par exemple, la valeur de retour de `"abc".Insert(2, "XYZ")` est « abXYZc ».  
  
   
  
## Examples  
 L’exemple suivant insère un caractère d’espace dans la quatrième position de caractère (le caractère à l’index 3) d’une chaîne.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 L’application console suivante invite les utilisateurs à entrer un ou plusieurs des adjectifs pour décrire deux animaux. Il appelle ensuite la <xref:System.String.Insert%2A> méthode pour insérer le texte entré par l’utilisateur dans une chaîne.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est négatif ou supérieur à la longueur de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à rechercher dans le pool interne.</param>
        <summary>Récupère la référence du système au <see cref="T:System.String" /> spécifié.</summary>
        <returns>Référence du système à <paramref name="str" /> si elle est dans le pool interne ; sinon, nouvelle référence à une chaîne ayant la valeur <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le common language runtime permet d’économiser de stockage de chaînes en conservant une table, appelée pool interne, qui contient une référence unique à chaque chaîne littérale unique déclarée ou créée par programmation dans votre programme. Par conséquent, une instance d’une chaîne littérale avec une valeur particulière existe uniquement une fois dans le système.  
  
 Par exemple, si vous attribuez la même chaîne littérale à plusieurs variables, le runtime récupère la même référence à la chaîne littérale dans le pool interne et assigne à chaque variable.  
  
 Le <xref:System.String.Intern%2A> méthode utilise le pool interne pour rechercher une chaîne égale à la valeur de `str`. Si cette chaîne existe, sa référence dans le pool interne est retourné. Si la chaîne n’existe pas, une référence à `str` est ajouté au pool interne, cette référence est retournée.  
  
 Dans l’exemple suivant, la chaîne s1, ce qui a la valeur « MyTest », est déjà dans le pool interne, car il s’agit d’un littéral dans le programme. Le <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe génère un nouvel objet string qui a la même valeur que s1. Une référence à cette chaîne est assignée à s2. Le <xref:System.String.Intern%2A> méthode recherche une chaîne ayant la même valeur que s2. Étant donné que cette chaîne existe, la méthode retourne la même référence qui est assignée à s1. Cette référence est ensuite assignée à s3. Les références s1 et s2 considérées comme égales, car ils font référence à des objets différents ; les références s1 et s3 équivalentes, car ils font référence à la même chaîne.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Comparez cette méthode à la <xref:System.String.IsInterned%2A> (méthode).  
  
## <a name="version-considerations"></a>Considérations relatives à la version  
 Dans le [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], le <xref:System.String.Intern%2A> méthode reprend son comportement dans le .NET Framework 1.0 et 1.1 en ce qui concerne la centralisation de la chaîne vide. Dans l’exemple suivant, la variable `str1` est affectée à une référence à <xref:System.String.Empty>et la variable `str2` est affectée à la référence à <xref:System.String.Empty> qui est retourné en appelant le <xref:System.String.Intern%2A> méthode après avoir converti un <xref:System.Text.StringBuilder>objet dont la valeur est <xref:System.String.Empty> vers une chaîne. Puis les références contenues dans `str1` et `str2` sont une comparaison d’égalité.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 Dans le [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], et [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` et `str2` sont égaux. Dans le [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] et [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` et `str2` ne sont pas égaux.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous essayez de réduire la quantité totale de mémoire, votre application alloue, n’oubliez pas que la centralisation de chaîne a deux effets secondaires indésirables. Tout d’abord, la mémoire allouée pour internées <xref:System.String> objets n’est pas susceptible d’être libérée tant que le common language runtime (CLR) se termine. La raison est que la référence du CLR à la dans le pool interne <xref:System.String> objet peut persister après que votre application, ou même votre domaine d’application, se termine. Ensuite, pour intern une chaîne, vous devez d’abord créer la chaîne. La mémoire utilisée par le <xref:System.String> objet doit toujours être alloué, même si la mémoire doit finalement être nettoyées.  
  
 Le .NET Framework version 2.0 introduit le <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membre d’énumération. Le <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membre marque un assembly comme ne nécessitant ne pas d’internement de littéral de chaîne. Vous pouvez appliquer <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> à un assembly à l’aide de la <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribut. En outre, lorsque vous utilisez le [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) pour compiler un assembly avant l’exécution, les chaînes ne sont pas intégrées entre les modules.  
  
   
  
## Examples  
 L’exemple suivant utilise trois chaînes sont égales en valeur pour déterminer si une chaîne créée récemment et une chaîne dans le pool interne sont égales.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Chaîne à rechercher dans le pool interne.</param>
        <summary>Récupère une référence à un <see cref="T:System.String" /> spécifié.</summary>
        <returns>Référence à <paramref name="str" /> si elle figure dans le pool interne du Common Language Runtime ; sinon, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le common language runtime gère automatiquement une table, appelée pool interne, qui contient une seule instance de chaque constante de chaîne littérale unique déclarée dans un programme, ainsi qu’une instance unique de <xref:System.String> ajouter par programmation en appelant le <xref:System.String.Intern%2A> (méthode).  
  
 Le pool interne conserve le stockage de chaînes. Si vous affectez une constante de chaîne littérale à plusieurs variables, chaque variable est définie pour référencer la même constante dans le pool interne au lieu de référencer plusieurs instances différentes de <xref:System.String> qui ont des valeurs identiques.  
  
 Cette méthode recherche `str` dans le pool interne. Si `str` a déjà été dans le pool interne, une référence à cette instance est retournée ; sinon, `null` est retournée.  
  
 Comparez cette méthode à la <xref:System.String.Intern%2A> (méthode).  
  
 Cette méthode ne retourne pas une valeur booléenne. Si vous appelez la méthode, car vous voulez une valeur booléenne qui indique si une chaîne particulière est dans le pool interne, vous pouvez utiliser le code suivant.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  À compter de .NET Framework version 2.0, vous pouvez remplacer l’utilisation du pool interne lorsque vous utilisez le [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) pour installer un assembly dans le cache des images natives sur un ordinateur local. Pour plus d’informations, consultez Considérations sur les performances dans la section Notes pour la <xref:System.String.Intern%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant montre que les chaînes littérales sont automatiquement intégrées par le compilateur.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indique si cette chaîne figure dans un formulaire particulier de normalisation Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si cette chaîne se trouve dans un formulaire de normalisation C Unicode.</summary>
        <returns>
          <see langword="true" /> si cette chaîne figure dans un formulaire de normalisation C ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, le tri, la correspondance et les autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire de la représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. .NET prend actuellement en charge les formulaires de normalisation C, D, KC et KD.  
  
 Pour obtenir une description des formulaires de normalisation Unicode prises en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne est normalisée avec succès selon différents formulaires de normalisation.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère dans une chaîne non normalisée. Par conséquent, si une chaîne contient des caractères non normalisée suivies de caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lèvera une <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formulaire de normalisation Unicode.</param>
        <summary>Indique si cette chaîne figure dans le formulaire de normalisation Unicode spécifié.</summary>
        <returns>
          <see langword="true" /> si cette chaîne se trouve dans le formulaire de normalisation spécifié par le paramètre <paramref name="normalizationForm" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, le tri, la correspondance et les autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire de la représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. .NET prend actuellement en charge les formulaires de normalisation C, D, KC et KD.  
  
 Pour obtenir une description des formulaires de normalisation Unicode prises en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.IsNormalized%2A> et <xref:System.String.Normalize%2A> méthodes.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère dans une chaîne non normalisée. Par conséquent, si une chaîne contient des caractères non normalisée suivies de caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lèvera une <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à tester.</param>
        <summary>Indique si la chaîne spécifiée est <see langword="null" /> ou une chaîne vide ("").</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> est <see langword="null" /> ou une chaîne vide ("") ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> est une méthode pratique qui vous permet de tester simultanément si un <xref:System.String> est `null` ou sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>. Il est équivalent au code suivant :  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Vous pouvez utiliser la <xref:System.String.IsNullOrWhiteSpace%2A> méthode pour tester si une chaîne est `null`, sa valeur est <xref:System.String.Empty?displayProperty=nameWithType>, ou il se compose uniquement d’espaces blancs.  
  
## <a name="what-is-a-null-string"></a>Qu’est une chaîne null ?

Une chaîne est `null` si elle n’a pas reçu d’une valeur (en C++ et Visual Basic) ou si elle a été explicitement affectée une valeur de `null`. Bien que le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité peut gérer correctement une chaîne null, comme le montre l’exemple suivant, une tentative pour appeler l’une si ses membres lève un <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>Qu’est une chaîne vide ?  

Une chaîne est vide si elle est explicitement affectée une chaîne vide (" ») ou <xref:System.String.Empty?displayProperty=nameWithType>. Une chaîne vide est un <xref:System.String.Length%2A> de 0.  L’exemple suivant crée une chaîne vide et affiche sa valeur et sa longueur.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 L’exemple suivant examine trois chaînes et détermine si chaque chaîne a la valeur, est une chaîne vide ou `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à tester.</param>
        <summary>Indique si une chaîne spécifiée est <see langword="null" />, vide ou se compose uniquement d'espaces blancs.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> est <see langword="null" /> ou <see cref="F:System.String.Empty" />, ou si <paramref name="value" /> est composé exclusivement d'espaces blancs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> est une méthode pratique qui est semblable au code suivant, mais offre de meilleures performances :  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Espaces blancs sont définis par la norme Unicode. Le <xref:System.String.IsNullOrWhiteSpace%2A> méthode interprète n’importe quel caractère qui retourne une valeur de `true` lorsqu’il est passé à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> méthode comme un caractère d’espace blanc.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de chaînes, puis passe chaque élément du tableau à la <xref:System.String.IsNullOrWhiteSpace%2A> (méthode).  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatène les éléments d’un tableau spécifié ou les membres d’une collection, en utilisant le séparateur spécifié entre chaque élément ou membre.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur.<paramref name="separator" /> est inclus dans la chaîne retournée uniquement si <paramref name="values" /> contient plusieurs éléments.</param>
        <param name="values">Collection qui contient les chaînes à concaténer.</param>
        <summary>Concatène les membres d’une collection <see cref="T:System.Collections.Generic.IEnumerable`1" /> construite de type <see cref="T:System.String" />, en utilisant le séparateur spécifié entre chaque membre.</summary>
        <returns>Chaîne composée des membres de <paramref name="values" /> délimités par la chaîne <paramref name="separator" />. Si les <paramref name="values" /> ne possèdent aucun membre, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si tous les membres du `values` est `null`, une chaîne vide est utilisée à la place.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un `IEnumerable(Of String)` collection sans avoir à convertir les éléments dans un tableau de chaînes. Il est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). L’exemple suivant passe un `List(Of String)` objet qui contient les lettres majuscules ou minuscules de l’alphabet à une expression lambda qui sélectionne des lettres qui sont égales ou supérieures à une lettre particulière (c'est-à-dire, dans l’exemple, « M »). Le `IEnumerable(Of String)` collection retournée par la <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> méthode est passée à la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> méthode pour afficher le résultat sous forme de chaîne unique.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieures ou égales à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type <xref:System.String>, qu’il passe ensuite à la <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. <paramref name="separator" /> est inclus dans la chaîne retournée uniquement si <paramref name="values" /> contient plusieurs éléments.</param>
        <param name="values">Tableau qui contient les éléments à concaténer.</param>
        <summary>Concatène les éléments d'un tableau d'objets, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des éléments de <paramref name="values" /> séparés par la chaîne <paramref name="separator" />. Si <paramref name="values" /> est un tableau vide, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null` ou si un élément de la `values` autre que le premier élément est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Consultez les Notes relatives à la section d’appelants si le premier élément du `values` est `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> est une méthode pratique qui vous permet de concaténer chaque élément dans un tableau d’objets sans convertir explicitement ses éléments en chaînes. La représentation sous forme de chaîne de chaque objet dans le tableau est dérivée en appelant l’objet `ToString` (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieures ou égales à 100. Il assigne le résultat à un tableau d’entiers, qu’il passe ensuite à la <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> (méthode).  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Si le premier élément du <paramref name="values" /> est <see langword="null" />, le <see cref="M:System.String.Join(System.String,System.Object[])" /> méthode ne concaténez pas les éléments dans <paramref name="values" /> mais retourne <see cref="F:System.String.Empty" />. Un certain nombre de solutions de contournement pour ce problème sont disponible. Le plus simple consiste à affecter la valeur <see cref="F:System.String.Empty" /> vers le premier élément du tableau, comme dans l’exemple suivant montre.  
  
[ ! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [ ! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. <paramref name="separator" /> est inclus dans la chaîne retournée uniquement si <paramref name="value" /> contient plusieurs éléments.</param>
        <param name="value">Tableau qui contient les éléments à concaténer.</param>
        <summary>Concatène tous les éléments d'un tableau de chaînes, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des éléments de <paramref name="value" /> séparés par la chaîne <paramref name="separator" />. Si <paramref name="value" /> est un tableau vide, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si `separator` est «, » et les éléments de `value` sont « apple », « orange », « grape » et « pear », `Join(separator, value)` retourne « apple, orange, grape, pear ».  
  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si aucun élément de `value` est `null`, une chaîne vide est utilisée à la place.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Join%2A> (méthode).  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Chaîne à utiliser comme séparateur. <paramref name="separator" /> est inclus dans la chaîne retournée uniquement si <paramref name="value" /> contient plusieurs éléments.</param>
        <param name="value">Tableau qui contient les éléments à concaténer.</param>
        <param name="startIndex">Premier élément dans <paramref name="value" /> à utiliser.</param>
        <param name="count">Nombre d'éléments de <paramref name="value" /> à utiliser.</param>
        <summary>Concatène les éléments spécifiés d'un tableau de chaînes, en utilisant le séparateur spécifié entre chaque élément.</summary>
        <returns>Chaîne composée des chaînes de <paramref name="value" /> délimitées par la chaîne <paramref name="separator" />.  
  
- ou - 
 <see cref="F:System.String.Empty" /> si <paramref name="count" /> est égal à zéro et que <paramref name="value" /> ne contient aucun élément, ou si <paramref name="separator" /> et tous les éléments de <paramref name="value" /> sont <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, si `separator` est «, » et les éléments de `value` sont « apple », « orange », « grape » et « pear », `Join(separator, value, 1, 2)` retourne « orange, grape ».  
  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si aucun élément de `value` est `null`, une chaîne vide est utilisée à la place.  
  
   
  
## Examples  
 L’exemple suivant concatène deux éléments d’un tableau de noms de fruits.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à 0.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="count" /> est supérieur au nombre d’éléments de <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Mémoire insuffisante.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">Types des membres de <paramref name="values" />.</typeparam>
        <param name="separator">Chaîne à utiliser comme séparateur.<paramref name="separator" /> est inclus dans la chaîne retournée uniquement si <paramref name="values" /> contient plusieurs éléments.</param>
        <param name="values">Collection qui contient les objets à concaténer.</param>
        <summary>Concatène les membres d’une collection, en utilisant le séparateur spécifié entre chaque membre.</summary>
        <returns>Chaîne composée des membres de <paramref name="values" /> délimités par la chaîne <paramref name="separator" />. Si les <paramref name="values" /> ne possèdent aucun membre, la méthode retourne <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `separator` est `null`, une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>) est utilisé à la place. Si tous les membres du `values` est `null`, une chaîne vide est utilisée à la place.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> est une méthode pratique qui vous permet de concaténer chaque membre d’un <xref:System.Collections.Generic.IEnumerable%601> collection sans les convertissant d’abord en chaînes. La représentation sous forme de chaîne de chaque objet dans le <xref:System.Collections.Generic.IEnumerable%601> collection est dérivée en appelant l’objet `ToString` (méthode).  
  
 Cette méthode est particulièrement utile avec les expressions de requête Language-Integrated Query (LINQ). Par exemple, le code suivant définit un très simple `Animal` classe qui contient le nom d’un animal et l’ordre auquel il appartient. Il définit ensuite un <xref:System.Collections.Generic.List%601> objet qui contient un nombre de `Animal` objets. Le <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> méthode d’extension est appelée pour extraire le `Animal` objets dont la propriété `Order` propriété correspond à « Rongeur ». Le résultat est passé à la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 L’exemple suivant utilise le crible d’Ératosthène pour calculer les nombres premiers qui sont inférieures ou égales à 100. Il assigne le résultat à un <xref:System.Collections.Generic.List%601> objet de type entier, qu’il passe ensuite à la <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> (méthode).  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère ou d'une chaîne Unicode spécifiés dans cette instance. La méthode retourne -1 si le caractère ou la chaîne est introuvable dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère Unicode spécifié dans cette instance.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est disponible ou -1 s'il est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 Cette méthode commence la recherche à la position du dernier caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvé ou la position du premier caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant définit un `ExtractFilename` méthode qui utilise le <xref:System.String.LastIndexOf%28System.Char%29> méthode pour rechercher le dernier caractère de séparation de répertoire dans une chaîne et extraire le nom du fichier de la chaîne. Si le fichier existe, la méthode retourne le nom de fichier sans son chemin d’accès.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvé ou la position du premier caractère a été examinée.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.LastIndexOf%28System.String%29> méthode retourne toujours <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, ce qui représente la dernière position d’index dans l’instance actuelle. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%28System.String%29> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union conditionnel (U + 00AD), un trait d’union conditionnel suivi par « n » et un trait d’union conditionnel suivi par « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, dans chaque cas, étant donné que le trait d’union conditionnel est un caractère ignorable, le résultat est le même comme si le trait d’union conditionnel n’avait pas été inclus dans `value`. Lorsque vous recherchez un trait d’union conditionnel uniquement, la méthode retourne 6 et 5. Ces valeurs correspondent à l’index du dernier caractère dans les deux chaînes.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 L’exemple suivant supprime les balises HTML à partir d’une chaîne si les balises de début et de fin de la chaîne. Si une chaîne se termine par une fermeture crochet pointu (« > »), l’exemple utilise le <xref:System.String.LastIndexOf%2A> méthode pour trouver le début de la balise de fin.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour rechercher le dernier index d’une sous-chaîne dans une instance de chaîne en utilisant les règles de comparaison de la culture actuelle, appelez le <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'un caractère Unicode spécifié dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est trouvé, ou -1 s'il est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> -1. cette méthode commence la recherche à la `startIndex` position de cette instance et le revenu en arrière vers le début de l’instance actuelle jusqu'à ce que des caractères `value` est trouvé ou la position du premier caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère dans la chaîne au début. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’un caractère dans une chaîne, depuis la fin de la chaîne au début de la chaîne.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à zéro ou supérieur ou égal à la longueur de cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position de cette instance et de se poursuit jusqu'à ce que vers l’arrière de caractère `value` est trouvé ou la position du premier caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère dans la chaîne au début.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> méthode est utilisée pour trouver une sous-chaîne qui inclut un trait d’union conditionnel (U + 00AD) et qui précède ou qui inclut le « m » final dans une chaîne. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou version ultérieure, étant donné que le trait d’union conditionnel dans la chaîne de recherche est ignorée, la méthode pour trouver une sous-chaîne qui se compose du trait d’union conditionnel et « m » retourne la position du « m » dans la chaîne, tandis que l’appel pour trouver un substrin g comprenant le trait d’union conditionnel et « n » retourne la position de la « n ». Lorsque la chaîne de recherche contient uniquement le trait d’union conditionnel, la méthode retourne l’index de « m », qui représente la valeur de `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’une chaîne dans la chaîne cible, depuis la fin de la chaîne cible au début de la chaîne cible.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de l’instance actuelle.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à -1 ou supérieur à zéro.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour rechercher l’index d’une sous-chaîne qui précède une position de caractère particulier en utilisant les règles de comparaison de la culture actuelle, appelez le <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. Un paramètre spécifie le type de recherche à utiliser pour la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est disponible ou -1 si elle est introuvable. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
 La recherche commence à la dernière position de caractère de cette instance et se poursuit vers le début jusqu'à ce que `value` est trouvé ou la position du premier caractère a été examinée.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="options" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> méthode retourne toujours <see cref="P:System.String.Length" /> – 1, ce qui représente la dernière position d’index dans l’instance actuelle.  
  
Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> méthode est utilisée pour rechercher des trois sous-chaînes (un trait d’union conditionnel (U + 00AD), un trait d’union conditionnel suivi par « n » et un trait d’union conditionnel suivi par « m ») dans les deux chaînes. Une seule des chaînes contient un trait d'union conditionnel. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, étant donné que le trait d’union conditionnel est un caractère ignorable, une recherche dépendante de la culture retourne la même valeur que renverrait si le trait d’union conditionnel ne figuraient pas dans la chaîne de recherche. Une recherche ordinale, toutefois, recherche le trait d’union conditionnel dans une chaîne avec succès et signale qu’il est absent de la deuxième chaîne.  
  
[ ! code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [ ! code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Caractère Unicode à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence du caractère Unicode spécifié dans une sous-chaîne de cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de base zéro de <paramref name="value" /> si ce caractère est trouvé, ou -1 s'il est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 Cette méthode commence la recherche à la `startIndex` position et se poursuit vers le début de cette instance en tant que caractères `value` est trouvé ou `count` positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’un caractère dans une sous-chaîne, depuis la fin de la sous-chaîne au début de la sous-chaîne.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est inférieur à zéro ou supérieur ou égal à la longueur de cette instance.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> - <paramref name="count" /> + 1 est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de départ de base zéro de <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position de cette instance et de se poursuit jusqu'à ce que vers l’arrière de caractère `value` est trouvé ou `count` positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne.  
  
 Cette méthode effectue une recherche de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
 Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture, si `value` contient un caractère ignorable, le résultat est équivalent à la recherche avec ce caractère supprimé. Si `value` se compose uniquement d’un ou plusieurs caractères ignorables, le <xref:System.String.LastIndexOf%2A> méthode retourne toujours `startIndex`, qui est la position de caractère à partir duquel commence la recherche. Dans l’exemple suivant, la <xref:System.String.LastIndexOf%2A> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) dans les deux caractères qui précèdent le dernier « m » de deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ».  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de toutes les occurrences d’une chaîne dans une sous-chaîne, à partir de la fin de la sous-chaîne au début de la sous-chaîne.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> - <paramref name="count" /> + 1 spécifie une position qui ne figure pas dans cette instance.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="start" /> est inférieur à -1 ou supérieur à zéro.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="count" /> est supérieur à 1.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour effectuer cette opération en utilisant les règles de comparaison de la culture actuelle, appelez le <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale l'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans l'objet <see cref="T:System.String" /> actuel. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne. Un paramètre spécifie le type de comparaison à effectuer pendant la recherche de la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position et se poursuit jusqu'à ce que vers l’arrière de caractères `value` est trouvé ou la position du premier caractère a été examinée. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche tous les caractères à partir du dernier caractère dans la chaîne au début.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de l’instance actuelle.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> est inférieur à -1 ou supérieur à zéro.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  
  
Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m », en commençant par le dernier « m » dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Notez que, dans le cas de la première chaîne, qui inclut le trait d'union conditionnel suivi d'un « m », la méthode ne parvient pas à retourner l'index du trait d'union, mais retourne à la place celui de la lettre « m ». La méthode retourne l'index du trait d'union conditionnel dans la première chaîne uniquement lorsqu'elle effectue une comparaison ordinale.  
  
[ ! code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [ ! code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <param name="comparisonType">L'une des valeurs d'énumération qui spécifie les règles de la recherche.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence d'une chaîne spécifiée dans cette instance. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour le nombre spécifié de positions de caractères. Un paramètre spécifie le type de comparaison à effectuer pendant la recherche de la chaîne spécifiée.</summary>
        <returns>Position d'index de départ de base zéro du paramètre <paramref name="value" /> si cette chaîne est trouvée, ou -1 si elle est introuvable ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />. Si <paramref name="value" /> est <see cref="F:System.String.Empty" />, la valeur de retour est la plus petite de <paramref name="startIndex" /> et la dernière position d'index dans cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro. Autrement dit, le premier caractère dans la chaîne est à l’index zéro et la dernière est à <xref:System.String.Length%2A> - 1.  
  
 La recherche commence à la `startIndex` position et se poursuit jusqu'à ce que vers l’arrière de caractères `value` est trouvé ou `count` positions de caractère aient été examinées. Par exemple, si `startIndex` est <xref:System.String.Length%2A> - 1, la méthode recherche vers l’arrière `count` caractères à partir du dernier caractère dans la chaîne.  
  
 Le `comparisonType` paramètre permet de rechercher le `value` paramètre à l’aide de la culture actuelle ou indifférente, à l’aide d’une recherche de la casse et à l’aide des règles de comparaison ordinale ou de word.  
  
   
  
## Examples  
 L’exampledemonstrates suivant trois surcharges de la <xref:System.String.LastIndexOf%2A> méthode qui recherchent la dernière occurrence d’une chaîne dans une autre chaîne à l’aide de différentes valeurs de la <xref:System.StringComparison> énumération.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> est supérieur à la longueur de cette instance.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> - <paramref name="count" /> + 1 spécifie une position qui ne figure pas dans cette instance.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="start" /> est inférieur à -1 ou supérieur à zéro.  
  
- ou - 
L’instance actuelle est égale à <see cref="F:System.String.Empty" /> et <paramref name="count" /> est supérieur à 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur de <see cref="T:System.StringComparison" /> valide.</exception>
        <block subset="none" type="usage">
          <para>Les jeux de caractères incluent les caractères ignorables, à savoir les caractères qui ne sont pas considérés lors de l'exécution d'une comparaison linguistique ou dépendante de la culture. Dans une recherche dépendante de la culture (autrement dit, si <paramref name="comparisonType" /> n'est pas <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), si <paramref name="value" /> contient un caractère ignorable, le résultat est équivalent à une recherche avec ce caractère supprimé. Si <paramref name="value" /> se compose uniquement d’un ou plusieurs caractères ignorables, le <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode retourne toujours <paramref name="startIndex" />, qui est la position de caractère à partir duquel commence la recherche.  
  
Dans l’exemple suivant, la <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> méthode est utilisée pour rechercher la position d’un trait d’union conditionnel (U + 00AD) suivie d’un « m » dans tous les mais la première position de caractère avant le dernier « m » dans les deux chaînes. Une seule des chaînes contient la sous-chaîne requise. Si l’exemple est exécuté le [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou une version ultérieure, dans les deux cas, étant donné que le trait d’union conditionnel est un caractère ignorable, la méthode retourne l’index « m » dans la chaîne lorsqu’elle effectue une comparaison dépendante de la culture. Lorsqu’elle effectue une comparaison ordinale, toutefois, il recherche la sous-chaîne uniquement dans la première chaîne. Notez que dans le cas de la première chaîne, ce qui inclut le trait d’union conditionnel suivi d’un « m », la méthode ne parvient pas à retourner l’index du trait d’union, mais au lieu de cela retourne l’index du « m » lorsqu’il effectue une comparaison dépendante de la culture. La méthode retourne l'index du trait d'union conditionnel dans la première chaîne uniquement lorsqu'elle effectue une comparaison ordinale.  
  
[ ! code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [ ! code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La méthode retourne -1 si les caractères du tableau sont introuvables dans cette instance.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Cette méthode commence la recherche à la position du dernier caractère de cette instance et se poursuit vers le début jusqu'à un caractère dans `anyOf` est trouvé ou la position du premier caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence de n’importe quel caractère dans la chaîne « est » dans une autre chaîne.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Cette méthode commence la recherche à la `startIndex` position de cette instance et de se poursuit jusqu'à ce que de type caractère dans vers l’arrière de caractère `anyOf` est trouvé ou la position du premier caractère a été examinée. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence de n’importe quel caractère dans la chaîne « est » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" /> et <paramref name="startIndex" /> spécifie une position qui ne figure pas dans cette instance.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Tableau de caractères Unicode contenant un ou plusieurs caractères à rechercher.</param>
        <param name="startIndex">Position de départ de la recherche. La recherche se poursuit à partir de <paramref name="startIndex" /> vers le début de cette instance.</param>
        <param name="count">Nombre de positions de caractère à examiner.</param>
        <summary>Signale la position d'index de base zéro de la dernière occurrence dans cette instance d'un ou plusieurs caractères spécifiés dans un tableau Unicode. La recherche commence à une position de caractère spécifiée et se poursuit vers le début de la chaîne pour un nombre spécifié de positions de caractères.</summary>
        <returns>Position d'index de la dernière occurrence dans cette instance où tout caractère dans <paramref name="anyOf" /> a été trouvé ; -1 si aucun caractère dans <paramref name="anyOf" /> n'a été trouvé ou si l'instance actuelle est égale à <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numérotation de l’index commence à partir de zéro.  
  
 Cette méthode commence la recherche à la `startIndex` position de cette instance et de se poursuit jusqu'à ce que de type caractère dans vers l’arrière de caractère `anyOf` est trouvé ou `count` positions de caractère aient été examinées. La recherche respecte la casse.  
  
 Cette méthode effectue une recherche ordinale (indépendante de la culture), où un caractère est considéré comme équivalent à un autre caractère uniquement si leurs valeurs Unicode sont identiques. Pour effectuer une recherche dépendante de la culture, utilisez la <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> méthode, où une valeur scalaire Unicode représentant un caractère précomposé, telles que la ligature « Æ » (U + 00C 6), peut être considéré comme équivalent à n’importe quelle occurrence des composants du caractère dans la corriger la séquence, telles que « AE » (U + 0041, U + 0045), en fonction de la culture.  
  
   
  
## Examples  
 L’exemple suivant recherche l’index de la dernière occurrence de n’importe quel caractère dans la chaîne « aid » dans une sous-chaîne d’une autre chaîne.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="count" /> ou <paramref name="startIndex" /> est un nombre négatif.  
  
- ou - 
L’instance actuelle n’est pas égale à <see cref="F:System.String.Empty" />, et <paramref name="startIndex" /> moins <paramref name="count" />+ 1 est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de caractères de l'objet <see cref="T:System.String" /> actuel.</summary>
        <value>Nombre de caractères de la chaîne actuelle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Length%2A> propriété retourne le nombre de <xref:System.Char> objets dans cette instance, pas le nombre de caractères Unicode. La raison est qu’un caractère Unicode peut être représenté par plusieurs <xref:System.Char>. Utilisez le <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe pour travailler avec chaque caractère Unicode plutôt que chaque <xref:System.Char>.  
  
 Dans certains langages, tels que C et C++, un caractère null indique la fin d’une chaîne. Dans .NET, un caractère null peut être incorporé dans une chaîne. Lorsqu’une chaîne inclut un ou plusieurs caractères null, ils sont inclus dans la longueur totale de la chaîne. Par exemple, dans la chaîne suivante, les sous-chaînes « abc » et « def » sont séparés par un caractère null. Le <xref:System.String.Length%2A> propriété renvoie 7, ce qui indique qu’il inclut les six caractères alphabétiques, ainsi que le caractère null.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Length%2A> propriété.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dont la représentation binaire se trouve dans un formulaire particulier de normalisation Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans un formulaire de normalisation C Unicode.</summary>
        <returns>Nouvelle chaîne normalisée dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans un formulaire de normalisation C Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. Par exemple, un des points de code suivant peut représenter la lettre « ắ » :  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 L’existence de plusieurs représentations pour un seul caractère complique la recherche, le tri, la correspondance et les autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire de la représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. .NET prend en charge quatre formulaires de normalisation (C, D, KC et KD) qui sont définies par la norme Unicode. Lorsque deux chaînes sont représentées dans le même formulaire de normalisation, ils peuvent être comparés à l’aide d’une comparaison ordinale.  
  
 Pour normaliser et comparer deux chaînes, procédez comme suit :  
  
1.  Obtenir les chaînes à comparer à partir d’une source d’entrée, tel qu’un fichier ou un périphérique d’entrée utilisateur.  
  
2.  Appelez le <xref:System.String.Normalize> méthode pour normaliser les chaînes à un formulaire de normalisation C.  
  
3.  Pour comparer deux chaînes, appeler une méthode qui prend en charge la comparaison de chaînes ordinale, comme le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode) et fournir une valeur <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> comme le <xref:System.StringComparison> argument. Pour trier un tableau de chaînes normalisées, passez un `comparer` valeur <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> à la surcharge appropriée de <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Émettez les chaînes dans la sortie triée selon l’ordre indiqué par l’étape précédente.  
  
 Pour obtenir une description des formulaires de normalisation Unicode prises en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant normalise une chaîne à chacun des quatre formulaires de normalisation, confirme que la chaîne a été normalisée dans le formulaire de normalisation spécifié, puis répertorie les points de code dans la chaîne normalisée.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère dans une chaîne non normalisée. Par conséquent, si une chaîne contient des caractères non normalisée suivies de caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode lèvera une <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Formulaire de normalisation Unicode.</param>
        <summary>Retourne une nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans le formulaire de normalisation Unicode spécifié.</summary>
        <returns>Nouvelle chaîne dont la valeur textuelle est identique à celle de cette chaîne, mais dont la représentation binaire se trouve dans le formulaire de normalisation spécifié par le paramètre <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Certains caractères Unicode ont plusieurs représentations binaires équivalentes des combinaisons d’et/ou des caractères Unicode composites. L’existence de plusieurs représentations pour un seul caractère complique la recherche, le tri, la correspondance et les autres opérations.  
  
 La norme Unicode définit un processus appelé normalisation qui retourne une représentation binaire de la représentation binaire équivalente d’un caractère donné. La normalisation peut être effectuée avec plusieurs algorithmes, appelés formulaires de normalisation, qui sont régis par des règles différentes. .NET prend en charge quatre formulaires de normalisation (C, D, KC et KD) qui sont définies par la norme Unicode. Lorsque deux chaînes sont représentées dans le même formulaire de normalisation, ils peuvent être comparés à l’aide d’une comparaison ordinale.  
  
 Pour normaliser et comparer deux chaînes, procédez comme suit :  
  
1.  Obtenir les chaînes à comparer à partir d’une source d’entrée, tel qu’un fichier ou un périphérique d’entrée utilisateur.  
  
2.  Appelez le <xref:System.String.Normalize%28System.Text.NormalizationForm%29> méthode pour normaliser les chaînes à un formulaire de normalisation spécifié.  
  
3.  Pour comparer deux chaînes, appeler une méthode qui prend en charge la comparaison de chaînes ordinale, comme le <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> (méthode) et fournir une valeur <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> comme le <xref:System.StringComparison> argument. Pour trier un tableau de chaînes normalisées, passez un `comparer` valeur <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> à la surcharge appropriée de <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Émettez les chaînes dans la sortie triée selon l’ordre indiqué par l’étape précédente.  
  
 Pour obtenir une description des formulaires de normalisation Unicode prises en charge, consultez <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant normalise une chaîne à chacun des quatre formulaires de normalisation, confirme que la chaîne a été normalisée dans le formulaire de normalisation spécifié, puis répertorie les points de code dans la chaîne normalisée.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’instance actuelle contient des caractères Unicode non valides.</exception>
        <block subset="none" type="usage">
          <para>Le <see cref="Overload:System.String.IsNormalized" /> méthode retourne <see langword="false" /> dès qu’il rencontre le premier caractère dans une chaîne non normalisée. Par conséquent, si une chaîne contient des caractères non normalisée suivies de caractères Unicode non valides, le <see cref="Overload:System.String.Normalize" /> méthode peut lever une <see cref="T:System.ArgumentException" /> bien que <see cref="Overload:System.String.IsNormalized" /> retourne <see langword="false" />.</para>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux chaînes spécifiées ont la même valeur.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est égale à la valeur de <paramref name="b" /> ; sinon <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.op_Equality%2A> méthode définit l’opération de l’opérateur d’égalité pour la <xref:System.String> classe. Il permet de code tel que celui indiqué dans la section exemple. L’opérateur, appelle à son tour, la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%29> (méthode), qui effectue une comparaison ordinale (respectant la casse et indépendantes de la culture).  
  
> [!NOTE]
>  Le compilateur Visual Basic ne résout pas l’opérateur d’égalité comme un appel à la <xref:System.String.op_Equality%2A> (méthode). Au lieu de cela, l’opérateur d’égalité encapsule un appel à la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’opérateur d’égalité.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">Première chaîne à comparer ou <see langword="null" />.</param>
        <param name="b">Seconde chaîne à comparer ou <see langword="null" />.</param>
        <summary>Détermine si deux chaînes spécifiées ont des valeurs différentes.</summary>
        <returns>
          <see langword="true" /> si la valeur de <paramref name="a" /> est différente de la valeur de <paramref name="b" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.op_Inequality%2A> méthode définit l’opération de l’opérateur d’inégalité pour la <xref:System.String> classe.   Il permet de code tel que celui indiqué dans la section Exemples.  
  
 Le <xref:System.String.op_Inequality%2A> opérateur à son tour appelle la méthode statique <xref:System.String.Equals%28System.String%2CSystem.String%29> (méthode), qui effectue une comparaison ordinale (respectant la casse et indépendantes de la culture).  
  
> [!NOTE]
>  Le compilateur Visual Basic ne résout pas l’opérateur d’inégalité comme un appel à la <xref:System.String.op_Inequality%2A> (méthode). Au lieu de cela, l’opérateur d’inégalité encapsule un appel à la <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant illustre l’opérateur d’inégalité.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne d'une longueur spécifiée dans laquelle le début de la chaîne actuelle est complété par des espaces ou un caractère Unicode spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette instance à droite en les complétant par des espaces à gauche pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à droite et complétée à gauche par autant de caractères que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace Unicode est défini comme hexadécimale 0 x 0020.  
  
 Le <xref:System.String.PadLeft%28System.Int32%29> méthode remplit le début de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie droite de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadLeft%2A> méthode remplit l’instance actuelle avec les espaces blancs, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec des espaces blancs afin que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.PadLeft%2A> (méthode).  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <param name="paddingChar">Caractère Unicode de remplissage.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette instance à droite en les complétant par un caractère Unicode spécifié à gauche pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à droite et complétée à gauche par autant de caractères <paramref name="paddingChar" /> que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> méthode remplit le début de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie droite de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadLeft%2A> méthode remplit l’instance actuelle avec les espaces blancs, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec le leader `paddingChar` caractères de sorte que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.PadLeft%2A> (méthode).  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne d'une longueur spécifiée dans laquelle la fin de la chaîne actuelle est complétée par des espaces ou un caractère Unicode spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette chaîne à gauche en les complétant par des espaces à droite pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à gauche et complétée à droite par autant de caractères que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un espace Unicode est défini comme hexadécimale 0 x 0020.  
  
 Le <xref:System.String.PadRight%28System.Int32%29> méthode remplit la fin de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie gauche de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadRight%2A> méthode remplit l’instance actuelle avec les espaces blancs, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui est remplie avec l’espace blanc de fin afin que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.PadRight%2A> (méthode).  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">Nombre de caractères dans la chaîne qui en résulte, égal au nombre de caractères d'origine plus tout caractère de remplissage supplémentaire.</param>
        <param name="paddingChar">Caractère Unicode de remplissage.</param>
        <summary>Retourne une nouvelle chaîne qui aligne les caractères de cette chaîne à gauche en les complétant par un caractère Unicode spécifié à droite pour une longueur totale spécifiée.</summary>
        <returns>Nouvelle chaîne équivalant à cette instance, mais alignée à gauche et complétée à droite par autant de caractères <paramref name="paddingChar" /> que nécessaire pour créer une longueur de <paramref name="totalWidth" />. Toutefois, si <paramref name="totalWidth" /> est inférieure à la longueur de cette instance, la méthode retourne une référence à l'instance existante. Si <paramref name="totalWidth" /> est égale à la longueur de cette instance, la méthode retourne une nouvelle chaîne qui est identique à cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> méthode remplit la fin de la chaîne retournée. Cela signifie que, lorsqu’il est utilisé avec les langues de droite à gauche, il remplit la partie gauche de la chaîne.  
  
> [!NOTE]
>  Si le <xref:System.String.PadRight%2A> méthode remplit l’instance actuelle avec les espaces blancs, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne remplie à l’aide de fin `paddingChar` caractères de sorte que sa longueur totale `totalWidth` caractères.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.PadRight%2A> (méthode).  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> est inférieur à zéro.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle un nombre spécifié de caractères de la chaîne actuelle est supprimé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de base zéro où commence la suppression des caractères.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle tous les caractères de l'instance actuelle ont été supprimés à partir d'une position spécifiée et jusqu'à la dernière position.</summary>
        <returns>Nouvelle chaîne équivalente à cette chaîne, à l'exception des caractères supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], les chaînes sont de base zéro. La valeur de la `startIndex` paramètre peut aller de zéro à un de moins que la longueur de l’instance de chaîne.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle tous les caractères à partir de la position `startIndex` à la fin de la chaîne d’origine ont été supprimés.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.Remove%2A> (méthode). Le cas suivant la dernière supprime tout le texte à partir de l’index spécifié jusqu'à la fin de la chaîne. Le dernier cas supprime trois caractères à partir de l’index spécifié.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> spécifie une position qui n’est pas dans cette chaîne.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de base zéro où commence la suppression des caractères.</param>
        <param name="count">Nombre de caractères à supprimer.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle un nombre spécifié de caractères a été supprimé dans l'instance actuelle à partir d'une position spécifiée.</summary>
        <returns>Nouvelle chaîne équivalente à cette instance, à l'exception des caractères supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], les chaînes sont de base zéro. La valeur de la `startIndex` paramètre peut aller de zéro à un de moins que la longueur de l’instance de chaîne.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle le nombre de caractères spécifiés par le `count` paramètre ont été supprimés. Les caractères sont supprimés à la position spécifiée par `startIndex`.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez supprimer le deuxième prénom d’un nom complet.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="count" /> spécifient une position située en dehors de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'un caractère Unicode spécifié ou de <see cref="T:System.String" /> dans la chaîne actuelle sont remplacées par un autre caractère Unicode spécifié ou <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">Caractère Unicode à remplacer.</param>
        <param name="newChar">Caractère Unicode permettant de remplacer toutes les occurrences de <paramref name="oldChar" />.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'un caractère Unicode spécifié dans cette instance sont remplacées par un autre caractère Unicode spécifié.</summary>
        <returns>Chaîne équivalente à cette instance, sauf que toutes les instances de <paramref name="oldChar" /> sont remplacées par <paramref name="newChar" />. Si <paramref name="oldChar" /> est introuvable dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode effectue une recherche ordinale de (respect de la casse et indépendantes de la culture) pour rechercher `oldChar`.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle toutes les occurrences de `oldChar` sont remplacés par `newChar`.  
  
 Étant donné que cette méthode retourne la chaîne modifiée, vous pouvez chaîner des appels successifs à la <xref:System.String.Replace%2A> méthode pour effectuer des remplacements multiples sur la chaîne d’origine. Appels de méthode sont exécutées de gauche à droite. L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant crée une liste de valeurs séparées par des virgules en remplaçant par des virgules pour les champs vides entre une série de nombres.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">Chaîne à remplacer.</param>
        <param name="newValue">Chaîne permettant de remplacer toutes les occurrences de <paramref name="oldValue" />.</param>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences d'une chaîne spécifiée dans l'instance actuelle sont remplacées par une autre chaîne spécifiée.</summary>
        <returns>Chaîne équivalente à la chaîne actuelle, sauf que toutes les instances de <paramref name="oldValue" /> sont remplacées par <paramref name="newValue" />. Si <paramref name="oldValue" /> est introuvable dans l'instance actuelle, la méthode retourne l'instance actuelle sans modification.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `newValue` est `null`, toutes les occurrences de `oldValue` sont supprimés.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle toutes les occurrences de `oldValue` sont remplacés par `newValue`.  
  
 Cette méthode effectue une recherche ordinale de (respect de la casse et indépendantes de la culture) pour rechercher `oldValue`.  
  
 Étant donné que cette méthode retourne la chaîne modifiée, vous pouvez chaîner des appels successifs à la <xref:System.String.Replace%2A> méthode pour effectuer des remplacements multiples sur la chaîne d’origine. Appels de méthode sont exécutées de gauche à droite. L'exemple suivant illustre cette situation.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser la <xref:System.String.Replace%2A> méthode pour corriger une faute d’orthographe.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> est la chaîne vide ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne un tableau de chaînes qui contient les sous-chaînes de cette instance, séparées par les éléments d'une chaîne ou d'un tableau de caractères Unicode spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> est utilisé pour diviser une chaîne délimitée en sous-chaînes. Vous pouvez utiliser soit un tableau de caractères pour spécifier zéro, un ou plusieurs caractères de délimitation (le <xref:System.String.Split%28System.Char%5B%5D%29> méthode), ou vous pouvez utiliser un tableau de caractères pour spécifier zéro, une ou plusieurs chaînes de délimitation. Des surcharges de la <xref:System.String.Split%2A> méthode permettent de limiter le nombre de sous-chaînes retourné par la méthode (la <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> méthode), afin de déterminer si les chaînes vides sont incluses dans les sous-chaînes retournées (le <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> et <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> méthodes, ou faire les deux (le <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> et <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> méthodes).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternatives à String.Split

 Le <xref:System.String.Split%2A> méthode n’est pas toujours la meilleure façon de diviser une chaîne délimitée en sous-chaînes. Si vous ne souhaitez pas extraire toutes les sous-chaînes d’une chaîne délimitée, ou si vous souhaitez analyser une chaîne basée sur un modèle au lieu d’un jeu de caractères de délimiteur, envisagez les options suivantes.  
  
### <a name="regular-expressions"></a>Expressions régulières  
 Si vos chaînes de se conformer à un modèle fixe, vous pouvez utiliser une expression régulière pour extraire et gérer leurs éléments. Par exemple, si les chaînes prennent la forme «*nombre* *opérande* *nombre*» que vous pouvez utiliser un [expression régulière](~/docs/standard/base-types/regular-expressions.md) pour extraire et gérer le éléments de la chaîne. Voici un exemple :  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 Le modèle d’expression régulière `(\d+)\s+([-+*/])\s+(\d+)` est défini comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du premier groupe de capture.|  
|`\s+`|Correspond à un ou plusieurs caractères d’espace blanc.|  
|`([-+*/])`|Correspond à une connexion de l’opérateur arithmétique (+, -, *, ou /). Il s'agit du deuxième groupe de capture.|  
|`\s+`|Correspond à un ou plusieurs caractères d’espace blanc.|  
|`(\d+)`|Mettre en correspondance un ou plusieurs chiffres décimaux. Il s'agit du troisième groupe de capture.|  
  
 Vous pouvez également utiliser une expression régulière pour extraire des sous-chaînes d’une chaîne basée sur un modèle plutôt qu’un ensemble fixe de caractères. Il s’agit d’un scénario courant lorsqu’un de ces conditions se produise :  
  
-   Un ou plusieurs caractères délimiteur ne pas toujours servent d’un délimiteur dans le <xref:System.String> instance.  
  
-   La séquence et le nombre de caractères de délimitation est variable ou inconnu.  
  
 Par exemple, le <xref:System.String.Split%2A> méthode ne peut pas être utilisée pour fractionner la chaîne suivante, car le nombre de `\n` (en c#) ou `vbCrLf` (en Visual Basic) de caractères est variable, et ils ne traitent pas de toujours comme délimiteurs.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Une expression régulière peut fractionner cette chaîne facilement, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 Le modèle d’expression régulière `\[([^\[\]]+)\]` est défini comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\[`|Mettre en correspondance un crochet ouvrant.|  
|`([^\[\]]+)`|Correspond à n’importe quel caractère qui n’est pas une ouverture ou un crochet fermant une ou plusieurs fois. Il s'agit du premier groupe de capture.|  
|`\]`|Mettre en correspondance un crochet fermant.|  
  
 Le <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode est presque identique à <xref:System.String.Split%2A?displayProperty=nameWithType>, à ceci près qu’il fractionne une chaîne basée sur un modèle d’expression régulière au lieu d’un jeu de caractères fixe. Par exemple, l’exemple suivant utilise la <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> méthode pour fractionner une chaîne qui contient les sous-chaînes délimitées par différentes combinaisons de traits d’union et d’autres caractères.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 Le modèle d’expression régulière `\s-\s?[+*]?\s?-\s` est défini comme suit :  
  
|Motif|Description |  
|-------------|-----------------|  
|`\s-`|Mettre en correspondance un espace blanc suivi par un trait d’union.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`[+*]?`|Mettre en correspondance zéro ou une occurrence d’un le + ou * caractère.|  
|`\s?`|Mettre en correspondance zéro ou un espace blanc.|  
|`-\s`|Mettre en correspondance un trait d’union suivi d’un caractère d’espace blanc.|  
  
### <a name="search-methods-and-the-substring-method"></a>Méthodes de recherche et de la méthode Substring  
 Si vous n’êtes pas intéressé par toutes les sous-chaînes dans une chaîne, vous préférerez peut-être utiliser une des méthodes de comparaison de chaînes qui retourne l’index à partir duquel commence la correspondance. Vous pouvez ensuite appeler la <xref:System.String.Substring%2A> méthode pour extraire la sous-chaîne que vous souhaitez. Les méthodes de comparaison de chaînes sont les suivantes :  
  
-   <xref:System.String.IndexOf%2A>, qui retourne l’index de base zéro de la première occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.IndexOfAny%2A>, qui retourne l’index de base zéro dans l’instance actuelle de la chaîne de la première occurrence de n’importe quel caractère dans un tableau de caractères.  
  
-   <xref:System.String.LastIndexOf%2A>, qui retourne l’index de base zéro de la dernière occurrence d’un caractère ou une chaîne dans une instance de chaîne.  
  
-   <xref:System.String.LastIndexOfAny%2A>, qui retourne un index de base zéro dans l’instance actuelle de la chaîne de la dernière occurrence de n’importe quel caractère dans un tableau de caractères.  
  
 L’exemple suivant utilise la <xref:System.String.IndexOf%2A> méthode pour rechercher les périodes dans une chaîne. Il utilise ensuite la <xref:System.String.Substring%2A> méthode pour retourner des phrases complètes.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <summary>Divise une chaîne en sous-chaînes en fonction des caractères contenus dans un tableau.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette instance qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une chaîne est délimitée par un ensemble connu de caractères, vous pouvez utiliser la <xref:System.String.Split%28System.Char%5B%5D%29> méthode pour le séparer en sous-chaînes.   
  
### <a name="return-value-details"></a>Détails de la valeur de retour  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le tableau de séparateur inclut le caractère «- » et la valeur de l’instance actuelle de la chaîne est « aa-bb-cc », la méthode retourne un tableau qui contient trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si deux délimiteurs sont adjacents, ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément correspondant dans le tableau retourné contient <xref:System.String.Empty>. Voici quelques exemples :  
  
|Valeur de chaîne|Séparateur|Tableau retourné|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|nouveau Char [] {',', ' '} (C#)<br /><br /> Char() = {«, » c, « « c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|« Banana »|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|{« Banana »}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouveau Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|null (C#)<br /><br /> Nothing (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>Le tableau de séparateur  
 Chaque élément de séparateur définit un délimiteur distinct qui se compose d’un seul caractère. Si le `separator` argument est `null` ou ne contient aucun caractère, la méthode traite des espaces comme séparateurs. Espaces blancs sont définies par Unicode standard ; elles retournent `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Résolution de surcharge String.Split(Char[]) et du compilateur  
 Bien que le paramètre unique pour cette surcharge de <xref:System.String.Split%2A?displayProperty=nameWithType> est un tableau de caractères, vous pouvez l’appeler avec un seul caractère, comme le montre l’exemple suivant.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Étant donné que le `separator` paramètre est décoré avec le <xref:System.ParamArrayAttribute> attribut, compilateurs interprète un seul caractère comme un tableau de caractères de l’élément. Cela n’est pas le cas pour d’autres <xref:System.String.Split%2A?displayProperty=nameWithType> surcharges qui incluent un `separator` paramètre ; vous devez passer explicitement ces surcharges un tableau de caractères en tant que le `separator` argument.  
  
### <a name="comparison-details"></a>Détails de la comparaison  
 Le <xref:System.String.Split%28System.Char%5B%5D%29> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des caractères dans le `separator` de tableau et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%28System.Char%5B%5D%29> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide de règles de tri ordinal respectant la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez le <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode). Vous avez également la possibilité d’utiliser le <xref:System.String.Compare%2A> méthode pour trouver une sous-chaîne dans une chaîne.  
  
 Pour fractionner une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Pour fractionner une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
## Examples  
 L’exemple suivant montre comment extraire des mots individuels à partir d’un bloc de texte en traitant les espaces blancs et signes de ponctuation comme délimiteurs. Le tableau de caractères est passé à la `separator` paramètre de la <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> méthode se compose d’un espace et un caractère de tabulation, ainsi que des symboles de ponctuation courants.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des caractères contenus dans un tableau. Vous pouvez aussi spécifier le nombre maximal de sous-chaînes à retourner.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette instance qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance. Si `count` est égal à zéro, un tableau vide est retourné.  
  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espace blanc sont supposés pour être les délimiteurs. Espaces blancs sont définis par la norme Unicode et retournée `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si deux délimiteurs sont adjacents, ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il existe plus de `count` sous-chaînes de cette instance, le premier `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les caractères restants dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
 Le tableau suivant fournit des exemples.  
  
|Valeur de chaîne|Séparateur|Nombre|Tableau retourné|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|nouveau Char [] {',', ' '} (C#)<br /><br /> Char() = {«, » c, « « c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|« Banana »|nouveau Char [] {'. '} (C#)<br /><br /> Char() = {«. » c} (Visual Basic)|2|{« Banana »}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|nouveau Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{« Darb\nSmarba »} (C#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|new [] Char null (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|« Darb\nSmarba » (c#)<br /><br /> « Darb » & vbLf & « Smarba » (Visual Basic)|new [] Char null (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment `count` affecte le nombre de chaînes retournées par <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en sous-chaînes en fonction des caractères contenus dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Détails de la valeur de retour  
 Caractères de délimitation (les caractères dans le `separator` tableau) ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le `separator` tableau inclut le caractère «- » et la valeur de l’instance actuelle de la chaîne est « aa-bb-cc », la méthode retourne un tableau qui contient trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient aucun des caractères de `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Si le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, la méthode retourne un tableau vide.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un seul caractère. Si le `options` argument est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, si `separator` inclut deux éléments, «- » et «\_», est la valeur de l’instance de chaîne »-\_aa -\_» et la valeur de la `options` argument est <xref:System.StringSplitOptions.None>, la méthode retourne un tableau de chaînes avec les cinq éléments suivants :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui précède le «- » caractère à l’index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide entre les «- » caractère à l’index 0 et le caractère « _ » à l’index 1.  
  
3.  « aa »,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le caractère « _ » à l’index 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le «- » caractère à l’index 5.  
  
### <a name="the-separator-array"></a>Le tableau de séparateur  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espace blanc sont supposés pour être les délimiteurs. Espaces blancs sont définis par la norme Unicode et retournée `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Détails de la comparaison  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des caractères dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide de règles de tri ordinal respectant la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez le <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de chaînes qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteur ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en sous-chaînes en fonction des chaînes contenues dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs chaînes dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsqu’une chaîne est délimitée par un ensemble connu de chaînes, vous pouvez utiliser la <xref:System.String.Split%2A> méthode pour le séparer en sous-chaînes.  
  
### <a name="return-value-details"></a>Détails de la valeur de retour  
 Les chaînes de délimiteur ne sont pas inclus dans les éléments du tableau retourné. Par exemple, si le `separator` tableau comprend la chaîne «-- » et la valeur de l’instance actuelle de la chaîne est « aa, bb-cc », la méthode retourne un tableau qui contient trois éléments : « aa », « bb » et « cc ».  
  
 Si cette instance ne contient pas une des chaînes dans `separator`, le tableau retourné se compose d’un élément unique qui contient cette instance.  
  
 Si le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, la méthode retourne un tableau vide.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un ou plusieurs caractères. Si le `options` argument est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty?displayProperty=nameWithType>. Par exemple, si `separator` inclut deux éléments, «- » et « _ », la valeur de l’instance de la chaîne est « - _aa -\_» et la valeur de la `options` argument est <xref:System.StringSplitOptions.None>, la méthode retourne une table de chaînes avec les cinq éléments suivants :  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui précède le «- » sous-chaîne à l’index 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide entre les «- » sous-chaîne à l’index 0 et la sous-chaîne « _ » à l’index 1.  
  
3.  « aa »,  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit la sous-chaîne « _ » à l’index 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, qui représente la chaîne vide qui suit le «- » sous-chaîne à index 5.  
  
### <a name="the-separator-array"></a>Le tableau de séparateur  
 Si un des éléments dans `separator` se compose de plusieurs caractères, l’intégralité de la sous-chaîne est considéré comme un délimiteur. Par exemple, si un des éléments dans `separator` est « 10 », tente de fractionner la chaîne « This10is10a10string ». Retourne le tableau de quatre éléments suivant : {« This », « est », « a », « string ». }.  
  
 Si le `separator` paramètre est `null` ou ne contient aucun caractère, espace blanc sont supposés pour être les délimiteurs. Espaces blancs sont définis par la norme Unicode et retournée `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
 Si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Détails de la comparaison  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des chaînes dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide de règles de tri ordinal respectant la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez le <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
 Le <xref:System.String.Split%2A> méthode ignore tout élément de `separator` dont la valeur est `null` ou une chaîne vide ( » »).  
  
 Pour éviter des résultats ambigus lorsque des chaînes dans `separator` ont en commun, les caractères le <xref:System.String.Split%2A> opération passe à partir du début à la fin de la valeur de l’instance et recherche le premier élément de `separator` qui est égal à un délimiteur dans le instance. L’ordre dans lequel les sous-chaînes sont produisent dans l’instance est prioritaire sur l’ordre des éléments dans `separator`.  
  
 Par exemple, considérez une instance dont la valeur est « abcdef ». Si le premier élément dans `separator` était « ef » et le deuxième élément était « bcde », le résultat de l’opération de fractionnement serait un tableau de chaînes qui contient deux éléments, « a » et « f ». Il s’agit, car la sous-chaîne dans l’instance, « bcde », est rencontrée et correspond à un élément dans `separator` avant de la sous-chaîne « f ».  
  
 Toutefois, si le premier élément du `separator` était « bcd » et le deuxième élément était « bc », le résultat de l’opération de fractionnement serait un tableau de chaînes qui contient deux éléments, « a » et « ef ». Il s’agit, car « bcd » est le premier délimiteur de `separator` qui correspond à un délimiteur de l’instance. Si l’ordre des séparateurs d’a été inversé de sorte que le premier élément a été « bc » et le deuxième élément était « bcd », le résultat serait un tableau de chaînes qui contient deux éléments, « a » et « def ».  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant illustre la différence dans les tableaux retournés par l’appel d’une chaîne <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> méthode avec ses `options` paramètre égal à <xref:System.StringSplitOptions.None?displayProperty=nameWithType> et <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 L’exemple suivant définit un tableau de séparateurs qui incluent des caractères de ponctuation et espaces blancs. En passant ce tableau ainsi qu’une valeur de <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> à la <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> méthode retourne un tableau qui se compose des mots individuels à partir de la chaîne.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Notez que la méthode est appelée avec le `options` affectée à l’argument <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Cela empêche le tableau retourné à partir, y compris <xref:System.String.Empty?displayProperty=nameWithType> valeurs qui représentent les correspondances de sous-chaîne vide entre les signes de ponctuation et espaces blancs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de caractères qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteurs ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des caractères contenus dans un tableau.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par un ou plusieurs caractères dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caractères de séparation ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient aucun des caractères de `separator`, ou le `count` paramètre est 1, le tableau retourné se compose d’un élément unique qui contient cette instance. Si le `separator` paramètre est `null` ou ne contient aucun caractère, espace blanc sont supposés pour être les délimiteurs. Espaces blancs sont définis par la norme Unicode et retournée `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode). Toutefois, si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la valeur null. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Si le `count` paramètre est égal à zéro, ou le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, un tableau vide est retourné.  
  
 Chaque élément de `separator` définit un caractère délimiteur séparé. Si le `options` paramètre est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il existe plus de `count` sous-chaînes de cette instance, le premier `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les caractères restants dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Tableau de chaînes qui délimite les sous-chaînes de cette chaîne, tableau vide qui ne contient pas de délimiteur ou <see langword="null" />.</param>
        <param name="count">Nombre maximal de sous-chaînes à retourner.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> pour ignorer les éléments vides du tableau retourné ou <see cref="F:System.StringSplitOptions.None" /> pour les inclure.</param>
        <summary>Fractionne une chaîne en un nombre maximal de sous-chaînes en fonction des chaînes contenues dans un tableau. Vous pouvez préciser si les sous-chaînes incluent les éléments d'un tableau vide.</summary>
        <returns>Tableau dont les éléments contiennent les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs chaînes dans <paramref name="separator" />. Pour plus d'informations, consultez la section Remarques.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Détails de la valeur de retour  
 Les chaînes de délimiteur ne sont pas inclus dans les éléments du tableau retourné.  
  
 Si cette instance ne contient pas une des chaînes dans `separator`, ou le `count` paramètre est 1, le tableau retourné se compose d’un élément unique qui contient cette instance. Si le `separator` paramètre est `null` ou ne contient aucun caractère, espace blanc sont supposés pour être les délimiteurs. Espaces blancs sont définis par la norme Unicode et retournée `true` s’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode). Toutefois, si le `separator` paramètre dans l’appel à cette surcharge de méthode est `null`, la résolution de surcharge du compilateur échoue. Pour identifier sans ambiguïté la méthode appelée, votre code doit indiquer le type de la `null`. L’exemple suivant montre plusieurs façons d’identifier sans ambiguïté cette surcharge.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Si le `count` paramètre est égal à zéro, ou le `options` paramètre est <xref:System.StringSplitOptions.RemoveEmptyEntries> et la longueur de cette instance est égale à zéro, un tableau vide est retourné.  
  
 Chaque élément de `separator` définit un délimiteur séparé qui se compose d’un ou plusieurs caractères. Si le `options` paramètre est <xref:System.StringSplitOptions.None>et deux délimiteurs sont adjacents ou un délimiteur est trouvé au début ou à la fin de cette instance, l’élément de tableau correspondant contient <xref:System.String.Empty>.  
  
 S’il existe plus de `count` sous-chaînes de cette instance, le premier `count` sous-chaînes moins 1 sont retournées dans la première `count` éléments moins 1 de la valeur de retour et les caractères restants dans cette instance sont retournés dans le dernier élément de la valeur de retour.  
  
 Si `count` est supérieur au nombre de sous-chaînes, les sous-chaînes disponibles sont retournées et aucune exception n’est levée.  
  
### <a name="the-separator-array"></a>Le tableau de séparateur  
 Si un des éléments dans `separator` se compose de plusieurs caractères, l’intégralité de la sous-chaîne est considéré comme un délimiteur. Par exemple, si un des éléments dans `separator` est « 10 », tente de fractionner la chaîne « This10is10a10string ». retourne ce tableau de quatre éléments : {« This », « est », « a », « string ». }.  
  
### <a name="comparison-details"></a>Détails de la comparaison  
 Le <xref:System.String.Split%2A> méthode extrait les sous-chaînes de cette chaîne qui sont délimitées par une ou plusieurs des chaînes dans le `separator` paramètre et retourne ces sous-chaînes comme éléments d’un tableau.  
  
 Le <xref:System.String.Split%2A> méthode recherche les délimiteurs en effectuant des comparaisons à l’aide de règles de tri ordinal respectant la casse. Pour plus d’informations sur word, de chaîne et de tri ordinal, consultez le <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> énumération.  
  
 Le <xref:System.String.Split%2A> méthode ignore tout élément de `separator` dont la valeur est `null` ou une chaîne vide ( » »).  
  
 Pour éviter des résultats ambigus lorsque des chaînes dans `separator` ont en commun, les caractères le <xref:System.String.Split%2A> méthode passe à partir du début à la fin de la valeur de l’instance et recherche le premier élément de `separator` qui est égal à un délimiteur dans le instance. L’ordre dans lequel les sous-chaînes sont produisent dans l’instance est prioritaire sur l’ordre des éléments dans `separator`.  
  
 Par exemple, considérez une instance dont la valeur est « abcdef ». Si le premier élément dans `separator` était « ef » et le deuxième élément était « bcde », le résultat de l’opération de fractionnement serait « a » et « f ». Il s’agit, car la sous-chaîne dans l’instance, « bcde », est rencontrée et correspond à un élément dans `separator` avant de la sous-chaîne « f ».  
  
 Toutefois, si le premier élément du `separator` était « bcd » et le deuxième élément était « bc », le résultat de l’opération de fractionnement serait « a » et « ef ». Il s’agit, car « bcd » est le premier délimiteur de `separator` qui correspond à un délimiteur de l’instance. Si l’ordre des séparateurs d’a été inversé de sorte que le premier élément a été « bc » et le deuxième élément était « bcd », le résultat serait « a » et « def ».  
  
### <a name="performance-considerations"></a>Considérations sur les performances  
 Le <xref:System.String.Split%2A> méthodes d’allouent de mémoire pour l’objet tableau retourné et un <xref:System.String> objet pour chaque élément du tableau. Si votre application requiert des performances optimales, ou si la gestion de l’allocation de mémoire est critique dans votre application, envisagez d’utiliser le <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> (méthode) et éventuellement le <xref:System.String.Compare%2A> (méthode), pour trouver une sous-chaîne dans une chaîne.  
  
 Si vous fractionnez une chaîne à un caractère de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode à rechercher un caractère de séparation dans la chaîne. Si vous fractionnez une chaîne à une chaîne de séparation, utilisez la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> méthode pour rechercher le premier caractère de la chaîne de séparateur. Utilisez ensuite le <xref:System.String.Compare%2A> méthode pour déterminer si les caractères après le premier caractère sont identiques aux caractères restants de la chaîne de séparateur.  
  
 En outre, si le même jeu de caractères est utilisé pour fractionner des chaînes dans plusieurs <xref:System.String.Split%2A> des appels de méthode, envisagez la création d’un tableau unique et son référencement dans chaque appel de méthode. Cela réduit considérablement la surcharge supplémentaire de chaque appel de méthode.  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.StringSplitOptions> énumération à inclure ou exclure des sous-chaînes générées par le <xref:System.String.Split%2A> (méthode).  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> est un nombre négatif.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> ne fait pas partie des valeurs <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>Dans le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] et versions antérieures, si le <see cref="M:System.String.Split(System.Char[])" /> est transmis à la méthode un <paramref name="separator" /> qui est <see langword="null" /> ou ne contient aucun caractère, la méthode utilise un jeu de caractères légèrement différent pour fractionner la chaîne que le <see cref="M:System.String.Trim(System.Char[])" /> méthode fait pour découper la chaîne. À compter de .NET Framework 4, les deux méthodes utilisent un ensemble identique de caractères d’espaces blancs Unicode.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si le début de cette instance de chaîne correspond à une chaîne spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée.</summary>
        <returns>
          <see langword="true" /> si <paramref name="value" /> correspond au début de cette instance ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare `value` à la sous-chaîne au début de cette instance est la même longueur que `value`et retourne une indication précisant si elles sont égales. Pour être égale, `value` doit être une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>), doit être une référence à cette même instance, ou correspondre au début de cette instance.  
  
 Cette méthode effectue une comparaison de mots (respectant la casse et dépendante de la culture) à l’aide de la culture actuelle.  
  
   
  
## Examples  
 L’exemple suivant définit un `StripStartTags` méthode qui utilise le <xref:System.String.StartsWith%28System.String%29> balises de début de la méthode pour supprimer HTML depuis le début d’une chaîne. Notez que le `StripStartTags` méthode est appelée de manière récursive pour vous assurer que plusieurs balises de début HTML au début de la ligne sont supprimés. L’exemple ne supprime pas les balises HTML incorporés dans une chaîne.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de comparaison de chaînes qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour déterminer si une chaîne commence par une sous-chaîne particulière en utilisant les règles de comparaison de chaîne de la culture actuelle, appelez le <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> surcharge de méthode avec une valeur de <see cref="F:System.StringComparison.CurrentCulture" /> pour son <paramref name="comparisonType" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <param name="comparisonType">Une des valeurs d'énumération qui détermine le mode de comparaison entre cette chaîne et <paramref name="value" />.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de l'option spécifiée.</summary>
        <returns>
          <see langword="true" /> si cette instance commence par <paramref name="value" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.StartsWith%2A> méthode compare le `value` paramètre à la sous-chaîne au début de cette chaîne et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une référence à cette même chaîne, doit être une chaîne vide (« »), ou correspondre au début de cette chaîne. Le type de comparaison effectuée par le <xref:System.String.StartsWith%2A> méthode varie selon la valeur de la `comparisonType` paramètre. La comparaison peut utiliser les conventions de la culture actuelle (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> et <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) ou la culture dite indifférente (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> et <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), ou il peut être constitué d’une comparaison caractère par caractère de points de code (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). La comparaison peut également être respect de la casse (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, ou <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), ou il peut ignorer la casse (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 L’exemple suivant recherche la chaîne « the » au début d’une chaîne plus longue qui commence par le mot « The ». Comme la sortie de l’exemple, un appel à la <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> méthode qui effectue une comparaison indépendante de la culture, mais la casse ne correspond pas à la chaîne, pendant un appel qui effectue une comparaison de culture et de scénarios insensitive correspond à la chaîne.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 L’exemple suivant détermine si une chaîne commence par une sous-chaîne particulière. Il initialise un tableau de chaînes à deux dimensions. Le premier élément dans la deuxième dimension contient une chaîne, et le deuxième élément contient la chaîne à rechercher au début de la première chaîne. Les résultats sont affectés par le choix de la culture, si la casse est ignorée, et si une comparaison ordinale est effectuée. Notez que lorsque l’instance de chaîne contient une ligature, les comparaisons dépendantes de la culture avec ses caractères consécutifs mettre en correspondance.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> n’est pas une valeur <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">Chaîne à comparer.</param>
        <param name="ignoreCase">
          <see langword="true" /> pour ignorer la casse pendant la comparaison, sinon, <see langword="false" />.</param>
        <param name="culture">Informations culturelles déterminant le mode de comparaison entre cette chaîne et <paramref name="value" />. Si <paramref name="culture" /> est <see langword="null" />, la culture actuelle est utilisée.</param>
        <summary>Détermine si le début de cette instance de chaîne correspond à la chaîne spécifiée quand elle est comparée à l'aide de la culture spécifiée.</summary>
        <returns>
          <see langword="true" /> si le paramètre <paramref name="value" /> correspond au début de cette chaîne ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode compare le `value` paramètre à la sous-chaîne au début de cette chaîne est la même longueur que `value`et retourne une valeur qui indique s’ils sont égaux. Pour être égale, `value` doit être une chaîne vide (<xref:System.String.Empty?displayProperty=nameWithType>), doit être une référence à cette même instance, ou correspondre au début de cette instance.  
  
 Cette méthode effectue une comparaison à l’aide de la casse spécifiée et la culture.  
  
   
  
## Examples  
 L’exemple suivant détermine si une chaîne se produit au début d’une autre chaîne. Le <xref:System.String.StartsWith%2A> méthode est appelée plusieurs fois à l’aide de la casse, casse et différentes cultures qui influencent les résultats de la recherche.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère une sous-chaîne de cette instance.  
  
Ce membre est surchargé. Pour obtenir des informations complètes sur ce membre, notamment sa syntaxe, son utilisation et des exemples s’y rapportant, cliquez sur un nom dans la liste de surcharge.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de caractère de départ de base zéro d'une sous-chaîne dans cette instance.</param>
        <summary>Récupère une sous-chaîne de cette instance. La sous-chaîne commence à une position de caractère spécifiée et continue jusqu'à la fin de la chaîne.</summary>
        <returns>Chaîne équivalente à la sous-chaîne qui commence à <paramref name="startIndex" /> dans cette instance ou <see cref="F:System.String.Empty" /> si <paramref name="startIndex" /> est égal à la longueur de cette instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous appelez le <xref:System.String.Substring%28System.Int32%29> méthode pour extraire une sous-chaîne d’une chaîne qui commence à une position de caractère spécifié et se termine à la fin de la chaîne. La position de caractère de départ est de base zéro ; en d’autres termes, le premier caractère dans la chaîne est à l’index 0, pas l’index 1. Pour extraire une sous-chaîne qui commence à une position de caractère spécifié et se termine avant la fin de la chaîne, appelez le <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> (méthode).  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne qui commence à la `startIndex` position dans la chaîne actuelle.  
  
 Pour extraire une sous-chaîne qui commence par un caractère particulier ou d’une séquence de caractères, appeler une méthode telle que <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> pour obtenir la valeur de `startIndex`. Le deuxième exemple illustre cela ; Il extrait une valeur de clé qui commence à une position de caractère après le caractère « = ».  
  
 Si `startIndex` est égal à zéro, la méthode retourne la chaîne d’origine est inchangée.  
   
  
## Examples  
 L’exemple suivant montre comment obtenir une sous-chaîne à partir d’une chaîne.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 L’exemple suivant utilise le <xref:System.String.Substring%2A> (méthode) pour séparer les paires clé/valeur qui sont délimitées par une est égal à caractère (« = »).  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Le <xref:System.String.IndexOf%2A> méthode est utilisée pour obtenir la position du caractère égal dans la chaîne. L’appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode extrait le nom de clé, qui commence au premier caractère dans la chaîne et s’étend sur le nombre de caractères retournés par l’appel à la <xref:System.String.IndexOf%2A> (méthode). L’appel à la <xref:System.String.Substring%28System.Int32%29> méthode extrait ensuite la valeur assignée à la clé. Il démarre à une position de caractère au-delà du caractère equals et s’étend à la fin de la chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> est inférieur à zéro ou supérieur à la longueur de cette instance.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de caractère de départ de base zéro d'une sous-chaîne dans cette instance.</param>
        <param name="length">Nombre de caractères dans la sous-chaîne.</param>
        <summary>Récupère une sous-chaîne de cette instance. La sous-chaîne commence à une position de caractère spécifiée et sa longueur est définie.</summary>
        <returns>Chaîne équivalente à la sous-chaîne de longueur <paramref name="length" /> qui commence à <paramref name="startIndex" /> dans cette instance ou <see cref="F:System.String.Empty" /> si <paramref name="startIndex" /> est égal à la longueur de cette instance et <paramref name="length" /> a la valeur zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous appelez le <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode pour extraire une sous-chaîne d’une chaîne qui commence à une position de caractère spécifié et se termine avant la fin de la chaîne. La position de caractère de départ est de base zéro ; en d’autres termes, le premier caractère dans la chaîne est à l’index 0, pas l’index 1. Pour extraire une sous-chaîne qui commence à une position de caractère spécifiée et continue jusqu'à la fin de la chaîne, appelez le <xref:System.String.Substring%28System.Int32%29> (méthode).  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne avec `length` caractères à partir de la `startIndex` position dans la chaîne actuelle.  
  
 Le `length` paramètre représente le nombre total de caractères à extraire à partir de l’instance actuelle de la chaîne. Cela inclut le caractère de début située à l’index `startIndex`.  En d’autres termes, le <xref:System.String.Substring%2A> méthode tente d’extraire des caractères à partir de l’index `startIndex` à index `startIndex`  +  `length` - 1.  
  
 Pour extraire une sous-chaîne qui commence par un caractère particulier ou d’une séquence de caractères, appeler une méthode telle que <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> pour obtenir la valeur de `startIndex`.  
  
 Si la sous-chaîne s’étend de `startIndex` à une séquence de caractères spécifié, vous pouvez appeler une méthode comme <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> pour obtenir l’index de caractère de fin ou de la séquence de caractères.  Vous pouvez ensuite convertir en cette valeur à une position d’index dans la chaîne comme suit :  
  
-   Si vous avez effectué une recherche pour un caractère unique qui consiste à marquer la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  -  `startIndex` + 1, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode. L’exemple suivant extrait un bloc continu de caractères « b » d’une chaîne.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Si vous avez effectué une recherche pour plusieurs caractères qui sont pour marquer la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  +  `endMatchLength`  -  `startIndex`, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode., et `endMatchLength` est la longueur de la séquence de caractères qui marque la fin de la sous-chaîne. L’exemple suivant extrait un bloc de texte qui contient un document XML `<definition>` élément.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Si le caractère ou séquence de caractères n’est pas inclus dans la fin de la sous-chaîne, la `length` paramètre est égal à `endIndex`  -  `startIndex`, où `endIndex` est la valeur de retour de la <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> méthode.  
  
 Si `startIndex` est égal à zéro et est égale à la longueur de la chaîne actuelle, la méthode retourne la chaîne d’origine est inchangée.  
  
   
  
## Examples  
 L’exemple suivant illustre un simple appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode qui extrait les deux caractères d’une chaîne en commençant à la sixième position de caractère (autrement dit, à l’index cinq).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 L’exemple suivant utilise la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode dans les trois cas suivants pour isoler des sous-chaînes dans une chaîne. Dans les deux cas les sous-chaînes sont utilisées dans les comparaisons, et dans le troisième cas une exception est levée, car les paramètres non valides sont spécifiés.  
  
-   Il extrait le caractère unique et la troisième position dans la chaîne (à l’index 2) et la compare à un « c ». Cette comparaison retourne `true`.  
  
-   Il extrait zéro caractères en commençant à la quatrième position dans la chaîne (à l’index 3) et le transmet à la <xref:System.String.IsNullOrEmpty%2A> (méthode). Cette fonction retourne true, car l’appel à la <xref:System.String.Substring%2A> retourne de la méthode <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il tente d’extraire un seul caractère, en commençant à la quatrième position dans la chaîne. Étant donné qu’aucun caractère à cette position, l’appel de méthode lève un <xref:System.ArgumentOutOfRangeException> exception.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 L’exemple suivant utilise le <xref:System.String.Substring%2A> (méthode) pour séparer les paires clé/valeur qui sont délimitées par une est égal à caractère (« = »).  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 Le <xref:System.String.IndexOf%2A> méthode est utilisée pour obtenir la position du caractère égal dans la chaîne. L’appel à la <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> méthode extrait le nom de clé, qui commence au premier caractère dans la chaîne et s’étend sur le nombre de caractères retournés par l’appel à la <xref:System.String.IndexOf%2A> (méthode). L’appel à la <xref:System.String.Substring%28System.Int32%29> méthode extrait ensuite la valeur assignée à la clé. Il démarre à une position de caractère au-delà du caractère equals et s’étend à la fin de la chaîne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> plus <paramref name="length" /> indique une position qui n’est pas dans cette instance.  
  
- ou - 
 <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Énumérateur fortement typé qui peut être utilisé pour parcourir l’objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut être utilisé uniquement lorsque le <xref:System.String> instance est castée en un <xref:System.Collections.Generic.IEnumerable%601> objet d’interface. Pour plus d'informations, voir la méthode <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un énumérateur qui itère au sein de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Énumérateur qui peut être utilisé pour itérer au sein de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.Collections.IEnumerable>. Pour plus d'informations, voir la méthode <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ce paramètre est ignoré.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> si la valeur de la chaîne actuelle est <see cref="F:System.Boolean.TrueString" /> ; <see langword="false" /> si la valeur de la chaîne actuelle est <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de la chaîne actuelle n’est pas <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.Byte.MaxValue" /> ou inférieur à <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>Caractère à l'index 0 dans l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> est un nombre inférieur à <see cref="F:System.Decimal.MinValue" /> ou supérieur à <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre inférieur à <see cref="F:System.Double.MinValue" /> ou supérieur à <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.Int16.MaxValue" /> ou inférieur à <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.SByte.MaxValue" /> ou inférieur à <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Type de l'objet retourné.</param>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ChangeType%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être convertie en type spécifié par le paramètre <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.UInt16.MaxValue" /> ou inférieur à <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">La valeur de l’objet <see cref="T:System.String" /> actuel ne peut pas être analysée.</exception>
        <exception cref="T:System.OverflowException">La valeur de l’objet <see cref="T:System.String" /> actuel est un nombre supérieur à <see cref="F:System.UInt32.MaxValue" /> ou inférieur à <see cref="F:System.UInt32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Objet qui fournit des informations de mise en forme propres à la culture.</param>
        <summary>Pour obtenir une description de ce membre, consultez <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Valeur convertie de l'objet <see cref="T:System.String" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.String> est castée en interface <xref:System.IConvertible>. L’alternative recommandée consiste à appeler le <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie les caractères de cette instance vers un tableau de caractères Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les caractères de cette instance vers un tableau de caractères Unicode.</summary>
        <returns>Tableau de caractères Unicode dont les éléments sont les caractères individuels de cette instance. Si cette instance est une chaîne vide, le tableau retourné est vide et sa longueur est égale à zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie chaque caractère (autrement dit, chaque <xref:System.Char> objet) dans une chaîne à un tableau de caractères. Le premier caractère copié est à l’index zéro du tableau de caractères retourné ; le dernier caractère copié est à l’index <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Pour créer une chaîne à partir des caractères dans un tableau de caractères, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructeur.  
  
 Pour créer un tableau d’octets qui contient les caractères encodés dans une chaîne, instanciez approprié <xref:System.Text.Encoding> objet et appelez ses <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> (méthode). Voici quelques-unes des encodages standards disponibles dans .NET :  
  
|Encodage|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Pour plus d’informations, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.ToCharArray%2A> méthode pour extraire les caractères dans une chaîne à un tableau de caractères. Il affiche ensuite la chaîne d’origine et les éléments du tableau.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 L’exemple suivant définit une chaîne contenant les caractères utilisés comme séparateurs dans une chaîne délimitée. Il appelle ensuite la <xref:System.String.ToCharArray%2A> méthode pour créer un tableau de caractères qui peut être passé à la <xref:System.String.Split%28System.Char%5B%5D%29> (méthode) pour séparer la chaîne délimitée dans ses sous-chaînes individuels.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">Position de départ d'une sous-chaîne dans cette instance.</param>
        <param name="length">Longueur de la sous-chaîne dans cette instance.</param>
        <summary>Copie les caractères d'une sous-chaîne spécifiée de cette instance vers un tableau de caractères Unicode.</summary>
        <returns>Tableau de caractères Unicode dont les éléments sont le nombre de caractères <paramref name="length" /> dans cette instance commençant à partir de la position de caractère <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie les caractères dans une partie d’une chaîne vers un tableau de caractères. Pour créer une chaîne à partir d’une plage de caractères dans un tableau de caractères, appelez le <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructeur.  
  
 Le `startIndex` paramètre est de base zéro. Autrement dit, l’index du premier caractère dans l’instance de chaîne est égal à zéro.  
  
 Si `length` est égal à zéro, le tableau retourné est vide et a une longueur nulle. Si cette instance est `null` ou une chaîne vide (" »), le tableau retourné est vide et a une longueur nulle.  
  
 Pour créer un tableau d’octets qui contient les caractères encodés dans une partie d’une chaîne, instanciez approprié <xref:System.Text.Encoding> objet et appelez ses <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> (méthode). Les encodages standards disponibles dans .NET sont les suivantes :  
  
|Encodage|Object|  
|--------------|------------|  
|non|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Pour plus d’informations, consultez [encodage de caractères dans .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 L’exemple suivant convertit une sous-chaîne dans une chaîne en un tableau de caractères, puis énumère et affiche les éléments du tableau.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> est inférieur à zéro.  
  
- ou - 
 <paramref name="startIndex" /> plus <paramref name="length" /> est supérieur à la longueur de cette instance.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en minuscules.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en minuscules.</summary>
        <returns>Chaîne en minuscules.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode prend en compte les règles de casse de la culture actuelle.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 L’opération de casse qui résulte de l’appel la <xref:System.String.ToLower> méthode tient compte des conventions de casse de la culture actuelle. Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes. Cela produit le même résultat dans chaque culture (contrairement à la <xref:System.String.ToLower> méthode) et effectue plus efficacement.  
  
   
  
## Examples  
 L’exemple suivant convertit plusieurs chaînes de casse mixtes en minuscules.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de casse de chaîne qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour convertir un caractère en minuscule à l’aide des conventions de casse de la culture actuelle, appelez le <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> surcharge de méthode avec une valeur de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> pour son <paramref name="culture" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
        <summary>Retourne une copie de cette chaîne en minuscules, à l'aide des règles de casse de la culture spécifiée.</summary>
        <returns>Équivalent en minuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Règles de casse de la culture spécifiée par le `culture` paramètre déterminent la manière dont la casse de la chaîne est modifiée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous passez le <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> méthode un <xref:System.Globalization.CultureInfo> autre que l’objet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l’opération de casse prend en compte les règles spécifiques à la culture. Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant convertit deux chaînes de caractères majuscules en minuscules à l’aide des cultures Anglais (États-Unis) et Turc-Turquie, puis compare les chaînes en minuscules. Les chaînes en majuscules sont identiques, sauf que pour chaque occurrence de l’Unicode LATIN MAJUSCULE I dans une chaîne, l’autre chaîne contient lettre majuscule de LATIN I surmontée.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cet objet <see cref="T:System.String" /> converti en minuscules à l'aide des règles de casse de la culture indifférente.</summary>
        <returns>Équivalent en minuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La culture dite indifférente représente une culture qui est indépendante de la culture. Il est associé avec la langue anglaise, mais pas avec un pays spécifique ou une région. Pour plus d'informations, consultez la propriété <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si votre application varie selon le cas d’une chaîne modifie de manière prévisible qui n’est pas affectée par la culture actuelle, utilisez la <xref:System.String.ToLowerInvariant%2A> (méthode). Le <xref:System.String.ToLowerInvariant%2A> méthode est équivalente à `ToLower(CultureInfo.InvariantCulture)`. La méthode est recommandée lors de la collection de chaînes doit apparaître dans un ordre prévisible dans un contrôle d’interface utilisateur.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en minuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de chaînes qui contient un mot unique dans un nombre de langues. Le <xref:System.String.ToLowerInvariant%2A> méthode est utilisée pour remplir les éléments d’un tableau parallèle avec la version de non-respect de la casse de chaque mot. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> méthode est utilisée pour trier le tableau de la casse selon l’ordre des éléments dans le tableau en minuscules pour s’assurer que les éléments apparaissent dans le même ordre, quel que soit le langage.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Convertit la valeur de cette instance en <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne cette instance de <see cref="T:System.String" /> ; aucune conversion n'est effectivement effectuée.</summary>
        <returns>Chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que cette méthode retourne simplement la chaîne actuelle est inchangée, il n’est pas nécessaire d’appeler directement. Il est généralement appelé implicitement une opération, comme le montre l’exemple de forme composite.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.String.ToString%2A> (méthode). Notez que l’exemple n’appelle pas explicitement le <xref:System.String.ToString%2A> (méthode). Au lieu de cela, la méthode est appelée implicitement par le [mise en forme composite](~/docs/standard/base-types/composite-formatting.md) fonctionnalité.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Réservé) Objet fournissant des informations de mise en forme propres à la culture.</param>
        <summary>Retourne cette instance de <see cref="T:System.String" /> ; aucune conversion n'est effectivement effectuée.</summary>
        <returns>Chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` est réservé et ne participe actuellement pas à cette opération.  
  
 Étant donné que cette méthode retourne simplement la chaîne actuelle est inchangée, il n’est pas nécessaire d’appeler directement.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en majuscules.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cette chaîne convertie en majuscules.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode utilise des règles de casse de la culture actuelle pour convertir chaque caractère dans l’instance actuelle en son équivalent en majuscule. Si un caractère n’a pas d’équivalent majuscule, il reste inchangé dans la chaîne retournée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
 Le <xref:System.String.ToUpper%2A> méthode est souvent utilisée pour convertir une chaîne en majuscules afin qu’il peut être utilisé dans une comparaison respectant la casse. Une meilleure méthode pour effectuer une comparaison respectant la casse consiste à appeler une méthode de comparaison de chaîne qui a une <xref:System.StringComparison> dont vous affectez la valeur de paramètre <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> pour obtenir une comparaison dépendante de la culture, non-respect de la casse.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 L’opération de casse qui résulte de l’appel la <xref:System.String.ToUpper> méthode tient compte des conventions de casse de la culture actuelle. Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture (contrairement à la <xref:System.String.ToUpper> méthode) et effectue plus efficacement.  
  
   
  
## Examples  
 L’exemple suivant appelle la <xref:System.String.ToUpper%2A> méthode pour convertir une série de chaînes de caractères qui contiennent chaque caractère Latin de base, Supplément Latin-1 et Latin étendu A jeux de caractères. Il affiche ensuite chaque chaîne dont le caractère majuscule est différent de son caractère minuscule.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Comme expliqué dans [meilleures pratiques pour l’utilisation de chaînes](~/docs/standard/base-types/best-practices-strings.md), nous vous recommandons d’éviter d’appeler des méthodes de casse de chaîne qui substituent des valeurs par défaut et à la place appellent des méthodes qui requièrent des paramètres explicitement spécifiés. Pour convertir une chaîne en majuscules à l’aide des conventions de casse de la culture actuelle, appelez le <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> surcharge de méthode avec une valeur de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> pour son <paramref name="culture" /> paramètre.</para>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Objet qui fournit les règles de casse propres à la culture.</param>
        <summary>Retourne une copie de cette chaîne convertie en majuscules à l'aide des règles de casse de la culture spécifiée.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Règles de casse de la culture spécifiée par le `culture` paramètre déterminent la manière dont la casse d’une chaîne est modifiée.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous passez le <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> méthode un <xref:System.Globalization.CultureInfo> autre que l’objet <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, l’opération de casse prend en compte les règles spécifiques à la culture. Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> (méthode). Cela produit le même résultat dans chaque culture et plus efficace.  
  
   
  
## Examples  
 L’exemple suivant convertit une chaîne de caractères minuscules en deux chaînes de caractères en majuscules à l’aide des cultures Anglais (États-Unis) et Turc-Turquie, puis compare les chaînes en majuscules. Les chaînes en majuscules sont identiques, sauf que pour chaque occurrence de l’Unicode LATIN MAJUSCULE I dans une chaîne, l’autre chaîne contient lettre majuscule de LATIN I surmontée.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une copie de cet objet <see cref="T:System.String" /> converti en majuscules à l'aide des règles de casse de la culture indifférente.</summary>
        <returns>Équivalent en majuscules de la chaîne actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La culture dite indifférente représente une culture qui est indépendante de la culture. Il est associé avec la langue anglaise, mais pas avec un pays spécifique ou une région. Pour plus d'informations, consultez la propriété <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Si votre application varie selon le cas d’une chaîne modifie de manière prévisible qui n’est pas affectée par la culture actuelle, utilisez la <xref:System.String.ToUpperInvariant%2A> (méthode). Le <xref:System.String.ToUpperInvariant%2A> méthode est équivalente à `ToUpper(CultureInfo.InvariantCulture)`. La méthode est recommandée lors de la collection de chaînes doit apparaître dans un ordre prévisible dans un contrôle d’interface utilisateur.  
  
> [!NOTE]
>  Cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères dans l’instance actuelle sont convertis en majuscules.  
  
## <a name="security-considerations"></a>Considérations relatives à la sécurité  
 Si vous devez utiliser la version en minuscules ou majuscules d’un identificateur de système d’exploitation, tel qu’un nom de fichier, appelé canal ou clé de Registre, utilisez la <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> méthodes.  
  
   
  
## Examples  
 L’exemple suivant définit un tableau de chaînes qui contient un mot unique dans un nombre de langues. Le <xref:System.String.ToUpperInvariant%2A> méthode est utilisée pour remplir les éléments d’un tableau parallèle avec la version de non-respect de la casse de chaque mot. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> méthode est utilisée pour trier le tableau de la casse selon l’ordre des éléments dans le tableau en majuscules pour vous assurer que les éléments apparaissent dans le même ordre, quel que soit le langage.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une nouvelle chaîne dans laquelle toutes les occurrences situées au début et à la fin d'un jeu de caractères spécifiés dans l'objet <see cref="T:System.String" /> actuel sont supprimées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les espaces blancs de début ou de fin de chaîne de l'objet <see cref="T:System.String" /> actuel.</summary>
        <returns>Chaîne restante après la suppression de tous les espaces blancs de début et de fin de la chaîne actuelle. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Trim%2A> méthode supprime de la chaîne actuelle, tous les caractères d’espace blanc de fin. Chaque opération de suppression et de fin s’arrête lorsqu’un caractère autre qu’un espace blanc est rencontré. Par exemple, si la chaîne actuelle est « abc xyz », la <xref:System.String.Trim%2A> méthode retourne « abc xyz ». Pour supprimer les espaces entre les mots dans une chaîne, utilisez [Expressions régulières .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Si le <xref:System.String.Trim%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères d’espace blanc de début et de fin trouvés dans l’instance actuelle sont supprimés.  
  
 Si la chaîne actuelle est égale à <xref:System.String.Empty> ou tous les caractères dans l’instance actuelle sont des espaces blancs, la méthode retourne <xref:System.String.Empty>.  
  
 Espaces blancs sont définis par la norme Unicode. Le <xref:System.String.Trim> méthode supprime les caractères de début et de fin qui produisent une valeur de retour de `true` lorsqu’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode).  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Trim?displayProperty=nameWithType> méthode pour supprimer tout espace blanc supplémentaire dans des chaînes entrées par l’utilisateur avant de les concaténer.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures conservent une liste interne d’espaces blancs que cette méthode supprime. En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent un <see langword="true" /> valeur de retour lorsqu’ils sont transmis à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> méthode). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et versions antérieures, supprime deux caractères, espace de largeur zéro (U + 200 b) et l’espace de NO-BREAK de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]et versions ultérieures ne ne supprimez pas. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures ne supprime pas les trois caractères d’espaces blancs Unicode : séparateur de voyelle MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées au début et à la fin d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> du début et de la fin de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou est un tableau vide, les espaces blancs sont plutôt supprimés. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.Trim%2A> méthode supprime de la chaîne actuelle, tous les caractères de début et de fin qui se trouvent dans le `trimChars` paramètre. Chacun de début et de fin trim opération s’arrête lorsqu’un caractère qui n’est pas `trimChars` est rencontrée. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.Trim%2A> méthode retourne « abc456xyz ».  
  
> [!NOTE]
>  Si le <xref:System.String.Trim%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans laquelle toutes les début et de fin `trimChars` caractères trouvés dans l’instance actuelle sont supprimés.  
  
 Si la chaîne actuelle est égale à <xref:System.String.Empty> ou tous les caractères dans l’instance actuelle sont des caractères dans le `trimChars` de tableau, la méthode retourne <xref:System.String.Empty>.  
  
 Si `trimChars` est `null` ou un tableau vide, cette méthode supprime tous les caractères ou de fin qui entraînent le renvoi de la méthode `true` lorsqu’ils sont passés à la <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> (méthode),  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> méthode pour supprimer espace, astérisque (*) et des caractères apostrophe (') à partir d’une chaîne.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent un <see langword="true" /> valeur de retour lorsqu’ils sont transmis à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> méthode). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et versions antérieures, supprime deux caractères, espace de largeur zéro (U + 200 b) et l’espace de NO-BREAK de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]et versions ultérieures ne ne supprimez pas. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures ne supprime pas les trois caractères d’espaces blancs Unicode : séparateur de voyelle MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées à la fin d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> de la fin de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, ce sont les espaces blancs Unicode qui sont supprimés. Si aucun caractère ne peut être tronqué dans l'instance active, la méthode retourne l'instance active inchangée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.TrimEnd%2A> méthode supprime de la chaîne actuelle, tous les caractères de fin qui se trouvent dans le `trimChars` paramètre. L’opération de suppression s’arrête lorsque le premier caractère qui n’est pas dans `trimChars` est rencontré à la fin de la chaîne. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.TrimEnd%2A> méthode retourne « 123abc456xyz ».  
  
> [!NOTE]
>  Si le <xref:System.String.TrimEnd%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, il retourne une nouvelle chaîne dans les caractères de fin de toutes les trouvés dans `trimChars` sont supprimés de la chaîne actuelle.  
  
   
  
## Examples  
 L’exemple suivant montre comment vous pouvez utiliser la <xref:System.String.TrimEnd%28System.Char%5B%5D%29> méthode pour supprimer les espaces blancs ou des marques de ponctuation à la fin d’une chaîne.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent un <see langword="true" /> valeur de retour lorsqu’ils sont transmis à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> méthode). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et versions antérieures, supprime deux caractères, espace de largeur zéro (U + 200 b) et l’espace de NO-BREAK de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et versions ultérieures ne ne supprimez pas. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures ne supprime pas les trois caractères d’espaces blancs Unicode : séparateur de voyelle MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Tableau de caractères Unicode à supprimer, ou <see langword="null" />.</param>
        <summary>Supprime, de l'objet <see cref="T:System.String" /> actuel, toutes les occurrences situées au début d'un jeu de caractères spécifiés dans un tableau.</summary>
        <returns>Chaîne qui reste après la suppression de toutes les occurrences des caractères contenus dans le paramètre <paramref name="trimChars" /> du début de la chaîne actuelle. Si <paramref name="trimChars" /> est <see langword="null" /> ou est un tableau vide, les espaces blancs sont plutôt supprimés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.String.TrimStart%2A> méthode supprime de la chaîne actuelle, tous les caractères de début qui se trouvent dans le `trimChars` paramètre. L’opération de suppression s’arrête lorsqu’un caractère qui n’est pas `trimChars` est rencontrée. Par exemple, si la chaîne actuelle est « 123abc456xyz789 » et `trimChars` contient les chiffres à partir de « 1 » à « 9 », le <xref:System.String.TrimStart%2A> méthode retourne « abc456xyz789 ».  
  
> [!NOTE]
>  Si le <xref:System.String.TrimStart%2A> méthode supprime tous les caractères à partir de l’instance actuelle, cette méthode ne modifie pas la valeur de l’instance actuelle. Au lieu de cela, elle retourne une nouvelle chaîne dans laquelle tous les caractères d’espace blanc non significatif trouvés dans l’instance actuelle sont supprimés.  
  
   
  
## Examples  
 L’exemple suivant montre les fonctionnalités de base de la <xref:System.String.TrimStart%2A> méthode :

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 L’exemple suivant utilise la <xref:System.String.TrimStart%2A> méthode pour supprimer un espace blanc et les caractères de commentaire de lignes de code source. Le `StripComments` méthode encapsule un appel à <xref:System.String.TrimStart%2A> et transmet un tableau de caractères qui contient un espace et le caractère de commentaire, qui est une apostrophe (') en Visual Basic et une barre oblique (/) en c#. Le <xref:System.String.TrimStart%2A> méthode est également appelée pour supprimer des espaces blancs lors de l’évaluation si une chaîne est un commentaire.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 L’exemple suivant illustre un appel à la méthode `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures conserve une liste interne d’espaces blancs que cette méthode supprime si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide. En commençant par le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], si <paramref name="trimChars" /> est <see langword="null" /> ou un tableau vide, la méthode supprime tous les caractères d’espaces blancs Unicode (autrement dit, les caractères qui produisent un <see langword="true" /> valeur de retour lorsqu’ils sont transmis à la <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> méthode). Grâce à cette modification, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et versions antérieures, supprime deux caractères, espace de largeur zéro (U + 200 b) et l’espace de NO-BREAK de largeur zéro (U + FEFF), qui le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] et versions ultérieures ne ne supprimez pas. En outre, le <see cref="M:System.String.Trim" /> méthode dans le [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] et les versions antérieures ne supprime pas les trois caractères d’espaces blancs Unicode : séparateur de voyelle MONGOL (U + 180E), espace insécable étroite (U + 202F) et espace moyenne mathématique (U + 205F).</para>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>