<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="3575d47a0ba065e8986f03d99279f478811907b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/20/2019" /><Meta Name="ms.locfileid" Value="65922721" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Prend en charge toutes les classes dans la hiérarchie de classes .NET et fournit des services de bas niveau aux classes dérivées. Ceci est la classe de base fondamentale de toutes les classes .NET ; elle constitue la racine de la hiérarchie des types.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Langues ne nécessitent généralement pas une classe déclare l’héritage de <xref:System.Object> , car l’héritage est implicite.  
  
 Comme toutes les classes dans .NET sont dérivés de <xref:System.Object>, toutes les méthodes définies dans le <xref:System.Object> classe est disponible dans tous les objets dans le système. Classes dérivées peuvent et substituer certaines de ces méthodes, notamment :  
  
-   <xref:System.Object.Equals%2A> -Prend en charge les comparaisons entre objets.  
  
-   <xref:System.Object.Finalize%2A> -Effectue des opérations de nettoyage avant qu’un objet est automatiquement récupéré.  
  
-   <xref:System.Object.GetHashCode%2A> -Génère un nombre correspondant à la valeur de l’objet pour prendre en charge l’utilisation d’une table de hachage.  
  
-   <xref:System.Object.ToString%2A> -Fabrique une chaîne de texte explicite qui décrit une instance de la classe.  
  
## <a name="performance-considerations"></a>Considérations sur les performances  
 Si vous concevez une classe, telle qu’une collection, qui doit gérer tout type d’objet, vous pouvez créer des membres de classe qui acceptent des instances de la <xref:System.Object> classe. Toutefois, le processus de boxing et unboxing d’un type a une incidence sur les performances. Si vous savez que votre nouvelle classe devra souvent gérer certains types valeur, vous pouvez utiliser une des deux solutions suivantes pour réduire le coût de conversion boxing.  
  
-   Créer une méthode générale qui accepte un <xref:System.Object> type et un ensemble de surcharges de méthode spécifique au type qui acceptent chaque type de valeur que votre classe à gérer souvent. Si une méthode spécifique au type existe qui accepte le type de paramètre appelant, aucun boxing se produit et la méthode spécifique au type est appelée. S’il n’existe aucun argument de méthode qui correspond au type de paramètre appelant, le paramètre est boxed et la méthode générale est appelée.  
  
-   Concevez votre type et ses membres pour utiliser des génériques. Le common language runtime crée un type générique fermé lorsque vous créez une instance de votre classe et que vous spécifiez un argument de type générique. La méthode générique est spécifique au type et peut être appelée sans avoir à évaluer le paramètre appelant.  
  
 Bien qu’il est parfois nécessaire de développer des classes à usage général qui acceptent et retournent <xref:System.Object> types, vous pouvez améliorer les performances en fournissant également une classe spécifique au type pour gérer un type fréquemment utilisé. Par exemple, en fournissant une classe qui est spécifique à la définition et l’obtention des valeurs booléennes élimine le coût de conversion boxing et unboxing des valeurs booléennes.  
  
   
  
## Examples  
 L’exemple suivant définit un type Point dérivé le <xref:System.Object> classe et substitue un grand nombre de méthodes virtuelles de la <xref:System.Object> classe. En outre, l’exemple montre comment appeler la plupart des statiques et les méthodes de l’instance la <xref:System.Object> classe.  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Membres d’instance ne sont pas garantis pour être thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Object" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce constructeur est appelé par les constructeurs dans les classes dérivées, mais il peut également servir à créer directement une instance de la <xref:System.Object> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Détermine si deux instances d'objets sont égales.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à comparer à l'objet actuel.</param>
        <summary>Détermine si l'objet spécifié est identique à l'objet actuel.</summary>
        <returns><see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le type de comparaison entre l’instance actuelle et la `obj` paramètre varie selon que l’instance actuelle est un type référence ou un type valeur.  
  
-   Si l’instance actuelle est un type référence, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de référence et un appel à la <xref:System.Object.Equals%28System.Object%29> méthode équivaut à un appel à la <xref:System.Object.ReferenceEquals%2A> (méthode). L’égalité des références signifie que les variables d’objet sont comparés font référence au même objet. L’exemple suivant illustre le résultat de ce type de comparaison. Il définit un `Person` (classe), qui est un type référence, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1a` et `person2`, qui ont la même valeur. Il affecte également `person1a` à une autre variable d’objet, `person1b`. Comme la sortie de l’exemple, `person1a` et `person1b` sont égales, car elles référencent le même objet. Toutefois, `person1a` et `person2` ne sont pas égaux, même si elles ont la même valeur.  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   Si l’instance actuelle est un type valeur, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de valeur. L’égalité des valeurs signifie que les éléments suivants :  
  
    -   Les deux objets sont du même type. Comme le montre l’exemple suivant, un <xref:System.Byte> objet qui a la valeur 12 n’est pas égale une <xref:System.Int32> objet qui a la valeur 12, étant donné que les deux objets ont différents types d’exécution.  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   Les valeurs des champs publics et privés des deux objets sont égaux. L’exemple suivant teste l’égalité des valeurs. Il définit un `Person` structure, qui est un type valeur, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1` et `person2`, qui ont la même valeur. Comme le montre la sortie de l’exemple, même si deux variables objets font référence à des objets différents, `person1` et `person2` sont égaux, car ils ont la même valeur pour le privé `personName` champ.  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 Étant donné que le <xref:System.Object> classe est la classe de base pour tous les types dans le .NET Framework, le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode fournit la comparaison d’égalité par défaut pour tous les autres types. Toutefois, les types souvent remplacer le <xref:System.Object.Equals%2A> méthode pour implémenter l’égalité des valeurs. Pour plus d’informations, consultez les remarques pour les appelants et les notes de publication pour les sections les héritiers.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.Equals%28System.Object%29> surcharge de méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.Equals%28System.Object%29>. Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.Equals%28System.Object%29> (méthode). Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.Equals%28System.Object%29> surcharge de méthode.  
  
## <a name="notes-for-callers"></a>Notes de publication pour les appelants  
 Les classes dérivées fréquemment substituer la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour implémenter l’égalité des valeurs. En outre, les types fournissent aussi fréquemment une surcharge supplémentaire fortement typée à le `Equals` (méthode), généralement en implémentant le <xref:System.IEquatable%601> interface. Lorsque vous appelez le `Equals` méthode pour tester l’égalité, vous devez savoir si l’instance actuelle substitue <xref:System.Object.Equals%2A?displayProperty=nameWithType> et comprendre comment un appel particulier à un `Equals` méthode est résolue. Sinon, vous effectuer un test d’égalité est différente de ceux que vous aviez prévus, et la méthode peut retourner une valeur inattendue.  
  
 L'exemple suivant illustre cette situation. Il instancie trois <xref:System.Text.StringBuilder> objets avec des chaînes identiques et puis appelle les quatre à `Equals` méthodes. La première méthode appeler retourne `true`et le retour de trois autres `false`.  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 Dans le premier cas, fortement typé <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> surcharge de méthode qui teste l’égalité des valeurs, est appelée. Étant donné que les chaînes affectée aux deux <xref:System.Text.StringBuilder> objets sont égaux, la méthode retourne `true`. Toutefois, <xref:System.Text.StringBuilder> ne se substitue pas <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>. Pour cette raison, lorsque le <xref:System.Text.StringBuilder> objet est converti en un <xref:System.Object>, quand un <xref:System.Text.StringBuilder> instance est affectée à une variable de type <xref:System.Object>et à quel moment le <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> deux est transmis à la méthode <xref:System.Text.StringBuilder> objets, la valeur par défaut <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>méthode est appelée. Étant donné que <xref:System.Text.StringBuilder> est un type référence, cela équivaut à passer les deux <xref:System.Text.StringBuilder> des objets sur le <xref:System.Object.ReferenceEquals%2A> (méthode). Bien que les trois <xref:System.Text.StringBuilder> objets contiennent des chaînes identiques, ils font référence à trois objets distincts. Par conséquent, ces trois appels de méthode retour `false`.  
  
 Vous pouvez comparer l’objet en cours à un autre objet l’égalité des références en appelant le <xref:System.Object.ReferenceEquals%2A> (méthode). En Visual Basic, vous pouvez également utiliser le `is` mot clé (par exemple, `If Me Is otherObject Then ...`).  
  
## <a name="notes-for-inheritors"></a>Notes de publication pour les héritiers  
 Lorsque vous définissez votre propre type, ce type hérite des fonctionnalités définies par le `Equals` méthode de son type de base. Le tableau suivant répertorie l’implémentation par défaut de la `Equals` méthode pour les principales catégories de types dans le .NET Framework.  
  
|Catégorie de type|Égalité défini par|Commentaires|  
|-------------------|-------------------------|--------------|  
|Classe dérivée directement à partir de <xref:System.Object>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Égalité de référence ; équivalent à l’appel <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.|  
|Structure|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|Égalité des valeurs ; comparaison octet par octet directe ou comparaison de champ par champ à l’aide de la réflexion.|  
|Énumération|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|Valeurs doivent avoir le même type d’énumération et la même valeur sous-jacente.|  
|délégué|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|Les délégués doivent avoir le même type avec listes d’appel identiques.|  
|Interface|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|Égalité de référence.|  
  
 Pour un type valeur, vous devez toujours remplacer <xref:System.Object.Equals%2A>, car les tests d’égalité qui s’appuient sur la réflexion offrent des performances médiocres. Vous pouvez également remplacer l’implémentation par défaut de <xref:System.Object.Equals%2A> pour les types de référence pour tester l’égalité des valeurs au lieu de l’égalité de référence et pour définir la signification précise de l’égalité des valeurs. De telles implémentations de <xref:System.Object.Equals%2A> retourner `true` si les deux objets ont la même valeur, même s’ils ne sont pas la même instance. L’implémenteur du type décide ce qui constitue la valeur d’un objet, mais il est généralement tout ou partie des données stockées dans les variables d’instance de l’objet. Par exemple, la valeur d’un <xref:System.String> objet est basé sur les caractères de la chaîne ; le <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> substitutions de méthode le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour retourner `true` pour les deux instances qui contiennent les mêmes caractères dans le même ordre de chaîne.  
  
 L’exemple suivant montre comment substituer la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour tester l’égalité de valeur. Ce paramètre remplace le <xref:System.Object.Equals%2A> méthode pour la `Person` classe. Si `Person` accepté son implémentation de la classe de base de l’égalité, deux `Person` objets serait égales uniquement si elles référencé un objet unique. Toutefois, dans ce cas, deux `Person` objets sont égaux s’ils ont la même valeur pour le `Person.Id` propriété.  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 Outre l’écrasement <xref:System.Object.Equals%2A>, vous pouvez implémenter la <xref:System.IEquatable%601> interface pour fournir un test fortement typé pour l’égalité.  
  
 Les instructions suivantes doivent être remplies pour toutes les implémentations de la <xref:System.Object.Equals%28System.Object%29> (méthode). Dans la liste, `x`, `y`, et `z` représentent des références d’objet qui ne sont pas **null**.  
  
-   `x.Equals(x)` Retourne `true`, sauf dans les scénarios qui impliquent des types à virgule flottante. Consultez [ISO/IEC/IEEE 60559:2011, l’arithmétique à virgule flottante de technologie--microprocesseur systèmes--informations](https://www.iso.org/standard/57469.html).  
  
-   `x.Equals(y)` retourne la même valeur que `y.Equals(x)`.  
  
-   `x.Equals(y)` Retourne `true` si les deux `x` et `y` sont `NaN`.  
  
-   Si `(x.Equals(y) && y.Equals(z))` retourne `true`, puis `x.Equals(z)` retourne `true`.  
  
-   Les appels successifs à `x.Equals(y)` retournent la même valeur tant que les objets référencés par `x` et `y` ne sont pas modifiés.  
  
-   `x.Equals(null)` retourne `false`.  
  
 Les implémentations de <xref:System.Object.Equals%2A> ne doit pas lever des exceptions ; elles doivent toujours retourner une valeur. Par exemple, si `obj` est `null`, le <xref:System.Object.Equals%2A> méthode doit retourner `false` au lieu de lever un <xref:System.ArgumentNullException>.  
  
 Suivez ces instructions lors de la substitution <xref:System.Object.Equals%28System.Object%29>:  
  
-   Types qui implémentent <xref:System.IComparable> doit remplacer <xref:System.Object.Equals%28System.Object%29>.  
  
-   Les types qui substituent <xref:System.Object.Equals%28System.Object%29> doivent également substituer <xref:System.Object.GetHashCode%2A>; sinon, les tables de hachage peut ne pas fonctionneront correctement.  
  
-   Vous devez envisager d’implémenter le <xref:System.IEquatable%601> interface pour prendre en charge fortement typées teste l’égalité. Votre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implémentation doit retourner des résultats qui sont cohérents avec <xref:System.Object.Equals%2A>.  
  
-   Si votre langage de programmation prend en charge la surcharge d’opérateur et vous surchargez l’opérateur d’égalité pour un type donné, vous devez également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour retourner le même résultat que l’opérateur d’égalité. Cela permet de garantir que code de bibliothèque de classe qui utilise <xref:System.Object.Equals%2A> (tel que <xref:System.Collections.ArrayList> et <xref:System.Collections.Hashtable>) se comporte de manière cohérente avec le mode d’utilisation de l’opérateur d’égalité par le code d’application.  
  
### <a name="guidelines-for-reference-types"></a>Instructions pour les Types référence  
 Les instructions suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type référence :  
  
-   Pensez à substituer <xref:System.Object.Equals%2A> si la sémantique du type est le fait que le type représente une ou plusieurs valeurs.  
  
-   La plupart des types de référence ne doivent pas surcharger l’opérateur d’égalité, même si elles substituent <xref:System.Object.Equals%2A>. Toutefois, si vous implémentez un type référence qui doit avoir une sémantique de valeur, comme un type nombre complexe, vous devez substituer l’opérateur d’égalité.  
  
-   Vous ne devez pas substituer <xref:System.Object.Equals%2A> sur un type référence mutable. Il s’agit, car la substitution de <xref:System.Object.Equals%2A> nécessite également remplacer le <xref:System.Object.GetHashCode%2A> (méthode), comme indiqué dans la section précédente. Cela signifie que le code de hachage d’une instance d’un type référence mutable peut changer pendant sa durée de vie, ce qui peut entraîner l’objet à être perdues dans une table de hachage.  
  
### <a name="guidelines-for-value-types"></a>Instructions pour les Types valeur  
 Les instructions suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type de valeur :  
  
-   Si vous définissez un type valeur qui inclut un ou plusieurs champs dont les valeurs sont des types référence, vous devez substituer <xref:System.Object.Equals%28System.Object%29>. Le <xref:System.Object.Equals%28System.Object%29> implémentation fournie par <xref:System.ValueType> effectue une comparaison octet par octet pour les types de valeur dont les champs sont tous les types valeur, mais il utilise la réflexion pour effectuer une comparaison de champ par champ des types de valeur dont les champs incluent les types référence.  
  
-   Si vous substituez <xref:System.Object.Equals%2A> et votre langage de développement prend en charge la surcharge d’opérateur, vous devez surcharger l’opérateur d’égalité.  
  
-   Vous devez implémenter le <xref:System.IEquatable%601> interface. Fortement typées <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> méthode évite le boxing le `obj` argument.  
  
   
  
## Examples  
 L’exemple suivant montre un `Point` classe qui remplace le <xref:System.Object.Equals%2A> méthode pour fournir l’égalité des valeurs et un `Point3D` classe qui est dérivée de `Point`. Étant donné que `Point` substitue <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour tester l’égalité des valeurs, le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode n’est pas appelée. Toutefois, `Point3D.Equals` appels `Point.Equals` car `Point` implémente <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> d’une manière qui fournit l’égalité des valeurs.  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 Le `Point.Equals` méthode vérifie pour vous assurer que le `obj` argument n’est pas **null** et qu’il fait référence à une instance du même type que cet objet. Si une des vérifications échoue, la méthode retourne `false`.  
  
 Le `Point.Equals` les appels de méthode le <xref:System.Object.GetType%2A> méthode pour déterminer si les types d’exécution des deux objets sont identiques. Si la méthode a utilisé une vérification de la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic, elle retourne `true` dans les cas où `obj` est une instance d’une classe dérivée de `Point`, même si `obj` et actuel instance ne sont pas du même type d’exécution. Après avoir vérifié que les deux objets sont du même type, les conversions de méthode `obj` à taper `Point` et retourne le résultat de la comparaison des champs d’instance des deux objets.  
  
 Dans `Point3D.Equals`, héritées `Point.Equals` (méthode), qui remplace <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, est appelée avant toute autre action. Étant donné que `Point3D` est une classe sealed (`NotInheritable` en Visual Basic), une vérification sous la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic est suffisante pour vous assurer que `obj` est un `Point3D` objet. S’il s’agit une `Point3D` de l’objet, elle est convertie en un `Point` de l’objet et passée à l’implémentation de classe de base de <xref:System.Object.Equals%2A>. Uniquement lorsque héritées `Point.Equals` retourne de la méthode `true` est la méthode de comparer le `z` champs introduites dans la classe dérivée de l’instance.  
  
 L’exemple suivant définit un `Rectangle` classe qui implémente en interne un rectangle en tant que deux `Point` objets. Le `Rectangle` classe également remplacements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour fournir l’égalité des valeurs.  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 Certains langages tels que c# et Visual Basic prennent en charge la surcharge d’opérateur. Quand un type surcharge l’opérateur d’égalité, il doit également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour fournir les mêmes fonctionnalités. Cela est généralement effectuée en écrivant la <xref:System.Object.Equals%28System.Object%29> méthode en termes de l’opérateur d’égalité surchargé, comme dans l’exemple suivant.  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 Étant donné que `Complex` est un type valeur, il ne peut pas être dérivé.  Par conséquent, le remplacement <xref:System.Object.Equals%28System.Object%29> méthode ne doive pas appeler <xref:System.Object.GetType%2A> pour déterminer la durée d’exécution précise type de chaque objet, mais peut à la place utiliser la `is` opérateur en c# ou le `TypeOf` opérateur en Visual Basic pour vérifier le type de la `obj` paramètre.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Premier objet à comparer.</param>
        <param name="objB">Deuxième objet à comparer.</param>
        <summary>Détermine si les instances d'objet spécifiées sont considérées comme égales.</summary>
        <returns><see langword="true" /> si les objets sont considérés comme identiques ; sinon, <see langword="false" />. Si <paramref name="objA" /> et <paramref name="objB" /> ont tous deux la valeur **null**, la méthode retourne <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode statique <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> méthode indique si deux objets, `objA` et `objB`, sont égales. Il vous permet également de tester les objets dont la valeur est **null** d’égalité. Il compare `objA` et `objB` l’égalité comme suit :  
  
-   Il détermine si les deux objets représentent la même référence d’objet. S’ils le font, la méthode retourne `true`. Ce test équivaut à appeler le <xref:System.Object.ReferenceEquals%2A> (méthode). En outre, si les deux `objA` et `objB` sont **null**, la méthode retourne `true`.  
  
-   Il détermine si soit `objA` ou `objB` est **null**. Si, par conséquent, elle retourne `false`.  
  
-   Si les deux objets ne représentent pas la même référence d’objet et aucune n’est **null**, il appelle `objA`.`Equals` (`objB`) et retourne le résultat. Cela signifie que si `objA` remplace le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (méthode), ce remplacement est appelé.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> (méthode) et le compare avec la <xref:System.Object.ReferenceEquals%2A> (méthode).  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Autorise un objet à tenter de libérer des ressources et à exécuter d'autres opérations de nettoyage avant qu'il ne soit récupéré par une opération garbage collection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Object.Finalize%2A> méthode est utilisée pour effectuer des opérations de nettoyage sur les ressources non managées détenues par l’objet actuel avant la destruction de l’objet. La méthode est protégée et par conséquent est accessible uniquement par le biais de cette classe ou une classe dérivée.  
  
 Dans cette section :  
  
-   [Fonctionne de la finalisation](#How)  
  
-   [Notes de publication pour les implémenteurs](#Notes)  
  
-   [L’alternative de SafeHandle](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a>Fonctionne de la finalisation  
 Le <xref:System.Object> classe ne fournit pas d’implémentation pour le <xref:System.Object.Finalize%2A> (méthode) et que le garbage collector ne marque pas les types dérivés de <xref:System.Object> pour la finalisation, sauf si elles substituent la <xref:System.Object.Finalize%2A> (méthode).  
  
 Si un type remplace le <xref:System.Object.Finalize%2A> (méthode), le garbage collector ajoute une entrée pour chaque instance du type à une structure interne appelée la file d’attente de finalisation. La file d’attente de finalisation contient des entrées pour tous les objets dans le tas managé dont le code de finalisation doit s’exécuter avant que le garbage collector puisse récupérer leur mémoire. Le garbage collector appelle ensuite la <xref:System.Object.Finalize%2A> méthode automatiquement dans les conditions suivantes :  
  
-   Une fois que le garbage collector a découvert qu’un objet est inaccessible, sauf si l’objet a été exclu de finalisation par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
-   **Sur .NET Framework uniquement**, pendant l’arrêt d’un domaine d’application, sauf si l’objet est exempté de la finalisation. Lors de l’arrêt, même des objets qui sont toujours accessibles sont finalisées.  
  
 <xref:System.Object.Finalize%2A> est automatiquement appelé qu’une seule fois sur une instance donnée, sauf si l’objet est réinscrit à l’aide d’un mécanisme tel que <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> et <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> méthode n’a pas été appelée par la suite.  
  
 <xref:System.Object.Finalize%2A> opérations présentent les limitations suivantes :  
  
-   L’heure exacte lorsque le finaliseur s’exécute n’est pas défini. Pour garantir la mise en production déterministe des ressources pour implémenter des instances de votre classe, un `Close` méthode ou fournissez un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation.  
  
-   Les finaliseurs de deux objets ne sont pas garanties à exécuter dans un ordre spécifique, même si un objet fait référence à l’autre. Autrement dit, si l’objet a une référence à l’objet B, et avoir des finaliseurs, l’objet B peut avoir déjà été finalisée lorsque le finaliseur de l’objet A démarre.  
  
-   Le thread sur lequel s’exécute le finaliseur n’est pas spécifié.  
  
 Le <xref:System.Object.Finalize%2A> méthode ne peut pas s’exécuter jusqu'à la fin ou peut s’exécuter pas du tout dans les circonstances exceptionnelles suivantes :  
  
-   Si un autre finaliseur se bloque indéfiniment (entrera en une boucle infinie, tente d’obtenir un verrou, il peut obtenir jamais et ainsi de suite). Étant donné que le runtime tente d’exécuter des finaliseurs jusqu'à son achèvement, autres finaliseurs ne pas être appelés si un finaliseur se bloque indéfiniment.  
  
-   Si le processus se termine sans donner au runtime une chance à nettoyer. Dans ce cas, la première notification d’arrêt du processus du runtime est une notification DLL_PROCESS_DETACH.  
  
 Le runtime continue à finaliser des objets lors de l’arrêt aussi longtemps que le nombre d’objets finalisables diminuer.  
  
 Si <xref:System.Object.Finalize%2A> ou une substitution de <xref:System.Object.Finalize%2A> lève une exception et que le runtime n’est pas hébergée par une application qui substitue la stratégie par défaut, le runtime termine le processus et aucun actif `try` / `finally` blocs ou les finaliseurs sont exécutées. Ce comportement garantit l’intégrité du processus si le finaliseur ne peut pas libérer ou détruire des ressources.  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a>Remplacer la méthode Finalize 
 Vous devez substituer <xref:System.Object.Finalize%2A> pour une classe qui utilise des ressources non managées, telles que les descripteurs de fichiers ou des connexions de base de données qui doivent être lancées lorsque l’objet managé qui les utilise est ignorée pendant le garbage collection. Vous ne devez pas implémenter un <xref:System.Object.Finalize%2A> méthode pour les objets managés, car le garbage collector libère automatiquement les ressources managées.  
  
> [!IMPORTANT]
>  Si un <xref:System.Runtime.InteropServices.SafeHandle> objet n’est disponible qui encapsule votre ressource non managée, l’alternative recommandée consiste à implémenter le modèle de suppression avec un handle sécurisé et substituez pas <xref:System.Object.Finalize%2A>. Pour plus d’informations, consultez [alternative de SafeHandle The](#SafeHandle) section.  
  
 Le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode ne fait rien par défaut, mais vous devez substituer <xref:System.Object.Finalize%2A> uniquement si nécessaire et uniquement pour libérer les ressources non managées. Libération de la mémoire a tendance à prendre beaucoup plus de temps si une opération de finalisation est exécutée, car elle nécessite au moins deux garbage collections. En outre, vous devez substituer la <xref:System.Object.Finalize%2A> types de méthode pour référence uniquement. Le common language runtime finalise uniquement les types référence. Il ignore les finaliseurs dans les types valeur.  

L’étendue de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode est `protected`. Vous devez maintenir cette portée limitée lorsque vous substituez la méthode dans votre classe. En conservant un <xref:System.Object.Finalize%2A> méthode protégée, empêcher les utilisateurs de votre application à partir de l’appel d’un objet <xref:System.Object.Finalize%2A> directement la méthode.
  
 Toutes les implémentations de <xref:System.Object.Finalize%2A> dans un type dérivé doit appeler implémentation de son type de base de <xref:System.Object.Finalize%2A>. Ceci est le seul cas dans lequel application code est autorisé à appeler <xref:System.Object.Finalize%2A>. D’un objet <xref:System.Object.Finalize%2A> méthode ne doit pas appeler une méthode sur tous les objets autres que ceux de sa classe de base. Il s’agit, car les autres objets appelées pu être collectées en même temps que l’objet appelant, comme dans le cas d’un arrêt de runtime de langage commun. 
  
> [!NOTE]
>  Le compilateur c# ne vous permet pas de substituer le <xref:System.Object.Finalize%2A> (méthode). Au lieu de cela, vous fournissez un finaliseur en implémentant un [destructeur](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) pour votre classe. Un destructeur c# appelle automatiquement le destructeur de sa classe de base.  
>   
>  Visual C++ fournit aussi sa propre syntaxe pour l’implémentation de la <xref:System.Object.Finalize%2A> (méthode). Pour plus d’informations, consultez la section « Destructeurs et finaliseurs » de [Comment : Définir et consommer des Classes et Structs (C++ / c++ / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).  
  
 Étant donné que le garbage collection est non déterministe, vous ne savez pas précisément lorsque le garbage collector effectue la finalisation. Pour libérer les ressources immédiatement, vous pouvez également choisir d’implémenter le [dispose, modèle](~/docs/standard/garbage-collection/implementing-dispose.md) et <xref:System.IDisposable> interface. Le <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation peut être appelée par les consommateurs de votre classe pour libérer les ressources non managées, et vous pouvez utiliser la <xref:System.Object.Finalize%2A> méthode pour libérer les ressources non managées dans le cas où la <xref:System.IDisposable.Dispose%2A> méthode n’est pas appelée.  
  
 <xref:System.Object.Finalize%2A> peut effectuer presque toute action, y compris ressusciter (un objet qui rendre à nouveau accessible) a été nettoyé pendant le garbage collection. Toutefois, l’objet peut uniquement être réactivé une seule fois ; <xref:System.Object.Finalize%2A> ne peut pas être appelée sur des objets ressuscités pendant le garbage collection.
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a>L'alternative de SafeHandle  
 Création des finaliseurs fiables est souvent difficile, car vous ne pouvez pas faire d’hypothèses concernant l’état de votre application et non prise en charge des exceptions de système comme <xref:System.OutOfMemoryException> et <xref:System.StackOverflowException> terminer le finaliseur. Au lieu d’implémenter un finaliseur pour votre classe pour libérer les ressources non managées, vous pouvez utiliser un objet qui est dérivé de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe pour encapsuler vos ressources non managées et implémentez le modèle de suppression sans un finaliseur. Le .NET Framework fournit les classes suivantes dans le <xref:Microsoft.Win32?displayProperty=nameWithType> espace de noms qui sont dérivés de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> est une classe wrapper pour un handle de fichier.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> est une classe wrapper pour les descripteurs de fichier mappé en mémoire.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> est une classe wrapper pour un pointeur vers un bloc de mémoire non managée.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sont des classes wrapper pour les descripteurs de chiffrement.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> est une classe wrapper pour des handles de canal.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> est une classe wrapper pour un handle vers une clé de Registre.  
  
-   <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> est une classe wrapper pour un handle d’attente.  
  
 L’exemple suivant utilise le [dispose, modèle](~/docs/standard/garbage-collection/implementing-dispose.md) avec des handles sécurisés au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode). Il définit un `FileAssociation` classe qui encapsule les informations de Registre sur l’application qui gère les fichiers avec une extension de fichier particulier. Les handles de deux Registre retournés en tant que `out` paramètres par Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) appels de fonction sont passés à la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructeur. Le type protégé `Dispose` méthode appelle ensuite la `SafeRegistryHandle.Dispose` méthode pour libérer ces deux poignées.  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant vérifie que le <xref:System.Object.Finalize%2A> méthode est appelée lorsqu’un objet qui substitue <xref:System.Object.Finalize%2A> est détruit. Notez que, dans une application de production, le <xref:System.Object.Finalize%2A> méthode est substituée pour libérer les ressources non managées détenues par l’objet. Notez également que l’exemple c# fournit un destructeur au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode).  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 Pour obtenir un exemple supplémentaire qui remplace le <xref:System.Object.Finalize%2A> (méthode), consultez le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fait office de fonction de hachage par défaut.</summary>
        <returns>Code de hachage pour l'objet actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un code de hachage est une valeur numérique qui est utilisée pour insérer et identifier un objet dans une collection basée sur le hachage comme le <xref:System.Collections.Generic.Dictionary%602> (classe), le <xref:System.Collections.Hashtable> classe ou un type dérivé la <xref:System.Collections.DictionaryBase> classe. Le <xref:System.Object.GetHashCode%2A> méthode fournit ce code de hachage pour les algorithmes nécessitant des contrôles rapides de l’égalité d’objet.  
  
> [!NOTE]
>  Pour plus d’informations sur l’utilisation des codes de hachage dans les tables de hachage et pour certains algorithmes de code de hachage supplémentaires, consultez le [fonction de hachage](https://en.wikipedia.org/wiki/Hash_function) entrée dans Wikipedia.  
  
 Deux objets qui sont des codes de hachage de retour égale sont égaux. Toutefois, l’inverse n’est pas vrai : codes de hachage égales n’impliquent pas de l’égalité d’objet, car différents objets (inégaux) peuvent avoir des codes de hachage identiques. En outre, .NET ne garantit pas l’implémentation par défaut de la <xref:System.Object.GetHashCode%2A> méthode et la valeur de cette méthode est retournée peut varier entre les implémentations de .NET, telles que les différentes versions de .NET Framework et .NET Core et les plateformes, telles que 32 bits et plateformes 64 bits. Pour ces raisons, n’utilisez pas l’implémentation par défaut de cette méthode comme un identificateur d’objet unique à des fins hachage. Suivent les deux conséquences de cela :  
  
-   Vous ne devez pas supposer que les codes de hachage égales impliquent l’égalité d’objet.  
  
-   Vous ne devez jamais conserver ou utiliser un code de hachage en dehors du domaine d’application dans lequel il a été créé, car le même objet peuvent être hachées sur les plateformes, processus et domaines d’application.  
  
> [!WARNING]
>  Un code de hachage est destiné aux efficace d’insertion et de recherche dans les collections sont basées sur une table de hachage. Un code de hachage n’est pas une valeur permanente. Pour cette raison :  
>   
> -   Ne pas sérialiser les valeurs de code de hachage ou les stocker dans les bases de données.  
> -   N’utilisez pas le code de hachage comme clé pour récupérer un objet à partir d’une collection à clé.  
> -   Ne pas envoyer les codes de hachage entre les domaines d’application ou processus. Dans certains cas, les codes de hachage peuvent être calculées sur une base de domaine par processus ou par application.  
> -   N’utilisez pas le code de hachage au lieu d’une valeur renvoyée par une fonction de hachage cryptographique, si vous avez besoin d’un hachage de chiffrement fort. Pour les hachages de chiffrement, utilisez une classe dérivée de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
> -   Ne testez pas l’égalité des codes de hachage pour déterminer si deux objets sont égaux. (Les objets inégales peuvent avoir des codes de hachage identiques.) Pour tester l’égalité, appelez le <xref:System.Object.ReferenceEquals%2A> ou <xref:System.Object.Equals%2A> (méthode).  
  
 Le <xref:System.Object.GetHashCode%2A> méthode peut être substituée par un type dérivé. Si <xref:System.Object.GetHashCode%2A> est ne pas substituée, codes de hachage pour les types référence sont calculées en appelant le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> méthode de la classe de base, qui calcule un code de hachage basée sur la référence d’un objet ; pour plus d’informations, consultez <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. En d’autres termes, deux objets pour lesquels le <xref:System.Object.ReferenceEquals%2A> méthode retourne `true` ont des codes de hachage identiques. Si les types valeur ne substituent pas <xref:System.Object.GetHashCode%2A>, le <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> méthode de la classe de base utilise la réflexion pour calculer le code de hachage basé sur les valeurs des champs du type. En d’autres termes, les types de valeur dont les champs ont des valeurs égales ont des codes de hachage égales. Pour plus d’informations sur la substitution de <xref:System.Object.GetHashCode%2A>, consultez la section « Remarques à l’attention des héritiers ».  
  
> [!WARNING]
>  Si vous remplacez le <xref:System.Object.GetHashCode%2A> (méthode), vous devez également substituer <xref:System.Object.Equals%2A>et vice versa. Si votre substituée <xref:System.Object.Equals%2A> retourne de la méthode `true` lorsque deux objets sont testées pour l’égalité, votre substituée <xref:System.Object.GetHashCode%2A> méthode doit retourner la même valeur pour les deux objets.  
  
 Si un objet qui est utilisé en tant que clé dans une table de hachage ne fournit pas une implémentation utile de <xref:System.Object.GetHashCode%2A>, vous pouvez spécifier un fournisseur de code de hachage en fournissant un <xref:System.Collections.IEqualityComparer> implémentation à une des surcharges de la <xref:System.Collections.Hashtable> constructeur de classe.  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.GetHashCode%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.GetHashCode%2A>. Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.GetHashCode%2A>. Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.GetHashCode%2A> (méthode).  
  
   
  
## Examples  
 Une des manières plus simples pour calculer un code de hachage pour une valeur numérique qui a le même ou une plage plus petite que la <xref:System.Int32> type consiste à simplement retourner cette valeur. L’exemple suivant montre une telle implémentation pour un `Number` structure.  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 Souvent, un type a plusieurs champs de données qui peuvent participer à la génération du code de hachage. Permet de générer un code de hachage consiste à combiner ces champs à l’aide un `XOR (eXclusive OR)` opération, comme indiqué dans l’exemple suivant.  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 L’exemple précédent retourne le même code de hachage pour (n1, n2) et (n2, n1) et par conséquent, peut générer des collisions que sont souhaitables. Plusieurs solutions sont disponibles afin que les codes de hachage dans ces cas ne sont pas identiques. Une consiste à retourner le code de hachage d’un `Tuple` objet qui reflète l’ordre de chaque champ. L’exemple suivant montre une implémentation possible qui utilise le <xref:System.Tuple%602> classe. Notez, cependant, que la surcharge de performances de l’instanciation d’un `Tuple` objet peut affecter considérablement les performances globales d’une application qui stocke un grand nombre d’objets dans les tables de hachage.  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 Une autre solution de remplacement implique les codes de hachage individuels de pondération en décalant les codes de hachage des champs successives à gauche par deux ou plusieurs bits. Idéalement, au lieu d’être ignorés, les bits décalés au-delà de bit 31 doivent habiller plutôt qu’ignorées. Étant donné que les bits sont ignorés par les opérateurs de décalage vers la gauche en c# et Visual Basic, cela requiert la création d’une méthode MAJ-wrap gauche comme suit :  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 L’exemple suivant utilise ensuite cette méthode MAJ-wrap pour calculer le code de hachage de la `Point` structure utilisée dans les exemples précédents.  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Une fonction de hachage est utilisée pour générer rapidement un nombre (code de hachage) qui correspond à la valeur d’un objet. Fonctions de hachage sont généralement spécifiques à chaque type et, pour l’unicité, doivent utiliser au moins un des champs d’instance en tant qu’entrée. Codes de hachage ne doivent pas être calculées en utilisant les valeurs des champs statiques.  
  
Pour les classes dérivées à partir de <see cref="T:System.Object" />, le <see langword="GetHashCode" /> méthode permettre déléguer à la classe de base <see cref="M:System.Object.GetHashCode" /> implémentation uniquement si la classe dérivée définit l’égalité à une égalité de référence. L’implémentation par défaut de <see cref="M:System.Object.GetHashCode" /> pour référence types retourne un code de hachage qui est équivalent à celui retourné par la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> (méthode). Vous pouvez remplacer <see cref="M:System.Object.GetHashCode" /> pour les types référence immuable. En règle générale, pour les types référence mutables, vous devez substituer <see cref="M:System.Object.GetHashCode" /> uniquement si : 
-Vous pouvez calculer le code de hachage à partir des champs qui ne sont pas mutables ; ou 
-Vous pouvez vous assurer que le code de hachage d’un objet mutable ne change pas pendant que l’objet est contenu dans une collection qui s’appuie sur son code de hachage.  
  
Sinon, vous pourriez penser que l’objet mutable est perdue au cours de la table de hachage. Si vous choisissez de remplacer <see cref="M:System.Object.GetHashCode" /> pour un type référence mutable, la documentation doit indiquer clairement que les utilisateurs de votre type ne devraient pas modifier les valeurs d’objet tandis que l’objet est stocké dans une table de hachage.  
  
Pour les types valeur, <see cref="M:System.ValueType.GetHashCode" /> fournit une implémentation de code de hachage par défaut qui utilise la réflexion. Vous devez envisager de substitution pour de meilleures performances.  
  
 <block subset="none" type="note"><para>  
 Pour plus d’informations et des exemples de codes de hachage de plusieurs façons de calcul, consultez la section Exemples.  
  
</para></block>  
  
 Une fonction de hachage doit avoir les propriétés suivantes : 
-Si deux objets sont considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthode pour chaque objet doit retourner la même valeur. Toutefois, si deux objets ne sont pas considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthodes pour les deux objets n’ont pas à retourner des valeurs différentes.  
  
-Le <see cref="M:System.Object.GetHashCode" /> méthode pour un objet doit constamment retourner le même code de hachage tant qu’il n’existe aucune modification de l’état de l’objet qui détermine la valeur de retour de l’objet [System.Object.Equals](xref:System.Object.Equals*) (méthode). Notez que cela est vrai uniquement pour l’exécution en cours d’une application, et qu’un code de hachage différent peut être retourné si l’application est exécutée à nouveau.  
  
-Pour des performances optimales, une fonction de hachage doit générer une distribution uniforme pour toutes les entrées, y compris les entrées qui sont largement mis en cluster. Une conséquence est que les petites modifications à l’état de l’objet doivent entraîner de modifications importantes apportées au code de hachage qui en résulte pour de meilleures performances de table de hachage.  
  
-Fonctions de hachage doivent être peu coûteuses à calculer.  
  
-Le <see cref="M:System.Object.GetHashCode" /> méthode lever d’exceptions.  
  
Par exemple, l’implémentation de la <see cref="M:System.String.GetHashCode" /> méthode fournie par le <see cref="T:System.String" /> classe retourne des codes de hachage identiques pour les valeurs de chaîne identiques. Par conséquent, deux <see cref="T:System.String" /> objets retournent le même code de hachage si elles représentent la même valeur de chaîne. En outre, la méthode utilise tous les caractères dans la chaîne pour générer la sortie distribuée de manière raisonnablement aléatoire, même lorsque l’entrée est ordonnée en clusters dans certaines plages (par exemple, les nombreux utilisateurs peuvent posséder des chaînes qui contiennent uniquement les 128 caractères ASCII inférieurs, même si un chaîne peut contenir les caractères Unicode 65 535).  
  
En fournissant une bonne fonction de hachage sur une classe peut affecter considérablement les performances de l’ajout de ces objets à une table de hachage. Dans une table de hachage avec des clés qui fournissent une implémentation correcte d’une fonction de hachage, la recherche d’un élément prend un temps constant (par exemple, il s’agit d’une opération o (1)). Dans une table de hachage avec une mauvaise implémentation d’une fonction de hachage, les performances d’une recherche varie selon le nombre d’éléments dans la table de hachage (par exemple, un O (`n`) opération, où `n` est le nombre d’éléments dans la table de hachage). Un utilisateur malveillant peut entrer des données qui augmente le nombre de collisions, ce qui peut dégrader considérablement les performances des applications qui dépendent des tables de hachage, dans les conditions suivantes : 
-Lorsque les fonctions de hachage produisent des collisions fréquentes.  
  
-Lorsque une proportion importante des objets dans une table de hachage à générer des codes de hachage qui sont égales ou approximativement égal à l’autre.  
  
-Lorsque les utilisateurs d’entrée les données à partir de laquelle le code de hachage est calculé.  
  
Classes dérivées qui substituent <see cref="M:System.Object.GetHashCode" /> doivent également substituer <see cref="M:System.Object.Equals(System.Object)" /> afin de garantir que les deux objets sont considérés comme égaux ont le même code de hachage ; sinon, le <see cref="T:System.Collections.Hashtable" /> type peuvent ne pas fonctionne correctement.</para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le <see cref="T:System.Type" /> de l'instance actuelle.</summary>
        <returns>Type exact de l'instance actuelle au moment de l'exécution.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Étant donné que <xref:System.Object?displayProperty=nameWithType> est la classe de base pour tous les types dans .NET, système, tapez le <xref:System.Object.GetType%2A> méthode peut être utilisée pour retourner <xref:System.Type> objets qui représentent tous les types .NET. .NET reconnaît les cinq catégories de types suivantes :  
  
-   Classes, qui sont dérivés de <xref:System.Object?displayProperty=nameWithType>,  
  
-   Types valeur, qui sont dérivées de <xref:System.ValueType?displayProperty=nameWithType>.  
  
-   Interfaces, qui sont dérivés de <xref:System.Object?displayProperty=nameWithType> en commençant par le .NET Framework 2.0.  
  
-   Énumérations qui sont dérivées de <xref:System.Enum?displayProperty=nameWithType>.  
  
-   Les délégués sont dérivés de <xref:System.MulticastDelegate?displayProperty=nameWithType>.  
  
 Pour les deux objets `x` et `y` qui comportent des types de runtime identiques, `Object.ReferenceEquals(x.GetType(),y.GetType())` retourne `true`. L’exemple suivant utilise le <xref:System.Object.GetType%2A> méthode avec le <xref:System.Object.ReferenceEquals%2A> méthode pour déterminer si une valeur numérique est du même type que deux autres valeurs numériques.  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  Pour déterminer si un objet est un type spécifique, vous pouvez utiliser le mot clé de comparaison du type de votre langage ou construire. Par exemple, vous pouvez utiliser la `TypeOf…Is` construire en Visual Basic ou le `is` mot clé en c#.  
  
 Le <xref:System.Object.GetType%2A> méthode est héritée par tous les types qui dérivent de <xref:System.Object>. Cela signifie que, outre à l’aide du mot clé de comparaison de votre propre langage, vous pouvez utiliser la <xref:System.Object.GetType%2A> méthode pour déterminer le type d’un objet particulier, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 Le <xref:System.Type> objet expose les métadonnées associées à la classe de l’actuel <xref:System.Object>.  
  
   
  
## Examples  
 L’exemple de code suivant montre que <xref:System.Object.GetType%2A> retourne le type de runtime de l’instance actuelle.  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle du <see cref="T:System.Object" /> actuel.</summary>
        <returns>Copie superficielle du <see cref="T:System.Object" /> actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Object.MemberwiseClone%2A> méthode crée une copie superficielle en créant un nouvel objet, puis en copiant les champs non statiques de l’objet actuel vers le nouvel objet. Si un champ est un type valeur, une copie bit par bit du champ est effectuée. Si un champ est un type référence, la référence est copiée, mais l’objet référencé n’est pas. Par conséquent, l’objet d’origine et son clone font référence au même objet.  
  
 Par exemple, considérez un objet appelé X qui fait référence à son tour, les objets A et B, C. Une copie superficielle de X crée le nouvel objet X2 qui référence également des objets A et B. En revanche, une copie complète de X crée un nouvel objet X2 qui référence les nouveaux objets A2 et B2, qui sont des copies de A et B. B2 référence à son tour, le nouvel objet C2, qui est une copie de C. L’exemple illustre la différence entre un shallow et une opération de copie complète.  
  
 Il existe plusieurs façons d’implémenter une opération de copie complète si l’opération de copie superficielle exécutée par le <xref:System.Object.MemberwiseClone%2A> méthode ne répond pas à vos besoins. Notamment :  
  
-   Appeler un constructeur de classe de l’objet doit être copié pour créer un second objet avec les valeurs de propriété extraites du premier objet. Cela suppose que les valeurs d’un objet sont entièrement définies par son constructeur de classe.  
  
-   Appelez le <xref:System.Object.MemberwiseClone%2A> méthode pour créer une copie superficielle d’un objet, puis attribuez de nouveaux objets dont les valeurs sont les mêmes que l’objet d’origine à des propriétés ou les champs dont les valeurs sont des types référence. Le `DeepCopy` méthode dans l’exemple illustre cette approche.  
  
-   Sérialiser l’objet de manière complète copié, puis restaurez les données sérialisées à une variable d’objet différent.  
  
-   Utiliser la réflexion pour effectuer l’opération de copie complète avec la récurrence.  
  
   
  
## Examples  
 L’exemple suivant illustre la <xref:System.Object.MemberwiseClone%2A> (méthode). Il définit un `ShallowCopy` méthode qui appelle le <xref:System.Object.MemberwiseClone%2A> méthode pour effectuer une opération de copie superficielle sur un `Person` objet. Il définit également un `DeepCopy` méthode qui effectue une opération de copie complète sur un `Person` objet.  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 Dans cet exemple, le `Person.IdInfo` propriété retourne un `IdInfo` objet. En tant que la sortie de l’exemple, lorsqu’un `Person` est cloné en appelant le <xref:System.Object.MemberwiseClone%2A> (méthode), cloné `Person` objet est une copie indépendante de l’objet d’origine, sauf qu’ils partagent le même `Person.IdInfo` référence d’objet. Par conséquent, modification du clone `Person.IdInfo` propriété modifie l’objet d’origine `Person.IdInfo` propriété. En revanche, si une opération de copie complète est effectuée et cloné `Person` de l’objet, y compris son `Person.IdInfo` propriété, peut être modifié sans affecter l’objet d’origine.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">Premier objet à comparer.</param>
        <param name="objB">Deuxième objet à comparer.</param>
        <summary>Détermine si les instances de <see cref="T:System.Object" /> spécifiées sont identiques.</summary>
        <returns><see langword="true" /> si <paramref name="objA" /> est la même instance que <paramref name="objB" /> ou si les deux ont la valeur **null** ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la <xref:System.Object.Equals%2A> (méthode) et l’opérateur d’égalité, le <xref:System.Object.ReferenceEquals%2A> méthode ne peut pas être substituée. Pour cette raison, si vous souhaitez tester deux références d’égalité d’objets et vous ne savez pas sur l’implémentation de la `Equals` (méthode), vous pouvez appeler la <xref:System.Object.ReferenceEquals%2A> (méthode).  
  
 Toutefois, la valeur de retour de la <xref:System.Object.ReferenceEquals%2A> méthode peut-être apparaître comme étant anormaux dans ces deux scénarios :  
  
-   Lors de la comparaison des types valeur. Si `objA` et `objB` sont des types valeur, ils sont convertis avant d’être passés à la <xref:System.Object.ReferenceEquals%2A> (méthode). Cela signifie que si les deux `objA` et `objB` représentent la même instance d’un type valeur, le <xref:System.Object.ReferenceEquals%2A> méthode retourne néanmoins `false`, comme illustré dans l’exemple suivant.  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     Pour plus d’informations sur les types valeur boxing, consultez [Boxing et Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).  
  
-   Lors de la comparaison de chaînes. Si `objA` et `objB` sont des chaînes, la <xref:System.Object.ReferenceEquals%2A> retourne de la méthode `true` si la chaîne est dans le pool interne. Il n’effectue pas un test d’égalité de valeur.  Dans l’exemple suivant, `s1` et `s2` sont égales, car elles sont de deux instances d’une chaîne unique dans le pool interne. Toutefois, `s3` et `s4` ne sont pas égales, car même si elles sont ont des valeurs de chaîne identique, cette chaîne n’est pas intégrée.  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     Pour plus d’informations sur la centralisation des chaînes, consultez <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple suivant utilise <xref:System.Object.ReferenceEquals%2A> pour déterminer si deux objets sont la même instance.  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une chaîne qui représente l'objet actuel.</summary>
        <returns>Chaîne qui représente l'objet actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType> major est mise en forme de méthode dans le .NET Framework. Il convertit un objet en sa représentation sous forme de chaîne afin qu’il soit adapté à l’affichage. (Pour plus d’informations sur la mise en forme de la prise en charge dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).) Implémentations par défaut de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode retourne le nom qualifié complet du type d’objet.  
  
> [!IMPORTANT]
>  Vous avez peut-être atteint cette page en suivant le lien à partir de la liste des membres d’un autre type. C’est parce que ce type ne se substitue pas <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Au lieu de cela, il hérite des fonctionnalités de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).  
  
 Types de fréquemment substituent la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour fournir une représentation de chaîne plus appropriée d’un type particulier. Types surcharger aussi fréquemment le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour prendre en charge les chaînes de format ou la mise en forme dépendante de la culture.  
  
 Dans cette section :  
  
 [La méthode Object.ToString () par défaut](#Default)   
 [Substitution de la méthode Object.ToString)](#Overriding)   
 [La surcharge de la méthode ToString](#Overloading)   
 [Extension de la méthode Object.ToString](#Extending)   
 [Notes relatives à l’exécution de Windows](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a>La méthode Object.ToString () par défaut  
 L’implémentation par défaut de la <xref:System.Object.ToString%2A> méthode retourne le nom qualifié complet du type de la <xref:System.Object>, comme illustré dans l’exemple suivant.  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 Étant donné que <xref:System.Object> est la classe de base de tous les types de référence dans le .NET Framework, ce comportement est hérité par les types de référence qui ne remplacent pas les <xref:System.Object.ToString%2A> (méthode). L'exemple suivant illustre ce comportement. Il définit une classe nommée `Object1` qui accepte l’implémentation par défaut de tous les <xref:System.Object> membres. Son <xref:System.Object.ToString%2A> méthode retourne le nom de type qualifié complet de l’objet.  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a>Substitution de la méthode Object.ToString)  
 Les types couramment remplacer le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner une chaîne qui représente l’instance d’objet. Par exemple, la base de types tels que <xref:System.Char>, <xref:System.Int32>, et <xref:System.String> fournir <xref:System.Object.ToString%2A> qu’il retourne la forme de chaîne de la valeur qui représente l’objet. L’exemple suivant définit une classe, `Object2`, qui remplace le <xref:System.Object.ToString%2A> méthode pour retourner le nom de type ainsi que sa valeur.  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 Le tableau suivant répertorie les catégories de type dans .NET et indique si elles substituent la <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).  
  
|Catégorie de type|Overrides Object.ToString()|Comportement|  
|-------------------|-----------------------------------|--------------|  
|Classe|N/A|N/A|  
|Structure|Oui (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)|Identique à `Object.ToString()`|  
|Énumération|Oui (<xref:System.Enum.ToString?displayProperty=nameWithType>)|Le nom de membre|  
|Interface|Non|N/A|  
|délégué|Non|N/A|  
  
 Consultez les section Remarques à l’attention des héritiers pour plus d’informations sur la substitution <xref:System.Object.ToString%2A>.  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a>La surcharge de la méthode ToString  
 Outre l’écrasement Next sans paramètre <xref:System.Object.ToString?displayProperty=nameWithType> surcharger de nombreux types de méthode, le `ToString` méthode pour fournir des versions de la méthode qui acceptent des paramètres. En règle générale, cela pour prendre en charge la mise en forme de variable et de mise en forme dépendante de la culture.  
  
 L’exemple suivant surcharge la `ToString` méthode pour retourner une chaîne de résultat qui inclut la valeur des champs variés d’une `Automobile` classe. Il définit quatre chaînes de format : G, qui retourne le nom du modèle et l’année ; D, qui retourne le nom du modèle, une année et un nombre de portes ; C, qui retourne le nom du modèle, une année et un nombre de cylindres ; et A, qui retourne une chaîne avec toutes les valeurs de champ de quatre.  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 L’exemple suivant appelle surchargées <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthode pour afficher la mise en forme dépendante de la culture d’une valeur de devise.  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 Pour plus d’informations sur les chaînes de format et la mise en forme dépendante de la culture, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md). Pour les chaînes de format pris en charge par les valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md). Pour les chaînes de format pris en charge par les valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a>Extension de la méthode Object.ToString  
 Parce qu’un type hérite de la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode), vous pouvez trouver son comportement indésirable et souhaitez le modifier. Cela est particulièrement vrai pour les tableaux et des classes de collection. Bien que vous pouvez vous attendre le `ToString` méthode d’une classe de collection ou du tableau pour afficher les valeurs de ses membres, il affiche à la place le nom de type qualifié complet de type, comme le montre l’exemple suivant.  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 Vous avez plusieurs options pour produire la chaîne de résultat que vous aimeriez.  
  
-   Si le type est un tableau, un objet de collection ou un objet qui implémente le <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interfaces, vous pouvez énumérer ses éléments à l’aide de la `foreach` instruction en c# ou le `For Each...Next` construire en Visual Basic.  
  
-   Si la classe n’est pas `sealed` (en c#) ou `NotInheritable` (en Visual Basic), vous pouvez développer une classe wrapper qui hérite de la classe de base dont la propriété <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode que vous souhaitez personnaliser. Au minimum, cela nécessite que vous procédez comme suit :  
  
    1.  Implémenter tous les constructeurs nécessaires. Les classes dérivées n’héritent pas de leurs constructeurs de classe de base.  
  
    2.  Remplacer le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner la chaîne de résultat que vous aimeriez.  
  
     L’exemple suivant définit une classe wrapper pour la <xref:System.Collections.Generic.List%601> classe. Ce paramètre remplace le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour afficher la valeur de chaque méthode de la collection plutôt que le nom de type qualifié complet.  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   Développer un [méthode d’extension](~/docs/standard/design-guidelines/extension-methods.md) qui retourne la chaîne de résultat que vous souhaitez. Notez que vous ne pouvez pas remplacer la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> de cette façon (méthode) (autrement dit, votre classe d’extension (en c#) ou le module (en Visual Basic) ne peut pas avoir une méthode sans paramètre nommée `ToString` qui est appelée à la place le type d’origine `ToString` (méthode) . Vous devrez fournir un autre nom pour votre sans paramètre `ToString` remplacement.  
  
     L’exemple suivant définit deux méthodes qui étendent le <xref:System.Collections.Generic.List%601> classe : un sans paramètre `ToString2` (méthode) et un `ToString` méthode avec un <xref:System.String> paramètre qui représente une chaîne de format.  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a>Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]  
 Lorsque vous appelez le <xref:System.Object.ToString%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.ToString%2A>. Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)). Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas toujours un <xref:System.Object.ToString%2A>. Toutefois, ils semblent toujours avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit un comportement par défaut pour ces méthodes.  
  
 En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)], le common language runtime utilisera [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) sur un [!INCLUDE[wrt](~/includes/wrt-md.md)] objet avant de revenir à l’implémentation par défaut de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.ToString%2A> (méthode).  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a>Le [!INCLUDE[wrt](~/includes/wrt-md.md)] et l’Interface IStringable  
 En commençant par [!INCLUDE[win81](~/includes/win81-md.md)], le [!INCLUDE[wrt](~/includes/wrt-md.md)] inclut un [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dont la méthode unique, l’interface [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), renforce leur base mise en forme comparable à celle fourni par <xref:System.Object.ToString%2A?displayProperty=nameWithType>. Pour éviter toute ambiguïté, vous ne devez pas implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur les types managés.  
  
 Lorsque les objets managés sont appelées par du code natif ou par du code écrit dans des langages tels que JavaScript ou C++ / c++ / CX, ils apparaissent pour implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx). Le common language runtime achemine automatiquement les appels à partir de [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) à <xref:System.Object.ToString%2A?displayProperty=nameWithType> de l’événement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) n’est pas implémentée sur l’objet managé.  
  
> [!WARNING]
>  Étant donné que le common language runtime automatique-implémente [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) pour tous les types dans managés [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications, nous recommandons que vous ne fournissez pas votre propre [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implémentation. Implémentation [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) peut entraîner un comportement inattendu lors de l’appel `ToString` à partir de la [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / c++ / CX ou JavaScript.  
  
 Si vous choisissez d’implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dans un type managé public qui est exporté dans un [!INCLUDE[wrt](~/includes/wrt-md.md)] composant, les restrictions suivantes s’appliquent :  
  
-   Vous pouvez définir le [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface uniquement dans une relation « la classe implémente », tels que  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     en C#, ou  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     en Visual Basic.  
  
-   Vous ne pouvez pas implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur une interface.  
  
-   Vous ne pouvez pas déclarer un paramètre de type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).  
  
-   [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ne peut pas être le type de retour d’une méthode, une propriété ou un champ.  
  
-   Vous ne pouvez pas masquer votre [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implémentation de classes de base à l’aide d’une définition de méthode telle que la suivante :  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     Au lieu de cela, le [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation doit toujours remplacer l’implémentation de classe de base. Vous pouvez masquer une implémentation `ToString` uniquement en l'appelant sur une instance de classe fortement typée.  
  
 Notez que dans diverses conditions, les appels à partir du code natif à un type managé qui implémente [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ou masque son [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation peut entraîner un comportement inattendu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Quand vous implémentez vos propres types, vous devez substituer la <see cref="M:System.Object.ToString" /> méthode pour retourner des valeurs qui sont significatives pour ces types. Classes dérivées qui requièrent davantage de contrôle sur la mise en forme que <see cref="M:System.Object.ToString" /> fournit peut implémenter la <see cref="T:System.IFormattable" /> interface. Son <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> méthode vous permet de définir des chaînes de format qui contrôlent la mise en forme et d’utiliser un <see cref="T:System.IFormatProvider" /> objet qui peut fournir pour la mise en forme propres à la culture.  
  
Remplacements de la <see cref="M:System.Object.ToString" /> méthode doit suivre ces instructions : 
-La chaîne retournée doit être convivial et lisible par les humains.  
  
-La chaîne retournée doit identifier de manière unique la valeur de l’instance d’objet.  
  
-La chaîne retournée doit être aussi courte que possible afin qu’il soit adapté à l’affichage par un débogueur.  
  
-Votre <see cref="M:System.Object.ToString" /> substitution ne doit pas retourner <see cref="F:System.String.Empty" /> ou une chaîne null.  
  
-Votre <see cref="M:System.Object.ToString" /> override ne doit pas lever une exception.  
  
-Si la représentation sous forme de chaîne d’une instance est dépendante de la culture ou peut être mise en forme de plusieurs façons, implémentez le <see cref="T:System.IFormattable" /> interface.  
  
-Si la chaîne retournée inclut des informations sensibles, vous devez tout d’abord demander une autorisation appropriée. Si la demande réussit, vous pouvez retourner des informations sensibles. Sinon, vous devez retourner une chaîne qui exclut les informations sensibles.  
  
-Votre <see cref="M:System.Object.ToString" /> remplacement ne doit avoir aucun effet secondaire observable afin d’éviter les complications lors du débogage. Par exemple, un appel à la <see cref="M:System.Object.ToString" /> méthode ne doit pas modifier la valeur de champs d’instance.  
  
-Si votre type implémente une méthode d’analyse (ou <see langword="Parse" /> ou <see langword="TryParse" /> (méthode), un constructeur ou une autre méthode statique qui instancie une instance du type à partir d’une chaîne), vous devez vous assurer que la chaîne retournée par la <see cref="M:System.Object.ToString" /> méthode peut être converti en une instance d’objet.</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Mettre en forme des types dans .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
