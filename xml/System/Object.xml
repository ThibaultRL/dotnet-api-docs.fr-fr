<Type Name="Object" FullName="System.Object">
  <Metadata><Meta Name="ms.openlocfilehash" Value="308002d9ae24d643fad3d891656bd69b93f39794" /><Meta Name="ms.sourcegitcommit" Value="3575d47a0ba065e8986f03d99279f478811907b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/20/2019" /><Meta Name="ms.locfileid" Value="65922721" /></Metadata><TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="13d87-101">Prend en charge toutes les classes dans la hiérarchie de classes .NET et fournit des services de bas niveau aux classes dérivées.</span><span class="sxs-lookup"><span data-stu-id="13d87-101">Supports all classes in the .NET class hierarchy and provides low-level services to derived classes.</span></span> <span data-ttu-id="13d87-102">Ceci est la classe de base fondamentale de toutes les classes .NET ; elle constitue la racine de la hiérarchie des types.</span><span class="sxs-lookup"><span data-stu-id="13d87-102">This is the ultimate base class of all .NET classes; it is the root of the type hierarchy.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-103">Langues ne nécessitent généralement pas une classe déclare l’héritage de <xref:System.Object> , car l’héritage est implicite.</span><span class="sxs-lookup"><span data-stu-id="13d87-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="13d87-104">Comme toutes les classes dans .NET sont dérivés de <xref:System.Object>, toutes les méthodes définies dans le <xref:System.Object> classe est disponible dans tous les objets dans le système.</span><span class="sxs-lookup"><span data-stu-id="13d87-104">Because all classes in .NET are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="13d87-105">Classes dérivées peuvent et substituer certaines de ces méthodes, notamment :</span><span class="sxs-lookup"><span data-stu-id="13d87-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="13d87-106"><xref:System.Object.Equals%2A> -Prend en charge les comparaisons entre objets.</span><span class="sxs-lookup"><span data-stu-id="13d87-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="13d87-107"><xref:System.Object.Finalize%2A> -Effectue des opérations de nettoyage avant qu’un objet est automatiquement récupéré.</span><span class="sxs-lookup"><span data-stu-id="13d87-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="13d87-108"><xref:System.Object.GetHashCode%2A> -Génère un nombre correspondant à la valeur de l’objet pour prendre en charge l’utilisation d’une table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="13d87-109"><xref:System.Object.ToString%2A> -Fabrique une chaîne de texte explicite qui décrit une instance de la classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="13d87-110">Considérations sur les performances</span><span class="sxs-lookup"><span data-stu-id="13d87-110">Performance Considerations</span></span>  
 <span data-ttu-id="13d87-111">Si vous concevez une classe, telle qu’une collection, qui doit gérer tout type d’objet, vous pouvez créer des membres de classe qui acceptent des instances de la <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="13d87-112">Toutefois, le processus de boxing et unboxing d’un type a une incidence sur les performances.</span><span class="sxs-lookup"><span data-stu-id="13d87-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="13d87-113">Si vous savez que votre nouvelle classe devra souvent gérer certains types valeur, vous pouvez utiliser une des deux solutions suivantes pour réduire le coût de conversion boxing.</span><span class="sxs-lookup"><span data-stu-id="13d87-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="13d87-114">Créer une méthode générale qui accepte un <xref:System.Object> type et un ensemble de surcharges de méthode spécifique au type qui acceptent chaque type de valeur que votre classe à gérer souvent.</span><span class="sxs-lookup"><span data-stu-id="13d87-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="13d87-115">Si une méthode spécifique au type existe qui accepte le type de paramètre appelant, aucun boxing se produit et la méthode spécifique au type est appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="13d87-116">S’il n’existe aucun argument de méthode qui correspond au type de paramètre appelant, le paramètre est boxed et la méthode générale est appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="13d87-117">Concevez votre type et ses membres pour utiliser des génériques.</span><span class="sxs-lookup"><span data-stu-id="13d87-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="13d87-118">Le common language runtime crée un type générique fermé lorsque vous créez une instance de votre classe et que vous spécifiez un argument de type générique.</span><span class="sxs-lookup"><span data-stu-id="13d87-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="13d87-119">La méthode générique est spécifique au type et peut être appelée sans avoir à évaluer le paramètre appelant.</span><span class="sxs-lookup"><span data-stu-id="13d87-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="13d87-120">Bien qu’il est parfois nécessaire de développer des classes à usage général qui acceptent et retournent <xref:System.Object> types, vous pouvez améliorer les performances en fournissant également une classe spécifique au type pour gérer un type fréquemment utilisé.</span><span class="sxs-lookup"><span data-stu-id="13d87-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="13d87-121">Par exemple, en fournissant une classe qui est spécifique à la définition et l’obtention des valeurs booléennes élimine le coût de conversion boxing et unboxing des valeurs booléennes.</span><span class="sxs-lookup"><span data-stu-id="13d87-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-122">L’exemple suivant définit un type Point dérivé le <xref:System.Object> classe et substitue un grand nombre de méthodes virtuelles de la <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="13d87-123">En outre, l’exemple montre comment appeler la plupart des statiques et les méthodes de l’instance la <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="13d87-124">Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe.</span><span class="sxs-lookup"><span data-stu-id="13d87-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="13d87-125">Membres d’instance ne sont pas garantis pour être thread-safe.</span><span class="sxs-lookup"><span data-stu-id="13d87-125">Instance members are not guaranteed to be thread-safe.</span></span></threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-126">Initialise une nouvelle instance de la classe <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="13d87-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-127">Ce constructeur est appelé par les constructeurs dans les classes dérivées, mais il peut également servir à créer directement une instance de la <xref:System.Object> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="13d87-128">Détermine si deux instances d'objets sont égales.</span><span class="sxs-lookup"><span data-stu-id="13d87-128">Determines whether two object instances are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="13d87-129">Objet à comparer à l'objet actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-129">The object to compare with the current object.</span></span></param>
        <summary><span data-ttu-id="13d87-130">Détermine si l'objet spécifié est identique à l'objet actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-130">Determines whether the specified object is equal to the current object.</span></span></summary>
        <returns><span data-ttu-id="13d87-131"><see langword="true" /> si l’objet spécifié est égal à l’objet actuel ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="13d87-131"><see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-132">Le type de comparaison entre l’instance actuelle et la `obj` paramètre varie selon que l’instance actuelle est un type référence ou un type valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="13d87-133">Si l’instance actuelle est un type référence, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de référence et un appel à la <xref:System.Object.Equals%28System.Object%29> méthode équivaut à un appel à la <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="13d87-134">L’égalité des références signifie que les variables d’objet sont comparés font référence au même objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="13d87-135">L’exemple suivant illustre le résultat de ce type de comparaison.</span><span class="sxs-lookup"><span data-stu-id="13d87-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="13d87-136">Il définit un `Person` (classe), qui est un type référence, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1a` et `person2`, qui ont la même valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="13d87-137">Il affecte également `person1a` à une autre variable d’objet, `person1b`.</span><span class="sxs-lookup"><span data-stu-id="13d87-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="13d87-138">Comme la sortie de l’exemple, `person1a` et `person1b` sont égales, car elles référencent le même objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="13d87-139">Toutefois, `person1a` et `person2` ne sont pas égaux, même si elles ont la même valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="13d87-140">Si l’instance actuelle est un type valeur, le <xref:System.Object.Equals%28System.Object%29> méthode teste l’égalité de valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="13d87-141">L’égalité des valeurs signifie que les éléments suivants :</span><span class="sxs-lookup"><span data-stu-id="13d87-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="13d87-142">Les deux objets sont du même type.</span><span class="sxs-lookup"><span data-stu-id="13d87-142">The two objects are of the same type.</span></span> <span data-ttu-id="13d87-143">Comme le montre l’exemple suivant, un <xref:System.Byte> objet qui a la valeur 12 n’est pas égale une <xref:System.Int32> objet qui a la valeur 12, étant donné que les deux objets ont différents types d’exécution.</span><span class="sxs-lookup"><span data-stu-id="13d87-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="13d87-144">Les valeurs des champs publics et privés des deux objets sont égaux.</span><span class="sxs-lookup"><span data-stu-id="13d87-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="13d87-145">L’exemple suivant teste l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-145">The following example tests for value equality.</span></span> <span data-ttu-id="13d87-146">Il définit un `Person` structure, qui est un type valeur, et appelle le `Person` constructeur de classe à instancier deux nouveaux `Person` objets, `person1` et `person2`, qui ont la même valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="13d87-147">Comme le montre la sortie de l’exemple, même si deux variables objets font référence à des objets différents, `person1` et `person2` sont égaux, car ils ont la même valeur pour le privé `personName` champ.</span><span class="sxs-lookup"><span data-stu-id="13d87-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="13d87-148">Étant donné que le <xref:System.Object> classe est la classe de base pour tous les types dans le .NET Framework, le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode fournit la comparaison d’égalité par défaut pour tous les autres types.</span><span class="sxs-lookup"><span data-stu-id="13d87-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="13d87-149">Toutefois, les types souvent remplacer le <xref:System.Object.Equals%2A> méthode pour implémenter l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="13d87-150">Pour plus d’informations, consultez les remarques pour les appelants et les notes de publication pour les sections les héritiers.</span><span class="sxs-lookup"><span data-stu-id="13d87-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="13d87-151">Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="13d87-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="13d87-152">Lorsque vous appelez le <xref:System.Object.Equals%28System.Object%29> surcharge de méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="13d87-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="13d87-153">Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="13d87-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="13d87-154">Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.Equals%28System.Object%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="13d87-155">Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="13d87-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="13d87-156">les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.Equals%28System.Object%29> surcharge de méthode.</span><span class="sxs-lookup"><span data-stu-id="13d87-156">classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="13d87-157">Notes de publication pour les appelants</span><span class="sxs-lookup"><span data-stu-id="13d87-157">Notes for Callers</span></span>  
 <span data-ttu-id="13d87-158">Les classes dérivées fréquemment substituer la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour implémenter l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="13d87-159">En outre, les types fournissent aussi fréquemment une surcharge supplémentaire fortement typée à le `Equals` (méthode), généralement en implémentant le <xref:System.IEquatable%601> interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="13d87-160">Lorsque vous appelez le `Equals` méthode pour tester l’égalité, vous devez savoir si l’instance actuelle substitue <xref:System.Object.Equals%2A?displayProperty=nameWithType> et comprendre comment un appel particulier à un `Equals` méthode est résolue.</span><span class="sxs-lookup"><span data-stu-id="13d87-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="13d87-161">Sinon, vous effectuer un test d’égalité est différente de ceux que vous aviez prévus, et la méthode peut retourner une valeur inattendue.</span><span class="sxs-lookup"><span data-stu-id="13d87-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="13d87-162">L'exemple suivant illustre cette situation.</span><span class="sxs-lookup"><span data-stu-id="13d87-162">The following example provides an illustration.</span></span> <span data-ttu-id="13d87-163">Il instancie trois <xref:System.Text.StringBuilder> objets avec des chaînes identiques et puis appelle les quatre à `Equals` méthodes.</span><span class="sxs-lookup"><span data-stu-id="13d87-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="13d87-164">La première méthode appeler retourne `true`et le retour de trois autres `false`.</span><span class="sxs-lookup"><span data-stu-id="13d87-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="13d87-165">Dans le premier cas, fortement typé <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> surcharge de méthode qui teste l’égalité des valeurs, est appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="13d87-166">Étant donné que les chaînes affectée aux deux <xref:System.Text.StringBuilder> objets sont égaux, la méthode retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="13d87-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="13d87-167">Toutefois, <xref:System.Text.StringBuilder> ne se substitue pas <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13d87-168">Pour cette raison, lorsque le <xref:System.Text.StringBuilder> objet est converti en un <xref:System.Object>, quand un <xref:System.Text.StringBuilder> instance est affectée à une variable de type <xref:System.Object>et à quel moment le <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> deux est transmis à la méthode <xref:System.Text.StringBuilder> objets, la valeur par défaut <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>méthode est appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="13d87-169">Étant donné que <xref:System.Text.StringBuilder> est un type référence, cela équivaut à passer les deux <xref:System.Text.StringBuilder> des objets sur le <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="13d87-170">Bien que les trois <xref:System.Text.StringBuilder> objets contiennent des chaînes identiques, ils font référence à trois objets distincts.</span><span class="sxs-lookup"><span data-stu-id="13d87-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="13d87-171">Par conséquent, ces trois appels de méthode retour `false`.</span><span class="sxs-lookup"><span data-stu-id="13d87-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="13d87-172">Vous pouvez comparer l’objet en cours à un autre objet l’égalité des références en appelant le <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="13d87-173">En Visual Basic, vous pouvez également utiliser le `is` mot clé (par exemple, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="13d87-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="13d87-174">Notes de publication pour les héritiers</span><span class="sxs-lookup"><span data-stu-id="13d87-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="13d87-175">Lorsque vous définissez votre propre type, ce type hérite des fonctionnalités définies par le `Equals` méthode de son type de base.</span><span class="sxs-lookup"><span data-stu-id="13d87-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="13d87-176">Le tableau suivant répertorie l’implémentation par défaut de la `Equals` méthode pour les principales catégories de types dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="13d87-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="13d87-177">Catégorie de type</span><span class="sxs-lookup"><span data-stu-id="13d87-177">Type category</span></span>|<span data-ttu-id="13d87-178">Égalité défini par</span><span class="sxs-lookup"><span data-stu-id="13d87-178">Equality defined by</span></span>|<span data-ttu-id="13d87-179">Commentaires</span><span class="sxs-lookup"><span data-stu-id="13d87-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="13d87-180">Classe dérivée directement à partir de <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="13d87-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="13d87-181">Égalité de référence ; équivalent à l’appel <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="13d87-182">Structure</span><span class="sxs-lookup"><span data-stu-id="13d87-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="13d87-183">Égalité des valeurs ; comparaison octet par octet directe ou comparaison de champ par champ à l’aide de la réflexion.</span><span class="sxs-lookup"><span data-stu-id="13d87-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="13d87-184">Énumération</span><span class="sxs-lookup"><span data-stu-id="13d87-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="13d87-185">Valeurs doivent avoir le même type d’énumération et la même valeur sous-jacente.</span><span class="sxs-lookup"><span data-stu-id="13d87-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="13d87-186">délégué</span><span class="sxs-lookup"><span data-stu-id="13d87-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="13d87-187">Les délégués doivent avoir le même type avec listes d’appel identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="13d87-188">Interface</span><span class="sxs-lookup"><span data-stu-id="13d87-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="13d87-189">Égalité de référence.</span><span class="sxs-lookup"><span data-stu-id="13d87-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="13d87-190">Pour un type valeur, vous devez toujours remplacer <xref:System.Object.Equals%2A>, car les tests d’égalité qui s’appuient sur la réflexion offrent des performances médiocres.</span><span class="sxs-lookup"><span data-stu-id="13d87-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="13d87-191">Vous pouvez également remplacer l’implémentation par défaut de <xref:System.Object.Equals%2A> pour les types de référence pour tester l’égalité des valeurs au lieu de l’égalité de référence et pour définir la signification précise de l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="13d87-192">De telles implémentations de <xref:System.Object.Equals%2A> retourner `true` si les deux objets ont la même valeur, même s’ils ne sont pas la même instance.</span><span class="sxs-lookup"><span data-stu-id="13d87-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="13d87-193">L’implémenteur du type décide ce qui constitue la valeur d’un objet, mais il est généralement tout ou partie des données stockées dans les variables d’instance de l’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="13d87-194">Par exemple, la valeur d’un <xref:System.String> objet est basé sur les caractères de la chaîne ; le <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> substitutions de méthode le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour retourner `true` pour les deux instances qui contiennent les mêmes caractères dans le même ordre de chaîne.</span><span class="sxs-lookup"><span data-stu-id="13d87-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="13d87-195">L’exemple suivant montre comment substituer la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode pour tester l’égalité de valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="13d87-196">Ce paramètre remplace le <xref:System.Object.Equals%2A> méthode pour la `Person` classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="13d87-197">Si `Person` accepté son implémentation de la classe de base de l’égalité, deux `Person` objets serait égales uniquement si elles référencé un objet unique.</span><span class="sxs-lookup"><span data-stu-id="13d87-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="13d87-198">Toutefois, dans ce cas, deux `Person` objets sont égaux s’ils ont la même valeur pour le `Person.Id` propriété.</span><span class="sxs-lookup"><span data-stu-id="13d87-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="13d87-199">Outre l’écrasement <xref:System.Object.Equals%2A>, vous pouvez implémenter la <xref:System.IEquatable%601> interface pour fournir un test fortement typé pour l’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="13d87-200">Les instructions suivantes doivent être remplies pour toutes les implémentations de la <xref:System.Object.Equals%28System.Object%29> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="13d87-201">Dans la liste, `x`, `y`, et `z` représentent des références d’objet qui ne sont pas **null**.</span><span class="sxs-lookup"><span data-stu-id="13d87-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="13d87-202">`x.Equals(x)` Retourne `true`, sauf dans les scénarios qui impliquent des types à virgule flottante.</span><span class="sxs-lookup"><span data-stu-id="13d87-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="13d87-203">Consultez [ISO/IEC/IEEE 60559:2011, l’arithmétique à virgule flottante de technologie--microprocesseur systèmes--informations](https://www.iso.org/standard/57469.html).</span><span class="sxs-lookup"><span data-stu-id="13d87-203">See [ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic](https://www.iso.org/standard/57469.html).</span></span>  
  
-   <span data-ttu-id="13d87-204">`x.Equals(y)` retourne la même valeur que `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="13d87-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="13d87-205">`x.Equals(y)` Retourne `true` si les deux `x` et `y` sont `NaN`.</span><span class="sxs-lookup"><span data-stu-id="13d87-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="13d87-206">Si `(x.Equals(y) && y.Equals(z))` retourne `true`, puis `x.Equals(z)` retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="13d87-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="13d87-207">Les appels successifs à `x.Equals(y)` retournent la même valeur tant que les objets référencés par `x` et `y` ne sont pas modifiés.</span><span class="sxs-lookup"><span data-stu-id="13d87-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="13d87-208">`x.Equals(null)` retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="13d87-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="13d87-209">Les implémentations de <xref:System.Object.Equals%2A> ne doit pas lever des exceptions ; elles doivent toujours retourner une valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="13d87-210">Par exemple, si `obj` est `null`, le <xref:System.Object.Equals%2A> méthode doit retourner `false` au lieu de lever un <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="13d87-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="13d87-211">Suivez ces instructions lors de la substitution <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="13d87-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="13d87-212">Types qui implémentent <xref:System.IComparable> doit remplacer <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="13d87-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="13d87-213">Les types qui substituent <xref:System.Object.Equals%28System.Object%29> doivent également substituer <xref:System.Object.GetHashCode%2A>; sinon, les tables de hachage peut ne pas fonctionneront correctement.</span><span class="sxs-lookup"><span data-stu-id="13d87-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="13d87-214">Vous devez envisager d’implémenter le <xref:System.IEquatable%601> interface pour prendre en charge fortement typées teste l’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="13d87-215">Votre <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implémentation doit retourner des résultats qui sont cohérents avec <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="13d87-216">Si votre langage de programmation prend en charge la surcharge d’opérateur et vous surchargez l’opérateur d’égalité pour un type donné, vous devez également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour retourner le même résultat que l’opérateur d’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="13d87-217">Cela permet de garantir que code de bibliothèque de classe qui utilise <xref:System.Object.Equals%2A> (tel que <xref:System.Collections.ArrayList> et <xref:System.Collections.Hashtable>) se comporte de manière cohérente avec le mode d’utilisation de l’opérateur d’égalité par le code d’application.</span><span class="sxs-lookup"><span data-stu-id="13d87-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="13d87-218">Instructions pour les Types référence</span><span class="sxs-lookup"><span data-stu-id="13d87-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="13d87-219">Les instructions suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type référence :</span><span class="sxs-lookup"><span data-stu-id="13d87-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="13d87-220">Pensez à substituer <xref:System.Object.Equals%2A> si la sémantique du type est le fait que le type représente une ou plusieurs valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="13d87-221">La plupart des types de référence ne doivent pas surcharger l’opérateur d’égalité, même si elles substituent <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="13d87-222">Toutefois, si vous implémentez un type référence qui doit avoir une sémantique de valeur, comme un type nombre complexe, vous devez substituer l’opérateur d’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="13d87-223">Vous ne devez pas substituer <xref:System.Object.Equals%2A> sur un type référence mutable.</span><span class="sxs-lookup"><span data-stu-id="13d87-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="13d87-224">Il s’agit, car la substitution de <xref:System.Object.Equals%2A> nécessite également remplacer le <xref:System.Object.GetHashCode%2A> (méthode), comme indiqué dans la section précédente.</span><span class="sxs-lookup"><span data-stu-id="13d87-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="13d87-225">Cela signifie que le code de hachage d’une instance d’un type référence mutable peut changer pendant sa durée de vie, ce qui peut entraîner l’objet à être perdues dans une table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="13d87-226">Instructions pour les Types valeur</span><span class="sxs-lookup"><span data-stu-id="13d87-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="13d87-227">Les instructions suivantes s’appliquent à la substitution de <xref:System.Object.Equals%28System.Object%29> pour un type de valeur :</span><span class="sxs-lookup"><span data-stu-id="13d87-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="13d87-228">Si vous définissez un type valeur qui inclut un ou plusieurs champs dont les valeurs sont des types référence, vous devez substituer <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="13d87-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="13d87-229">Le <xref:System.Object.Equals%28System.Object%29> implémentation fournie par <xref:System.ValueType> effectue une comparaison octet par octet pour les types de valeur dont les champs sont tous les types valeur, mais il utilise la réflexion pour effectuer une comparaison de champ par champ des types de valeur dont les champs incluent les types référence.</span><span class="sxs-lookup"><span data-stu-id="13d87-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="13d87-230">Si vous substituez <xref:System.Object.Equals%2A> et votre langage de développement prend en charge la surcharge d’opérateur, vous devez surcharger l’opérateur d’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="13d87-231">Vous devez implémenter le <xref:System.IEquatable%601> interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="13d87-232">Fortement typées <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> méthode évite le boxing le `obj` argument.</span><span class="sxs-lookup"><span data-stu-id="13d87-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-233">L’exemple suivant montre un `Point` classe qui remplace le <xref:System.Object.Equals%2A> méthode pour fournir l’égalité des valeurs et un `Point3D` classe qui est dérivée de `Point`.</span><span class="sxs-lookup"><span data-stu-id="13d87-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="13d87-234">Étant donné que `Point` substitue <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour tester l’égalité des valeurs, le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode n’est pas appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="13d87-235">Toutefois, `Point3D.Equals` appels `Point.Equals` car `Point` implémente <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> d’une manière qui fournit l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="13d87-236">Le `Point.Equals` méthode vérifie pour vous assurer que le `obj` argument n’est pas **null** et qu’il fait référence à une instance du même type que cet objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="13d87-237">Si une des vérifications échoue, la méthode retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="13d87-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="13d87-238">Le `Point.Equals` les appels de méthode le <xref:System.Object.GetType%2A> méthode pour déterminer si les types d’exécution des deux objets sont identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="13d87-239">Si la méthode a utilisé une vérification de la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic, elle retourne `true` dans les cas où `obj` est une instance d’une classe dérivée de `Point`, même si `obj` et actuel instance ne sont pas du même type d’exécution.</span><span class="sxs-lookup"><span data-stu-id="13d87-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="13d87-240">Après avoir vérifié que les deux objets sont du même type, les conversions de méthode `obj` à taper `Point` et retourne le résultat de la comparaison des champs d’instance des deux objets.</span><span class="sxs-lookup"><span data-stu-id="13d87-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="13d87-241">Dans `Point3D.Equals`, héritées `Point.Equals` (méthode), qui remplace <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, est appelée avant toute autre action.</span><span class="sxs-lookup"><span data-stu-id="13d87-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="13d87-242">Étant donné que `Point3D` est une classe sealed (`NotInheritable` en Visual Basic), une vérification sous la forme `obj is Point` en c# ou `TryCast(obj, Point)` en Visual Basic est suffisante pour vous assurer que `obj` est un `Point3D` objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="13d87-243">S’il s’agit une `Point3D` de l’objet, elle est convertie en un `Point` de l’objet et passée à l’implémentation de classe de base de <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="13d87-244">Uniquement lorsque héritées `Point.Equals` retourne de la méthode `true` est la méthode de comparer le `z` champs introduites dans la classe dérivée de l’instance.</span><span class="sxs-lookup"><span data-stu-id="13d87-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="13d87-245">L’exemple suivant définit un `Rectangle` classe qui implémente en interne un rectangle en tant que deux `Point` objets.</span><span class="sxs-lookup"><span data-stu-id="13d87-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="13d87-246">Le `Rectangle` classe également remplacements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> pour fournir l’égalité des valeurs.</span><span class="sxs-lookup"><span data-stu-id="13d87-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="13d87-247">Certains langages tels que c# et Visual Basic prennent en charge la surcharge d’opérateur.</span><span class="sxs-lookup"><span data-stu-id="13d87-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="13d87-248">Quand un type surcharge l’opérateur d’égalité, il doit également substituer la <xref:System.Object.Equals%28System.Object%29> méthode pour fournir les mêmes fonctionnalités.</span><span class="sxs-lookup"><span data-stu-id="13d87-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="13d87-249">Cela est généralement effectuée en écrivant la <xref:System.Object.Equals%28System.Object%29> méthode en termes de l’opérateur d’égalité surchargé, comme dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="13d87-250">Étant donné que `Complex` est un type valeur, il ne peut pas être dérivé.</span><span class="sxs-lookup"><span data-stu-id="13d87-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="13d87-251">Par conséquent, le remplacement <xref:System.Object.Equals%28System.Object%29> méthode ne doive pas appeler <xref:System.Object.GetType%2A> pour déterminer la durée d’exécution précise type de chaque objet, mais peut à la place utiliser la `is` opérateur en c# ou le `TypeOf` opérateur en Visual Basic pour vérifier le type de la `obj` paramètre.</span><span class="sxs-lookup"><span data-stu-id="13d87-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="13d87-252">Premier objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="13d87-252">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="13d87-253">Deuxième objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="13d87-253">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="13d87-254">Détermine si les instances d'objet spécifiées sont considérées comme égales.</span><span class="sxs-lookup"><span data-stu-id="13d87-254">Determines whether the specified object instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="13d87-255"><see langword="true" /> si les objets sont considérés comme identiques ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="13d87-255"><see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="13d87-256">Si <paramref name="objA" /> et <paramref name="objB" /> ont tous deux la valeur **null**, la méthode retourne <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="13d87-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-257">La méthode statique <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> méthode indique si deux objets, `objA` et `objB`, sont égales.</span><span class="sxs-lookup"><span data-stu-id="13d87-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="13d87-258">Il vous permet également de tester les objets dont la valeur est **null** d’égalité.</span><span class="sxs-lookup"><span data-stu-id="13d87-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="13d87-259">Il compare `objA` et `objB` l’égalité comme suit :</span><span class="sxs-lookup"><span data-stu-id="13d87-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="13d87-260">Il détermine si les deux objets représentent la même référence d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="13d87-261">S’ils le font, la méthode retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="13d87-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="13d87-262">Ce test équivaut à appeler le <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="13d87-263">En outre, si les deux `objA` et `objB` sont **null**, la méthode retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="13d87-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="13d87-264">Il détermine si soit `objA` ou `objB` est **null**.</span><span class="sxs-lookup"><span data-stu-id="13d87-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="13d87-265">Si, par conséquent, elle retourne `false`.</span><span class="sxs-lookup"><span data-stu-id="13d87-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="13d87-266">Si les deux objets ne représentent pas la même référence d’objet et aucune n’est **null**, il appelle `objA`.`Equals` (`objB`) et retourne le résultat.</span><span class="sxs-lookup"><span data-stu-id="13d87-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="13d87-267">Cela signifie que si `objA` remplace le <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> (méthode), ce remplacement est appelé.</span><span class="sxs-lookup"><span data-stu-id="13d87-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-268">L’exemple suivant illustre la <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> (méthode) et le compare avec la <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-269">Autorise un objet à tenter de libérer des ressources et à exécuter d'autres opérations de nettoyage avant qu'il ne soit récupéré par une opération garbage collection.</span><span class="sxs-lookup"><span data-stu-id="13d87-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-270">Le <xref:System.Object.Finalize%2A> méthode est utilisée pour effectuer des opérations de nettoyage sur les ressources non managées détenues par l’objet actuel avant la destruction de l’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="13d87-271">La méthode est protégée et par conséquent est accessible uniquement par le biais de cette classe ou une classe dérivée.</span><span class="sxs-lookup"><span data-stu-id="13d87-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="13d87-272">Dans cette section :</span><span class="sxs-lookup"><span data-stu-id="13d87-272">In this section:</span></span>  
  
-   [<span data-ttu-id="13d87-273">Fonctionne de la finalisation</span><span class="sxs-lookup"><span data-stu-id="13d87-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="13d87-274">Notes de publication pour les implémenteurs</span><span class="sxs-lookup"><span data-stu-id="13d87-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="13d87-275">L’alternative de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="13d87-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="13d87-276">Fonctionne de la finalisation</span><span class="sxs-lookup"><span data-stu-id="13d87-276">How finalization works</span></span>  
 <span data-ttu-id="13d87-277">Le <xref:System.Object> classe ne fournit pas d’implémentation pour le <xref:System.Object.Finalize%2A> (méthode) et que le garbage collector ne marque pas les types dérivés de <xref:System.Object> pour la finalisation, sauf si elles substituent la <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="13d87-278">Si un type remplace le <xref:System.Object.Finalize%2A> (méthode), le garbage collector ajoute une entrée pour chaque instance du type à une structure interne appelée la file d’attente de finalisation.</span><span class="sxs-lookup"><span data-stu-id="13d87-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="13d87-279">La file d’attente de finalisation contient des entrées pour tous les objets dans le tas managé dont le code de finalisation doit s’exécuter avant que le garbage collector puisse récupérer leur mémoire.</span><span class="sxs-lookup"><span data-stu-id="13d87-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="13d87-280">Le garbage collector appelle ensuite la <xref:System.Object.Finalize%2A> méthode automatiquement dans les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="13d87-281">Une fois que le garbage collector a découvert qu’un objet est inaccessible, sauf si l’objet a été exclu de finalisation par un appel à la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="13d87-282">**Sur .NET Framework uniquement**, pendant l’arrêt d’un domaine d’application, sauf si l’objet est exempté de la finalisation.</span><span class="sxs-lookup"><span data-stu-id="13d87-282">**On .NET Framework only**, during shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="13d87-283">Lors de l’arrêt, même des objets qui sont toujours accessibles sont finalisées.</span><span class="sxs-lookup"><span data-stu-id="13d87-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="13d87-284"><xref:System.Object.Finalize%2A> est automatiquement appelé qu’une seule fois sur une instance donnée, sauf si l’objet est réinscrit à l’aide d’un mécanisme tel que <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> et <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> méthode n’a pas été appelée par la suite.</span><span class="sxs-lookup"><span data-stu-id="13d87-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="13d87-285"><xref:System.Object.Finalize%2A> opérations présentent les limitations suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="13d87-286">L’heure exacte lorsque le finaliseur s’exécute n’est pas défini.</span><span class="sxs-lookup"><span data-stu-id="13d87-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="13d87-287">Pour garantir la mise en production déterministe des ressources pour implémenter des instances de votre classe, un `Close` méthode ou fournissez un <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation.</span><span class="sxs-lookup"><span data-stu-id="13d87-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="13d87-288">Les finaliseurs de deux objets ne sont pas garanties à exécuter dans un ordre spécifique, même si un objet fait référence à l’autre.</span><span class="sxs-lookup"><span data-stu-id="13d87-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="13d87-289">Autrement dit, si l’objet a une référence à l’objet B, et avoir des finaliseurs, l’objet B peut avoir déjà été finalisée lorsque le finaliseur de l’objet A démarre.</span><span class="sxs-lookup"><span data-stu-id="13d87-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="13d87-290">Le thread sur lequel s’exécute le finaliseur n’est pas spécifié.</span><span class="sxs-lookup"><span data-stu-id="13d87-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="13d87-291">Le <xref:System.Object.Finalize%2A> méthode ne peut pas s’exécuter jusqu'à la fin ou peut s’exécuter pas du tout dans les circonstances exceptionnelles suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="13d87-292">Si un autre finaliseur se bloque indéfiniment (entrera en une boucle infinie, tente d’obtenir un verrou, il peut obtenir jamais et ainsi de suite).</span><span class="sxs-lookup"><span data-stu-id="13d87-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="13d87-293">Étant donné que le runtime tente d’exécuter des finaliseurs jusqu'à son achèvement, autres finaliseurs ne pas être appelés si un finaliseur se bloque indéfiniment.</span><span class="sxs-lookup"><span data-stu-id="13d87-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="13d87-294">Si le processus se termine sans donner au runtime une chance à nettoyer.</span><span class="sxs-lookup"><span data-stu-id="13d87-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="13d87-295">Dans ce cas, la première notification d’arrêt du processus du runtime est une notification DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="13d87-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="13d87-296">Le runtime continue à finaliser des objets lors de l’arrêt aussi longtemps que le nombre d’objets finalisables diminuer.</span><span class="sxs-lookup"><span data-stu-id="13d87-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="13d87-297">Si <xref:System.Object.Finalize%2A> ou une substitution de <xref:System.Object.Finalize%2A> lève une exception et que le runtime n’est pas hébergée par une application qui substitue la stratégie par défaut, le runtime termine le processus et aucun actif `try` / `finally` blocs ou les finaliseurs sont exécutées.</span><span class="sxs-lookup"><span data-stu-id="13d87-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="13d87-298">Ce comportement garantit l’intégrité du processus si le finaliseur ne peut pas libérer ou détruire des ressources.</span><span class="sxs-lookup"><span data-stu-id="13d87-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="13d87-299">Remplacer la méthode Finalize</span><span class="sxs-lookup"><span data-stu-id="13d87-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="13d87-300">Vous devez substituer <xref:System.Object.Finalize%2A> pour une classe qui utilise des ressources non managées, telles que les descripteurs de fichiers ou des connexions de base de données qui doivent être lancées lorsque l’objet managé qui les utilise est ignorée pendant le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="13d87-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="13d87-301">Vous ne devez pas implémenter un <xref:System.Object.Finalize%2A> méthode pour les objets managés, car le garbage collector libère automatiquement les ressources managées.</span><span class="sxs-lookup"><span data-stu-id="13d87-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="13d87-302">Si un <xref:System.Runtime.InteropServices.SafeHandle> objet n’est disponible qui encapsule votre ressource non managée, l’alternative recommandée consiste à implémenter le modèle de suppression avec un handle sécurisé et substituez pas <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="13d87-303">Pour plus d’informations, consultez [alternative de SafeHandle The](#SafeHandle) section.</span><span class="sxs-lookup"><span data-stu-id="13d87-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="13d87-304">Le <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode ne fait rien par défaut, mais vous devez substituer <xref:System.Object.Finalize%2A> uniquement si nécessaire et uniquement pour libérer les ressources non managées.</span><span class="sxs-lookup"><span data-stu-id="13d87-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="13d87-305">Libération de la mémoire a tendance à prendre beaucoup plus de temps si une opération de finalisation est exécutée, car elle nécessite au moins deux garbage collections.</span><span class="sxs-lookup"><span data-stu-id="13d87-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="13d87-306">En outre, vous devez substituer la <xref:System.Object.Finalize%2A> types de méthode pour référence uniquement.</span><span class="sxs-lookup"><span data-stu-id="13d87-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="13d87-307">Le common language runtime finalise uniquement les types référence.</span><span class="sxs-lookup"><span data-stu-id="13d87-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="13d87-308">Il ignore les finaliseurs dans les types valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="13d87-309">L’étendue de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> méthode est `protected`.</span><span class="sxs-lookup"><span data-stu-id="13d87-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="13d87-310">Vous devez maintenir cette portée limitée lorsque vous substituez la méthode dans votre classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="13d87-311">En conservant un <xref:System.Object.Finalize%2A> méthode protégée, empêcher les utilisateurs de votre application à partir de l’appel d’un objet <xref:System.Object.Finalize%2A> directement la méthode.</span><span class="sxs-lookup"><span data-stu-id="13d87-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="13d87-312">Toutes les implémentations de <xref:System.Object.Finalize%2A> dans un type dérivé doit appeler implémentation de son type de base de <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="13d87-313">Ceci est le seul cas dans lequel application code est autorisé à appeler <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="13d87-314">D’un objet <xref:System.Object.Finalize%2A> méthode ne doit pas appeler une méthode sur tous les objets autres que ceux de sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="13d87-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="13d87-315">Il s’agit, car les autres objets appelées pu être collectées en même temps que l’objet appelant, comme dans le cas d’un arrêt de runtime de langage commun.</span><span class="sxs-lookup"><span data-stu-id="13d87-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="13d87-316">Le compilateur c# ne vous permet pas de substituer le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="13d87-317">Au lieu de cela, vous fournissez un finaliseur en implémentant un [destructeur](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) pour votre classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="13d87-318">Un destructeur c# appelle automatiquement le destructeur de sa classe de base.</span><span class="sxs-lookup"><span data-stu-id="13d87-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="13d87-319">Visual C++ fournit aussi sa propre syntaxe pour l’implémentation de la <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="13d87-320">Pour plus d’informations, consultez la section « Destructeurs et finaliseurs » de [Comment : Définir et consommer des Classes et Structs (C++ / c++ / CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="13d87-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](https://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="13d87-321">Étant donné que le garbage collection est non déterministe, vous ne savez pas précisément lorsque le garbage collector effectue la finalisation.</span><span class="sxs-lookup"><span data-stu-id="13d87-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="13d87-322">Pour libérer les ressources immédiatement, vous pouvez également choisir d’implémenter le [dispose, modèle](~/docs/standard/garbage-collection/implementing-dispose.md) et <xref:System.IDisposable> interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="13d87-323">Le <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implémentation peut être appelée par les consommateurs de votre classe pour libérer les ressources non managées, et vous pouvez utiliser la <xref:System.Object.Finalize%2A> méthode pour libérer les ressources non managées dans le cas où la <xref:System.IDisposable.Dispose%2A> méthode n’est pas appelée.</span><span class="sxs-lookup"><span data-stu-id="13d87-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="13d87-324"><xref:System.Object.Finalize%2A> peut effectuer presque toute action, y compris ressusciter (un objet qui rendre à nouveau accessible) a été nettoyé pendant le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="13d87-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="13d87-325">Toutefois, l’objet peut uniquement être réactivé une seule fois ; <xref:System.Object.Finalize%2A> ne peut pas être appelée sur des objets ressuscités pendant le garbage collection.</span><span class="sxs-lookup"><span data-stu-id="13d87-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span>
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="13d87-326">L'alternative de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="13d87-326">The SafeHandle alternative</span></span>  
 <span data-ttu-id="13d87-327">Création des finaliseurs fiables est souvent difficile, car vous ne pouvez pas faire d’hypothèses concernant l’état de votre application et non prise en charge des exceptions de système comme <xref:System.OutOfMemoryException> et <xref:System.StackOverflowException> terminer le finaliseur.</span><span class="sxs-lookup"><span data-stu-id="13d87-327">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="13d87-328">Au lieu d’implémenter un finaliseur pour votre classe pour libérer les ressources non managées, vous pouvez utiliser un objet qui est dérivé de la <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> classe pour encapsuler vos ressources non managées et implémentez le modèle de suppression sans un finaliseur.</span><span class="sxs-lookup"><span data-stu-id="13d87-328">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="13d87-329">Le .NET Framework fournit les classes suivantes dans le <xref:Microsoft.Win32?displayProperty=nameWithType> espace de noms qui sont dérivés de <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="13d87-329">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="13d87-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> est une classe wrapper pour un handle de fichier.</span><span class="sxs-lookup"><span data-stu-id="13d87-330"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="13d87-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> est une classe wrapper pour les descripteurs de fichier mappé en mémoire.</span><span class="sxs-lookup"><span data-stu-id="13d87-331"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="13d87-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> est une classe wrapper pour un pointeur vers un bloc de mémoire non managée.</span><span class="sxs-lookup"><span data-stu-id="13d87-332"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="13d87-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, et <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sont des classes wrapper pour les descripteurs de chiffrement.</span><span class="sxs-lookup"><span data-stu-id="13d87-333"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="13d87-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> est une classe wrapper pour des handles de canal.</span><span class="sxs-lookup"><span data-stu-id="13d87-334"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="13d87-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> est une classe wrapper pour un handle vers une clé de Registre.</span><span class="sxs-lookup"><span data-stu-id="13d87-335"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="13d87-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> est une classe wrapper pour un handle d’attente.</span><span class="sxs-lookup"><span data-stu-id="13d87-336"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="13d87-337">L’exemple suivant utilise le [dispose, modèle](~/docs/standard/garbage-collection/implementing-dispose.md) avec des handles sécurisés au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-337">The following example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="13d87-338">Il définit un `FileAssociation` classe qui encapsule les informations de Registre sur l’application qui gère les fichiers avec une extension de fichier particulier.</span><span class="sxs-lookup"><span data-stu-id="13d87-338">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="13d87-339">Les handles de deux Registre retournés en tant que `out` paramètres par Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) appels de fonction sont passés à la <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-339">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](https://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="13d87-340">Le type protégé `Dispose` méthode appelle ensuite la `SafeRegistryHandle.Dispose` méthode pour libérer ces deux poignées.</span><span class="sxs-lookup"><span data-stu-id="13d87-340">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="13d87-341">L’exemple suivant vérifie que le <xref:System.Object.Finalize%2A> méthode est appelée lorsqu’un objet qui substitue <xref:System.Object.Finalize%2A> est détruit.</span><span class="sxs-lookup"><span data-stu-id="13d87-341">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="13d87-342">Notez que, dans une application de production, le <xref:System.Object.Finalize%2A> méthode est substituée pour libérer les ressources non managées détenues par l’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-342">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="13d87-343">Notez également que l’exemple c# fournit un destructeur au lieu de remplacer le <xref:System.Object.Finalize%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-343">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="13d87-344">Pour obtenir un exemple supplémentaire qui remplace le <xref:System.Object.Finalize%2A> (méthode), consultez le <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-344">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-345">Fait office de fonction de hachage par défaut.</span><span class="sxs-lookup"><span data-stu-id="13d87-345">Serves as the default hash function.</span></span></summary>
        <returns><span data-ttu-id="13d87-346">Code de hachage pour l'objet actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-346">A hash code for the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-347">Un code de hachage est une valeur numérique qui est utilisée pour insérer et identifier un objet dans une collection basée sur le hachage comme le <xref:System.Collections.Generic.Dictionary%602> (classe), le <xref:System.Collections.Hashtable> classe ou un type dérivé la <xref:System.Collections.DictionaryBase> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-347">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="13d87-348">Le <xref:System.Object.GetHashCode%2A> méthode fournit ce code de hachage pour les algorithmes nécessitant des contrôles rapides de l’égalité d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-348">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="13d87-349">Pour plus d’informations sur l’utilisation des codes de hachage dans les tables de hachage et pour certains algorithmes de code de hachage supplémentaires, consultez le [fonction de hachage](https://en.wikipedia.org/wiki/Hash_function) entrée dans Wikipedia.</span><span class="sxs-lookup"><span data-stu-id="13d87-349">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="13d87-350">Deux objets qui sont des codes de hachage de retour égale sont égaux.</span><span class="sxs-lookup"><span data-stu-id="13d87-350">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="13d87-351">Toutefois, l’inverse n’est pas vrai : codes de hachage égales n’impliquent pas de l’égalité d’objet, car différents objets (inégaux) peuvent avoir des codes de hachage identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-351">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="13d87-352">En outre, .NET ne garantit pas l’implémentation par défaut de la <xref:System.Object.GetHashCode%2A> méthode et la valeur de cette méthode est retournée peut varier entre les implémentations de .NET, telles que les différentes versions de .NET Framework et .NET Core et les plateformes, telles que 32 bits et plateformes 64 bits.</span><span class="sxs-lookup"><span data-stu-id="13d87-352">Furthermore, .NET does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET implementations, such as different versions of .NET Framework and .NET Core, and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="13d87-353">Pour ces raisons, n’utilisez pas l’implémentation par défaut de cette méthode comme un identificateur d’objet unique à des fins hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-353">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="13d87-354">Suivent les deux conséquences de cela :</span><span class="sxs-lookup"><span data-stu-id="13d87-354">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="13d87-355">Vous ne devez pas supposer que les codes de hachage égales impliquent l’égalité d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-355">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="13d87-356">Vous ne devez jamais conserver ou utiliser un code de hachage en dehors du domaine d’application dans lequel il a été créé, car le même objet peuvent être hachées sur les plateformes, processus et domaines d’application.</span><span class="sxs-lookup"><span data-stu-id="13d87-356">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="13d87-357">Un code de hachage est destiné aux efficace d’insertion et de recherche dans les collections sont basées sur une table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-357">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="13d87-358">Un code de hachage n’est pas une valeur permanente.</span><span class="sxs-lookup"><span data-stu-id="13d87-358">A hash code is not a permanent value.</span></span> <span data-ttu-id="13d87-359">Pour cette raison :</span><span class="sxs-lookup"><span data-stu-id="13d87-359">For this reason:</span></span>  
>   
> -   <span data-ttu-id="13d87-360">Ne pas sérialiser les valeurs de code de hachage ou les stocker dans les bases de données.</span><span class="sxs-lookup"><span data-stu-id="13d87-360">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="13d87-361">N’utilisez pas le code de hachage comme clé pour récupérer un objet à partir d’une collection à clé.</span><span class="sxs-lookup"><span data-stu-id="13d87-361">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="13d87-362">Ne pas envoyer les codes de hachage entre les domaines d’application ou processus.</span><span class="sxs-lookup"><span data-stu-id="13d87-362">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="13d87-363">Dans certains cas, les codes de hachage peuvent être calculées sur une base de domaine par processus ou par application.</span><span class="sxs-lookup"><span data-stu-id="13d87-363">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="13d87-364">N’utilisez pas le code de hachage au lieu d’une valeur renvoyée par une fonction de hachage cryptographique, si vous avez besoin d’un hachage de chiffrement fort.</span><span class="sxs-lookup"><span data-stu-id="13d87-364">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="13d87-365">Pour les hachages de chiffrement, utilisez une classe dérivée de la <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-365">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="13d87-366">Ne testez pas l’égalité des codes de hachage pour déterminer si deux objets sont égaux.</span><span class="sxs-lookup"><span data-stu-id="13d87-366">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="13d87-367">(Les objets inégales peuvent avoir des codes de hachage identiques.) Pour tester l’égalité, appelez le <xref:System.Object.ReferenceEquals%2A> ou <xref:System.Object.Equals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-367">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="13d87-368">Le <xref:System.Object.GetHashCode%2A> méthode peut être substituée par un type dérivé.</span><span class="sxs-lookup"><span data-stu-id="13d87-368">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="13d87-369">Si <xref:System.Object.GetHashCode%2A> est ne pas substituée, codes de hachage pour les types référence sont calculées en appelant le <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> méthode de la classe de base, qui calcule un code de hachage basée sur la référence d’un objet ; pour plus d’informations, consultez <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-369">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13d87-370">En d’autres termes, deux objets pour lesquels le <xref:System.Object.ReferenceEquals%2A> méthode retourne `true` ont des codes de hachage identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-370">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="13d87-371">Si les types valeur ne substituent pas <xref:System.Object.GetHashCode%2A>, le <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> méthode de la classe de base utilise la réflexion pour calculer le code de hachage basé sur les valeurs des champs du type.</span><span class="sxs-lookup"><span data-stu-id="13d87-371">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="13d87-372">En d’autres termes, les types de valeur dont les champs ont des valeurs égales ont des codes de hachage égales.</span><span class="sxs-lookup"><span data-stu-id="13d87-372">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="13d87-373">Pour plus d’informations sur la substitution de <xref:System.Object.GetHashCode%2A>, consultez la section « Remarques à l’attention des héritiers ».</span><span class="sxs-lookup"><span data-stu-id="13d87-373">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="13d87-374">Si vous remplacez le <xref:System.Object.GetHashCode%2A> (méthode), vous devez également substituer <xref:System.Object.Equals%2A>et vice versa.</span><span class="sxs-lookup"><span data-stu-id="13d87-374">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="13d87-375">Si votre substituée <xref:System.Object.Equals%2A> retourne de la méthode `true` lorsque deux objets sont testées pour l’égalité, votre substituée <xref:System.Object.GetHashCode%2A> méthode doit retourner la même valeur pour les deux objets.</span><span class="sxs-lookup"><span data-stu-id="13d87-375">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="13d87-376">Si un objet qui est utilisé en tant que clé dans une table de hachage ne fournit pas une implémentation utile de <xref:System.Object.GetHashCode%2A>, vous pouvez spécifier un fournisseur de code de hachage en fournissant un <xref:System.Collections.IEqualityComparer> implémentation à une des surcharges de la <xref:System.Collections.Hashtable> constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-376">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="13d87-377">Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="13d87-377">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="13d87-378">Lorsque vous appelez le <xref:System.Object.GetHashCode%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-378">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="13d87-379">Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="13d87-379">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="13d87-380">Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas actuellement un <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-380">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and currently don't implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="13d87-381">Toutefois, ils semblent avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit le comportement par défaut pour ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="13d87-381">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="13d87-382">les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.GetHashCode%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-382">classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-383">Une des manières plus simples pour calculer un code de hachage pour une valeur numérique qui a le même ou une plage plus petite que la <xref:System.Int32> type consiste à simplement retourner cette valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-383">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="13d87-384">L’exemple suivant montre une telle implémentation pour un `Number` structure.</span><span class="sxs-lookup"><span data-stu-id="13d87-384">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="13d87-385">Souvent, un type a plusieurs champs de données qui peuvent participer à la génération du code de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-385">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="13d87-386">Permet de générer un code de hachage consiste à combiner ces champs à l’aide un `XOR (eXclusive OR)` opération, comme indiqué dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-386">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="13d87-387">L’exemple précédent retourne le même code de hachage pour (n1, n2) et (n2, n1) et par conséquent, peut générer des collisions que sont souhaitables.</span><span class="sxs-lookup"><span data-stu-id="13d87-387">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="13d87-388">Plusieurs solutions sont disponibles afin que les codes de hachage dans ces cas ne sont pas identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-388">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="13d87-389">Une consiste à retourner le code de hachage d’un `Tuple` objet qui reflète l’ordre de chaque champ.</span><span class="sxs-lookup"><span data-stu-id="13d87-389">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="13d87-390">L’exemple suivant montre une implémentation possible qui utilise le <xref:System.Tuple%602> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-390">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="13d87-391">Notez, cependant, que la surcharge de performances de l’instanciation d’un `Tuple` objet peut affecter considérablement les performances globales d’une application qui stocke un grand nombre d’objets dans les tables de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-391">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="13d87-392">Une autre solution de remplacement implique les codes de hachage individuels de pondération en décalant les codes de hachage des champs successives à gauche par deux ou plusieurs bits.</span><span class="sxs-lookup"><span data-stu-id="13d87-392">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="13d87-393">Idéalement, au lieu d’être ignorés, les bits décalés au-delà de bit 31 doivent habiller plutôt qu’ignorées.</span><span class="sxs-lookup"><span data-stu-id="13d87-393">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="13d87-394">Étant donné que les bits sont ignorés par les opérateurs de décalage vers la gauche en c# et Visual Basic, cela requiert la création d’une méthode MAJ-wrap gauche comme suit :</span><span class="sxs-lookup"><span data-stu-id="13d87-394">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="13d87-395">L’exemple suivant utilise ensuite cette méthode MAJ-wrap pour calculer le code de hachage de la `Point` structure utilisée dans les exemples précédents.</span><span class="sxs-lookup"><span data-stu-id="13d87-395">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="13d87-396">Une fonction de hachage est utilisée pour générer rapidement un nombre (code de hachage) qui correspond à la valeur d’un objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-396">A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object.</span></span> <span data-ttu-id="13d87-397">Fonctions de hachage sont généralement spécifiques à chaque type et, pour l’unicité, doivent utiliser au moins un des champs d’instance en tant qu’entrée.</span><span class="sxs-lookup"><span data-stu-id="13d87-397">Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input.</span></span> <span data-ttu-id="13d87-398">Codes de hachage ne doivent pas être calculées en utilisant les valeurs des champs statiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-398">Hash codes should not be computed by using the values of static fields.</span></span>  
  
<span data-ttu-id="13d87-399">Pour les classes dérivées à partir de <see cref="T:System.Object" />, le <see langword="GetHashCode" /> méthode permettre déléguer à la classe de base <see cref="M:System.Object.GetHashCode" /> implémentation uniquement si la classe dérivée définit l’égalité à une égalité de référence.</span><span class="sxs-lookup"><span data-stu-id="13d87-399">For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality.</span></span> <span data-ttu-id="13d87-400">L’implémentation par défaut de <see cref="M:System.Object.GetHashCode" /> pour référence types retourne un code de hachage qui est équivalent à celui retourné par la <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-400">The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method.</span></span> <span data-ttu-id="13d87-401">Vous pouvez remplacer <see cref="M:System.Object.GetHashCode" /> pour les types référence immuable.</span><span class="sxs-lookup"><span data-stu-id="13d87-401">You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types.</span></span> <span data-ttu-id="13d87-402">En règle générale, pour les types référence mutables, vous devez substituer <see cref="M:System.Object.GetHashCode" /> uniquement si :</span><span class="sxs-lookup"><span data-stu-id="13d87-402">In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:</span></span> 
<span data-ttu-id="13d87-403">-Vous pouvez calculer le code de hachage à partir des champs qui ne sont pas mutables ; ou</span><span class="sxs-lookup"><span data-stu-id="13d87-403">-   You can compute the hash code from fields that are not mutable; or</span></span> 
<span data-ttu-id="13d87-404">-Vous pouvez vous assurer que le code de hachage d’un objet mutable ne change pas pendant que l’objet est contenu dans une collection qui s’appuie sur son code de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-404">-   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.</span></span>  
  
<span data-ttu-id="13d87-405">Sinon, vous pourriez penser que l’objet mutable est perdue au cours de la table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-405">Otherwise, you might think that the mutable object is lost in the hash table.</span></span> <span data-ttu-id="13d87-406">Si vous choisissez de remplacer <see cref="M:System.Object.GetHashCode" /> pour un type référence mutable, la documentation doit indiquer clairement que les utilisateurs de votre type ne devraient pas modifier les valeurs d’objet tandis que l’objet est stocké dans une table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-406">If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.</span></span>  
  
<span data-ttu-id="13d87-407">Pour les types valeur, <see cref="M:System.ValueType.GetHashCode" /> fournit une implémentation de code de hachage par défaut qui utilise la réflexion.</span><span class="sxs-lookup"><span data-stu-id="13d87-407">For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection.</span></span> <span data-ttu-id="13d87-408">Vous devez envisager de substitution pour de meilleures performances.</span><span class="sxs-lookup"><span data-stu-id="13d87-408">You should consider overriding it for better performance.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="13d87-409">Pour plus d’informations et des exemples de codes de hachage de plusieurs façons de calcul, consultez la section Exemples.</span><span class="sxs-lookup"><span data-stu-id="13d87-409">For more information and examples that compute hash codes in a variety of ways, see the Examples section.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="13d87-410">Une fonction de hachage doit avoir les propriétés suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-410">A hash function must have the following properties:</span></span> 
<span data-ttu-id="13d87-411">-Si deux objets sont considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthode pour chaque objet doit retourner la même valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-411">-   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value.</span></span> <span data-ttu-id="13d87-412">Toutefois, si deux objets ne sont pas considérés comme égaux, la <see cref="M:System.Object.GetHashCode" /> méthodes pour les deux objets n’ont pas à retourner des valeurs différentes.</span><span class="sxs-lookup"><span data-stu-id="13d87-412">However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.</span></span>  
  
<span data-ttu-id="13d87-413">-Le <see cref="M:System.Object.GetHashCode" /> méthode pour un objet doit constamment retourner le même code de hachage tant qu’il n’existe aucune modification de l’état de l’objet qui détermine la valeur de retour de l’objet [System.Object.Equals](xref:System.Object.Equals*) (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-413">-   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method.</span></span> <span data-ttu-id="13d87-414">Notez que cela est vrai uniquement pour l’exécution en cours d’une application, et qu’un code de hachage différent peut être retourné si l’application est exécutée à nouveau.</span><span class="sxs-lookup"><span data-stu-id="13d87-414">Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.</span></span>  
  
<span data-ttu-id="13d87-415">-Pour des performances optimales, une fonction de hachage doit générer une distribution uniforme pour toutes les entrées, y compris les entrées qui sont largement mis en cluster.</span><span class="sxs-lookup"><span data-stu-id="13d87-415">-   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered.</span></span> <span data-ttu-id="13d87-416">Une conséquence est que les petites modifications à l’état de l’objet doivent entraîner de modifications importantes apportées au code de hachage qui en résulte pour de meilleures performances de table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-416">An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.</span></span>  
  
<span data-ttu-id="13d87-417">-Fonctions de hachage doivent être peu coûteuses à calculer.</span><span class="sxs-lookup"><span data-stu-id="13d87-417">-   Hash functions should be inexpensive to compute.</span></span>  
  
<span data-ttu-id="13d87-418">-Le <see cref="M:System.Object.GetHashCode" /> méthode lever d’exceptions.</span><span class="sxs-lookup"><span data-stu-id="13d87-418">-   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.</span></span>  
  
<span data-ttu-id="13d87-419">Par exemple, l’implémentation de la <see cref="M:System.String.GetHashCode" /> méthode fournie par le <see cref="T:System.String" /> classe retourne des codes de hachage identiques pour les valeurs de chaîne identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-419">For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values.</span></span> <span data-ttu-id="13d87-420">Par conséquent, deux <see cref="T:System.String" /> objets retournent le même code de hachage si elles représentent la même valeur de chaîne.</span><span class="sxs-lookup"><span data-stu-id="13d87-420">Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value.</span></span> <span data-ttu-id="13d87-421">En outre, la méthode utilise tous les caractères dans la chaîne pour générer la sortie distribuée de manière raisonnablement aléatoire, même lorsque l’entrée est ordonnée en clusters dans certaines plages (par exemple, les nombreux utilisateurs peuvent posséder des chaînes qui contiennent uniquement les 128 caractères ASCII inférieurs, même si un chaîne peut contenir les caractères Unicode 65 535).</span><span class="sxs-lookup"><span data-stu-id="13d87-421">Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).</span></span>  
  
<span data-ttu-id="13d87-422">En fournissant une bonne fonction de hachage sur une classe peut affecter considérablement les performances de l’ajout de ces objets à une table de hachage.</span><span class="sxs-lookup"><span data-stu-id="13d87-422">Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table.</span></span> <span data-ttu-id="13d87-423">Dans une table de hachage avec des clés qui fournissent une implémentation correcte d’une fonction de hachage, la recherche d’un élément prend un temps constant (par exemple, il s’agit d’une opération o (1)).</span><span class="sxs-lookup"><span data-stu-id="13d87-423">In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation).</span></span> <span data-ttu-id="13d87-424">Dans une table de hachage avec une mauvaise implémentation d’une fonction de hachage, les performances d’une recherche varie selon le nombre d’éléments dans la table de hachage (par exemple, un O (`n`) opération, où `n` est le nombre d’éléments dans la table de hachage).</span><span class="sxs-lookup"><span data-stu-id="13d87-424">In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table).</span></span> <span data-ttu-id="13d87-425">Un utilisateur malveillant peut entrer des données qui augmente le nombre de collisions, ce qui peut dégrader considérablement les performances des applications qui dépendent des tables de hachage, dans les conditions suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-425">A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:</span></span> 
<span data-ttu-id="13d87-426">-Lorsque les fonctions de hachage produisent des collisions fréquentes.</span><span class="sxs-lookup"><span data-stu-id="13d87-426">-   When hash functions produce frequent collisions.</span></span>  
  
<span data-ttu-id="13d87-427">-Lorsque une proportion importante des objets dans une table de hachage à générer des codes de hachage qui sont égales ou approximativement égal à l’autre.</span><span class="sxs-lookup"><span data-stu-id="13d87-427">-   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.</span></span>  
  
<span data-ttu-id="13d87-428">-Lorsque les utilisateurs d’entrée les données à partir de laquelle le code de hachage est calculé.</span><span class="sxs-lookup"><span data-stu-id="13d87-428">-   When users input the data from which the hash code is computed.</span></span>  
  
<span data-ttu-id="13d87-429">Classes dérivées qui substituent <see cref="M:System.Object.GetHashCode" /> doivent également substituer <see cref="M:System.Object.Equals(System.Object)" /> afin de garantir que les deux objets sont considérés comme égaux ont le même code de hachage ; sinon, le <see cref="T:System.Collections.Hashtable" /> type peuvent ne pas fonctionne correctement.</span><span class="sxs-lookup"><span data-stu-id="13d87-429">Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</span></span></para></block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-430">Obtient le <see cref="T:System.Type" /> de l'instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="13d87-430">Gets the <see cref="T:System.Type" /> of the current instance.</span></span></summary>
        <returns><span data-ttu-id="13d87-431">Type exact de l'instance actuelle au moment de l'exécution.</span><span class="sxs-lookup"><span data-stu-id="13d87-431">The exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-432">Étant donné que <xref:System.Object?displayProperty=nameWithType> est la classe de base pour tous les types dans .NET, système, tapez le <xref:System.Object.GetType%2A> méthode peut être utilisée pour retourner <xref:System.Type> objets qui représentent tous les types .NET.</span><span class="sxs-lookup"><span data-stu-id="13d87-432">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET types.</span></span> <span data-ttu-id="13d87-433">.NET reconnaît les cinq catégories de types suivantes :</span><span class="sxs-lookup"><span data-stu-id="13d87-433">.NET recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="13d87-434">Classes, qui sont dérivés de <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="13d87-434">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="13d87-435">Types valeur, qui sont dérivées de <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-435">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="13d87-436">Interfaces, qui sont dérivés de <xref:System.Object?displayProperty=nameWithType> en commençant par le .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="13d87-436">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="13d87-437">Énumérations qui sont dérivées de <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-437">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="13d87-438">Les délégués sont dérivés de <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-438">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="13d87-439">Pour les deux objets `x` et `y` qui comportent des types de runtime identiques, `Object.ReferenceEquals(x.GetType(),y.GetType())` retourne `true`.</span><span class="sxs-lookup"><span data-stu-id="13d87-439">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="13d87-440">L’exemple suivant utilise le <xref:System.Object.GetType%2A> méthode avec le <xref:System.Object.ReferenceEquals%2A> méthode pour déterminer si une valeur numérique est du même type que deux autres valeurs numériques.</span><span class="sxs-lookup"><span data-stu-id="13d87-440">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="13d87-441">Pour déterminer si un objet est un type spécifique, vous pouvez utiliser le mot clé de comparaison du type de votre langage ou construire.</span><span class="sxs-lookup"><span data-stu-id="13d87-441">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="13d87-442">Par exemple, vous pouvez utiliser la `TypeOf…Is` construire en Visual Basic ou le `is` mot clé en c#.</span><span class="sxs-lookup"><span data-stu-id="13d87-442">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="13d87-443">Le <xref:System.Object.GetType%2A> méthode est héritée par tous les types qui dérivent de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="13d87-443">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="13d87-444">Cela signifie que, outre à l’aide du mot clé de comparaison de votre propre langage, vous pouvez utiliser la <xref:System.Object.GetType%2A> méthode pour déterminer le type d’un objet particulier, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-444">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="13d87-445">Le <xref:System.Type> objet expose les métadonnées associées à la classe de l’actuel <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="13d87-445">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-446">L’exemple de code suivant montre que <xref:System.Object.GetType%2A> retourne le type de runtime de l’instance actuelle.</span><span class="sxs-lookup"><span data-stu-id="13d87-446">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-447">Crée une copie superficielle du <see cref="T:System.Object" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-447">Creates a shallow copy of the current <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="13d87-448">Copie superficielle du <see cref="T:System.Object" /> actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-448">A shallow copy of the current <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-449">Le <xref:System.Object.MemberwiseClone%2A> méthode crée une copie superficielle en créant un nouvel objet, puis en copiant les champs non statiques de l’objet actuel vers le nouvel objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-449">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="13d87-450">Si un champ est un type valeur, une copie bit par bit du champ est effectuée.</span><span class="sxs-lookup"><span data-stu-id="13d87-450">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="13d87-451">Si un champ est un type référence, la référence est copiée, mais l’objet référencé n’est pas. Par conséquent, l’objet d’origine et son clone font référence au même objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-451">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="13d87-452">Par exemple, considérez un objet appelé X qui fait référence à son tour, les objets A et B, C. Une copie superficielle de X crée le nouvel objet X2 qui référence également des objets A et B. En revanche, une copie complète de X crée un nouvel objet X2 qui référence les nouveaux objets A2 et B2, qui sont des copies de A et B. B2 référence à son tour, le nouvel objet C2, qui est une copie de C. L’exemple illustre la différence entre un shallow et une opération de copie complète.</span><span class="sxs-lookup"><span data-stu-id="13d87-452">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="13d87-453">Il existe plusieurs façons d’implémenter une opération de copie complète si l’opération de copie superficielle exécutée par le <xref:System.Object.MemberwiseClone%2A> méthode ne répond pas à vos besoins.</span><span class="sxs-lookup"><span data-stu-id="13d87-453">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="13d87-454">Notamment :</span><span class="sxs-lookup"><span data-stu-id="13d87-454">These include the following:</span></span>  
  
-   <span data-ttu-id="13d87-455">Appeler un constructeur de classe de l’objet doit être copié pour créer un second objet avec les valeurs de propriété extraites du premier objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-455">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="13d87-456">Cela suppose que les valeurs d’un objet sont entièrement définies par son constructeur de classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-456">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="13d87-457">Appelez le <xref:System.Object.MemberwiseClone%2A> méthode pour créer une copie superficielle d’un objet, puis attribuez de nouveaux objets dont les valeurs sont les mêmes que l’objet d’origine à des propriétés ou les champs dont les valeurs sont des types référence.</span><span class="sxs-lookup"><span data-stu-id="13d87-457">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="13d87-458">Le `DeepCopy` méthode dans l’exemple illustre cette approche.</span><span class="sxs-lookup"><span data-stu-id="13d87-458">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="13d87-459">Sérialiser l’objet de manière complète copié, puis restaurez les données sérialisées à une variable d’objet différent.</span><span class="sxs-lookup"><span data-stu-id="13d87-459">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="13d87-460">Utiliser la réflexion pour effectuer l’opération de copie complète avec la récurrence.</span><span class="sxs-lookup"><span data-stu-id="13d87-460">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-461">L’exemple suivant illustre la <xref:System.Object.MemberwiseClone%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-461">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="13d87-462">Il définit un `ShallowCopy` méthode qui appelle le <xref:System.Object.MemberwiseClone%2A> méthode pour effectuer une opération de copie superficielle sur un `Person` objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-462">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="13d87-463">Il définit également un `DeepCopy` méthode qui effectue une opération de copie complète sur un `Person` objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-463">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="13d87-464">Dans cet exemple, le `Person.IdInfo` propriété retourne un `IdInfo` objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-464">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="13d87-465">En tant que la sortie de l’exemple, lorsqu’un `Person` est cloné en appelant le <xref:System.Object.MemberwiseClone%2A> (méthode), cloné `Person` objet est une copie indépendante de l’objet d’origine, sauf qu’ils partagent le même `Person.IdInfo` référence d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-465">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="13d87-466">Par conséquent, modification du clone `Person.IdInfo` propriété modifie l’objet d’origine `Person.IdInfo` propriété.</span><span class="sxs-lookup"><span data-stu-id="13d87-466">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="13d87-467">En revanche, si une opération de copie complète est effectuée et cloné `Person` de l’objet, y compris son `Person.IdInfo` propriété, peut être modifié sans affecter l’objet d’origine.</span><span class="sxs-lookup"><span data-stu-id="13d87-467">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA"><span data-ttu-id="13d87-468">Premier objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="13d87-468">The first object to compare.</span></span></param>
        <param name="objB"><span data-ttu-id="13d87-469">Deuxième objet à comparer.</span><span class="sxs-lookup"><span data-stu-id="13d87-469">The second object  to compare.</span></span></param>
        <summary><span data-ttu-id="13d87-470">Détermine si les instances de <see cref="T:System.Object" /> spécifiées sont identiques.</span><span class="sxs-lookup"><span data-stu-id="13d87-470">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span></span></summary>
        <returns><span data-ttu-id="13d87-471"><see langword="true" /> si <paramref name="objA" /> est la même instance que <paramref name="objB" /> ou si les deux ont la valeur **null** ; sinon, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="13d87-471"><see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-472">Contrairement à la <xref:System.Object.Equals%2A> (méthode) et l’opérateur d’égalité, le <xref:System.Object.ReferenceEquals%2A> méthode ne peut pas être substituée.</span><span class="sxs-lookup"><span data-stu-id="13d87-472">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="13d87-473">Pour cette raison, si vous souhaitez tester deux références d’égalité d’objets et vous ne savez pas sur l’implémentation de la `Equals` (méthode), vous pouvez appeler la <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-473">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="13d87-474">Toutefois, la valeur de retour de la <xref:System.Object.ReferenceEquals%2A> méthode peut-être apparaître comme étant anormaux dans ces deux scénarios :</span><span class="sxs-lookup"><span data-stu-id="13d87-474">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="13d87-475">Lors de la comparaison des types valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-475">When comparing value types.</span></span> <span data-ttu-id="13d87-476">Si `objA` et `objB` sont des types valeur, ils sont convertis avant d’être passés à la <xref:System.Object.ReferenceEquals%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-476">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="13d87-477">Cela signifie que si les deux `objA` et `objB` représentent la même instance d’un type valeur, le <xref:System.Object.ReferenceEquals%2A> méthode retourne néanmoins `false`, comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-477">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="13d87-478">Pour plus d’informations sur les types valeur boxing, consultez [Boxing et Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="13d87-478">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="13d87-479">Lors de la comparaison de chaînes.</span><span class="sxs-lookup"><span data-stu-id="13d87-479">When comparing strings.</span></span> <span data-ttu-id="13d87-480">Si `objA` et `objB` sont des chaînes, la <xref:System.Object.ReferenceEquals%2A> retourne de la méthode `true` si la chaîne est dans le pool interne.</span><span class="sxs-lookup"><span data-stu-id="13d87-480">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="13d87-481">Il n’effectue pas un test d’égalité de valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-481">It does not perform a test for value equality.</span></span>  <span data-ttu-id="13d87-482">Dans l’exemple suivant, `s1` et `s2` sont égales, car elles sont de deux instances d’une chaîne unique dans le pool interne.</span><span class="sxs-lookup"><span data-stu-id="13d87-482">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="13d87-483">Toutefois, `s3` et `s4` ne sont pas égales, car même si elles sont ont des valeurs de chaîne identique, cette chaîne n’est pas intégrée.</span><span class="sxs-lookup"><span data-stu-id="13d87-483">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="13d87-484">Pour plus d’informations sur la centralisation des chaînes, consultez <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-484">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="13d87-485">L’exemple suivant utilise <xref:System.Object.ReferenceEquals%2A> pour déterminer si deux objets sont la même instance.</span><span class="sxs-lookup"><span data-stu-id="13d87-485">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="13d87-486">Retourne une chaîne qui représente l'objet actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-486">Returns a string that represents the current object.</span></span></summary>
        <returns><span data-ttu-id="13d87-487">Chaîne qui représente l'objet actuel.</span><span class="sxs-lookup"><span data-stu-id="13d87-487">A string that represents the current object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="13d87-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> major est mise en forme de méthode dans le .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="13d87-488"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="13d87-489">Il convertit un objet en sa représentation sous forme de chaîne afin qu’il soit adapté à l’affichage.</span><span class="sxs-lookup"><span data-stu-id="13d87-489">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="13d87-490">(Pour plus d’informations sur la mise en forme de la prise en charge dans le .NET Framework, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).) Implémentations par défaut de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode retourne le nom qualifié complet du type d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-490">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="13d87-491">Vous avez peut-être atteint cette page en suivant le lien à partir de la liste des membres d’un autre type.</span><span class="sxs-lookup"><span data-stu-id="13d87-491">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="13d87-492">C’est parce que ce type ne se substitue pas <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-492">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13d87-493">Au lieu de cela, il hérite des fonctionnalités de la <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-493">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="13d87-494">Types de fréquemment substituent la <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour fournir une représentation de chaîne plus appropriée d’un type particulier.</span><span class="sxs-lookup"><span data-stu-id="13d87-494">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="13d87-495">Types surcharger aussi fréquemment le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour prendre en charge les chaînes de format ou la mise en forme dépendante de la culture.</span><span class="sxs-lookup"><span data-stu-id="13d87-495">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="13d87-496">Dans cette section :</span><span class="sxs-lookup"><span data-stu-id="13d87-496">In this section:</span></span>  
  
 <span data-ttu-id="13d87-497">[La méthode Object.ToString () par défaut](#Default) </span><span class="sxs-lookup"><span data-stu-id="13d87-497">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="13d87-498">[Substitution de la méthode Object.ToString)](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="13d87-498">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="13d87-499">[La surcharge de la méthode ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="13d87-499">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="13d87-500">[Extension de la méthode Object.ToString](#Extending) </span><span class="sxs-lookup"><span data-stu-id="13d87-500">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="13d87-501">Notes relatives à l’exécution de Windows</span><span class="sxs-lookup"><span data-stu-id="13d87-501">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="13d87-502">La méthode Object.ToString () par défaut</span><span class="sxs-lookup"><span data-stu-id="13d87-502">The default Object.ToString() method</span></span>  
 <span data-ttu-id="13d87-503">L’implémentation par défaut de la <xref:System.Object.ToString%2A> méthode retourne le nom qualifié complet du type de la <xref:System.Object>, comme illustré dans l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-503">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="13d87-504">Étant donné que <xref:System.Object> est la classe de base de tous les types de référence dans le .NET Framework, ce comportement est hérité par les types de référence qui ne remplacent pas les <xref:System.Object.ToString%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-504">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="13d87-505">L'exemple suivant illustre ce comportement.</span><span class="sxs-lookup"><span data-stu-id="13d87-505">The following example illustrates this.</span></span> <span data-ttu-id="13d87-506">Il définit une classe nommée `Object1` qui accepte l’implémentation par défaut de tous les <xref:System.Object> membres.</span><span class="sxs-lookup"><span data-stu-id="13d87-506">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="13d87-507">Son <xref:System.Object.ToString%2A> méthode retourne le nom de type qualifié complet de l’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-507">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="13d87-508">Substitution de la méthode Object.ToString)</span><span class="sxs-lookup"><span data-stu-id="13d87-508">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="13d87-509">Les types couramment remplacer le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner une chaîne qui représente l’instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-509">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="13d87-510">Par exemple, la base de types tels que <xref:System.Char>, <xref:System.Int32>, et <xref:System.String> fournir <xref:System.Object.ToString%2A> qu’il retourne la forme de chaîne de la valeur qui représente l’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-510">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="13d87-511">L’exemple suivant définit une classe, `Object2`, qui remplace le <xref:System.Object.ToString%2A> méthode pour retourner le nom de type ainsi que sa valeur.</span><span class="sxs-lookup"><span data-stu-id="13d87-511">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="13d87-512">Le tableau suivant répertorie les catégories de type dans .NET et indique si elles substituent la <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-512">The following table lists the type categories in .NET and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="13d87-513">Catégorie de type</span><span class="sxs-lookup"><span data-stu-id="13d87-513">Type category</span></span>|<span data-ttu-id="13d87-514">Overrides Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="13d87-514">Overrides Object.ToString()</span></span>|<span data-ttu-id="13d87-515">Comportement</span><span class="sxs-lookup"><span data-stu-id="13d87-515">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="13d87-516">Classe</span><span class="sxs-lookup"><span data-stu-id="13d87-516">Class</span></span>|<span data-ttu-id="13d87-517">N/A</span><span class="sxs-lookup"><span data-stu-id="13d87-517">n/a</span></span>|<span data-ttu-id="13d87-518">N/A</span><span class="sxs-lookup"><span data-stu-id="13d87-518">n/a</span></span>|  
|<span data-ttu-id="13d87-519">Structure</span><span class="sxs-lookup"><span data-stu-id="13d87-519">Structure</span></span>|<span data-ttu-id="13d87-520">Oui (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="13d87-520">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="13d87-521">Identique à `Object.ToString()`</span><span class="sxs-lookup"><span data-stu-id="13d87-521">Same as `Object.ToString()`</span></span>|  
|<span data-ttu-id="13d87-522">Énumération</span><span class="sxs-lookup"><span data-stu-id="13d87-522">Enumeration</span></span>|<span data-ttu-id="13d87-523">Oui (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="13d87-523">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="13d87-524">Le nom de membre</span><span class="sxs-lookup"><span data-stu-id="13d87-524">The member name</span></span>|  
|<span data-ttu-id="13d87-525">Interface</span><span class="sxs-lookup"><span data-stu-id="13d87-525">Interface</span></span>|<span data-ttu-id="13d87-526">Non</span><span class="sxs-lookup"><span data-stu-id="13d87-526">No</span></span>|<span data-ttu-id="13d87-527">N/A</span><span class="sxs-lookup"><span data-stu-id="13d87-527">n/a</span></span>|  
|<span data-ttu-id="13d87-528">délégué</span><span class="sxs-lookup"><span data-stu-id="13d87-528">Delegate</span></span>|<span data-ttu-id="13d87-529">Non</span><span class="sxs-lookup"><span data-stu-id="13d87-529">No</span></span>|<span data-ttu-id="13d87-530">N/A</span><span class="sxs-lookup"><span data-stu-id="13d87-530">n/a</span></span>|  
  
 <span data-ttu-id="13d87-531">Consultez les section Remarques à l’attention des héritiers pour plus d’informations sur la substitution <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-531">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="13d87-532">La surcharge de la méthode ToString</span><span class="sxs-lookup"><span data-stu-id="13d87-532">Overloading the ToString method</span></span>  
 <span data-ttu-id="13d87-533">Outre l’écrasement Next sans paramètre <xref:System.Object.ToString?displayProperty=nameWithType> surcharger de nombreux types de méthode, le `ToString` méthode pour fournir des versions de la méthode qui acceptent des paramètres.</span><span class="sxs-lookup"><span data-stu-id="13d87-533">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="13d87-534">En règle générale, cela pour prendre en charge la mise en forme de variable et de mise en forme dépendante de la culture.</span><span class="sxs-lookup"><span data-stu-id="13d87-534">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="13d87-535">L’exemple suivant surcharge la `ToString` méthode pour retourner une chaîne de résultat qui inclut la valeur des champs variés d’une `Automobile` classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-535">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="13d87-536">Il définit quatre chaînes de format : G, qui retourne le nom du modèle et l’année ; D, qui retourne le nom du modèle, une année et un nombre de portes ; C, qui retourne le nom du modèle, une année et un nombre de cylindres ; et A, qui retourne une chaîne avec toutes les valeurs de champ de quatre.</span><span class="sxs-lookup"><span data-stu-id="13d87-536">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="13d87-537">L’exemple suivant appelle surchargées <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> méthode pour afficher la mise en forme dépendante de la culture d’une valeur de devise.</span><span class="sxs-lookup"><span data-stu-id="13d87-537">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="13d87-538">Pour plus d’informations sur les chaînes de format et la mise en forme dépendante de la culture, consultez [mise en forme des Types](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="13d87-538">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="13d87-539">Pour les chaînes de format pris en charge par les valeurs numériques, consultez [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) et [les chaînes de Format numériques personnalisées](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="13d87-539">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="13d87-540">Pour les chaînes de format pris en charge par les valeurs de date et d’heure, consultez [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) et [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="13d87-540">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="13d87-541">Extension de la méthode Object.ToString</span><span class="sxs-lookup"><span data-stu-id="13d87-541">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="13d87-542">Parce qu’un type hérite de la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> (méthode), vous pouvez trouver son comportement indésirable et souhaitez le modifier.</span><span class="sxs-lookup"><span data-stu-id="13d87-542">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="13d87-543">Cela est particulièrement vrai pour les tableaux et des classes de collection.</span><span class="sxs-lookup"><span data-stu-id="13d87-543">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="13d87-544">Bien que vous pouvez vous attendre le `ToString` méthode d’une classe de collection ou du tableau pour afficher les valeurs de ses membres, il affiche à la place le nom de type qualifié complet de type, comme le montre l’exemple suivant.</span><span class="sxs-lookup"><span data-stu-id="13d87-544">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="13d87-545">Vous avez plusieurs options pour produire la chaîne de résultat que vous aimeriez.</span><span class="sxs-lookup"><span data-stu-id="13d87-545">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="13d87-546">Si le type est un tableau, un objet de collection ou un objet qui implémente le <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interfaces, vous pouvez énumérer ses éléments à l’aide de la `foreach` instruction en c# ou le `For Each...Next` construire en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="13d87-546">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="13d87-547">Si la classe n’est pas `sealed` (en c#) ou `NotInheritable` (en Visual Basic), vous pouvez développer une classe wrapper qui hérite de la classe de base dont la propriété <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode que vous souhaitez personnaliser.</span><span class="sxs-lookup"><span data-stu-id="13d87-547">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="13d87-548">Au minimum, cela nécessite que vous procédez comme suit :</span><span class="sxs-lookup"><span data-stu-id="13d87-548">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="13d87-549">Implémenter tous les constructeurs nécessaires.</span><span class="sxs-lookup"><span data-stu-id="13d87-549">Implement any necessary constructors.</span></span> <span data-ttu-id="13d87-550">Les classes dérivées n’héritent pas de leurs constructeurs de classe de base.</span><span class="sxs-lookup"><span data-stu-id="13d87-550">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="13d87-551">Remplacer le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour retourner la chaîne de résultat que vous aimeriez.</span><span class="sxs-lookup"><span data-stu-id="13d87-551">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="13d87-552">L’exemple suivant définit une classe wrapper pour la <xref:System.Collections.Generic.List%601> classe.</span><span class="sxs-lookup"><span data-stu-id="13d87-552">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="13d87-553">Ce paramètre remplace le <xref:System.Object.ToString%2A?displayProperty=nameWithType> méthode pour afficher la valeur de chaque méthode de la collection plutôt que le nom de type qualifié complet.</span><span class="sxs-lookup"><span data-stu-id="13d87-553">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="13d87-554">Développer un [méthode d’extension](~/docs/standard/design-guidelines/extension-methods.md) qui retourne la chaîne de résultat que vous souhaitez.</span><span class="sxs-lookup"><span data-stu-id="13d87-554">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="13d87-555">Notez que vous ne pouvez pas remplacer la valeur par défaut <xref:System.Object.ToString%2A?displayProperty=nameWithType> de cette façon (méthode) (autrement dit, votre classe d’extension (en c#) ou le module (en Visual Basic) ne peut pas avoir une méthode sans paramètre nommée `ToString` qui est appelée à la place le type d’origine `ToString` (méthode) .</span><span class="sxs-lookup"><span data-stu-id="13d87-555">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="13d87-556">Vous devrez fournir un autre nom pour votre sans paramètre `ToString` remplacement.</span><span class="sxs-lookup"><span data-stu-id="13d87-556">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="13d87-557">L’exemple suivant définit deux méthodes qui étendent le <xref:System.Collections.Generic.List%601> classe : un sans paramètre `ToString2` (méthode) et un `ToString` méthode avec un <xref:System.String> paramètre qui représente une chaîne de format.</span><span class="sxs-lookup"><span data-stu-id="13d87-557">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="13d87-558">Notes pour le [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="13d87-558">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="13d87-559">Lorsque vous appelez le <xref:System.Object.ToString%2A> méthode sur une classe dans le [!INCLUDE[wrt](~/includes/wrt-md.md)], il fournit le comportement par défaut pour les classes qui ne remplacent pas <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-559">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don't override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="13d87-560">Cela fait partie de la prise en charge le .NET Framework fournit pour la [!INCLUDE[wrt](~/includes/wrt-md.md)] (consultez [applications .NET Framework prend en charge pour Windows Store et Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="13d87-560">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="13d87-561">Classes dans le [!INCLUDE[wrt](~/includes/wrt-md.md)] n’héritent pas <xref:System.Object>et n’implémentent pas toujours un <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="13d87-561">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don't inherit <xref:System.Object>, and don't always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="13d87-562">Toutefois, ils semblent toujours avoir <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, et <xref:System.Object.GetHashCode%2A> méthodes lorsque vous les utilisez dans votre code c# ou Visual Basic et le .NET Framework fournit un comportement par défaut pour ces méthodes.</span><span class="sxs-lookup"><span data-stu-id="13d87-562">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="13d87-563">En commençant par le [!INCLUDE[net_v451](~/includes/net-v451-md.md)], le common language runtime utilisera [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) sur un [!INCLUDE[wrt](~/includes/wrt-md.md)] objet avant de revenir à l’implémentation par défaut de <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-563">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)] <span data-ttu-id="13d87-564">les classes qui sont écrits en c# ou Visual Basic peuvent remplacer la <xref:System.Object.ToString%2A> (méthode).</span><span class="sxs-lookup"><span data-stu-id="13d87-564">classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="13d87-565">Le [!INCLUDE[wrt](~/includes/wrt-md.md)] et l’Interface IStringable</span><span class="sxs-lookup"><span data-stu-id="13d87-565">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="13d87-566">En commençant par [!INCLUDE[win81](~/includes/win81-md.md)], le [!INCLUDE[wrt](~/includes/wrt-md.md)] inclut un [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dont la méthode unique, l’interface [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), renforce leur base mise en forme comparable à celle fourni par <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="13d87-566">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="13d87-567">Pour éviter toute ambiguïté, vous ne devez pas implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur les types managés.</span><span class="sxs-lookup"><span data-stu-id="13d87-567">To prevent ambiguity, you should not implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="13d87-568">Lorsque les objets managés sont appelées par du code natif ou par du code écrit dans des langages tels que JavaScript ou C++ / c++ / CX, ils apparaissent pour implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="13d87-568">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="13d87-569">Le common language runtime achemine automatiquement les appels à partir de [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) à <xref:System.Object.ToString%2A?displayProperty=nameWithType> de l’événement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) n’est pas implémentée sur l’objet managé.</span><span class="sxs-lookup"><span data-stu-id="13d87-569">The common language runtime will automatically route calls from [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="13d87-570">Étant donné que le common language runtime automatique-implémente [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) pour tous les types dans managés [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] applications, nous recommandons que vous ne fournissez pas votre propre [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implémentation.</span><span class="sxs-lookup"><span data-stu-id="13d87-570">Because the common language runtime auto-implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="13d87-571">Implémentation [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) peut entraîner un comportement inattendu lors de l’appel `ToString` à partir de la [!INCLUDE[wrt](~/includes/wrt-md.md)], C++ / c++ / CX ou JavaScript.</span><span class="sxs-lookup"><span data-stu-id="13d87-571">Implementing [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="13d87-572">Si vous choisissez d’implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) dans un type managé public qui est exporté dans un [!INCLUDE[wrt](~/includes/wrt-md.md)] composant, les restrictions suivantes s’appliquent :</span><span class="sxs-lookup"><span data-stu-id="13d87-572">If you do choose to implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="13d87-573">Vous pouvez définir le [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface uniquement dans une relation « la classe implémente », tels que</span><span class="sxs-lookup"><span data-stu-id="13d87-573">You can define the [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="13d87-574">en C#, ou</span><span class="sxs-lookup"><span data-stu-id="13d87-574">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="13d87-575">en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="13d87-575">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="13d87-576">Vous ne pouvez pas implémenter [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) sur une interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-576">You cannot implement [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="13d87-577">Vous ne pouvez pas déclarer un paramètre de type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="13d87-577">You cannot declare a parameter to be of type [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="13d87-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ne peut pas être le type de retour d’une méthode, une propriété ou un champ.</span><span class="sxs-lookup"><span data-stu-id="13d87-578">[IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="13d87-579">Vous ne pouvez pas masquer votre [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implémentation de classes de base à l’aide d’une définition de méthode telle que la suivante :</span><span class="sxs-lookup"><span data-stu-id="13d87-579">You cannot hide your [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="13d87-580">Au lieu de cela, le [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation doit toujours remplacer l’implémentation de classe de base.</span><span class="sxs-lookup"><span data-stu-id="13d87-580">Instead, the [IStringable.ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="13d87-581">Vous pouvez masquer une implémentation `ToString` uniquement en l'appelant sur une instance de classe fortement typée.</span><span class="sxs-lookup"><span data-stu-id="13d87-581">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="13d87-582">Notez que dans diverses conditions, les appels à partir du code natif à un type managé qui implémente [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) ou masque son [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implémentation peut entraîner un comportement inattendu.</span><span class="sxs-lookup"><span data-stu-id="13d87-582">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](https://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="13d87-583">Quand vous implémentez vos propres types, vous devez substituer la <see cref="M:System.Object.ToString" /> méthode pour retourner des valeurs qui sont significatives pour ces types.</span><span class="sxs-lookup"><span data-stu-id="13d87-583">When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types.</span></span> <span data-ttu-id="13d87-584">Classes dérivées qui requièrent davantage de contrôle sur la mise en forme que <see cref="M:System.Object.ToString" /> fournit peut implémenter la <see cref="T:System.IFormattable" /> interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-584">Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface.</span></span> <span data-ttu-id="13d87-585">Son <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> méthode vous permet de définir des chaînes de format qui contrôlent la mise en forme et d’utiliser un <see cref="T:System.IFormatProvider" /> objet qui peut fournir pour la mise en forme propres à la culture.</span><span class="sxs-lookup"><span data-stu-id="13d87-585">Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.</span></span>  
  
<span data-ttu-id="13d87-586">Remplacements de la <see cref="M:System.Object.ToString" /> méthode doit suivre ces instructions :</span><span class="sxs-lookup"><span data-stu-id="13d87-586">Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:</span></span> 
<span data-ttu-id="13d87-587">-La chaîne retournée doit être convivial et lisible par les humains.</span><span class="sxs-lookup"><span data-stu-id="13d87-587">-   The returned string should be friendly and readable by humans.</span></span>  
  
<span data-ttu-id="13d87-588">-La chaîne retournée doit identifier de manière unique la valeur de l’instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-588">-   The returned string should uniquely identify the value of the object instance.</span></span>  
  
<span data-ttu-id="13d87-589">-La chaîne retournée doit être aussi courte que possible afin qu’il soit adapté à l’affichage par un débogueur.</span><span class="sxs-lookup"><span data-stu-id="13d87-589">-   The returned string should be as short as possible so that it is suitable for display by a debugger.</span></span>  
  
<span data-ttu-id="13d87-590">-Votre <see cref="M:System.Object.ToString" /> substitution ne doit pas retourner <see cref="F:System.String.Empty" /> ou une chaîne null.</span><span class="sxs-lookup"><span data-stu-id="13d87-590">-   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.</span></span>  
  
<span data-ttu-id="13d87-591">-Votre <see cref="M:System.Object.ToString" /> override ne doit pas lever une exception.</span><span class="sxs-lookup"><span data-stu-id="13d87-591">-   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.</span></span>  
  
<span data-ttu-id="13d87-592">-Si la représentation sous forme de chaîne d’une instance est dépendante de la culture ou peut être mise en forme de plusieurs façons, implémentez le <see cref="T:System.IFormattable" /> interface.</span><span class="sxs-lookup"><span data-stu-id="13d87-592">-   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.</span></span>  
  
<span data-ttu-id="13d87-593">-Si la chaîne retournée inclut des informations sensibles, vous devez tout d’abord demander une autorisation appropriée.</span><span class="sxs-lookup"><span data-stu-id="13d87-593">-   If the returned string includes sensitive information, you should first demand an appropriate permission.</span></span> <span data-ttu-id="13d87-594">Si la demande réussit, vous pouvez retourner des informations sensibles. Sinon, vous devez retourner une chaîne qui exclut les informations sensibles.</span><span class="sxs-lookup"><span data-stu-id="13d87-594">If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.</span></span>  
  
<span data-ttu-id="13d87-595">-Votre <see cref="M:System.Object.ToString" /> remplacement ne doit avoir aucun effet secondaire observable afin d’éviter les complications lors du débogage.</span><span class="sxs-lookup"><span data-stu-id="13d87-595">-   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging.</span></span> <span data-ttu-id="13d87-596">Par exemple, un appel à la <see cref="M:System.Object.ToString" /> méthode ne doit pas modifier la valeur de champs d’instance.</span><span class="sxs-lookup"><span data-stu-id="13d87-596">For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.</span></span>  
  
<span data-ttu-id="13d87-597">-Si votre type implémente une méthode d’analyse (ou <see langword="Parse" /> ou <see langword="TryParse" /> (méthode), un constructeur ou une autre méthode statique qui instancie une instance du type à partir d’une chaîne), vous devez vous assurer que la chaîne retournée par la <see cref="M:System.Object.ToString" /> méthode peut être converti en une instance d’objet.</span><span class="sxs-lookup"><span data-stu-id="13d87-597">-   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</span></span></para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="13d87-598">Mettre en forme des types dans .NET</span><span class="sxs-lookup"><span data-stu-id="13d87-598">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
