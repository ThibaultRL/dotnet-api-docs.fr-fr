<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6f7442b0db6a9cee28d0064242be3f4defb452a6" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65009425" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des méthodes pour la création, la manipulation, la recherche ainsi que le tri des tableaux et sert de classe de base pour tous les tableaux du Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> classe n’est pas dans le cadre de la <xref:System.Collections> espaces de noms. Toutefois, il est toujours considéré comme une collection, car il est basé sur le <xref:System.Collections.IList> interface.  
  
 Le <xref:System.Array> est la classe de base pour les implémentations de langage qui prennent en charge les tableaux. Toutefois, seul le système et les compilateurs peuvent dériver explicitement de la <xref:System.Array> classe. Les utilisateurs doivent employer les constructions de tableau fournies par le langage.  
  
 Un élément est une valeur dans un <xref:System.Array>. La longueur d’un <xref:System.Array> est le nombre total d’éléments qu’il peut contenir. La limite inférieure d’un <xref:System.Array> est l’index de son premier élément. Un <xref:System.Array> peut avoir une limite inférieure quelconque, mais il a une limite inférieure de zéro par défaut. Une autre limite inférieure peut être définie lors de la création d’une instance de la <xref:System.Array> à l’aide de la classe <xref:System.Array.CreateInstance%2A>. Un multidimensionnelles <xref:System.Array> peut avoir différentes limites pour chaque dimension. Un tableau peut avoir un maximum de 32 dimensions.  
  
 Contrairement aux classes dans le <xref:System.Collections> espaces de noms, <xref:System.Array> a une capacité fixe. Pour augmenter la capacité, vous devez créer un nouveau <xref:System.Array> objet avec la capacité requise, copier les éléments de l’ancien <xref:System.Array> de l’objet vers le nouveau et supprimer l’ancienne <xref:System.Array>.  

 La taille du tableau est limitée à un total d’éléments de 4 milliards, ainsi qu’un index maximal de 0X7FEFFFFF dans n’importe quelle dimension donné (0X7FFFFFC7 pour les tableaux d’octets et des tableaux de structures d’un octet).
  
 **.NET framework :** Par défaut, la taille maximale d’un <xref:System.Array> est de 2 gigaoctets (Go). Dans un environnement 64 bits, vous pouvez éviter la restriction de taille en définissant le `enabled` attribut de la [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) élément de configuration à `true` dans l’environnement d’exécution.
  
 Tableaux unidimensionnels implémentent la <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> et <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfaces génériques. Les implémentations sont fournies aux tableaux au moment de l’exécution, et par conséquent, les interfaces génériques n’apparaissent pas dans la syntaxe de déclaration pour le <xref:System.Array> classe. En outre, il n’existe aucun rubriques de référence pour les membres d’interface qui sont uniquement accessibles en castant un tableau le type d’interface générique (implémentations d’interface explicite). Le point clé à connaître lors de la conversion d’un tableau à une de ces interfaces est que les membres qui ajoutent, insérer ou supprimer des éléments throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> objets fournissent des informations sur les déclarations de type tableau. <xref:System.Array> objets avec le même type de tableau partagent le même <xref:System.Type> objet.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> et <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> peut ne pas retourner les résultats attendus avec <xref:System.Array> , car si un tableau est casté en type <xref:System.Array>, le résultat est un objet, pas un tableau. Autrement dit, `typeof(System.Array).IsArray` retourne `false`, et `typeof(System.Array).GetElementType` retourne `null`.  
  
 Le <xref:System.Array.Copy%2A?displayProperty=nameWithType> méthode copie les éléments non seulement entre les tableaux du même type, mais également entre les tableaux standard de types différents ; il gère automatiquement de conversion de types.  
  
 Certaines méthodes, telles que <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, et <xref:System.Array.SetValue%2A>, fournissent des surcharges qui acceptent des entiers 64 bits en tant que paramètres pour prendre en charge des tableaux de grande capacité. <xref:System.Array.LongLength%2A> et <xref:System.Array.GetLongLength%2A> retournent des entiers 64 bits qui indique la longueur du tableau.  
  
 Le <xref:System.Array> le tri n’est pas garanti.  Vous devez trier les <xref:System.Array> avant d’effectuer des opérations (telles que <xref:System.Array.BinarySearch%2A>) qui nécessitent le <xref:System.Array> à trier.  
  
 À l’aide un <xref:System.Array> objet de pointeurs en code natif n’est pas pris en charge et lève un <xref:System.NotSupportedException> pour plusieurs méthodes.  
  
   
  
## Examples  
 Le code suivant montre l’exemple comment <xref:System.Array.Copy%2A?displayProperty=nameWithType> copie des éléments entre un tableau de type entier et un tableau de type <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 L’exemple de code suivant crée et initialise un <xref:System.Array> et affiche ses propriétés et ses éléments.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Statique public (<see langword="Shared" /> en Visual Basic) de ce type sont thread-safe. Il n'est pas garanti que les membres d'instance soient thread-safe.  
  
Cette implémentation ne fournit pas synchronisé wrapper (thread-safe) pour un <see cref="T:System.Array" />; Toutefois, les classes .NET Framework basées sur <see cref="T:System.Array" /> fournissent leur propre version synchronisée de la collection en utilisant le <see cref="P:System.Array.SyncRoot" /> propriété.  
  
L'énumération d'une collection n'est intrinsèquement pas une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Tableaux (guide de programmation C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Tableaux dans Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Le tableau de base zéro unidimensionnel à inclure dans un wrapper en lecture seule <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</param>
        <summary>Retourne un wrapper en lecture seule pour le tableau spécifié.</summary>
        <returns>Wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> en lecture seule pour le tableau spécifié.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour éviter toute modification dans le tableau, exposent uniquement par l’intermédiaire de ce wrapper.  
  
 Une collection est en lecture seule est simplement une collection avec un wrapper qui empêche la modification de la collection ; Par conséquent, si des modifications sont apportées à la collection sous-jacente, la collection en lecture seule reflète ces modifications.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant encapsule un tableau en lecture seule <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche une valeur dans un <see cref="T:System.Array" /> trié unidimensionnel, à l’aide d’un algorithme de recherche binaire.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel trié à explorer.</param>
        <param name="value">Objet à rechercher.</param>
        <summary>Recherche un élément spécifique dans tout un tableau trié unidimensionnel, à l’aide de l’interface <see cref="T:System.IComparable" /> implémentée par chaque élément du tableau et par l’objet spécifié.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le <xref:System.Array> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Soit `value` ou tous les éléments de `array` doit implémenter le <xref:System.IComparable> interface, ce qui est utilisé pour les comparaisons. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable> implémentation ; sinon, le résultat peut être incorrect.  
  
> [!NOTE]
>  Si`value` n’implémente pas le <xref:System.IComparable> interface, les éléments de `array` ne sont pas testés pour <xref:System.IComparable> avant le début de la recherche. Une exception est levée si la recherche rencontre un élément qui n’implémente pas <xref:System.IComparable>.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Array.BinarySearch%2A> pour localiser un objet spécifique dans un <xref:System.Array>.  
  
> [!NOTE]
>  Le tableau est créé avec ses éléments dans l’ordre de tri croissant. Le <xref:System.Array.BinarySearch%2A> méthode requiert le tableau à trier dans l’ordre croissant.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> n’implémente pas l’interface <see cref="T:System.IComparable" /> et la recherche rencontre un élément qui n’implémente pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel trié à explorer.</param>
        <param name="value">Objet à rechercher.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Recherche une valeur dans l’intégralité d’un tableau trié unidimensionnel, à l’aide de l’interface <see cref="T:System.Collections.IComparer" /> spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le <xref:System.Array> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` n’est pas `null`, les éléments de `array` sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.IComparer> implémentation. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par `comparer`; sinon, le résultat peut être incorrect.  
  
 Si`comparer` est `null`, la comparaison est effectuée à l’aide de la <xref:System.IComparable> implémentation fournie par l’élément lui-même ou par la valeur spécifiée. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable> implémentation ; sinon, le résultat peut être incorrect.  
  
> [!NOTE]
>  Si `comparer` est `null` et `value` n’implémente pas le <xref:System.IComparable> interface, les éléments de `array` ne sont pas testés pour <xref:System.IComparable> avant le début de la recherche. Une exception est levée si la recherche rencontre un élément qui n’implémente pas <xref:System.IComparable>.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> a la valeur <see langword="null" /> et <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> a la valeur <see langword="null" />, <paramref name="value" /> n’implémente pas l’interface <see cref="T:System.IComparable" /> et la recherche rencontre un élément qui n’implémente pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel trié à explorer.</param>
        <param name="index">Index de départ de la plage dans laquelle effectuer la recherche.</param>
        <param name="length">Longueur de la plage dans laquelle effectuer la recherche.</param>
        <param name="value">Objet à rechercher.</param>
        <summary>Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface <see cref="T:System.IComparable" /> implémentée par chaque élément du tableau et par la valeur spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le <xref:System.Array> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Soit `value` ou tous les éléments de `array` doit implémenter le <xref:System.IComparable> interface, ce qui est utilisé pour les comparaisons. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable> implémentation ; sinon, le résultat peut être incorrect.  
  
> [!NOTE]
>  Si `value` n’implémente pas le <xref:System.IComparable> interface, les éléments de `array` ne sont pas testés pour <xref:System.IComparable> avant le début de la recherche. Une exception est levée si la recherche rencontre un élément qui n’implémente pas <xref:System.IComparable>.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
 <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> n’implémente pas l’interface <see cref="T:System.IComparable" /> et la recherche rencontre un élément qui n’implémente pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel trié à explorer.</param>
        <param name="index">Index de départ de la plage dans laquelle effectuer la recherche.</param>
        <param name="length">Longueur de la plage dans laquelle effectuer la recherche.</param>
        <param name="value">Objet à rechercher.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel à l’aide de l’interface <see cref="T:System.Collections.IComparer" /> spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le <xref:System.Array> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est un supérieur à la limite supérieure du tableau, il n’existe aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` n’est pas `null`, les éléments de `array` sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.IComparer> implémentation. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par `comparer`; sinon, le résultat peut être incorrect.  
  
 Si `comparer` est `null`, la comparaison est effectuée à l’aide de la <xref:System.IComparable> implémentation fournie par l’élément lui-même ou par la valeur spécifiée. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable> implémentation ; sinon, le résultat peut être incorrect.  
  
> [!NOTE]
>  Si `comparer` est `null` et `value` n’implémente pas le <xref:System.IComparable> interface, les éléments de `array` ne sont pas testés pour <xref:System.IComparable> avant le début de la recherche. Une exception est levée si la recherche rencontre un élément qui n’implémente pas <xref:System.IComparable>.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception lors de l’utilisation <xref:System.IComparable>.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
 <paramref name="comparer" /> a la valeur <see langword="null" /> et <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> a la valeur <see langword="null" />, <paramref name="value" /> n’implémente pas l’interface <see cref="T:System.IComparable" /> et la recherche rencontre un élément qui n’implémente pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro trié unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher.</param>
        <summary>Recherche un élément spécifique dans un tableau entier trié unidimensionnel, à l’aide de l’interface générique <see cref="T:System.IComparable`1" /> implémentée par chaque élément de <see cref="T:System.Array" /> et par l’objet spécifié.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si `array` ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 `T` doit implémenter le <xref:System.IComparable%601> interface générique, qui est utilisé pour les comparaisons. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable%601> implémentation ; sinon, le résultat peut être incorrect.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable%601> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable%601> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> surcharge de méthode générique et le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode générique. Un tableau de chaînes est créé, dans aucun ordre particulier.  
  
 Le tableau est affiché, trié et affiche à nouveau. Les tableaux doivent être triées pour pouvoir utiliser le <xref:System.Array.BinarySearch%2A> (méthode).  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%2A> et <xref:System.Array.BinarySearch%2A> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 Le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est. Le tableau et la valeur de retour de la <xref:System.Array.BinarySearch%2A> méthode sont passés à la `ShowWhere` une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau. L’index est négatif si la chaîne n’est pas dans le tableau, donc la `ShowWhere` méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, `Xor`-1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche str ing.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> n’implémente pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro trié unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Recherche une valeur dans l’intégralité d’un tableau trié unidimensionnel, à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le <xref:System.Array> ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` n’est pas `null`, les éléments de `array` sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation d’interface générique. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par `comparer`; sinon, le résultat peut être incorrect.  
  
 Si `comparer` est `null`, la comparaison est effectuée à l’aide de la <xref:System.IComparable%601> implémentation d’interface générique fournie par `T`. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable%601> implémentation ; sinon, le résultat peut être incorrect.  
  
> [!NOTE]
>  Si `comparer` est `null` et `value` n’implémente pas le <xref:System.IComparable%601> interface générique, les éléments de `array` ne sont pas testés pour <xref:System.IComparable%601> avant le début de la recherche. Une exception est levée si la recherche rencontre un élément qui n’implémente pas <xref:System.IComparable%601>.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable%601> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable%601> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique et le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 Le tableau est affiché, trié et affiche à nouveau. Les tableaux doivent être triées pour pouvoir utiliser le <xref:System.Array.BinarySearch%2A> (méthode).  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> et <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 Le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est. Le tableau et la valeur de retour de la <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthode sont passés à la `ShowWhere` une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau. L’index est négatif si la chaîne n’est pas n le tableau, donc la `ShowWhere` méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> a la valeur <see langword="null" /> et <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et <paramref name="T" /> n’implémente pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro, unidimensionnel et trié à explorer.</param>
        <param name="index">Index de départ de la plage dans laquelle effectuer la recherche.</param>
        <param name="length">Longueur de la plage dans laquelle effectuer la recherche.</param>
        <param name="value">Objet à rechercher.</param>
        <summary>Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface générique <see cref="T:System.IComparable`1" /> implémentée par chaque élément de <see cref="T:System.Array" /> et par la valeur spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le tableau ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 `T` doit implémenter le <xref:System.IComparable%601> interface générique, qui est utilisé pour les comparaisons. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable%601> implémentation ; sinon, le résultat peut être incorrect.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable%601> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable%601> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
 <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> n’implémente pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro, unidimensionnel et trié à explorer.</param>
        <param name="index">Index de départ de la plage dans laquelle effectuer la recherche.</param>
        <param name="length">Longueur de la plage dans laquelle effectuer la recherche.</param>
        <param name="value">Objet à rechercher.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Recherche une valeur dans une plage d’éléments d’un tableau trié unidimensionnel, à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <returns>Index de la <paramref name="value" /> spécifiée dans l’<paramref name="array" /> spécifié, si <paramref name="value" /> est trouvé. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est inférieur à un ou plusieurs éléments dans <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du premier élément supérieur à <paramref name="value" />. Si <paramref name="value" /> est introuvable et que <paramref name="value" /> est supérieur à tous les éléments de <paramref name="array" />, le nombre négatif retourné est le complément de bits de l’index du dernier élément plus 1. Si cette méthode est appelée avec un <paramref name="array" /> non trié, la valeur de retour peut être incorrecte et un nombre négatif peut être retourné, même si <paramref name="value" /> est présent dans <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode ne prend pas en charge la recherche dans les tableaux qui contiennent des index négatif. `array` doivent être triées avant d’appeler cette méthode.  
  
 Si le tableau ne contient pas la valeur spécifiée, la méthode retourne un entier négatif. Vous pouvez appliquer l’opérateur de complément au niveau du bit (~ en c#, `Not` en Visual Basic) au résultat négatif pour produire un index. Si cet index est égal à la taille du tableau, ne contient aucun élément supérieur à `value` dans le tableau. Sinon, c’est l’index du premier élément qui est supérieure à `value`.  
  
 Le comparateur personnalise la manière dont les éléments sont comparés. Par exemple, vous pouvez utiliser un <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> en tant que comparateur pour effectuer des recherches de chaîne de non-respect de la casse.  
  
 Si `comparer` n’est pas `null`, les éléments de `array` sont comparées à la valeur spécifiée à l’aide de la <xref:System.Collections.Generic.IComparer%601> implémentation d’interface générique. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par `comparer`; sinon, le résultat peut être incorrect.  
  
 Si `comparer` est `null`, la comparaison est effectuée à l’aide de la <xref:System.IComparable%601> implémentation d’interface générique fournie pour le type `T`. Les éléments de `array` doivent déjà être triés par ordre croissant selon l’ordre de tri défini par le <xref:System.IComparable%601> implémentation ; sinon, le résultat peut être incorrect.  
  
 Les éléments en double sont autorisés. Si le <xref:System.Array> contient plus d’un élément égal à `value`, la méthode retourne l’index de qu’un seul des occurrences et pas nécessairement la première condition.  
  
 `null` peut toujours être comparé à n’importe quel autre type référence. Par conséquent, les comparaisons avec `null` ne génèrent pas d’exception lors de l’utilisation <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Pour chaque élément testé, `value` est passé à approprié <xref:System.IComparable%601> implémentation, même si `value` est `null`. Autrement dit, le <xref:System.IComparable%601> implémentation détermine comment un élément donné est comparé à `null`.  
  
 Cette méthode est un O (log `n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
 <paramref name="comparer" /> a la valeur <see langword="null" /> et <paramref name="value" /> est d’un type qui n’est pas compatible avec les éléments de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et <paramref name="T" />n’implémente pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Le tableau dont les éléments doivent être effacés.</param>
        <param name="index">Index de départ de la plage d'éléments à effacer.</param>
        <param name="length">Nombre d'éléments à effacer.</param>
        <summary>Définit une plage d'éléments dans un tableau à la valeur par défaut de chaque type d'élément.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode réinitialise chaque élément dans un tableau à la valeur par défaut du type d’élément. Il définit des éléments de types référence (y compris <xref:System.String> éléments) à `null`et définit les éléments de types de valeur pour les valeurs par défaut indiqués dans le tableau suivant.  
  
|Type|Value|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Tous les types numériques intégraux et à virgule flottante|0 (zéro)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Autres types de valeur|Valeur par défaut des champs du type|  
  
 La plage d’éléments effacés est renvoyée à partir d’une ligne à une ligne dans un tableau multidimensionnel.  
  
 Cette méthode efface uniquement les valeurs des éléments ; elle ne supprime pas les éléments proprement dits. Un tableau a une taille fixe ; Par conséquent, les éléments ne peuvent pas être ajoutés ou supprimés.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple suivant utilise la <xref:System.Array.Clear%2A> méthode pour rétablir les valeurs entières dans un tableau unidimensionnel, deux et trois dimensions.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 L’exemple suivant définit un `TimeZoneTime` structure qui inclut un <xref:System.TimeZoneInfo> champ et un <xref:System.DateTimeOffset> champ. Il appelle ensuite la <xref:System.Array.Clear%2A> méthode pour effacer un élément dans un tableau de deux éléments `TimeZoneTime` valeurs. La méthode définit la valeur de l’élément effacée à la valeur par défaut d’un <xref:System.TimeZoneInfo> objet, qui est `null`et la valeur par défaut un <xref:System.DateTimeOffset> objet, qui est <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.  
  
ou 
La somme d’<paramref name="index" /> et <paramref name="length" /> est supérieure à la taille d’<paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée une copie superficielle de <see cref="T:System.Array" />.</summary>
        <returns>Copie superficielle de <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une copie superficielle d’un <xref:System.Array> copie uniquement les éléments de la <xref:System.Array>, si elles sont des types référence ou types valeur, mais ne copie pas les objets que les références. Les références dans le nouveau <xref:System.Array> des objets qui pointent vers le même les références dans la version d’origine <xref:System.Array> pointent vers.  
  
 En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Le clone est du même <xref:System.Type> que l’original <xref:System.Array>.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 Le code suivant exemple clones un <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> de tableau et illustre le comportement d’une copie superficielle.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> qui contient les données à copier.</param>
        <param name="sourceIndex">Entier 32 bits qui représente l’index du <paramref name="sourceArray" /> auquel la copie commence.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> qui reçoit les données.</param>
        <param name="destinationIndex">Entier 32 bits qui représente l’index du <paramref name="destinationArray" /> auquel le stockage commence.</param>
        <param name="length">Entier 32 bits qui représente le nombre d'éléments à copier.</param>
        <summary>Copie une plage d’éléments à partir d’un <see cref="T:System.Array" /> commençant à l’index source spécifié, puis les colle dans un autre <see cref="T:System.Array" /> commençant à l’index de destination spécifié.  Garantit que toutes les modifications sont annulées si la copie ne se déroule pas intégralement avec succès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceArray` et `destinationArray` les paramètres doivent avoir le même nombre de dimensions.  Le `sourceArray` type doit être identique ou dérivé de la `destinationArray` type ; sinon, un <xref:System.ArrayTypeMismatchException> est levée.  Contrairement aux <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> vérifie la compatibilité des types de tableau avant d’effectuer toute opération.  
  
 Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel end-to-end. Par exemple, si un tableau a trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau serait copier toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne). Pour commencer la copie à partir du deuxième élément du troisième ligne (ou colonne), `sourceIndex` doit être la limite supérieure de la première ligne (ou colonne) et la longueur de la deuxième ligne (ou colonne) plus deux.  
  
 Si `sourceArray` et `destinationArray` se chevauchent, cette méthode se comporte comme si les valeurs d’origine de `sourceArray` ont été conservées dans un emplacement temporaire avant `destinationArray` est remplacé.  
  
 [C++]  
  
 Cette méthode est équivalente à la fonction C/C++ standard `memmove`, et non `memcpy`.  
  
 Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur.  Si `sourceArray` et `destinationArray` des tableaux de type référence ou des tableaux de type <xref:System.Object>, une copie superficielle est effectuée. Une copie superficielle d’un <xref:System.Array> est un nouveau <xref:System.Array> contenant des références aux mêmes éléments que l’original <xref:System.Array>. Les éléments eux-mêmes ou quoi que ce soit référencé par les éléments ne sont pas copiés. En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Si cette méthode lève une exception lors de la copie, le `destinationArray` reste inchangé, par conséquent, <xref:System.Array.ConstrainedCopy%2A> peut être utilisé dans une région d’exécution limitée (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> ont des classements différents.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Le type <paramref name="sourceArray" /> n’est pas le même que le type <paramref name="destinationArray" />, ni un dérivé de celui-ci.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément de <paramref name="sourceArray" /> ne peut pas être converti en type <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> est inférieur à la limite inférieure de la première dimension de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="destinationIndex" /> est inférieur à la limite inférieure de la première dimension de <paramref name="destinationArray" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="sourceIndex" /> et la fin de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="destinationIndex" /> et la fin de <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">Type des éléments du tableau source.</typeparam>
        <typeparam name="TOutput">Type des éléments du tableau cible.</typeparam>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel de base zéro à convertir en un type cible.</param>
        <param name="converter"><see cref="T:System.Converter`2" /> qui convertit chaque élément d’un type en un autre type.</param>
        <summary>Convertit un tableau d'un type en un tableau d'un autre type.</summary>
        <returns>Tableau du type cible qui contient les éléments convertis du tableau source.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Converter%602> est un délégué à une méthode qui convertit un objet vers le type cible.  Les éléments de `array` sont passés à la <xref:System.Converter%602>, et les éléments convertis sont enregistrés dans le nouveau tableau.  
  
 La source `array` reste inchangé.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant définit une méthode nommée `PointFToPoint` qui convertit un <xref:System.Drawing.PointF> structure un <xref:System.Drawing.Point> structure. L’exemple crée ensuite un tableau de <xref:System.Drawing.PointF> structures, crée un `Converter<PointF, Point>` déléguer (`Converter(Of PointF, Point)` en Visual Basic) pour représenter le `PointFToPoint` (méthode) et passe le délégué à la <xref:System.Array.ConvertAll%2A> (méthode). Le <xref:System.Array.ConvertAll%2A> méthode passe chaque élément de la liste d’entrée à la `PointFToPoint` (méthode) et met les éléments convertis dans une nouvelle liste de <xref:System.Drawing.Point> structures. Les deux listes sont affichées.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="converter" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie une plage d’éléments d’un <see cref="T:System.Array" /> vers un autre <see cref="T:System.Array" /> et effectue éventuellement le casting de type et le boxing.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> qui contient les données à copier.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> qui reçoit les données.</param>
        <param name="length">Entier 32 bits qui représente le nombre d'éléments à copier.</param>
        <summary>Copie une série d’éléments de <see cref="T:System.Array" /> en commençant au premier élément, et les colle dans un autre <see cref="T:System.Array" /> en commençant au premier élément. La longueur est spécifiée sous forme d'un entier 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceArray` et `destinationArray` les paramètres doivent avoir le même nombre de dimensions. En outre, `destinationArray` doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en charge les données copiées.  
  
 Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout. Par exemple, si un tableau a trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau serait copier toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).  
  
 Si `sourceArray` et `destinationArray` se chevauchent, cette méthode se comporte comme si les valeurs d’origine de `sourceArray` ont été conservées dans un emplacement temporaire avant `destinationArray` est remplacé.  
  
 [C++]  
  
 Cette méthode est équivalente à la fonction C/C++ standard `memmove`, et non `memcpy`.  
  
 Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur. Cast de type est effectuée, en fonction des besoins.  
  
-   Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié. Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.  
  
-   Lors de la copie à partir d’un tableau de type référence ou type valeur à une <xref:System.Object> tableau, un <xref:System.Object> est créée pour contenir chaque valeur ou référence, puis copié. Lors de la copie à partir d’un <xref:System.Object> tableau à un tableau de type référence ou type valeur et l’affectation n’est pas possible, un <xref:System.InvalidCastException> est levée.  
  
-   Si `sourceArray` et `destinationArray` des tableaux de type référence ou des tableaux de type <xref:System.Object>, une copie superficielle est effectuée. Une copie superficielle d’un <xref:System.Array> est un nouveau <xref:System.Array> contenant des références aux mêmes éléments que l’original <xref:System.Array>. Les éléments eux-mêmes ou quoi que ce soit référencé par les éléments ne sont pas copiés. En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Un <xref:System.ArrayTypeMismatchException> est levée si les tableaux sont de types incompatibles. Compatibilité de type est définie comme suit :  
  
-   Un type est compatible avec lui-même.  
  
-   Un type valeur est compatible avec <xref:System.Object> et avec un type interface implémenté par ce type de valeur. Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement. Les types déconnectés ne sont pas compatibles.  
  
-   Deux types de valeur (prédéfinies) intrinsèque sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue. Une conversion étendue jamais perd les informations, tandis qu’une conversion restrictive peut perdre des informations. Par exemple, convertir un entier signé 32 bits d’un entier signé 64 bits est une conversion étendue et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive. Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
-   Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.  
  
-   Les énumérations ont une conversion implicite vers <xref:System.Enum> et à leur type sous-jacent.  
  
 Si tous les éléments `sourceArray` nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface à un objet) et un ou plusieurs éléments ne peut pas être castés en type correspondant dans `destinationArray`, un <xref:System.InvalidCastException> est levée.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `destinationArray` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> ont des classements différents.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> sont de types incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément de <paramref name="sourceArray" /> ne peut pas être converti en type <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> est supérieur au nombre d’éléments de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="length" /> est supérieur au nombre d’éléments de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> qui contient les données à copier.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> qui reçoit les données.</param>
        <param name="length">Entier 64 bits qui représente le nombre d'éléments à copier. L’entier doit être compris entre zéro et <see cref="F:System.Int32.MaxValue" />, inclus.</param>
        <summary>Copie une série d’éléments de <see cref="T:System.Array" /> en commençant au premier élément, et les colle dans un autre <see cref="T:System.Array" /> en commençant au premier élément. La longueur est spécifiée sous forme d'un entier 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceArray` et `destinationArray` les paramètres doivent avoir le même nombre de dimensions. En outre, `destinationArray` doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en charge les données copiées.  
  
 Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel bout en bout. Par exemple, si un tableau a trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau serait copier toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne).  
  
 Si `sourceArray` et `destinationArray` se chevauchent, cette méthode se comporte comme si les valeurs d’origine de `sourceArray` ont été conservées dans un emplacement temporaire avant `destinationArray` est remplacé.  
  
 [C++]  
  
 Cette méthode est équivalente à la fonction C/C++ standard `memmove`, et non `memcpy`.  
  
 Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur. Cast de type est effectuée, en fonction des besoins.  
  
-   Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié. Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.  
  
-   Lors de la copie à partir d’un tableau de type référence ou type valeur à une <xref:System.Object> tableau, un <xref:System.Object> est créée pour contenir chaque valeur ou référence, puis copié. Lors de la copie à partir d’un <xref:System.Object> tableau à un tableau de type référence ou type valeur et l’affectation n’est pas possible, un <xref:System.InvalidCastException> est levée.  
  
-   Si `sourceArray` et `destinationArray` des tableaux de type référence ou des tableaux de type <xref:System.Object>, une copie superficielle est effectuée. Une copie superficielle d’un <xref:System.Array> est un nouveau <xref:System.Array> contenant des références aux mêmes éléments que l’original <xref:System.Array>. Les éléments eux-mêmes ou quoi que ce soit référencé par les éléments ne sont pas copiés. En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Un <xref:System.ArrayTypeMismatchException> est levée si les tableaux sont de types incompatibles. Compatibilité de type est définie comme suit :  
  
-   Un type est compatible avec lui-même.  
  
-   Un type valeur est compatible avec <xref:System.Object> et avec un type interface implémenté par ce type de valeur. Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement. Les types déconnectés ne sont pas compatibles.  
  
-   Deux types de valeur (prédéfinies) intrinsèque sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue. Une conversion étendue jamais perd les informations, tandis qu’une conversion restrictive peut perdre des informations. Par exemple, convertir un entier signé 32 bits d’un entier signé 64 bits est une conversion étendue et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive. Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
-   Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.  
  
-   Les énumérations ont une conversion implicite vers <xref:System.Enum> et à leur type sous-jacent.  
  
 Si tous les éléments `sourceArray` nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface à un objet) et un ou plusieurs éléments ne peut pas être castés en type correspondant dans `destinationArray`, un <xref:System.InvalidCastException> est levée.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `destinationArray` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> ont des classements différents.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> sont de types incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément de <paramref name="sourceArray" /> ne peut pas être converti en type <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> est inférieur à 0 ou supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> est supérieur au nombre d’éléments de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="length" /> est supérieur au nombre d’éléments de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> qui contient les données à copier.</param>
        <param name="sourceIndex">Entier 32 bits qui représente l’index du <paramref name="sourceArray" /> auquel la copie commence.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> qui reçoit les données.</param>
        <param name="destinationIndex">Entier 32 bits qui représente l’index du <paramref name="destinationArray" /> auquel le stockage commence.</param>
        <param name="length">Entier 32 bits qui représente le nombre d'éléments à copier.</param>
        <summary>Copie une plage d’éléments à partir d’un <see cref="T:System.Array" /> commençant à l’index source spécifié, puis les colle dans un autre <see cref="T:System.Array" /> commençant à l’index de destination spécifié. La longueur et les index sont spécifiés en tant qu'entiers 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceArray` et `destinationArray` les paramètres doivent avoir le même nombre de dimensions. En outre, `destinationArray` doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à partir de la `destinationIndex` position pour prendre en charge les données copiées.  
  
 Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel end-to-end. Par exemple, si un tableau a trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau serait copier toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne). Pour commencer la copie à partir du deuxième élément du troisième ligne (ou colonne), `sourceIndex` doit être la limite supérieure de la première ligne (ou colonne) et la longueur de la deuxième ligne (ou colonne) plus deux.  
  
 Si `sourceArray` et `destinationArray` se chevauchent, cette méthode se comporte comme si les valeurs d’origine de `sourceArray` ont été conservées dans un emplacement temporaire avant `destinationArray` est remplacé.  
  
 [C++]  
  
 Cette méthode est équivalente à la fonction C/C++ standard `memmove`, et non `memcpy`.  
  
 Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur. Cast de type est effectuée, en fonction des besoins.  
  
-   Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié. Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.  
  
-   Lors de la copie à partir d’un tableau de type référence ou type valeur à une <xref:System.Object> tableau, un <xref:System.Object> est créée pour contenir chaque valeur ou référence, puis copié. Lors de la copie à partir d’un <xref:System.Object> tableau à un tableau de type référence ou type valeur et l’affectation n’est pas possible, un <xref:System.InvalidCastException> est levée.  
  
-   Si `sourceArray` et `destinationArray` des tableaux de type référence ou des tableaux de type <xref:System.Object>, une copie superficielle est effectuée. Une copie superficielle d’un <xref:System.Array> est un nouveau <xref:System.Array> contenant des références aux mêmes éléments que l’original <xref:System.Array>. Les éléments eux-mêmes ou quoi que ce soit référencé par les éléments ne sont pas copiés. En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Un <xref:System.ArrayTypeMismatchException> est levée si les tableaux sont de types incompatibles. Compatibilité de type est définie comme suit :  
  
-   Un type est compatible avec lui-même.  
  
-   Un type valeur est compatible avec <xref:System.Object> et avec un type interface implémenté par ce type de valeur. Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement. Les types déconnectés ne sont pas compatibles.  
  
-   Deux types de valeur (prédéfinies) intrinsèque sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue. Une conversion étendue jamais perd les informations, tandis qu’une conversion restrictive peut perdre des informations. Par exemple, convertir un entier signé 32 bits d’un entier signé 64 bits est une conversion étendue et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive. Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
-   Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.  
  
-   Les énumérations ont une conversion implicite vers <xref:System.Enum> et à leur type sous-jacent.  
  
 Si tous les éléments `sourceArray` nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface à un objet) et un ou plusieurs éléments ne peut pas être castés en type correspondant dans `destinationArray`, un <xref:System.InvalidCastException> est levée.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `destinationArray` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment copier à partir d’un <xref:System.Array> de type <xref:System.Object> vers un autre <xref:System.Array> de type entier.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> ont des classements différents.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> sont de types incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément de <paramref name="sourceArray" /> ne peut pas être converti en type <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> est inférieur à la limite inférieure de la première dimension de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="destinationIndex" /> est inférieur à la limite inférieure de la première dimension de <paramref name="destinationArray" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="sourceIndex" /> et la fin de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="destinationIndex" /> et la fin de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><see cref="T:System.Array" /> qui contient les données à copier.</param>
        <param name="sourceIndex">Entier 64 bits qui représente l’index du <paramref name="sourceArray" /> auquel la copie commence.</param>
        <param name="destinationArray"><see cref="T:System.Array" /> qui reçoit les données.</param>
        <param name="destinationIndex">Entier 64 bits qui représente l’index du <paramref name="destinationArray" /> auquel le stockage commence.</param>
        <param name="length">Entier 64 bits qui représente le nombre d'éléments à copier. L’entier doit être compris entre zéro et <see cref="F:System.Int32.MaxValue" />, inclus.</param>
        <summary>Copie une plage d’éléments à partir d’un <see cref="T:System.Array" /> commençant à l’index source spécifié, puis les colle dans un autre <see cref="T:System.Array" /> commençant à l’index de destination spécifié. La longueur et les index sont spécifiés en tant qu'entiers 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `sourceArray` et `destinationArray` les paramètres doivent avoir le même nombre de dimensions. En outre, `destinationArray` doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à partir de la `destinationIndex` position pour prendre en charge les données copiées.  
  
 Lors de la copie entre des tableaux multidimensionnels, le tableau se comporte comme un tableau unidimensionnel de long, où les lignes (ou les colonnes) sont placés sur le plan conceptuel end-to-end. Par exemple, si un tableau a trois lignes (ou colonnes) avec quatre éléments chaque, copie de six éléments à partir du début du tableau serait copier toutes les quatre éléments de la première ligne (ou colonne) et les deux premiers éléments de la deuxième ligne (ou colonne). Pour commencer la copie à partir du deuxième élément du troisième ligne (ou colonne), `sourceIndex` doit être la limite supérieure de la première ligne (ou colonne) et la longueur de la deuxième ligne (ou colonne) plus deux.  
  
 Si `sourceArray` et `destinationArray` se chevauchent, cette méthode se comporte comme si les valeurs d’origine de `sourceArray` ont été conservées dans un emplacement temporaire avant `destinationArray` est remplacé.  
  
 [C++]  
  
 Cette méthode est équivalente à la fonction C/C++ standard `memmove`, et non `memcpy`.  
  
 Les tableaux peuvent être des tableaux de type référence ou des tableaux de type valeur. Cast de type est effectuée, en fonction des besoins.  
  
-   Lors de la copie à partir d’un tableau de type référence à un tableau de type valeur, chaque élément est unboxed, puis copié. Lors de la copie à partir d’un tableau de type valeur dans un tableau de type référence, chaque élément est converti (boxed), puis copié.  
  
-   Lors de la copie à partir d’un tableau de type référence ou type valeur à une <xref:System.Object> tableau, un <xref:System.Object> est créée pour contenir chaque valeur ou référence, puis copié. Lors de la copie à partir d’un <xref:System.Object> tableau à un tableau de type référence ou type valeur et l’affectation n’est pas possible, un <xref:System.InvalidCastException> est levée.  
  
-   Si `sourceArray` et `destinationArray` des tableaux de type référence ou des tableaux de type <xref:System.Object>, une copie superficielle est effectuée. Une copie superficielle d’un <xref:System.Array> est un nouveau <xref:System.Array> contenant des références aux mêmes éléments que l’original <xref:System.Array>. Les éléments eux-mêmes ou quoi que ce soit référencé par les éléments ne sont pas copiés. En revanche, une copie complète d’un <xref:System.Array> copie les éléments et tous les éléments référencés directement ou indirectement par les éléments.  
  
 Un <xref:System.ArrayTypeMismatchException> est levée si les tableaux sont de types incompatibles. Compatibilité de type est définie comme suit :  
  
-   Un type est compatible avec lui-même.  
  
-   Un type valeur est compatible avec <xref:System.Object> et avec un type interface implémenté par ce type de valeur. Un type valeur est considéré comme connecté à une interface uniquement s’il implémente cette interface directement. Les types déconnectés ne sont pas compatibles.  
  
-   Deux types de valeur (prédéfinies) intrinsèque sont compatibles si la copie à partir du type de source pour le type de destination est une conversion étendue. Une conversion étendue jamais perd les informations, tandis qu’une conversion restrictive peut perdre des informations. Par exemple, convertir un entier signé 32 bits d’un entier signé 64 bits est une conversion étendue et la conversion d’un entier signé 64 bits à un entier signé 32 bits est une conversion restrictive. Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
-   Un type non intrinsèque valeur (défini par l’utilisateur) est compatible uniquement avec lui-même.  
  
-   Les énumérations ont une conversion implicite vers <xref:System.Enum> et à leur type sous-jacent.  
  
 Si tous les éléments `sourceArray` nécessite un cast aval (par exemple, à partir d’une classe de base pour une classe dérivée ou d’une interface à un objet) et un ou plusieurs éléments ne peut pas être castés en type correspondant dans `destinationArray`, un <xref:System.InvalidCastException> est levée.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `destinationArray` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment copier à partir d’un <xref:System.Array> de type <xref:System.Object> vers un autre <xref:System.Array> de type entier.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> ont des classements différents.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> et <paramref name="destinationArray" /> sont de types incompatibles.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément de <paramref name="sourceArray" /> ne peut pas être converti en type <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> est en dehors de la plage d’index valides pour <paramref name="sourceArray" />.  
  
ou 
 <paramref name="destinationIndex" /> est en dehors de la plage d’index valides pour <paramref name="destinationArray" />.  
  
ou 
 <paramref name="length" /> est inférieur à 0 ou supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="sourceIndex" /> et la fin de <paramref name="sourceArray" />.  
  
ou 
 <paramref name="length" /> est supérieur au nombre d’éléments compris entre <paramref name="destinationIndex" /> et la fin de <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel constituant la destination des éléments copiés à partir du tableau actuel.</param>
        <param name="index">Entier 32 bits qui représente l’index de <paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié en commençant à l'index du tableau de destination spécifié. L'index est spécifié en tant qu'entier 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie tous les éléments de l’instance actuelle de tableau à la `array` tableau de destination, en commençant à l’index `index`. Le `array` tableau de destination doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les éléments copiés. Sinon, la méthode lève une exception.  
  
 Cette méthode prend en charge la <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Si l’implémentation <xref:System.Collections.ICollection?displayProperty=nameWithType> est requis ne sont pas explicitement, utilisez <xref:System.Array.Copy%2A> afin d’éviter l’indirection supplémentaire.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `array` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Array.Length%2A>. Il effectue une copie superficielle uniquement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment copier un <xref:System.Array> vers un autre <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 L’exemple de code suivant montre comment copier un <xref:System.Array> vers un autre <xref:System.Array> avec une limite inférieure différente de zéro. Notez que la source entière <xref:System.Array> est copié, y compris les éléments vides qui remplacent les éléments existants dans la cible <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> est multidimensionnel.  
  
ou 
Le nombre d’éléments dans le tableau source est supérieur au nombre d’éléments disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Le type du <see cref="T:System.Array" /> source ne peut pas être converti automatiquement en type du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.RankException">Le tableau source est multidimensionnel.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément du <see cref="T:System.Array" /> source ne peut pas être casté en type du <paramref name="array" /> de destination.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel constituant la destination des éléments copiés à partir du tableau actuel.</param>
        <param name="index">Entier 64 bits qui représente l’index de <paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie tous les éléments du tableau unidimensionnel actuel dans le tableau unidimensionnel spécifié en commençant à l'index du tableau de destination spécifié. L'index est spécifié en tant qu'entier 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode copie tous les éléments de l’instance actuelle de tableau à la `array` tableau de destination, en commençant à l’index `index`. Le `array` tableau de destination doit déjà avoir été dimensionné et doit avoir un nombre suffisant d’éléments à prendre en compte les éléments copiés. Sinon, la méthode lève une exception.  
  
 Cette méthode prend en charge la <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Si l’implémentation <xref:System.Collections.ICollection?displayProperty=nameWithType> est requis ne sont pas explicitement, utilisez <xref:System.Array.Copy%2A> afin d’éviter l’indirection supplémentaire.  
  
 Si cette méthode lève une exception lors de la copie, l’état de `array` n’est pas défini.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Array.Length%2A>. Il effectue une copie superficielle uniquement.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment copier un <xref:System.Array> vers un autre <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 L’exemple de code suivant montre comment copier un <xref:System.Array> vers un autre <xref:System.Array> avec une limite inférieure différente de zéro. Notez que la source entière <xref:System.Array> est copié, y compris les éléments vides qui remplacent les éléments existants dans la cible <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est en dehors de la plage d’index valides pour <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> est multidimensionnel.  
  
ou 
Le nombre d’éléments dans le tableau source est supérieur au nombre d’éléments disponible entre <paramref name="index" /> et la fin du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">Le type du <see cref="T:System.Array" /> source ne peut pas être casté automatiquement en type du <paramref name="array" /> de destination.</exception>
        <exception cref="T:System.RankException">Le <see cref="T:System.Array" /> source est multidimensionnel.</exception>
        <exception cref="T:System.InvalidCastException">Au moins un élément du <see cref="T:System.Array" /> source ne peut pas être casté en type du <paramref name="array" /> de destination.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="length">Taille du <see cref="T:System.Array" /> à créer.</param>
        <summary>Crée un <see cref="T:System.Array" /> unidimensionnel du <see cref="T:System.Type" /> et de la longueur spécifiés, à l’aide d’un index de base zéro.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> unidimensionnel du <see cref="T:System.Type" /> et de la longueur spécifiés, avec un index de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser une dimension <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="lengths">Tableau d’entiers 32 bits qui représentent la taille de chaque dimension du <see cref="T:System.Array" /> à créer.</param>
        <summary>Crée un <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro. Les longueurs de dimensions sont spécifiées en tant qu'entiers 32 bits.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Le nombre d’éléments dans le `lengths` tableau doit être égal au nombre de dimensions dans le nouveau <xref:System.Array>. Chaque élément de la `lengths` tableau doit spécifier la longueur de la dimension correspondante dans le nouveau <xref:System.Array>.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est le produit de toutes les valeurs dans `lengths`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.  
  
ou 
Le tableau <paramref name="lengths" /> contient moins d’un élément.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Toute valeur de <paramref name="lengths" /> est inférieure à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="lengths">Tableau d’entiers 64 bits qui représentent la taille de chaque dimension du <see cref="T:System.Array" /> à créer. Chaque entier du tableau doit être compris entre zéro et <see cref="F:System.Int32.MaxValue" /> inclus.</param>
        <summary>Crée un <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro. Les longueurs de dimensions sont spécifiées en tant qu'entiers 64 bits.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Le nombre d’éléments dans le `lengths` tableau doit être égal au nombre de dimensions dans le nouveau <xref:System.Array>. Chaque élément de la `lengths` tableau doit spécifier la longueur de la dimension correspondante dans le nouveau <xref:System.Array>.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est le produit de toutes les valeurs dans `lengths`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.  
  
ou 
Le tableau <paramref name="lengths" /> contient moins d’un élément.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Toute valeur dans <paramref name="lengths" /> est inférieure à 0 ou supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="length1">Taille de la première dimension du <see cref="T:System.Array" /> à créer.</param>
        <param name="length2">Taille de la deuxième dimension du <see cref="T:System.Array" /> à créer.</param>
        <summary>Crée un <see cref="T:System.Array" /> à deux dimensions du <see cref="T:System.Type" /> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> à deux dimensions du <see cref="T:System.Type" /> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est le produit de `length1` et `length2`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser une à deux dimensions <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> est inférieur à zéro.  
  
ou 
 <paramref name="length2" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="lengths">Tableau unidimensionnel qui contient la taille de chaque dimension du <see cref="T:System.Array" /> à créer.</param>
        <param name="lowerBounds">Tableau unidimensionnel qui contient la limite inférieure (index de départ) de chaque dimension du <see cref="T:System.Array" /> à créer.</param>
        <summary>Crée un <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> et des longueurs de dimensions spécifiés, avec les limites inférieures déterminées.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> multidimensionnel du <see cref="T:System.Type" /> spécifié avec la longueur et la limite inférieure déterminées pour chaque dimension.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Le `lengths` et `lowerBounds` tableaux doivent avoir le même nombre d’éléments. Le nombre d’éléments dans le `lengths` tableau doit être égal au nombre de dimensions dans le nouveau <xref:System.Array>.  
  
 Chaque élément de la `lengths` tableau doit spécifier la longueur de la dimension correspondante dans le nouveau <xref:System.Array>.  
  
 Chaque élément de la `lowerBounds` tableau doit spécifier la limite inférieure de la dimension correspondante dans le nouveau <xref:System.Array>. En règle générale, la bibliothèque de classes .NET Framework et de nombreux langages de programmation ne gèrent pas les limites inférieures différentes de zéro.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est le produit de toutes les valeurs dans `lengths`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser un multidimensionnelles <xref:System.Array> avec les limites inférieures déterminées.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="lowerBounds" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.  
  
ou 
Le tableau <paramref name="lengths" /> contient moins d’un élément.  
  
ou 
Les tableaux <paramref name="lengths" /> et <paramref name="lowerBounds" /> ne contiennent pas le même nombre d’éléments.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Toute valeur de <paramref name="lengths" /> est inférieure à zéro.  
  
ou 
Toute valeur de <paramref name="lowerBounds" /> est très grande, comme la somme de la limite inférieure d’une dimension et de la longueur est supérieure à <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType"><see cref="T:System.Type" /> du <see cref="T:System.Array" /> à créer.</param>
        <param name="length1">Taille de la première dimension du <see cref="T:System.Array" /> à créer.</param>
        <param name="length2">Taille de la deuxième dimension du <see cref="T:System.Array" /> à créer.</param>
        <param name="length3">Taille de la troisième dimension du <see cref="T:System.Array" /> à créer.</param>
        <summary>Crée un <see cref="T:System.Array" /> à trois dimensions du <see cref="T:System.Type" /> et des longueurs de dimensions spécifiés, à l’aide d’un index de base zéro.</summary>
        <returns>Nouveau <see cref="T:System.Array" /> à trois dimensions du <see cref="T:System.Type" /> spécifié avec la longueur déterminée pour chaque dimension, à l’aide d’un index de base zéro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement à la plupart des classes, <xref:System.Array> fournit le <xref:System.Array.CreateInstance%2A> méthode, au lieu de constructeurs publics, pour permettre l’accès par liaison tardive.  
  
 Les éléments de type référence sont initialisés à `null`. Éléments de type valeur sont initialisés à zéro.  
  
 Cette méthode est un O (`n`) opération, où `n` est le produit de `length1`, `length2`, et `length3`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer et initialiser un à trois dimensions <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> n’est pas un <see cref="T:System.Type" /> valide.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> n'est pas pris en charge. Par exemple, <see cref="T:System.Void" /> n’est pas pris en charge.  
  
ou 
 <paramref name="elementType" /> est un type générique ouvert.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> est inférieur à zéro.  
  
ou 
 <paramref name="length2" /> est inférieur à zéro.  
  
ou 
 <paramref name="length3" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <summary>Retourne un tableau vide.</summary>
        <returns>Tableau vide.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à rechercher.</param>
        <summary>Détermine si le tableau spécifié contient des éléments qui correspondent aux conditions définies par le prédicat spécifié.</summary>
        <returns><see langword="true" /> si <paramref name="array" /> contient un ou plusieurs éléments qui correspondent aux conditions définies par le prédicat spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>, et le traitement s’arrête lorsqu’une correspondance est trouvée.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le <xref:System.Predicate%601> déléguer explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant spécifie les conditions de correspondance pour le <xref:System.Array.Exists%2A> méthode à l’aide d’expressions lambda pour vérifier si une planète commence par une lettre donnée ou si la planète se trouve sur le tableau donné.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 L’exemple suivant utilise la <xref:System.Array.Exists%2A> méthode pour indiquer si tous les noms dans un tableau de chaînes commencent par un caractère spécifié. L’exemple instancie un `StringSearcher` objet en passant la chaîne à rechercher pour son constructeur de classe. Le `StringSearcher.StartsWith` méthode a la même signature que le <xref:System.Predicate%601> déléguer. Lorsque le <xref:System.Array.Exists%2A> méthode est appelée, chaque membre du tableau est passé au délégué jusqu'à ce qu’elle retourne `true` ou effectue une itération de tous les éléments dans le tableau.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Vous pouvez également utiliser une expression lambda non définissent explicitement une méthode dont la signature correspond à celle du délégué. L’exemple suivant remplace le `StringSearcher` classe et ses `StartsWith` méthode avec une expression lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Expressions lambda (Guide de programmation C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Expressions lambda (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Le tableau de base zéro unidimensionnel à explorer.</param>
        <param name="match">Le prédicat qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la première occurrence dans le <see cref="T:System.Array" /> entier.</summary>
        <returns>Premier élément qui correspond aux conditions définies par le prédicat spécifié, s'il est trouvé ; sinon, valeur par défaut du type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode ou une expression lambda qui retourne `true` si l’objet passé à il correspond aux conditions définies dans la délégué ou l’expression lambda.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>, en commençant par le premier élément et se terminant par le dernier élément.  Traitement s’arrête lorsqu’une correspondance est trouvée.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant utilise un <xref:System.Predicate%601> délégué avec le <xref:System.Array.Find%2A> une méthode générique pour rechercher un tableau de <xref:System.Drawing.Point> structures. La méthode que le délégué représente, `ProductGT10`, retourne `true` si le produit des champs X et Y est supérieur à 100 000. Le <xref:System.Array.Find%2A> méthode appelle le délégué pour chaque élément du tableau, en retournant le premier point qui répond à la condition de test.  
  
> [!NOTE]
>  Utilisateurs Visual Basic et c# n’ont pas créer le délégué explicitement ou de spécifier l’argument de type de la méthode générique. Les compilateurs déterminent les types nécessaires à partir des arguments de méthode que vous fournissez.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Au lieu de définir explicitement une méthode avec la signature nécessaire, l’instanciation d’un <xref:System.Predicate%601> déléguer et en transmettant le délégué à la <xref:System.Array.Find%2A> (méthode), il est courant d’utiliser une expression lambda. L’exemple suivant est identique au précédent, sauf qu’elle utilise une expression lambda en tant que le `match` argument.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions des éléments à rechercher.</param>
        <summary>Récupère tous les éléments qui correspondent aux conditions définies par le prédicat spécifié.</summary>
        <returns><see cref="T:System.Array" /> contenant tous les éléments qui correspondent aux conditions définies par le prédicat spécifié, le cas échéant ; sinon, <see cref="T:System.Array" /> vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>, et les éléments qui correspondent aux conditions sont enregistrés dans le tableau retourné.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant crée un tableau de nombres aléatoires 50 avec des valeurs qui peuvent aller de 0 à 1 000. Il appelle ensuite la <xref:System.Array.FindAll%2A> méthode avec une expression lambda qui retourne les valeurs comprises entre 300 à 600. Notez que l’expression lambda est passée à un paramètre nommé `x`;  Cela représente le membre du groupe individuel qui est passé à la <xref:System.Predicate%601>. Notez également que l’ordinateur local `lBound` et `uBound` variables sont accessibles au sein de l’expression lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 L’exemple de code suivant montre le <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, et <xref:System.Array.FindAll%2A> méthodes génériques. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.Find%2A> méthode générique parcourt le tableau à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément « Amargasaurus ».  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindLast%2A> méthode générique est utilisé pour la recherche dans le tableau à partir de la fin. Il recherche l’élément « Dilophosaurus » à la position 5. Le <xref:System.Array.FindAll%2A> méthode générique est utilisée pour retourner un tableau contenant tous les éléments qui se terminent par « saurus ». Les éléments sont affichés.  
  
 L’exemple de code montre également le <xref:System.Array.Exists%2A> et <xref:System.Array.TrueForAll%2A> méthodes génériques.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un élément qui correspond aux conditions définies par un prédicat spécifié, puis retourne l’index de base zéro de la première occurrence au sein d’un <see cref="T:System.Array" /> ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans le <see cref="T:System.Array" /> entier.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> recherche est effectuée vers l’avant à partir du premier élément au dernier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 1.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau. Il recherche l’élément à la position 5. Enfin, le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2. Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="startIndex">Index de début de base zéro de la recherche.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Array" /> qui s'étend de l'index spécifié au dernier élément.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> recherche est effectuée vers l’avant `startIndex` et jusqu’au dernier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir de `startIndex` à la fin de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 1.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau. Il recherche l’élément à la position 5. Enfin, le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2. Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="startIndex">Index de début de base zéro de la recherche.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la première occurrence trouvée dans la plage d'éléments de <see cref="T:System.Array" /> qui commence à l'index spécifié et contient le nombre d'éléments spécifié.</summary>
        <returns>Index de base zéro de la première occurrence d’un élément qui répond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> recherche est effectuée vers l’avant `startIndex` et en terminant à `startIndex` plus `count` -1, si `count` est supérieur à 0.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 1.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 2 à la fin du tableau. Il recherche l’élément à la position 5. Enfin, le <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments en commençant à la position 2. Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne la dernière occurrence dans le <see cref="T:System.Array" /> entier.</summary>
        <returns>Dernier élément qui correspond aux conditions définies par le prédicat spécifié, le cas échéant ; sinon, valeur par défaut du type <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>, déplacement vers l’arrière dans le <xref:System.Array>, en commençant par le dernier élément et se terminant par le premier élément.  Traitement s’arrête lorsqu’une correspondance est trouvée.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, et <xref:System.Array.FindAll%2A> méthodes génériques. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.Find%2A> méthode générique parcourt le tableau à partir du début, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément « Amargasaurus ».  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le`Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindLast%2A> méthode générique est utilisé pour la recherche dans le tableau à partir de la fin. Il recherche l’élément « Dilophosaurus » à la position 5. Le <xref:System.Array.FindAll%2A> méthode générique est utilisée pour retourner un tableau contenant tous les éléments qui se terminent par « saurus ». Les éléments sont affichés.  
  
 L’exemple de code montre également le <xref:System.Array.Exists%2A> et <xref:System.Array.TrueForAll%2A> méthodes génériques.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche un élément qui correspond aux conditions définies par un prédicat spécifié et retourne l’index de base zéro de la dernière occurrence dans un <see cref="T:System.Array" /> ou une partie de celui-ci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l’index de base zéro de la dernière occurrence trouvée dans le <see cref="T:System.Array" /> entier.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> recherche est effectuée vers l’arrière à partir du dernier élément vers le premier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindLastIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau vers l’arrière à partir de la fin, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 5.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau. Il recherche l’élément à la position 1. Enfin, le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 4, 3 et 2). Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l'index de base zéro de la dernière occurrence trouvée dans la plage d'éléments du <see cref="T:System.Array" /> qui s'étend du premier élément à l'index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et jusqu’au premier élément.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir du début de `array` à `startIndex`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindLastIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau vers l’arrière à partir de la fin, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 5.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau. Il recherche l’élément à la position 1. Enfin, le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 4, 3 et 2). Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> qui définit les conditions de l’élément à rechercher.</param>
        <summary>Recherche un élément qui correspond aux conditions définies par le prédicat spécifié et retourne l’index de base zéro de la dernière occurrence trouvée dans la plage d’éléments du <see cref="T:System.Array" /> qui contient le nombre d’éléments spécifié et se termine à l’index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence d’un élément qui correspond aux conditions définies par <paramref name="match" />, si cette occurrence est trouvée ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et en terminant à `startIndex` moins `count` + 1, si `count` est supérieur à 0.  
  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne `true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges de la <xref:System.Array.FindLastIndex%2A> méthode générique. Un tableau de chaînes est créé, contenant des noms de dinosaure 8, deux d'entre eux (positions 1 et 5) se terminent par « saurus ». L’exemple de code définit également une méthode de prédicat de recherche nommée `EndsWithSaurus`, qui accepte un paramètre de chaîne et retourne une valeur Boolean indiquant si la chaîne d’entrée se termine par « saurus ».  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode parcourt le tableau vers l’arrière à partir de la fin, chaque élément en passant à la `EndsWithSaurus` (méthode). La recherche s’arrête lorsque la `EndsWithSaurus` retourne de la méthode `true` pour l’élément à la position 5.  
  
> [!NOTE]
>  En c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 Le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant à la position 4 au début du tableau. Il recherche l’élément à la position 1. Enfin, le <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> surcharge de méthode est utilisée pour rechercher la plage de trois éléments commençant à la position 4 et en (autrement dit, 4, 3 et 2). Elle retourne -1, car aucun nom de dinosaure dans cette plage qui se terminent par « saurus ».  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel de base zéro sur les éléments duquel l’action doit être exécutée.</param>
        <param name="action">Le <see cref="T:System.Action`1" /> à exécuter sur chaque élément de <paramref name="array" />.</param>
        <summary>Exécute l'action spécifiée sur chaque élément du tableau spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Action%601> est un délégué à une méthode qui effectue une action sur l’objet passé.  Les éléments de `array` sont passés à la <xref:System.Action%601>.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Array.ForEach%2A> pour afficher les carrés de chaque élément dans un tableau d’entiers.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="action" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne <see cref="T:System.Collections.IEnumerator" /> pour l'objet <see cref="T:System.Array" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> pour <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 Le `foreach` instruction du langage c# (`for each` en C++, `For Each` en Visual Basic) masque la complexité des énumérateurs. Il est donc recommandé d'utiliser `foreach` plutôt que de manipuler l'énumérateur directement.  
  
 Les énumérateurs peuvent être utilisés pour lire les données de la collection, mais ils ne permettent pas de modifier la collection sous-jacente.  
  
 Au départ, l'énumérateur est positionné avant le premier élément de la collection. <xref:System.Collections.IEnumerator.Reset%2A> replace également l'énumérateur à cette position.  À cette position, <xref:System.Collections.IEnumerator.Current%2A> n'est pas défini. Par conséquent, vous devez appeler <xref:System.Collections.IEnumerator.MoveNext%2A> pour avancer l'énumérateur jusqu'au premier élément de la collection avant de lire la valeur de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retourne le même objet tant que <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> n'est pas appelé. <xref:System.Collections.IEnumerator.MoveNext%2A> affecte l'élément suivant à <xref:System.Collections.IEnumerator.Current%2A>.  
  
 Si <xref:System.Collections.IEnumerator.MoveNext%2A> passe à la fin de la collection, l’énumérateur est positionnée après le dernier élément dans la collection et <xref:System.Collections.IEnumerator.MoveNext%2A> retourne `false`. Lorsque l’énumérateur se trouve à cette position, les appels suivants à <xref:System.Collections.IEnumerator.MoveNext%2A> également retourner `false`. Si le dernier appel à <xref:System.Collections.IEnumerator.MoveNext%2A> retourné `false`, <xref:System.Collections.IEnumerator.Current%2A> n’est pas défini. Pour attribuer une nouvelle fois <xref:System.Collections.IEnumerator.Current%2A> au premier élément de la collection, vous pouvez appeler <xref:System.Collections.IEnumerator.Reset%2A> suivi de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Un énumérateur est valide tant que la collection demeure inchangée. Si des modifications sont apportées à la collection, telles que l’ajout, la modification ou la suppression d’éléments, l’énumérateur est définitivement invalidé et son comportement n’est pas défini.  
  
 L'énumérateur ne dispose pas d'un accès exclusif à la collection. Par conséquent, l'énumération d'une collection n'est pas intrinsèquement une procédure thread-safe.  Pour garantir la sécurité des threads pendant l'énumération, vous pouvez verrouiller la collection tout au long de cette opération.  Pour permettre à plusieurs threads d’accéder en lecture et en écriture à la collection, vous devez implémenter votre propre synchronisation.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser <xref:System.Array.GetEnumerator%2A> pour répertorier les éléments d’un tableau.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimension de base zéro de <see cref="T:System.Array" /> dont la longueur doit être déterminée.</param>
        <summary>Obtient un entier 32 bits qui représente le nombre d’éléments dans la dimension spécifiée de <see cref="T:System.Array" />.</summary>
        <returns>Entier 32 bits qui représente le nombre d'éléments dans la dimension spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un exemple de <xref:System.Array.GetLength%2A> est `GetLength(0)`, qui retourne le nombre d’éléments dans la première dimension de le <xref:System.Array>.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser <xref:System.Array.GetLength%2A> pour afficher les dimensions de deux tableaux avec des classements différents.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> est inférieur à zéro.  
  
ou 
 <paramref name="dimension" /> est supérieur ou égal à <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimension de base zéro de <see cref="T:System.Array" /> dont la longueur doit être déterminée.</param>
        <summary>Obtient un entier 64 bits qui représente le nombre d’éléments dans la dimension spécifiée de <see cref="T:System.Array" />.</summary>
        <returns>Entier 64 bits qui représente le nombre d’éléments dans la dimension spécifiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un exemple de <xref:System.Array.GetLongLength%2A> est `GetLongLength(0)`, qui retourne le nombre d’éléments dans la première dimension de le <xref:System.Array>.  
  
 Cette méthode est une opération o (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> est inférieur à zéro.  
  
ou 
 <paramref name="dimension" /> est supérieur ou égal à <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimension de base zéro du tableau dont l'index de départ doit être déterminé.</param>
        <summary>Obtient l'index du premier élément de la dimension spécifiée dans le tableau.</summary>
        <returns>Index du premier élément de la dimension spécifiée dans le tableau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Retourne l’index de départ de la première dimension du tableau, et `GetLowerBound(Rank - 1)` retourne l’index de départ de la dernière dimension du tableau.  
  
 Le <xref:System.Array.GetLowerBound%2A> méthode retourne toujours une valeur qui indique l’index de la limite inférieure du tableau, même si le tableau est vide.  
  
 Notez que, bien que la plupart des tableaux dans le .NET Framework sont de base zéro (autrement dit, le <xref:System.Array.GetLowerBound%2A> méthode retourne la valeur zéro pour chaque dimension d’un tableau), le .NET Framework ne prend pas en charge les tableaux qui ne sont pas de base zéro. Ces tableaux peuvent être créés avec le <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> (méthode) et peut également être retourné à partir de code non managé.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes pour afficher les limites d’un tableau unidimensionnel et à deux dimensions et pour afficher les valeurs de leurs éléments de tableau.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> est inférieur à zéro.  
  
ou 
 <paramref name="dimension" /> est supérieur ou égal à <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Dimension de base zéro du tableau dont la limite supérieure doit être déterminée.</param>
        <summary>Obtient l'index du dernier élément de la dimension spécifiée dans le tableau.</summary>
        <returns>Index du dernier élément de la dimension spécifiée dans le tableau, ou -1 si la dimension spécifiée est vide.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Retourne le dernier index dans la première dimension du tableau, et `GetUpperBound(Rank - 1)` retourne le dernier index de la dernière dimension du tableau.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes pour afficher les limites d’un tableau unidimensionnel et à deux dimensions et pour afficher les valeurs de leurs éléments de tableau.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> est inférieur à zéro.  
  
ou 
 <paramref name="dimension" /> est supérieur ou égal à <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient la valeur de l’élément spécifié dans le courant <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">Entier 32 bits qui représente la position de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée de l’<see cref="T:System.Array" /> unidimensionnel. L'index est spécifié en tant qu'entier 32 bits.</summary>
        <returns>Valeur à la position spécifiée de l’<see cref="T:System.Array" /> unidimensionnel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si la valeur de `index` est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement une dimension.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> est en dehors de la plage d’index valides pour le <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Tableau unidimensionnel d’entiers 32 bits qui représentent les index spécifiant la position de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> multidimensionnel. Les index sont spécifiés sous la forme d'un tableau d'entiers 32 bits.</summary>
        <returns>Valeur à la position spécifiée dans l’<see cref="T:System.Array" /> multidimensionnel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre d’éléments dans `indices` doit être égal au nombre de dimensions dans le <xref:System.Array>. Tous les éléments dans le `indices` tableau doit spécifier collectivement de la position de l’élément souhaité dans le multidimensionnelles <xref:System.Array>.  
  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre de dimensions dans l’<see cref="T:System.Array" /> actuel n’est pas égal au nombre d’éléments dans <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Tout élément dans <paramref name="indices" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">Entier 64 bits qui représente la position de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée de l’<see cref="T:System.Array" /> unidimensionnel. L'index est spécifié en tant qu'entier 64 bits.</summary>
        <returns>Valeur à la position spécifiée de l’<see cref="T:System.Array" /> unidimensionnel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si la valeur de `index` est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement une dimension.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est en dehors de la plage d’index valides pour le <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Tableau unidimensionnel d’entiers 64 bits qui représentent les index spécifiant la position de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> multidimensionnel. Les index sont spécifiés sous la forme d’un tableau d’entiers 64 bits.</summary>
        <returns>Valeur à la position spécifiée dans l’<see cref="T:System.Array" /> multidimensionnel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre d’éléments dans `indices` doit être égal au nombre de dimensions dans le <xref:System.Array>. Tous les éléments dans le `indices` tableau doit spécifier collectivement de la position de l’élément souhaité dans le multidimensionnelles <xref:System.Array>.  
  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre de dimensions dans l’<see cref="T:System.Array" /> actuel n’est pas égal au nombre d’éléments dans <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tout élément dans <paramref name="indices" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Entier 32 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index2">Entier 32 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions. Les index sont spécifiés en tant qu'entiers 32 bits.</summary>
        <returns>Valeur à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’<see cref="T:System.Array" /> actuel ne possède pas exactement deux dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Soit <paramref name="index1" /> ou <paramref name="index2" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Entier 64 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index2">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions. Les index sont spécifiés en tant qu’entiers 64 bits.</summary>
        <returns>Valeur à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’<see cref="T:System.Array" /> actuel ne possède pas exactement deux dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Soit <paramref name="index1" /> ou <paramref name="index2" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Entier 32 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index2">Entier 32 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index3">Entier 32 bits qui représente l’index de la troisième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> à trois dimensions. Les index sont spécifiés en tant qu'entiers 32 bits.</summary>
        <returns>Valeur à la position spécifiée du <see cref="T:System.Array" /> à trois dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement trois dimensions.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> est en dehors de la plage d’index valides pour la dimension correspondante du <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">Entier 64 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index2">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <param name="index3">Entier 64 bits qui représente l’index de la troisième dimension de l’élément <see cref="T:System.Array" /> à obtenir.</param>
        <summary>Obtient la valeur à la position spécifiée du <see cref="T:System.Array" /> à trois dimensions. Les index sont spécifiés en tant qu’entiers 64 bits.</summary>
        <returns>Valeur à la position spécifiée du <see cref="T:System.Array" /> à trois dimensions.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Cette méthode est une opération o (1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement trois dimensions.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> est en dehors de la plage d’index valides pour la dimension correspondante du <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel ou dans une plage d'éléments dans le tableau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel.</summary>
        <returns>L’index de la première occurrence de <paramref name="value" /> dans <paramref name="array" />, s’il existe ; sinon, la limite inférieure du tableau -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche tous les éléments d’un tableau unidimensionnel `value`. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant de chaque élément `Equals` méthode jusqu'à ce qu’il trouve une correspondance. Cela signifie que si l’élément remplace la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode, qui substituent est appelée.  
  
 Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement -1 si`value` n’est pas trouvée. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) et `value` n’est trouvée, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple appelle trois surcharges de la <xref:System.Array.IndexOf%2A> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de départ de la recherche. 0 (zéro) est valide dans un tableau vide.</param>
        <summary>Recherche l’objet spécifié dans une plage d’éléments d’un tableau unidimensionnel, et retourne l’index de sa première occurrence. La plage s’étend d’un index spécifié à la fin du tableau.</summary>
        <returns>Index de la première occurrence de <paramref name="value" />, si elle existe, au sein de la plage d’éléments de <paramref name="array" />, qui s’étend de <paramref name="startIndex" /> jusqu’au dernier élément ; sinon, limite inférieure du tableau moins 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans un tableau unidimensionnel à partir de l’élément à index `startIndex` jusqu’au dernier élément. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant le `Equals` (méthode) de chaque élément jusqu'à ce qu’il trouve une correspondance. Cela signifie que si l’élément remplace la <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> méthode, qui substituent est appelée.  
  
 Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement -1 si `value` n’est pas trouvée. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType>(0 x 80000000) et `value` n’est trouvée, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Si `startIndex` est égal à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode retourne -1. Si `startIndex` est supérieur à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir de `startIndex` à la fin de `array`.  
  
   
  
## Examples  
 L’exemple appelle trois surcharges de la <xref:System.Array.IndexOf%2A> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> est en dehors de la plage d’index valides pour <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de départ de la recherche. 0 (zéro) est valide dans un tableau vide.</param>
        <param name="count">Nombre d'éléments à explorer.</param>
        <summary>Recherche l'objet spécifié dans une plage d'éléments d'un tableau unidimensionnel, et retourne l'index de sa première occurrence. La plage commence à un index spécifié pour un nombre d'éléments spécifié.</summary>
        <returns>Index de la première occurrence de <paramref name="value" />, si elle existe dans <paramref name="array" /> entre l’index <paramref name="startIndex" /> et <paramref name="startIndex" /> + <paramref name="count" /> - 1 ; sinon, limite inférieure du tableau moins 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche les éléments d’un tableau unidimensionnel à partir de `startIndex` à `startIndex` plus `count` -1, si `count` est supérieur à 0. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant le `Equals` (méthode) de chaque élément jusqu'à ce qu’il trouve une correspondance. Cela signifie que si l’élément remplace la <xref:System.Object.Equals%2A?displayProperty=nameWithType> méthode, qui substituent est appelée.  
  
 Étant donné que la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 lorsque `value` n’est pas trouvée. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType> (0 x 80000000) et `value` n’est trouvée, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Si `startindex` est égal à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode retourne -1. Si `startIndex` est supérieur à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
   
  
## Examples  
 L’exemple appelle trois surcharges de la <xref:System.Array.IndexOf%2A> méthode pour rechercher l’index d’une chaîne dans un tableau de chaînes :  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, pour déterminer la première occurrence de la chaîne « the » dans un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans la quatrième aux derniers éléments d’un tableau de chaînes.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, pour déterminer la première occurrence de la chaîne « the » dans une chaîne de tableau à partir de l’élément qui suit la dernière correspondance à la fin du tableau. Pour déterminer la valeur de la `count` argument, il soustrait la limite supérieure du tableau à partir de l’index de départ et ajoute une.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Le tableau de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <summary>Recherche l'objet spécifié et retourne l'index de sa première occurrence dans un tableau unidimensionnel.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="value" /> dans le <paramref name="array" /> entier, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche tous les éléments d’un tableau unidimensionnel `value`. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant le `T.Equals` méthode sur chaque élément. Cela signifie que si `T` remplace le <xref:System.Object.Equals%2A> méthode, qui substituent est appelée.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges génériques de la <xref:System.Array.IndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Le tableau de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de début de base zéro de la recherche. 0 (zéro) est valide dans un tableau vide.</param>
        <summary>Recherche l’objet spécifié dans une plage d’éléments d’un tableau unidimensionnel, et retourne l’index de sa première occurrence. La plage s’étend d’un index spécifié à la fin du tableau.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="value" /> dans la plage d’éléments de <paramref name="array" /> qui s’étend de <paramref name="startIndex" /> jusqu’au dernier élément, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans un tableau unidimensionnel à partir de l’élément à `startIndex` à la fin du tableau. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant le `T.Equals` méthode sur chaque élément. Cela signifie que si `T` remplace le <xref:System.Object.Equals%2A> méthode, qui substituent est appelée.  
  
 Si `startIndex` est égal à <xref:System.Array.Length%2A>, la méthode retourne - 1.If `startIndex` est supérieur à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir de `startIndex` à la fin de `array`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges génériques de la <xref:System.Array.IndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Le tableau de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de début de base zéro de la recherche. 0 (zéro) est valide dans un tableau vide.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <summary>Recherche l’objet spécifié dans une plage d’éléments d’un tableau unidimensionnel, et retourne l’index de sa première occurrence. La plage commence à un index spécifié pour un nombre d'éléments spécifié.</summary>
        <returns>Index de base zéro de la première occurrence de <paramref name="value" /> dans la plage d’éléments de <paramref name="array" /> qui commence à <paramref name="startIndex" /> et qui contient le nombre d’éléments spécifié dans <paramref name="count" />, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche les éléments d’un tableau unidimensionnel à partir de `startIndex` à `startIndex` plus `count` -1, si `count` est supérieur à 0. Pour déterminer si `value` existe dans `array`, la méthode effectue une comparaison d’égalité en appelant le `T.Equals` méthode sur chaque élément. Cela signifie que si `T` remplace le <xref:System.Object.Equals%2A> méthode, qui substituent est appelée.  
  
 Si `startIndex` est égal à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode retourne -1.  Si `startIndex` est supérieur à <xref:System.Array.Length%2A?displayProperty=nameWithType>, la méthode lève un <xref:System.ArgumentOutOfRangeException>.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
   
  
## Examples  
 L’exemple suivant illustre les trois surcharges génériques de la <xref:System.Array.IndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode de recherche dans le tableau à partir du début et de la première occurrence de la chaîne. Le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau en commençant par l’emplacement d’index 3 et en continuant à la fin du tableau et la deuxième occurrence de la chaîne. Enfin, le <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de deux entrées, en commençant à l’emplacement d’index deux ; elle retourne -1, car aucune instance de la chaîne de recherche dans cette plage.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Initialise tous les éléments du <see cref="T:System.Array" /> de type valeur en appelant le constructeur par défaut du type valeur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode est conçue pour aider les compilateurs à prendre en charge des tableaux de type valeur ; la plupart des utilisateurs n’avez pas besoin de cette méthode. Il ne doit pas être utilisé sur des tableaux de type référence.  
  
 Si le <xref:System.Array> n’est pas un type valeur <xref:System.Array> ou si le type de valeur n’a pas un constructeur par défaut, le <xref:System.Array> n’est pas modifié.  
  
 Le type de valeur <xref:System.Array> peut avoir n’importe quel limite inférieure et n’importe quel nombre de dimensions.  
  
 Cette méthode est un O (`n`) opération, où `n` est <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Vous pouvez utiliser cette méthode uniquement sur les types valeur qui possèdent des constructeurs. Toutefois, les types de valeur natives de c# n’ont pas de constructeurs.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Array" /> est de taille fixe.</summary>
        <value>Cette propriété est toujours <see langword="true" /> pour tous les tableaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implémente le <xref:System.Array.IsFixedSize%2A> propriété, car elle est requise par le <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Un tableau avec une taille fixe n’autorise pas l’ajout ou la suppression d’éléments après le tableau est créé, mais elle permet la modification des éléments existants.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si <see cref="T:System.Array" /> est en lecture seule.</summary>
        <value>Cette propriété est toujours <see langword="false" /> pour tous les tableaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implémente le <xref:System.Array.IsReadOnly%2A> propriété, car elle est requise par le <xref:System.Collections.IList?displayProperty=nameWithType> interface. Un tableau qui est en lecture seule n’autorise pas l’ajout, la suppression ou la modification d’éléments après que le tableau est créé.  
  
 Si vous avez besoin d’une collection en lecture seule, utilisez un <xref:System.Collections> classe qui implémente le <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Si vous effectuez un cast ou convertir un tableau à une <xref:System.Collections.IList> objet d’interface, le <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> retourne de la propriété `false`. Toutefois, si vous effectuez un cast ou convertir un tableau à un <xref:System.Collections.Generic.IList%601> interface, le `IsReadOnly` retourne de la propriété `true`.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Array" /> est synchronisé (thread-safe).</summary>
        <value>Cette propriété est toujours <see langword="false" /> pour tous les tableaux.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implémente le <xref:System.Array.IsSynchronized%2A> propriété, car elle est requise par le <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Les classes .NET framework basées sur <xref:System.Array> fournissent leur propre version synchronisée de la collection en utilisant le <xref:System.Array.SyncRoot%2A> propriété.  
  
 Les classes qui utilisent des tableaux peuvent également implémenter leur propre à l’aide de la synchronisation du <xref:System.Array.SyncRoot%2A> propriété. Le code de synchronisation doit effectuer les opérations sur les `SyncRoot` de la collection, pas directement sur la collection. Cela garantit un bon fonctionnement des collections dérivées d’autres objets. Plus précisément, la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément la collection. Notez que certaines implémentations de <xref:System.Array.SyncRoot%2A> peut retourner le <xref:System.Array> lui-même.  
  
 L’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller un tableau pendant toute l’énumération à l’aide de la <xref:System.Array.SyncRoot%2A> propriété.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne l’index de la dernière occurrence d’une valeur dans un <see cref="T:System.Array" /> unidimensionnel ou dans une partie du <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel dans lequel rechercher.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence dans l’ensemble du <see cref="T:System.Array" /> unidimensionnel.</summary>
        <returns>Index de la dernière occurrence de <paramref name="value" /> au sein de la totalité du <paramref name="array" />, s’il existe ; sinon, la limite inférieure du tableau -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensionnel <xref:System.Array> recherche est effectuée vers l’arrière à partir du dernier élément vers le premier élément.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le `Equals` implémentation de ce type est utilisée.  
  
 Dans la mesure où la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 lorsque `value` est introuvable. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType> et `value` est introuvable, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType>, c'est-à-dire `System.Int32.MinValue - 1`.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
 Dans le .NET Framework version 2.0, cette méthode utilise la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la <xref:System.Array> pour déterminer si le <xref:System.Object> spécifié par le `value` paramètre existe. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `value` <xref:System.Object> lui-même.  
  
 <xref:System.IComparable.CompareTo%2A> méthodes de la `item` paramètre sur les objets dans la collection.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel dans lequel rechercher.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de départ de la recherche vers le haut.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence dans la plage d’éléments du <see cref="T:System.Array" /> unidimensionnel qui s’étend du premier élément jusqu’à l’index spécifié.</summary>
        <returns>Index de la dernière occurrence de <paramref name="value" /> dans la plage d’éléments de <paramref name="array" /> qui s’étend du premier élément jusqu’à <paramref name="startIndex" />, s’il existe ; sinon, la limite inférieure du tableau -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensionnel <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et jusqu’au premier élément.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le `Equals` implémentation de ce type est utilisée.  
  
 Dans la mesure où la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 lorsque `value` est introuvable. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType> et `value` est introuvable, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType>, c'est-à-dire `System.Int32.MinValue - 1`.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir du début de `array` à `startIndex`.  
  
 Dans le .NET Framework version 2.0, cette méthode utilise la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la <xref:System.Array> pour déterminer si le <xref:System.Object> spécifié par le `value` paramètre existe. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `value` <xref:System.Object> lui-même.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> est en dehors de la plage d’index valides pour <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel dans lequel rechercher.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de départ de la recherche vers le haut.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence au sein de la plage d’éléments du <see cref="T:System.Array" /> unidimensionnel qui contient le nombre d’éléments spécifié et se termine à l’index spécifié.</summary>
        <returns>Index de la dernière occurrence de <paramref name="value" /> au sein de la plage d’éléments de <paramref name="array" /> qui contient le nombre d’éléments spécifié dans <paramref name="count" /> et se termine à <paramref name="startIndex" />, si cette occurrence existe ; sinon, limite inférieure du tableau -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensionnel <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et en terminant à `startIndex` moins `count` + 1, si `count` est supérieur à 0.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le`Equals` implémentation de ce type est utilisée.  
  
 Dans la mesure où la plupart des tableaux ont une limite inférieure de zéro, cette méthode retourne généralement-1 lorsque `value` est introuvable. Dans le cas rare où la limite inférieure du tableau est égale à <xref:System.Int32.MinValue?displayProperty=nameWithType> et `value` est introuvable, cette méthode retourne <xref:System.Int32.MaxValue?displayProperty=nameWithType>, c'est-à-dire `System.Int32.MinValue - 1`.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
 Dans le .NET Framework version 2.0, cette méthode utilise la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la <xref:System.Array> pour déterminer si le <xref:System.Object> spécifié par le `value` paramètre existe. Dans les versions antérieures du .NET Framework, cette détermination était effectuée à l’aide de la <xref:System.Object.Equals%2A> et <xref:System.IComparable.CompareTo%2A> méthodes de la `value` <xref:System.Object> lui-même.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment déterminer l’index de la dernière occurrence d’un élément spécifié dans un tableau. Notez que le <xref:System.Array.LastIndexOf%2A> méthode est une recherche vers l’arrière ; par conséquent, `count` doit être inférieur ou égal à (`startIndex` -la limite inférieure du tableau + 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence dans le <see cref="T:System.Array" /> entier.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="value" /> dans le <paramref name="array" /> entier, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> recherche est effectuée vers l’arrière à partir du dernier élément vers le premier élément.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le `Equals` implémentation de ce type est utilisée.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges génériques de la <xref:System.Array.LastIndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode recherche l’intégralité du tableau à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne. Enfin, le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence dans la plage d’éléments du <see cref="T:System.Array" /> qui s’étend du premier élément jusqu’à l’index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="value" /> dans la plage d’éléments de <paramref name="array" /> qui s’étend du premier élément à <paramref name="startIndex" />, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et jusqu’au premier élément.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le `Equals` implémentation de ce type est utilisée.  
  
 Cette méthode est un O (`n`) opération, où `n` est le nombre d’éléments à partir du début de `array` à `startIndex`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges génériques de la <xref:System.Array.LastIndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode recherche l’intégralité du tableau à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne. Enfin, le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à explorer.</param>
        <param name="value">Objet à rechercher dans <paramref name="array" />.</param>
        <param name="startIndex">Index de début de base zéro de la recherche vers le haut.</param>
        <param name="count">Nombre d'éléments contenus dans la section où la recherche doit être effectuée.</param>
        <summary>Recherche l’objet spécifié et retourne l’index de la dernière occurrence dans la plage d’éléments de l’<see cref="T:System.Array" /> qui contient le nombre d’éléments spécifié et se termine à l’index spécifié.</summary>
        <returns>Index de base zéro de la dernière occurrence de <paramref name="value" /> dans la plage d’éléments de <paramref name="array" /> qui contient le nombre d’éléments spécifié dans <paramref name="count" /> et qui se termine à <paramref name="startIndex" />, s’il est trouvé ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array> est effectuée vers l’arrière commençant à `startIndex` et en terminant à `startIndex` moins `count` + 1, si `count` est supérieur à 0.  
  
 Les éléments sont comparés à la valeur spécifiée à l’aide de la <xref:System.Object.Equals%2A?displayProperty=nameWithType> (méthode). Si le type d’élément est un type non intrinsèque de (défini par l’utilisateur), le `Equals` implémentation de ce type est utilisée.  
  
 Cette méthode est un O (`n`) opération, où `n` est `count`.  
  
   
  
## Examples  
 L’exemple de code suivant illustre les trois surcharges génériques de la <xref:System.Array.LastIndexOf%2A> (méthode). Un tableau de chaînes est créé, avec une entrée qui apparaît deux fois, à l’emplacement d’index 0 et emplacement d’index 5. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode recherche l’intégralité du tableau à partir de la fin et la deuxième occurrence de la chaîne. Le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher le tableau vers l’arrière en commençant par l’emplacement d’index 3 et en continuant vers le début du tableau et recherche la première occurrence de la chaîne. Enfin, le <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode est utilisée pour rechercher une plage de quatre entrées, en commençant à l’emplacement d’index 4 et l’extension vers l’arrière (autrement dit, il recherche les éléments aux emplacements 4, 3, 2 et 1) ; cette recherche retourne -1, car aucune instance de la recherche chaîne dans cette plage.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> n’est pas compris dans la plage d’index valides pour <paramref name="array" />.  
  
ou 
 <paramref name="count" /> est inférieur à zéro.  
  
ou 
 <paramref name="startIndex" /> et <paramref name="count" /> ne spécifient pas une section valide dans <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d’éléments dans toutes les dimensions du <see cref="T:System.Array" />.</summary>
        <value>Nombre total d’éléments dans toutes les dimensions du <see cref="T:System.Array" /> ; zéro si le tableau ne contient pas d’élément.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Array.Length%2A> propriété à obtenir le nombre total d’éléments dans un tableau. Il utilise également le <xref:System.Array.GetUpperBound%2A> méthode pour déterminer le nombre d’éléments dans chaque dimension d’un tableau multidimensionnel.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Le tableau est multidimensionnel et contient plus de <see cref="F:System.Int32.MaxValue" /> éléments.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un entier 64 bits qui représente le nombre total d’éléments dans toutes les dimensions du <see cref="T:System.Array" />.</summary>
        <value>Entier 64 bits qui représente le nombre total d’éléments dans toutes les dimensions du <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le rang (nombre de dimensions) du <see cref="T:System.Array" />. Par exemple, un tableau unidimensionnel retourne 1, un tableau bidimensionnel retourne 2, etc.</summary>
        <value>Rang (nombre de dimensions) du <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par exemple, le code Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 et le code c#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 créer un tableau de trois dimensions avec un <xref:System.Array.Rank%2A> propriété dont la valeur est 3.  
  
 Un tableau en escalier (tableau de tableaux) est un tableau unidimensionnel. la valeur de son <xref:System.Array.Rank%2A> propriété est 1.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple suivant initialise un tableau unidimensionnel, un tableau à deux dimensions et un tableau en escalier et récupère le <xref:System.Array.Rank%2A> propriété de chacun d’eux.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array">Tableau unidimensionnel de base zéro à redimensionner, ou <see langword="null" /> pour créer un tableau avec la taille spécifiée.</param>
        <param name="newSize">Taille du nouveau tableau.</param>
        <summary>Modifie le nombre d'éléments d'un tableau unidimensionnel avec la nouvelle taille spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode alloue un nouveau tableau avec la taille spécifiée, copie les éléments à partir du tableau ancien vers le nouveau, puis remplace l’ancien tableau par le nouveau. `array` doit être un tableau unidimensionnel.  
  
 Si `array` est `null`, cette méthode crée un nouveau tableau avec la taille spécifiée.  
  
 Si `newSize` est supérieure à la <xref:System.Array.Length%2A> de l’ancien tableau, un nouveau tableau est alloué et tous les éléments sont copiés à partir de l’ancien tableau vers le nouveau.  Si `newSize` est inférieure à la <xref:System.Array.Length%2A> de l’ancien tableau, un nouveau tableau est alloué et les éléments sont copiés à partir de l’ancien tableau vers le nouveau jusqu'à ce que le nouveau soit rempli ; le reste des éléments dans le tableau ancien sont ignorés.  Si `newSize` est égale à la <xref:System.Array.Length%2A> de l’ancien tableau, cette méthode ne fait rien.  
  
 Cette méthode est un O (`n`) opération, où `n` est `newSize`.  
  
 Le <xref:System.Array.Resize%2A> méthode redimensionne uniquement un tableau unidimensionnel. Le <xref:System.Array> classe n’inclut pas d’une méthode pour le redimensionnement des tableaux multidimensionnels. Pour ce faire, vous devez fournir votre propre code ou appeler une méthode spéciale dans une bibliothèque tierce. Le code suivant illustre une implémentation possible pour une méthode qui redimensionne un tableau de *n* dimensions.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 L’exemple suivant montre comment le redimensionnement affecte le tableau.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> est inférieur à zéro.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverse l’ordre des éléments dans un <see cref="T:System.Array" /> unidimensionnel ou dans une partie de <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel à inverser.</param>
        <summary>Extrait la séquence des éléments de l’intégralité du <see cref="T:System.Array" /> unidimensionnel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après un appel à cette méthode, l’élément à `myArray[i]`, où `i` est n’importe quel index dans le tableau, se déplace vers `myArray[j]`, où `j` est égal à `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
 Comme le montre l’exemple suivant, la <xref:System.Array.Reverse%2A> méthode peut être utilisée pour inverser un tableau en escalier. Il initialise un tableau en escalier avec un seul élément pour chaque mois de l’année en cours dans le calendrier de la culture actuelle. Chaque élément contient un tableau avec autant d’éléments comme les mois en question a des jours. L’exemple affiche le contenu du tableau, appels le <xref:System.Array.Reverse%2A> (méthode), puis affiche le contenu du tableau inversé.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 L’exemple de code suivant montre comment inverser le tri des valeurs dans une <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel à inverser.</param>
        <param name="index">Index de départ de la section à inverser.</param>
        <param name="length">Nombre d'éléments contenus dans la section à inverser.</param>
        <summary>Inverse l’ordre des éléments dans la plage d’éléments du <see cref="T:System.Array" /> unidimensionnel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après un appel à cette méthode, l’élément à `myArray[i]`, où `i` est n’importe quel index dans le tableau, se déplace vers `myArray[j]`, où `j` est égal à `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Le <xref:System.Array.Reverse%2A> méthode peut être utilisée pour inverser un tableau en escalier.  
  
 Cette méthode est un O (`n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment inverser le tri des valeurs dans une plage d’éléments dans un <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Affecte la valeur spécifiée à l’élément spécifié dans le <see cref="T:System.Array" /> actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index">Entier 32 bits qui représente la position de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément situé à la position spécifiée dans le <see cref="T:System.Array" /> unidimensionnel. L'index est spécifié en tant qu'entier 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si la valeur de `index` est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement une dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> est en dehors de la plage d’index valides pour le <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="indices">Tableau unidimensionnel d'entiers 32 bits qui représentent les index spécifiant la position de l'élément à définir.</param>
        <summary>Affecte une valeur à l’élément à la position spécifiée du <see cref="T:System.Array" /> multidimensionnel. Les index sont spécifiés sous la forme d'un tableau d'entiers 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre d’éléments dans `indices` doit être égal au nombre de dimensions dans le <xref:System.Array>. Tous les éléments dans le `indices` tableau doit spécifier collectivement de la position de l’élément souhaité dans le multidimensionnelles <xref:System.Array>.  
  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si les valeurs dans le `indices` tableau est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre de dimensions dans le <see cref="T:System.Array" /> actuel n’est pas égal au nombre d’éléments dans <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Tout élément dans <paramref name="indices" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index">Entier 64 bits qui représente la position de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément situé à la position spécifiée dans le <see cref="T:System.Array" /> unidimensionnel. L'index est spécifié en tant qu'entier 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si la valeur de `index` est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement une dimension.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est en dehors de la plage d’index valides pour le <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="indices">Tableau unidimensionnel d’entiers 64 bits qui représentent les index spécifiant la position de l’élément à définir.</param>
        <summary>Affecte une valeur à l’élément à la position spécifiée du <see cref="T:System.Array" /> multidimensionnel. Les index sont spécifiés sous la forme d’un tableau d’entiers 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nombre d’éléments dans `indices` doit être égal au nombre de dimensions dans le <xref:System.Array>. Tous les éléments dans le `indices` tableau doit spécifier collectivement de la position de l’élément souhaité dans le multidimensionnelles <xref:System.Array>.  
  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si les valeurs dans le `indices` tableau est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Le nombre de dimensions dans le <see cref="T:System.Array" /> actuel n’est pas égal au nombre d’éléments dans <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tout élément dans <paramref name="indices" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index1">Entier 32 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index2">Entier 32 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions. Les index sont spécifiés en tant qu'entiers 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’<see cref="T:System.Array" /> actuel ne possède pas exactement deux dimensions.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Soit <paramref name="index1" /> ou <paramref name="index2" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index1">Entier 64 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index2">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément à la position spécifiée du <see cref="T:System.Array" /> à deux dimensions. Les index sont spécifiés en tant qu’entiers 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">L’<see cref="T:System.Array" /> actuel ne possède pas exactement deux dimensions.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> ne peut pas être converti en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Soit <paramref name="index1" /> ou <paramref name="index2" /> est en dehors de la plage d’index valides pour la dimension correspondante de l’<see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index1">Entier 32 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index2">Entier 32 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index3">Entier 32 bits qui représente l’index de la troisième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément situé à la position spécifiée dans le <see cref="T:System.Array" /> à trois dimensions. Les index sont spécifiés en tant qu'entiers 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement trois dimensions.</exception>
        <exception cref="T:System.InvalidCastException">Impossible de convertir <paramref name="value" /> en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> est en dehors de la plage d’index valides pour la dimension correspondante du <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">Nouvelle valeur de l'élément spécifié.</param>
        <param name="index1">Entier 64 bits qui représente l’index de la première dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index2">Entier 64 bits qui représente l’index de la deuxième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <param name="index3">Entier 64 bits qui représente l’index de la troisième dimension de l’élément <see cref="T:System.Array" /> à définir.</param>
        <summary>Affecte une valeur à l’élément situé à la position spécifiée dans le <see cref="T:System.Array" /> à trois dimensions. Les index sont spécifiés en tant qu’entiers 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Array.GetLowerBound%2A> et <xref:System.Array.GetUpperBound%2A> méthodes peuvent déterminer si un des index est hors limites.  
  
 Pour plus d’informations sur les conversions, consultez <xref:System.Convert>.  
  
 Cette méthode est une opération o (1).  
  
> [!NOTE]
>  Si <xref:System.Array.SetValue%2A> est utilisée pour affecter `null` à un élément d’un tableau de types valeur, tous les champs de l’élément sont initialisés à zéro. La valeur de l’élément n’est pas une référence null et ne peut pas être trouvée en recherchant une référence null.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment définir et obtenir une valeur spécifique dans un tableau unidimensionnel ou multidimensionnel.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement trois dimensions.</exception>
        <exception cref="T:System.InvalidCastException">Impossible de convertir <paramref name="value" /> en type d’élément du <see cref="T:System.Array" /> actuel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> est en dehors de la plage d’index valides pour la dimension correspondante du <see cref="T:System.Array" /> actuel.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Trie les éléments dans un tableau unidimensionnel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel à trier.</param>
        <summary>Trie les éléments dans l’intégralité d’un <see cref="T:System.Array" /> unidimensionnel à l’aide de l’implémentation <see cref="T:System.IComparable" /> de chaque élément du <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément de `array` doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment trier les valeurs dans une <xref:System.Array> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel qui contient les éléments correspondant à chaque clé du <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <see langword="null" /> pour trier uniquement <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <summary>Trie une paire d’objets <see cref="T:System.Array" /> unidimensionnels (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’implémentation de <see cref="T:System.IComparable" /> de chaque clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Chaque clé dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 L’exemple suivant montre comment trier les deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs. Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> est multidimensionnel.  
  
ou 
<paramref name="items" /><see cref="T:System.Array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel à trier.</param>
        <param name="comparer">Implémentation à utiliser pendant la comparaison d’éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Trie les éléments d’un <see cref="T:System.Array" /> unidimensionnel à l’aide de l’objet <see cref="T:System.Collections.IComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est `null`, chaque élément de `array` doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
 Le .NET Framework inclut prédéfinis <xref:System.Collections.IComparer> implémentations répertoriés dans le tableau suivant.  
  
|Implémentation|Description|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compare deux objets, mais effectue une comparaison de chaînes respectant la casse.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture actuelle.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compare deux objets de type `T` à l’aide d’ordre de tri par défaut du type.|  
  
 Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <xref:System.Collections.IComparer> implémentation à le `comparer` paramètre. L’exemple fait cela en définissant un `ReverseComparer` classe qui inverse l’ordre de tri par défaut pour les instances d’un type et effectue la comparaison de chaînes respectant la casse.  
  
   
  
## Examples  
 L’exemple suivant trie les valeurs dans un tableau de chaînes à l’aide du comparateur par défaut. Il définit également un personnalisé <xref:System.Collections.IComparer> implémentation nommée `ReverseComparer` qui inverse l’ordre de tri par défaut d’un objet lors de l’exécution d’une comparaison de chaînes respectant la casse. Notez que la sortie peut varier en fonction de la culture actuelle.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> a la valeur <see langword="null" />, et un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" /></exception>
        <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel qui contient les éléments correspondant à chaque clé du <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <see langword="null" /> pour trier uniquement <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Trie une paire d’objets <see cref="T:System.Array" /> unidimensionnels (l’un contient les clés et l’autre les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’objet <see cref="T:System.Collections.IComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Si `comparer` est `null`, chaque clé dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Le .NET Framework inclut prédéfinis <xref:System.Collections.IComparer> implémentations répertoriés dans le tableau suivant.  
  
|Implémentation|Description|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compare deux objets, mais effectue une comparaison de chaînes respectant la casse.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture actuelle.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compare deux objets de type `T` à l’aide d’ordre de tri par défaut du type.|  
  
 Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <xref:System.Collections.IComparer> implémentation à le `comparer` paramètre. L’exemple fait cela en définissant un <xref:System.Collections.IComparer> implémentation qui inverse l’ordre de tri par défaut et effectue la comparaison de chaînes respectant la casse.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 L’exemple suivant montre comment trier les deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs. Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> est multidimensionnel.  
  
ou 
<paramref name="items" /><see cref="T:System.Array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel à trier.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <summary>Trie les éléments d’une plage d’éléments d’un <see cref="T:System.Array" /> unidimensionnel à l’aide de l’implémentation <see cref="T:System.IComparable" /> de chaque élément de l’<see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément dans la plage spécifiée d’éléments dans `array` doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment trier les valeurs dans une <xref:System.Array> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel qui contient les éléments correspondant à chaque clé du <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <see langword="null" /> pour trier uniquement <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <summary>Trie une plage d’éléments dans une paire d’objets <see cref="T:System.Array" /> unidimensionnels (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’implémentation <see cref="T:System.IComparable" /> de chaque clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Chaque clé dans la plage spécifiée d’éléments dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment trier les deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs. Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> est multidimensionnel.  
  
ou 
<paramref name="items" /><see cref="T:System.Array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="keys" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
 <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><see cref="T:System.Array" /> unidimensionnel à trier.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Trie les éléments d’une plage d’éléments d’un <see cref="T:System.Array" /> unidimensionnel à l’aide du <see cref="T:System.Collections.IComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est `null`, chaque élément dans la plage spécifiée d’éléments dans `array` doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Le .NET Framework inclut prédéfinis <xref:System.Collections.IComparer> implémentations répertoriés dans le tableau suivant.  
  
|Implémentation|Description|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compare deux objets, mais effectue une comparaison de chaînes respectant la casse.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture actuelle.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compare deux objets de type `T` à l’aide d’ordre de tri par défaut du type.|  
  
 Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <xref:System.Collections.IComparer> implémentation à le `comparer` paramètre. L’exemple fait cela en définissant un `ReverseComparer` classe qui inverse l’ordre de tri par défaut pour les instances d’un type et effectue la comparaison de chaînes respectant la casse.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment trier les valeurs dans une <xref:System.Array> à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> a la valeur <see langword="null" />, et un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" /></exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel qui contient les éléments correspondant à chaque clé du <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <see langword="null" /> pour trier uniquement <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <param name="comparer">Implémentation de <see cref="T:System.Collections.IComparer" /> à utiliser pendant la comparaison d'éléments.  
  
ou 
 <see langword="null" /> pour utiliser l’implémentation de <see cref="T:System.IComparable" /> de chaque élément.</param>
        <summary>Trie une plage d’éléments dans une paire d’objets <see cref="T:System.Array" /> unidimensionnels (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’objet <see cref="T:System.Collections.IComparer" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Si `comparer` est `null`, chaque clé dans la plage spécifiée d’éléments dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable> interface soit faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Le .NET Framework inclut prédéfinis <xref:System.Collections.IComparer> implémentations répertoriés dans le tableau suivant.  
  
|Implémentation|Description|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compare deux objets, mais effectue une comparaison de chaînes respectant la casse.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture actuelle.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compare deux objets en utilisant les conventions de tri de la culture dite indifférente.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compare deux objets de type `T` à l’aide d’ordre de tri par défaut du type.|  
  
 Vous pouvez prennent également en charge les comparaisons personnalisées en fournissant une instance de votre propre <xref:System.Collections.IComparer> implémentation à le `comparer` paramètre. L’exemple fait cela en définissant un personnalisé <xref:System.Collections.IComparer> implémentation qui inverse l’ordre de tri par défaut et effectue la comparaison de chaînes respectant la casse.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment trier les deux tableaux associés où le premier tableau contient les clés et le second contient les valeurs. Les tris sont effectués à l’aide du comparateur par défaut et un comparateur personnalisé qui inverse l’ordre de tri. Notez que le résultat peut varier en fonction de l’actuel <xref:System.Globalization.CultureInfo>.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> est multidimensionnel.  
  
ou 
<paramref name="items" /><see cref="T:System.Array" /> est multidimensionnel.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure d’<paramref name="keys" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la limite inférieure de <paramref name="keys" /> ne correspond pas à la limite inférieure de <paramref name="items" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
 <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="items" /><see cref="T:System.Array" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à trier.</param>
        <summary>Trie les éléments dans l’intégralité d’un <see cref="T:System.Array" /> à l’aide de l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément du <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément de `array` doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> surcharge de méthode générique et le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode générique. Un tableau de chaînes est créé, dans aucun ordre particulier.  
  
 Le tableau est affiché, trié et affiche à nouveau.  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%2A> et <xref:System.Array.BinarySearch%2A> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 Le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est. Le tableau et la valeur de retour de la <xref:System.Array.BinarySearch%2A> méthode sont passés à la `ShowWhere` une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau. L’index est négatif si la chaîne n’est pas n le tableau, donc la `ShowWhere` méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à trier</param>
        <param name="comparer">Implémentation de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d’éléments, ou <see langword="null" /> pour utiliser l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Trie les éléments dans un <see cref="T:System.Array" /> à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est `null`, chaque élément de `array` doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique et le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 Le tableau est affiché, trié et affiche à nouveau. Les tableaux doivent être triées pour pouvoir utiliser le <xref:System.Array.BinarySearch%2A> (méthode).  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> et <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 Le <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique est ensuite utilisée pour rechercher des deux chaînes, qui n’est pas dans le tableau et l’autre qui est. Le tableau et la valeur de retour de la <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthode sont passés à la `ShowWhere` une méthode générique, qui affiche la valeur d’index si la chaîne est trouvée, sinon les éléments de la chaîne de recherche se situant entre s’il s’agissait du tableau. L’index est négatif si la chaîne n’est pas n le tableau, donc la `ShowWhere` méthode accepte le complément de bits (le ~ opérateur en c# et Visual C++, `Xor` -1 en Visual Basic) pour obtenir l’index du premier élément dans la liste qui est supérieure à la recherche de String NG.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à trier.</param>
        <param name="comparison"><see cref="T:System.Comparison`1" /> à utiliser pendant la comparaison d'éléments.</param>
        <summary>Trie les éléments inclus dans un <see cref="T:System.Array" /> à l’aide de l’objet <see cref="T:System.Comparison`1" /> spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> surcharge de méthode.  
  
 L’exemple de code définit une autre méthode de comparaison des chaînes, nommée `CompareDinosByLength`. Cette méthode fonctionne comme suit : Tout d’abord, les comparateurs sont testés pour`null`, et une référence null est considérée comme inférieure à une valeur non null. Deuxièmement, les longueurs de chaîne sont comparées, et la plus longue chaîne est jugée supérieure. Troisièmement, si les longueurs sont égales, la comparaison de chaînes ordinaire est utilisée.  
  
 Un tableau de chaînes est créé et rempli avec quatre chaînes, dans aucun ordre particulier. La liste inclut également une chaîne vide et une référence null. La liste s’affiche, trié à l’aide un <xref:System.Comparison%601> délégué générique représentant le `CompareDinosByLength` (méthode) et affiche à nouveau.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="comparison" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">L’implémentation de <paramref name="comparison" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparison" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à trier.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <summary>Trie les éléments d’une plage d’éléments d’un <see cref="T:System.Array" /> à l’aide de l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément de <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque élément dans la plage spécifiée d’éléments dans `array` doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode générique et le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique pour trier une plage dans un tableau.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure, composé de trois herbivores suivis par trois carnivores (tyrannosaures, pour être précis). Le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode générique est utilisée pour trier les trois derniers éléments du tableau, qui sont ensuite affichées. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique est utilisée avec `ReverseCompare` pour trier les trois derniers éléments dans l’ordre inverse. Dinosaures entièrement désordonnés sont affichent de nouveau.  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> et <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à trier.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <param name="comparer">Implémentation de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d’éléments, ou <see langword="null" /> pour utiliser l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Trie les éléments d’une plage d’éléments dans un <see cref="T:System.Array" /> à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `comparer` est `null`, chaque élément dans la plage spécifiée d’éléments dans `array` doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec tous les autres éléments de `array`.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode générique et le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique pour trier une plage dans un tableau.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure, composé de trois herbivores suivis par trois carnivores (tyrannosaures, pour être précis). Le <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge de méthode générique est utilisée pour trier les trois derniers éléments du tableau, qui sont ensuite affichées. Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge de méthode générique est utilisée avec `ReverseCompare` pour trier les trois derniers éléments dans l’ordre inverse. Dinosaures entièrement désordonnés sont affichent de nouveau.  
  
> [!NOTE]
>  Les appels à la <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> et <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type du premier argument. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="array" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="array" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Type des éléments du tableau des clés.</typeparam>
        <typeparam name="TValue">Type des éléments du tableau des éléments.</typeparam>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <paramref name="keys" />, ou <see langword="null" /> pour trier uniquement <paramref name="keys" />.</param>
        <summary>Trie une paire d’objets <see cref="T:System.Array" /> (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Chaque clé dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, et <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> des surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure (clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs). Les tableaux sont ensuite triés et affiche plusieurs fois :  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge et une instance de `ReverseCompare` sont utilisées pour inverser l’ordre de tri des tableaux associés.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.  
  
> [!NOTE]
>  Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la limite inférieure de <paramref name="keys" /> ne correspond pas à la limite inférieure de <paramref name="items" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Type des éléments du tableau des clés.</typeparam>
        <typeparam name="TValue">Type des éléments du tableau des éléments.</typeparam>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <paramref name="keys" />, ou <see langword="null" /> pour trier uniquement <paramref name="keys" />.</param>
        <param name="comparer">Implémentation de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d’éléments, ou <see langword="null" /> pour utiliser l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Trie une paire d’objets <see cref="T:System.Array" /> (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Si `comparer` est `null`, chaque clé dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, et <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> des surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure (clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs). Les tableaux sont ensuite triés et affiche plusieurs fois :  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.  
  
-   Le [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > surcharge et une instance de `ReverseCompare` sont utilisées pour inverser l’ordre de tri des tableaux associés.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.  
  
> [!NOTE]
>  Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la limite inférieure de <paramref name="keys" /> ne correspond pas à la limite inférieure de <paramref name="items" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Type des éléments du tableau des clés.</typeparam>
        <typeparam name="TValue">Type des éléments du tableau des éléments.</typeparam>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <paramref name="keys" />, ou <see langword="null" /> pour trier uniquement <paramref name="keys" />.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <summary>Trie une plage d’éléments dans une paire d’objets <see cref="T:System.Array" /> (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’implémentation d’interface générique <see cref="T:System.IComparable`1" /> de chaque clé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Chaque clé dans la plage spécifiée d’éléments dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, et <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>` (`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure (clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs). Les tableaux sont ensuite triés et affiche plusieurs fois :  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge et une instance de `ReverseCompare` sont utilisées pour inverser l’ordre de tri des tableaux associés.  
  
-   Le [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.  
  
> [!NOTE]
>  Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="keys" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la limite inférieure de <paramref name="keys" /> ne correspond pas à la limite inférieure de <paramref name="items" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
 <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">Type des éléments du tableau des clés.</typeparam>
        <typeparam name="TValue">Type des éléments du tableau des éléments.</typeparam>
        <param name="keys"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les clés à trier.</param>
        <param name="items"><see cref="T:System.Array" /> unidimensionnel de base zéro qui contient les éléments correspondant aux clés dans <paramref name="keys" />, ou <see langword="null" /> pour trier uniquement <paramref name="keys" />.</param>
        <param name="index">Index de départ de la plage à trier.</param>
        <param name="length">Nombre d'éléments à trier dans la plage.</param>
        <param name="comparer">Implémentation de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> à utiliser pendant la comparaison d’éléments, ou <see langword="null" /> pour utiliser l’implémentation de l’interface générique <see cref="T:System.IComparable`1" /> de chaque élément.</param>
        <summary>Trie une plage d’éléments dans une paire d’objets <see cref="T:System.Array" /> (l’un contient les clés et l’autre, les éléments correspondants) en fonction des clés du premier <see cref="T:System.Array" /> à l’aide de l’interface générique <see cref="T:System.Collections.Generic.IComparer`1" /> spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque clé dans le `keys` <xref:System.Array> possède un élément correspondant le `items` <xref:System.Array>. Lorsqu’une clé est repositionnée pendant le tri, l’élément correspondant dans le `items` <xref:System.Array> est repositionné de la même façon. Par conséquent, le `items` <xref:System.Array> est trié selon la disposition des clés correspondantes dans le `keys` <xref:System.Array>.  
  
 Si `comparer` est `null`, chaque clé dans la plage spécifiée d’éléments dans le `keys` <xref:System.Array> doit implémenter le <xref:System.IComparable%601> interface générique pour pouvoir faire des comparaisons avec toutes les autres clés.  
  
 Vous pouvez trier s’il y a plus d’éléments que les clés, mais les éléments qui n’ont aucune clé correspondante ne seront pas triés. Vous ne pouvez pas trier s’il existe plusieurs clés que d’éléments ; cela lèverait une <xref:System.ArgumentException>.  
  
 Si le tri n’est pas terminé avec succès, les résultats sont indéfinis.  
  
 Cette méthode utilise l’algorithme de tri approfondi (introsort) comme suit :  
  
-   Si la taille de partition est moins de 16 éléments, il utilise un [tri d’insertion](https://en.wikipedia.org/wiki/Insertion_sort) algorithme.  
  
-   Si le nombre de partitions est supérieure à 2 * journal<sup>N</sup>, où *N* correspond à la plage du tableau d’entrée, il utilise un [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorithme.  
  
-   Sinon, il utilise un [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithme.  
  
 Cette implémentation effectue un tri instable ; Autrement dit, si deux éléments sont égaux, leur ordre ne peut pas être conservé. En revanche, un tri stable conserve l’ordre des éléments qui sont égaux.  
  
 Pour les tableaux qui sont triées en utilisant les algorithmes Heapsort et trions rapidement, dans le pire des cas, cette méthode est un O (`n` journal `n`) opération, où `n` est `length`.  
  
   
  
## Examples  
 L’exemple de code suivant montre le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, et [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > les surcharges de méthode générique, pour le tri de paires de tableaux qui représentent les clés et valeurs.  
  
 L’exemple de code définit un autre comparateur pour les chaînes nommées `ReverseCompare`, qui implémente le `IComparer<string>`(`IComparer(Of String)` en Visual Basic, `IComparer<String^>` dans Visual C++) interface générique. Le comparateur appelle le <xref:System.String.CompareTo%28System.String%29> méthode, en inversant l’ordre des comparateurs afin que les chaînes de trier haut-bas au lieu de faible à élevé.  
  
 L’exemple de code crée et affiche un tableau de noms de dinosaure (clés) et un tableau d’entiers représentant la longueur maximale de chaque dinosaure en mètres (les valeurs). Les tableaux sont ensuite triés et affiche plusieurs fois :  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> surcharge est utilisée pour trier les deux tableaux dans l’ordre des noms dinosaure dans le premier tableau.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> surcharge et une instance de `ReverseCompare` sont utilisées pour inverser l’ordre de tri des tableaux associés.  
  
-   Le <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> surcharge est utilisée pour trier les trois derniers éléments des deux tableaux.  
  
-   Le [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > surcharge est utilisée pour trier les trois derniers éléments des deux tableaux dans l’ordre inverse.  
  
> [!NOTE]
>  Les appels aux méthodes génériques ne pas rechercher les appels à leurs équivalents non génériques, car Visual Basic, c# et C++ déduisent le type du paramètre de type générique à partir du type des deux premiers arguments. Si vous utilisez le [Ildasm.exe (désassembleur IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) pour examiner le langage intermédiaire Microsoft (MSIL), vous pouvez voir que les méthodes génériques sont appelées.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à la limite inférieure de <paramref name="keys" />.  
  
ou 
 <paramref name="length" /> est inférieur à zéro.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> n’est pas <see langword="null" />, et la limite inférieure de <paramref name="keys" /> ne correspond pas à la limite inférieure de <paramref name="items" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et la longueur de <paramref name="keys" /> est supérieure à la longueur d’<paramref name="items" />.  
  
ou 
 <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="keys" /><see cref="T:System.Array" />.  
  
ou 
 <paramref name="items" /> n’est pas <see langword="null" />, et <paramref name="index" /> et <paramref name="length" /> ne spécifient pas une plage valide dans <paramref name="items" /><see cref="T:System.Array" />.  
  
ou 
L’implémentation de <paramref name="comparer" /> a provoqué une erreur pendant le tri. Par exemple, <paramref name="comparer" /> peut ne pas retourner 0 pendant la comparaison d’un élément à lui-même.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> est <see langword="null" />, et un ou plusieurs éléments de <paramref name="keys" /><see cref="T:System.Array" /> n’implémentent pas l’interface générique <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>Le .NET Framework 4 et les versions antérieures utilisaient uniquement l’algorithme de tri rapide. Tri rapide identifie les comparateurs non valides dans certaines situations dans lesquelles l’opération de tri lève une <see cref="T:System.IndexOutOfRangeException" /> exception et lève un <see cref="T:System.ArgumentException" /> exception à l’appelant. En commençant par le [!INCLUDE[net_v45](~/includes/net-v45-md.md)], il est possible qu’opérations de tri qui précédemment a levé <see cref="T:System.ArgumentException" /> pas lève une exception, car les algorithmes de tri et heapsort d’insertion ne pas détectent un comparateur non valide. La plupart du temps, cela s’applique aux tableaux avec moins de 16 éléments.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Exécution d'opérations de chaînes indépendantes de la culture dans des tableaux</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Array" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété implémente la <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Les classes .NET framework basées sur <xref:System.Array> fournissent leur propre version synchronisée de la collection en utilisant le <xref:System.Array.SyncRoot%2A> propriété.  
  
 Les classes qui utilisent des tableaux peuvent également implémenter leur propre à l’aide de la synchronisation du <xref:System.Array.SyncRoot%2A> propriété. Le code de synchronisation doit effectuer les opérations sur les `SyncRoot` de la collection, pas directement sur la collection. Cela garantit un bon fonctionnement des collections dérivées d’autres objets. Plus précisément, la synchronisation est assurée avec les autres threads qui pourraient modifier simultanément la collection. Notez que certaines implémentations de <xref:System.Array.SyncRoot%2A> peut retourner le <xref:System.Array> lui-même.  
  
 L’énumération d’une collection n’est pas intrinsèquement une procédure thread-safe. Même lorsqu'une collection est synchronisée, les autres threads peuvent toujours la modifier, ce qui entraîne la levée d'une exception par l'énumérateur. Pour garantir la sécurité des threads au cours de l’énumération, vous pouvez verrouiller la collection pendant l’ensemble de l’énumération ou bien intercepter les exceptions résultant des modifications apportées par les autres threads.  
  
 La récupération de la valeur de cette propriété est une opération O(1).  
  
   
  
## Examples  
 L’exemple de code suivant montre comment verrouiller un tableau pendant toute l’énumération à l’aide de la <xref:System.Array.SyncRoot%2A> propriété.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans le <see cref="T:System.Array" />.</summary>
        <value>Nombre d’éléments contenus dans la collection.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'accès à <see cref="T:System.Array" /> est synchronisé (thread safe).</summary>
        <value>True si l’accès à la <see cref="T:System.Array" /> est synchronisé (thread-safe) ; sinon, false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Array" />.</summary>
        <value>Objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Array" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à ajouter à <see cref="T:System.Collections.IList" />.</param>
        <summary>L’appel de cette méthode lève toujours une exception <see cref="T:System.NotSupportedException" />.</summary>
        <returns>L'ajout d'une valeur à un tableau n'est pas pris en charge. Aucune valeur n'est retournée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En règle générale, un <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implémentation ajoute un membre à une collection. Toutefois, étant donné que les tableaux ont une taille fixe (la <xref:System.Array.IsFixedSize%2A> propriété retourne toujours `true`), cette méthode lève toujours une <xref:System.NotSupportedException> exception.  
  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> est de taille fixe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les éléments de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> est en lecture seule.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à rechercher dans la liste active. L’élément à trouver peut être <see langword="null" /> pour les types référence.</param>
        <summary>Détermine si le <see cref="T:System.Collections.IList" /> contient un élément.</summary>
        <returns><see langword="true" /> si <paramref name="value" /> existe dans <see cref="T:System.Collections.IList" /> ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à rechercher dans la liste active.</param>
        <summary>Détermine l'index d'un élément spécifique d'<see cref="T:System.Collections.IList" />.</summary>
        <returns>Index de valeur s'il figure dans la liste ; sinon, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Index auquel <paramref name="value" /> doit être inséré.</param>
        <param name="value">Objet à insérer.</param>
        <summary>Insère un élément dans <see cref="T:System.Collections.IList" /> à l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> n'est pas un index valide dans <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.IList" /> est de taille fixe.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> est une référence null dans <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Array" /> est de taille fixe.</summary>
        <value>True si le <see cref="T:System.Array" /> fixe taille ; sinon, false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si l'objet <see cref="T:System.Array" /> est en lecture seule.</summary>
        <value>True si le <see cref="T:System.Array" /> est en lecture seule ; sinon, false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l'élément à obtenir ou à définir.</param>
        <summary>Obtient ou définit l'élément au niveau de l'index spécifié.</summary>
        <value>Élément au niveau de l'index spécifié.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> est inférieur à zéro.  
  
ou 
 <paramref name="index" /> est supérieur ou égal à <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">Le <see cref="T:System.Array" /> actuel ne possède pas exactement une dimension.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Objet à supprimer de <see cref="T:System.Collections.IList" />.</param>
        <summary>Supprime la première occurrence d'un objet spécifique de <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.IList" /> est de taille fixe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Index de l'élément à supprimer.</param>
        <summary>Supprime l'élément <see cref="T:System.Collections.IList" /> au niveau de l'index spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">L’index n’est pas un index valide dans <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> est en lecture seule.  
  
ou 
<see cref="T:System.Collections.IList" /> est de taille fixe.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à l'instance actuelle.</param>
        <param name="comparer">Objet qui compare l’objet actuel à un objet <paramref name="other" />.</param>
        <summary>Détermine si l’objet collection actuel précède, se situe à la même position que, ou suit un autre objet dans l’ordre de tri.</summary>
        <returns>Entier qui indique la relation de l'objet de collection actuel par rapport aux autres objets, comme indiqué dans le tableau suivant.  
  
 <list type="table"><listheader><term> Valeur de retour 
 </term><description> Description 
 </description></listheader><item><term> -1 
 </term><description> L’instance actuelle précède <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> L’instance actuelle et <paramref name="other" /> sont égaux.  
  
 </description></item><item><term> 1 
 </term><description> L’instance actuelle suit <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">Objet à comparer à l'instance actuelle.</param>
        <param name="comparer">Objet qui détermine si l’instance actuelle et <paramref name="other" /> sont égales.</param>
        <summary>Détermine si un objet est identique à l'instance actuelle.</summary>
        <returns><see langword="true" /> si les deux objets sont égaux ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">Objet qui calcule le code de hachage de l'objet actif.</param>
        <summary>Retourne un code de hachage pour l'instance actuelle.</summary>
        <returns>Code de hachage de l'instance actuelle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est une implémentation d'un membre d'interface explicite. Il peut uniquement être utilisé lorsque l'instance de <xref:System.Array> est castée en interface <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">Type des éléments du tableau.</typeparam>
        <param name="array"><see cref="T:System.Array" /> de base zéro unidimensionnel à vérifier par rapport aux conditions.</param>
        <param name="match">Le prédicat qui définit les conditions à vérifier par rapport aux éléments.</param>
        <summary>Détermine si chaque élément dans le tableau correspond aux conditions définies par le prédicat spécifié.</summary>
        <returns><see langword="true" /> si chaque élément dans <paramref name="array" /> correspond aux conditions définies par le prédicat spécifié ; sinon, <see langword="false" />. Si le tableau ne contient pas d’éléments, la valeur de retour est <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Predicate%601> est un délégué à une méthode qui retourne`true` si l’objet passé à il correspond aux conditions définies dans le délégué.  Les éléments de `array` sont passés à la <xref:System.Predicate%601>, et le traitement est interrompu lorsque le délégué retourne `false` pour n’importe quel élément.  
  
 Cette méthode est un O (`n`) opération, où `n` est la <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 L’exemple suivant détermine si le dernier caractère de chaque élément dans un tableau de chaînes est un nombre. Il crée deux tableaux de chaînes. Le premier tableau inclut à la fois des chaînes qui se terminent par des caractères alphabétiques et des chaînes qui se terminent par des caractères numériques. Le deuxième tableau se compose uniquement de chaînes qui se terminent par des caractères numériques. L’exemple définit également un `EndWithANumber` méthode dont la signature correspond à la <xref:System.Predicate%601> déléguer. L’exemple passe chaque tableau pour le <xref:System.Array.TrueForAll%2A> méthode ainsi qu’un délégué qui représente le `EndsWithANumber` (méthode).  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 L’exemple suivant est similaire à la première, sauf qu’il transmet le tableau de chaînes à le <xref:System.Array.TrueForAll%2A> (méthode), ainsi que d’une expression lambda qui détermine si un élément de tableau particulier se termine avec la représentation sous forme de chaîne d’un nombre.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 Dans les deux cas, le <xref:System.Array.TrueForAll%2A> méthode retourne `false` dès qu’il rencontre le premier élément du tableau qui ne se termine pas dans un nombre. Sinon, elle retourne `true` après l’itération de tous les éléments dans le tableau.  
  
> [!NOTE]
>  Comme le montrent les deux exemples, en c# et Visual Basic, il n’est pas nécessaire de créer le `Predicate<string>` déléguer (`Predicate(Of String)` en Visual Basic) explicitement. Ces langages déduisent le délégué approprié à partir du contexte et créer automatiquement.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> a la valeur <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>