<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e0c6cd93db10995b051b068ce1439987f93a2699" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39902759" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Représente un domaine d'application qui est un environnement isolé dans lequel s'exécutent les applications. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domaines d’application, qui sont représentées par <xref:System.AppDomain> objets, aider à fournir des limites d’isolation, de déchargement et de sécurité pour l’exécution de code managé.  
  
-   Utiliser des domaines d’application pour isoler les tâches qui peuvent interrompre un processus. Si l’état de la <xref:System.AppDomain> qui exécute une tâche devient instable, le <xref:System.AppDomain> peut être déchargé sans affecter le processus. Ceci est important lorsqu’un processus doit s’exécuter pendant de longues périodes sans avoir à redémarrer. Vous pouvez également utiliser des domaines d’application pour isoler les tâches qui ne doivent pas partager de données.  
  
-   Si un assembly est chargé dans le domaine d’application par défaut, il ne peut pas être déchargée de la mémoire pendant que le processus est en cours d’exécution. Toutefois, si vous ouvrez un deuxième domaine d’application pour charger et exécuter l’assembly, l’assembly est déchargé lorsque ce domaine d’application est déchargé. Cette technique permet de réduire la plage de travail de processus à long terme qui utilisent parfois des DLL volumineuses.  
  
 Plusieurs domaines d’application peuvent s’exécuter dans un processus unique. Toutefois, il n'est pas une correspondance entre domaines d’application et les threads. Plusieurs threads peuvent appartenir à un seul domaine d’application, et pendant un thread donné n’est pas limité à un seul domaine d’application, à un moment donné, un thread s’exécute dans un seul domaine d’application.  
  
 Domaines d’application sont créés à l’aide de la <xref:System.AppDomain.CreateDomain%2A> (méthode). <xref:System.AppDomain> instances sont utilisées pour charger et exécuter des assemblys (<xref:System.Reflection.Assembly>). Quand un <xref:System.AppDomain> est n’est plus en cours d’utilisation, il peut être déchargé.  
  
 Le <xref:System.AppDomain> classe implémente un ensemble d’événements qui permettent aux applications de répondre lorsqu’un assembly est chargé, un domaine d’application est déchargé ou quand une exception non gérée est levée.  
  
 Pour plus d’informations sur l’utilisation des domaines d’application, consultez [domaines d’Application](~/docs/framework/app-domains/application-domains.md).  
  
 Cette classe implémente le <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, et <xref:System.Security.IEvidenceFactory> interfaces.  
  
 Vous ne devez jamais créer un wrapper accessible à distance pour un <xref:System.AppDomain> objet. Cela peut publier une référence à distance à cet <xref:System.AppDomain>, exposant des méthodes telles que <xref:System.AppDomain.CreateInstance%2A> pour l’accès à distance et en détruisant ainsi la sécurité d’accès du code pour que <xref:System.AppDomain>. Clients malveillants qui se connectent à la distance <xref:System.AppDomain> pu obtenir l’accès à n’importe quelle ressource le <xref:System.AppDomain> lui-même a accès à. Ne créez pas de wrappers accessibles à distance pour tout type qui étend <xref:System.MarshalByRefObject> et qui implémente des méthodes qui peuvent être utilisées par les clients malveillants pour ignorer le système de sécurité.  
  
> [!CAUTION]
>  La valeur par défaut pour le <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> propriété est `false`. Ce paramètre n’est pas sûre pour les services. Pour empêcher les services de téléchargement de code de confiance partielle, définissez cette propriété sur `true`.  
  
   
  
## Examples  
 Cet exemple montre comment créer un nouveau <xref:System.AppDomain>, instancier un type dans ce nouveau <xref:System.AppDomain>et communiquer avec l’objet de ce type. En outre, cet exemple montre comment décharger le <xref:System.AppDomain> à l’origine de l’objet d’être nettoyées.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le contexte d'activation du domaine d'application actuel.</summary>
        <value>Objet qui représente le contexte d'activation du domaine d'application actuel, ou <see langword="null" /> si le domaine n'a aucun contexte d'activation.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nom du répertoire à ajouter au chemin d’accès privé.</param>
        <summary>Ajoute le nom de répertoire spécifié à la liste des chemins d’accès privée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’utilisation de cette propriété n’est pas recommandée, car elle peut modifier le chemin de recherche pour les assemblys après que qu’ils ont déjà été chargés. Utilisez la propriété <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> à la place.  
  
 Le chemin d’accès privé ou un chemin de recherche relatif, est le chemin d’accès relatif au répertoire de base où le programme de résolution d’assembly tente de détecter les assemblys privés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identité de l'application dans le domaine d'application.</summary>
        <value>Objet qui identifie l'application dans le domaine d'application.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient des informations qui décrivent les autorisations accordées à une application et indiquent si l'application possède un niveau de confiance qui lui permet de s'exécuter.</summary>
        <value>Objet qui encapsule les autorisations et les informations d'approbation pour l'application dans le domaine d'application.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet d'assembly, sous la forme fournie par la propriété <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Retourne le nom complet d'assembly une fois que la stratégie a été appliquée.</summary>
        <returns>Chaîne qui contient le nom complet d'assembly une fois que la stratégie a été appliquée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ApplyPolicy%2A> afficher le nom de méthode prend un assembly et retourne le nom complet de la stratégie après. Cela est utile si vous avez besoin charger un assembly à l’aide de la stratégie, car le contexte de réflexion uniquement ne s’applique pas de stratégie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand un assembly est chargé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AssemblyLoadEventHandler> délégué pour cet événement indique l’assembly qui a été chargé.  
  
 Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <xref:System.Security.SecurityException> est levée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment le <xref:System.AppDomain.AssemblyLoad> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la résolution d'un assembly échoue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il incombe à le <xref:System.ResolveEventHandler> pour cet événement retourner l’assembly spécifié par le <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriété, ou retourner une valeur null si l’assembly n’est pas reconnu. L’assembly doit être chargé dans un contexte d’exécution ; Si elle est chargée dans le contexte de réflexion uniquement, la charge qui a provoqué le déclenchement de cet événement échoue.  
  
 Pour obtenir des conseils sur l’utilisation de cet événement, consultez [résolution des chargements d’assemblys](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriété retourne l’assembly qui a demandé le chargement d’assembly ne peut pas être résolu. Par exemple, le chargeur peut être impossible de charger une dépendance de l’assembly demandeur car l’assembly demandeur et sa dépendance ne figurent pas dans le chemin de recherche. Connaître l’identité de l’assembly demandeur peut être utile dans la recherche de la dépendance ou à identifier la version correcte, si plusieurs versions de la dépendance ne sont disponible. Pour plus d'informations, consultez <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Compter les [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], le <xref:System.ResolveEventHandler> événement est déclenché pour tous les assemblys, y compris les assemblys de ressource. Dans les versions antérieures, l’événement a été pas déclenché pour les assemblys de ressource. Si le système d’exploitation est localisé, le gestionnaire peut être appelé plusieurs fois : une fois pour chaque culture dans la chaîne de secours.  
  
 Pour cet événement, le <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriété retourne le nom de l’assembly avant de la stratégie est appliquée.  
  
> [!IMPORTANT]
>  Si plus d’un gestionnaire d’événements est inscrit pour cet événement, l’événement handlersarecalled dans l’ordre jusqu'à ce qu’un gestionnaire d’événements retourne une valeur qui n’est pas `null`. Gestionnaires d’événements suivants sont ignorés.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment le <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le répertoire de base qu'utilise le programme de résolution d'assembly pour détecter les assemblys.</summary>
        <value>Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété correspond à la <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> propriété. Elle peut également être récupérée à l’aide de la <xref:System.AppDomain.GetData%2A> méthode avec la chaîne « APPBASE ».  
  
   
  
## Examples  
 L’exemple de code suivant crée un nouveau domaine d’application, en spécifiant un répertoire de base à utiliser lors de la recherche d’assemblys à charger dans le domaine. L’exemple utilise ensuite le <xref:System.AppDomain.BaseDirectory%2A> propriété pour obtenir le chemin du répertoire de base pour l’affichage dans la console.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">pour l’accès aux informations dans le chemin d’accès lui-même, notamment si le chemin d’accès est sous la forme « file:// » ou \\\UNC\dir ou « c:\\». Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rétablit la chaîne vide ("") comme valeur du chemin d’accès qui spécifie l’emplacement des assemblys privés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chemin d’accès privé est un chemin d’accès relatif au répertoire de base que le common language runtime recherche pour localiser des assemblys privés.  
  
 Pour plus d'informations, consultez <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment utiliser le <xref:System.AppDomain.ClearPrivatePath%2A> méthode pour supprimer toutes les entrées de la liste des chemins d’accès privés à rechercher lorsque les assemblys sont chargés.  
  
 Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rétablit la chaîne vide ("") comme valeur de la liste des répertoires contenant des clichés instantanés d'assemblys.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chemin d’accès de copie de clichés instantanés est une liste de répertoires où clichés instantanés d’assemblys sont stockés.  
  
 Pour plus d’informations, consultez <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> et [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance d'un type COM spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom d'un fichier qui contient un assembly définissant le type demandé.</param>
        <param name="typeName">Nom du type demandé.</param>
        <summary>Crée une instance d'un type COM spécifié. Les paramètres spécifient le nom d'un fichier qui contient un assembly contenant le type et le nom du type.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer des objets à distance sans avoir à charger le type localement.  
  
 La valeur de retour doit pour être désencapsulée pour accéder à l’objet réel.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être appliqué explicitement ou par défaut pour le type COM pour cette méthode pour créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
   
  
## Examples  
 L’exemple suivant montre comment  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Impossible de charger le type.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur sans paramètre public n'a été trouvé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> est une classe abstraite.  
  
- ou - 
Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">Le <paramref name="assemblyName" /> est une chaîne vide ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L'objet COM auquel il est fait référence est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom d'un fichier qui contient un assembly définissant le type demandé.</param>
        <param name="typeName">Nom du type demandé.</param>
        <param name="hashValue">Représente la valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</param>
        <summary>Crée une instance d'un type COM spécifié. Les paramètres spécifient le nom d'un fichier qui contient un assembly contenant le type et le nom du type.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour créer des objets à distance sans avoir à charger le type localement.  
  
 La valeur de retour doit pour être désencapsulée pour accéder à l’objet réel.  
  
 Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribut avec une valeur de `true` doit être appliqué explicitement ou par défaut pour le type COM pour cette méthode pour créer une instance de ce type ; sinon, <xref:System.TypeLoadException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Impossible de charger le type.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur sans paramètre public n'a été trouvé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> est une classe abstraite.  
  
- ou - 
Ce membre a été appelé avec un mécanisme de liaison tardive.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> est la chaîne vide ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L'objet COM auquel il est fait référence est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un nouveau domaine d'application.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine.</param>
        <summary>Crée un domaine d'application portant le nom spécifié.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `friendlyName` paramètre est destiné à identifier le domaine de manière significative pour les utilisateurs. Cette chaîne doit être adaptée à l’affichage dans les interfaces utilisateur.  
  
 Cette surcharge de méthode utilise la <xref:System.AppDomainSetup> informations du domaine d’application par défaut.  
  
   
  
## Examples  
 L’exemple suivant illustre, en général, la création d’un domaine à l’aide d’une de la <xref:System.AppDomain.CreateDomain%2A> surcharges.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine. Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine. Pour plus d'informations, consultez <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Preuve qui établit l'identité du code exécuté dans le domaine d'application. Passez <see langword="null" /> pour utiliser la preuve du domaine d'application actuel.</param>
        <summary>Crée un domaine d'application portant le nom spécifié à l'aide de la preuve fournie.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de méthode utilise la <xref:System.AppDomainSetup> informations du domaine d’application par défaut.  
  
 Si `securityInfo` est ne pas fourni, la preuve du domaine d’application actuel est utilisée.  
  
> [!IMPORTANT]
>  N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox. Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la preuve fournie pour `securityInfo` n’affecte plus le jeu d’autorisations du domaine d’application. Utilisez le <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> surcharge de méthode pour créer des domaines d’application sandbox.  
  
   
  
## Examples  
 L’exemple suivant illustre, en général, la création d’un domaine à l’aide d’une de la <xref:System.AppDomain.CreateDomain%2A> surcharges.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine. Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine. Pour plus d'informations, consultez <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Preuve qui établit l'identité du code exécuté dans le domaine d'application. Passez <see langword="null" /> pour utiliser la preuve du domaine d'application actuel.</param>
        <param name="info">Objet contenant les informations d'initialisation du domaine d'application.</param>
        <summary>Crée un domaine d'application à l'aide du nom, de la preuve et des informations de configuration du domaine d'application spécifiés.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `info` est ne pas fourni, cette surcharge de méthode utilise la <xref:System.AppDomainSetup> informations du domaine d’application par défaut.  
  
 Si `securityInfo` est ne pas fourni, la preuve du domaine d’application actuel est utilisée.  
  
> [!IMPORTANT]
>  N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox. Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la preuve fournie pour `securityInfo` n’affecte plus le jeu d’autorisations du domaine d’application. Utilisez le <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> surcharge de méthode pour créer des domaines d’application sandbox.  
  
   
  
## Examples  
 L’exemple suivant illustre, en général, la création d’un domaine à l’aide d’une de la <xref:System.AppDomain.CreateDomain%2A> surcharges.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine. Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine. Pour plus d'informations, voir la description de <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Preuve qui établit l'identité du code exécuté dans le domaine d'application. Passez <see langword="null" /> pour utiliser la preuve du domaine d'application actuel.</param>
        <param name="info">Objet contenant les informations d'initialisation du domaine d'application.</param>
        <param name="grantSet">Jeu d'autorisations par défaut qui est accordé à tous les assemblys chargés dans le nouveau domaine d'application qui n'ont pas d'attributions spécifiques.</param>
        <param name="fullTrustAssemblies">Tableau des noms forts représentant les assemblys à considérer comme ayant un niveau de confiance suffisant dans le nouveau domaine d'application.</param>
        <summary>Crée un domaine d'application à l'aide du nom, de la preuve, des informations de configuration du domaine d'application, du jeu d'autorisations par défaut et du tableau d'assemblys ayant un niveau de confiance suffisant.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous devez définir le <xref:System.AppDomainSetup.ApplicationBase%2A> propriété de la <xref:System.AppDomainSetup> objet que vous fournissez pour `info`. Sinon, une exception est levée.  
  
 Si `securityInfo` est ne pas fourni, la preuve du domaine d’application actuel est utilisée.  
  
 Les informations fournies pour `grantSet` et `fullTrustAssemblies` est utilisé pour créer un <xref:System.Security.Policy.ApplicationTrust> objet pour le nouveau domaine d’application.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le domaine d'application est <see langword="null" />.  
  
- ou - 
La propriété <see cref="P:System.AppDomainSetup.ApplicationBase" /> n'est pas définie sur l'objet <see cref="T:System.AppDomainSetup" /> fourni pour <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour pouvoir créer et manipuler un domaine d’application. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine. Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine. Pour plus d'informations, consultez <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Preuve qui établit l'identité du code exécuté dans le domaine d'application. Passez <see langword="null" /> pour utiliser la preuve du domaine d'application actuel.</param>
        <param name="appBasePath">Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys. Pour plus d'informations, consultez <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Chemin d'accès par rapport au répertoire de base où le programme de résolution d'assembly doit détecter les assemblys privés. Pour plus d'informations, consultez <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Si la valeur est <see langword="true" />, un cliché instantané d'un assembly est chargé dans ce domaine d'application.</param>
        <summary>Crée un domaine d'application portant le nom donné, à l'aide de la preuve, du chemin d'accès de base de l'application, du chemin de recherche relatif et d'un paramètre spécifiant si un cliché instantané d'un assembly doit être chargé dans le domaine d'application.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si `securityInfo` est ne pas fourni, la preuve du domaine d’application actuel est utilisée.  
  
 Pour plus d’informations sur la copie de clichés instantanés, consultez <xref:System.AppDomain.ShadowCopyFiles%2A> et [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox. Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la preuve fournie pour `securityInfo` n’affecte plus le jeu d’autorisations du domaine d’application. Utilisez le <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> surcharge de méthode pour créer des domaines d’application sandbox.  
  
   
  
## Examples  
 L’exemple suivant illustre, en général, la création d’un domaine à l’aide d’une de la <xref:System.AppDomain.CreateDomain%2A> surcharges.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Nom convivial du domaine. Ce nom convivial peut être affiché dans les interfaces utilisateur pour identifier le domaine. Pour plus d'informations, consultez <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Preuve qui établit l'identité du code exécuté dans le domaine d'application. Passez <see langword="null" /> pour utiliser la preuve du domaine d'application actuel.</param>
        <param name="appBasePath">Répertoire de base utilisé par le programme de résolution d'assembly pour détecter les assemblys. Pour plus d'informations, consultez <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Chemin d'accès par rapport au répertoire de base où le programme de résolution d'assembly doit détecter les assemblys privés. Pour plus d'informations, consultez <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> pour charger un cliché instantané d'un assembly dans le domaine d'application.</param>
        <param name="adInit">Un délégué <see cref="T:System.AppDomainInitializer" /> qui représente une méthode de rappel à appeler quand le nouvel objet <see cref="T:System.AppDomain" /> est initialisé.</param>
        <param name="adInitArgs">Un tableau d’arguments de type chaîne à passer au rappel représenté par <c>adInit</c>, quand le nouvel objet <see cref="T:System.AppDomain" /> est initialisé.</param>
        <summary>Crée un domaine d'application portant le nom donné, à l'aide de la preuve, du chemin d'accès de base de l'application, du chemin de recherche relatif et d'un paramètre spécifiant si un cliché instantané d'un assembly doit être chargé dans le domaine d'application. Spécifie une méthode de rappel qui est appelée quand le domaine d'application est initialisé, et un tableau d'arguments de type chaîne à passer à la méthode de rappel.</summary>
        <returns>Domaine d'application nouvellement créé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode représentée par `adInit` est exécutée dans le contexte du domaine d’application nouvellement créé.  
  
 Si `securityInfo` est ne pas fourni, la preuve du domaine d’application actuel est utilisée.  
  
 Pour plus d’informations sur la copie de clichés instantanés, consultez <xref:System.AppDomain.ShadowCopyFiles%2A> et [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  N’utilisez pas cette surcharge de méthode pour créer des domaines d’application sandbox. Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la preuve fournie pour `securityInfo` n’affecte plus le jeu d’autorisations du domaine d’application. Utilisez le <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> surcharge de méthode pour créer des domaines d’application sandbox.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance d'un type spécifié défini dans un assembly déterminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <summary>Crée une instance du type spécifié défini dans l'assembly déterminé.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`.  
  
 Toute tentative d’appel <xref:System.AppDomain.CreateInstance%2A> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible. Dans la mesure où un <xref:System.Reflection.Assembly> n’est pas <xref:System.MarshalByRefObject>, lorsque cette méthode tente de retourner le <xref:System.Reflection.Assembly> pour l’assembly chargé au domaine d’application actuel, le common language runtime tente de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer. L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly qui a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans l'assembly déterminé. Un paramètre spécifie un tableau d'attributs d'activation.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`.  
  
 Toute tentative d’appel <xref:System.AppDomain.CreateInstance%2A> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible. Dans la mesure où un <xref:System.Reflection.Assembly> n’est pas <xref:System.MarshalByRefObject>, lorsque cette méthode tente de retourner le <xref:System.Reflection.Assembly> pour l’assembly chargé au domaine d’application actuel, le common language runtime tente de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer. L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly qui a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par le biais de la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans l'assembly déterminé. Les paramètres spécifient un binder, des indicateurs de liaisons, des arguments de constructeur, les informations spécifiques à la culture utilisées pour interpréter les arguments et des attributs d'activation facultatifs.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`.  
  
 Toute tentative d’appel <xref:System.AppDomain.CreateInstance%2A> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible. Dans la mesure où un <xref:System.Reflection.Assembly> n’est pas <xref:System.MarshalByRefObject>, lorsque cette méthode tente de retourner le <xref:System.Reflection.Assembly> pour l’assembly chargé au domaine d’application actuel, le common language runtime tente de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer. L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly qui a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par le biais de la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour autoriser la création de <c>typeName</c>.</param>
        <summary>Crée une instance du type spécifié défini dans l'assembly déterminé. Les paramètres spécifient un binder, des indicateurs de liaisons, des arguments de constructeur, des informations propres à la culture utilisées pour interpréter les arguments, des attributs d’activation et l’autorisation de créer le type.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance spécifiée par <paramref name="typeName" />. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`.  
  
 Toute tentative d’appel <xref:System.AppDomain.CreateInstance%2A> sur une cible de domaine d’application qui n’est pas le domaine d’application actuel entraîne un chargement réussi de l’assembly dans le domaine d’application cible. Dans la mesure où un <xref:System.Reflection.Assembly> n’est pas <xref:System.MarshalByRefObject>, lorsque cette méthode tente de retourner le <xref:System.Reflection.Assembly> pour l’assembly chargé au domaine d’application actuel, le common language runtime tente de charger l’assembly dans le domaine d’application actuel et le chargement peut échouer. L’assembly est chargé dans le domaine d’application actuel peut être différent de l’assembly qui a été chargé en premier si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
 <paramref name="securityAttributes" /> n’est pas un <see langword="null" />. Lorsque la stratégie CAS héritée n'est pas activée, <paramref name="securityAttributes" /> doit être <see langword="null." />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance d'un type spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <summary>Crée une instance du type spécifié. Les paramètres spécifient l'assembly dans lequel le type est défini et le nom du type.</summary>
        <returns>Instance de l'objet spécifié par <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstance%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`. Consultez le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété pour le format de `typeName`.  
  
> [!NOTE]
>  Si vous effectuez un appel à liaison anticipée à une méthode `M` d’un objet de type `T1` qui a été retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, et que la méthode permet à un appel à liaison anticipée à une méthode d’un objet de type `T2` dans un assembly `C` autre que le assembly actuel ou l’assembly contenant `T1`, assembly `C` est chargé dans le domaine d’application actuel. Ce chargement se produit même si l’appel à liaison anticipée à `T1.M()` a été effectuée dans le corps d’un <xref:System.Reflection.Emit.DynamicMethod>, ou dans un autre code généré dynamiquement. Si le domaine actuel est le domaine par défaut, assembly `C` ne peut pas être déchargé jusqu'à ce que le processus se termine. Si le domaine actuel ultérieurement tente de charger l’assembly `C`, le chargement peut échouer.  
  
   
  
## Examples  
 L’exemple de code suivant montre la façon la plus simple d’exécuter du code dans un autre domaine d’application. L’exemple définit une classe nommée `Worker` qui hérite de <xref:System.MarshalByRefObject>. Le `Worker` classe définit une méthode qui affiche le nom du domaine d’application dans lequel elle s’exécute. L’exemple crée des instances de `Worker` dans le domaine d’application par défaut et dans un nouveau domaine d’application.  
  
> [!NOTE]
>  L’assembly qui contient `Worker` doit être chargé dans les deux domaines d’application, mais il peut charger d’autres assemblys qui existent uniquement dans le nouveau domaine d’application.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">pour la capacité à lire le fichier contenant le manifeste d’assembly, ou si vous créez un type à partir d’un module autre que le fichier manifest. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié. Les paramètres spécifient l'assembly dans lequel le type est défini, le nom du type et un tableau d'attributs d'activation.</summary>
        <returns>Instance de l'objet spécifié par <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstance%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`. Consultez le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété pour le format de `typeName`.  
  
> [!NOTE]
>  Si vous effectuez un appel à liaison anticipée à une méthode `M` d’un objet de type `T1` qui a été retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, et que la méthode permet à un appel à liaison anticipée à une méthode d’un objet de type `T2` dans un assembly `C` autre que le assembly actuel ou l’assembly contenant `T1`, assembly `C` est chargé dans le domaine d’application actuel. Ce chargement se produit même si l’appel à liaison anticipée à `T1.M()` a été effectuée dans le corps d’un <xref:System.Reflection.Emit.DynamicMethod>, ou dans un autre code généré dynamiquement. Si le domaine actuel est le domaine par défaut, assembly `C` ne peut pas être déchargé jusqu'à ce que le processus se termine. Si le domaine actuel ultérieurement tente de charger l’assembly `C`, le chargement peut échouer.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par le biais de la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Objet propre à la culture utilisé pour régir la contrainte de types. Si <c>culture</c> a la valeur <see langword="null" />, le <see langword="CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. Généralement, tableau qui contient un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans l’assembly spécifié, en indiquant si la casse du nom de type est ignorée ; les attributs de liaison et le binder utilisés pour sélectionner le type à créer ; les arguments du constructeur ; la culture et les attributs d’activation.</summary>
        <returns>Instance de l'objet spécifié par <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstance%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`. Consultez le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété pour le format de `typeName`.  
  
> [!NOTE]
>  Si vous effectuez un appel à liaison anticipée à une méthode `M` d’un objet de type `T1` qui a été retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, et que la méthode permet à un appel à liaison anticipée à une méthode d’un objet de type `T2` dans un assembly `C` autre que le assembly actuel ou l’assembly contenant `T1`, assembly `C` est chargé dans le domaine d’application actuel. Ce chargement se produit même si l’appel à liaison anticipée à `T1.M()` a été effectuée dans le corps d’un <xref:System.Reflection.Emit.DynamicMethod>, ou dans un autre code généré dynamiquement. Si le domaine actuel est le domaine par défaut, assembly `C` ne peut pas être déchargé jusqu'à ce que le processus se termine. Si le domaine actuel ultérieurement tente de charger l’assembly `C`, le chargement peut échouer.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `ignoreCase` paramètre.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé lors de la création d’une instance d’un délégué. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par le biais de la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Objet propre à la culture utilisé pour régir la contrainte de types. Si <c>culture</c> a la valeur <see langword="null" />, le <see langword="CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour autoriser la création de <c>typeName</c>.</param>
        <summary>Crée une instance du type spécifié. Les paramètres spécifient le nom du type et la manière dont il est recherché et créé.</summary>
        <returns>Instance de l'objet spécifié par <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstance%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consultez <xref:System.Reflection.AssemblyName> pour le format de `assemblyName`. Consultez le <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriété pour le format de `typeName`.  
  
> [!NOTE]
>  Si vous effectuez un appel à liaison anticipée à une méthode `M` d’un objet de type `T1` qui a été retourné par <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, et que la méthode permet à un appel à liaison anticipée à une méthode d’un objet de type `T2` dans un assembly `C` autre que le assembly actuel ou l’assembly contenant `T1`, assembly `C` est chargé dans le domaine d’application actuel. Ce chargement se produit même si l’appel à liaison anticipée à `T1.M()` a été effectuée dans le corps d’un <xref:System.Reflection.Emit.DynamicMethod>, ou dans un autre code généré dynamiquement. Si le domaine actuel est le domaine par défaut, assembly `C` ne peut pas être déchargé jusqu'à ce que le processus se termine. Si le domaine actuel ultérieurement tente de charger l’assembly `C`, le chargement peut échouer.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation de la `ignoreCase` paramètre.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur correspondant n’a été trouvé.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’est pas autorisé à appeler ce constructeur.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">pour la capacité d’invoquer des opérations sur tous les membres de type. Énumération associée : <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance d'un type spécifié défini dans le fichier d'assembly déterminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé. L'assembly est chargé à l'aide de la méthode <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> .</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur par défaut `typeName` est appelé.  
  
 Pour plus d'informations, voir la méthode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Lorsque le <xref:System.AppDomain.CreateInstanceFrom%2A> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir duquel l’appel est effectué, l’assembly est chargé dans le domaine d’application cible. Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly à charger dans le domaine d’application appelant. Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive. Quand l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.  
  
-   Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <xref:System.MissingMethodException> peut se produire.  
  
-   Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <xref:System.InvalidCastException> peut être levée lorsqu’une tentative est effectuée pour effectuer un cast de l’instance.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> surcharge de méthode pour créer une instance d’un objet dans un domaine d’application cible et appeler ses méthodes.  
  
 L’exemple définit la `MarshallableExample` classe, qui peut être marshalée au-delà des limites du domaine d’application. L’exemple génère un chemin d’accès à l’assembly en cours d’exécution, crée un domaine d’application cible et utilise le <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> surcharge de méthode pour charger l’assembly de l’exemple dans le domaine d’application cible et créer une instance de `MarshallableExample`.  
  
> [!NOTE]
>  Le chemin d’accès est absolu dans cet exemple, mais un chemin d’accès relatif fonctionne également, car le <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> méthode est utilisée pour charger l’assembly.  
  
 Après le désencapsulage le handle d’objet, l’exemple illustre trois façons d’utiliser un objet dans un domaine d’application cible :  
  
-   Appel d’une méthode avec liaison tardive, à l’aide de la réflexion. Cela nécessite des informations de type, ce qui provoque l’assembly à charger dans le domaine d’application de l’appelant. (Dans cet exemple, il est déjà chargé.)  
  
-   Cast de l’objet à une interface connue à l’appelant et l’appelé. Si l’interface est définie dans l’assembly appelant ou dans un assembly tiers référencé par l’appelant et l’appelé, l’assembly appelé n’est pas chargé dans le domaine d’application de l’appelant.  
  
-   À l’aide de l’objet directement lorsque son type est connu à l’appelant. L’assembly doit être chargé dans le domaine d’application de l’appelant.  
  
 Une autre façon d’éviter de charger l’assembly appelé dans le domaine d’application de l’appelant est à l’appelant de dériver à partir de la <xref:System.MarshalByRefObject> classe et pour définir une méthode qui peut être exécutée dans le domaine d’application cible. Cette méthode peut utiliser la réflexion pour examiner un assembly cible, car l’assembly cible est déjà chargé dans le domaine d’application cible. Consultez l’exemple de la <xref:System.AppDomain.DynamicDirectory%2A> propriété.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur sans paramètre public n'a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé. L'assembly est chargé à l'aide de la méthode <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> .</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le constructeur par défaut `typeName` est appelé.  
  
 Pour plus d’informations sur cette méthode, consultez la <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (méthode).  
  
 Lorsque le <xref:System.AppDomain.CreateInstanceFrom%2A> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir duquel l’appel est effectué, l’assembly est chargé dans le domaine d’application cible. Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly à charger dans le domaine d’application appelant. Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive. Quand l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.  
  
-   Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <xref:System.MissingMethodException> peut se produire.  
  
-   Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <xref:System.InvalidCastException> peut être levée lorsqu’une tentative est effectuée pour effectuer un cast de l’instance.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé. L'assembly est chargé à l'aide de la méthode <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> .</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d'informations, voir la méthode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Lorsque le <xref:System.AppDomain.CreateInstanceFrom%2A> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir duquel l’appel est effectué, l’assembly est chargé dans le domaine d’application cible. Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly à charger dans le domaine d’application appelant. Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive. Quand l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.  
  
-   Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <xref:System.MissingMethodException> peut se produire.  
  
-   Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <xref:System.InvalidCastException> peut être levée lorsqu’une tentative est effectuée pour effectuer un cast de l’instance.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom, y compris le chemin d'accès, d'un fichier qui contient un assembly définissant le type demandé. L'assembly est chargé à l'aide de la méthode <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> .</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour autoriser la création de <c>typeName</c>.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>Objet qui est un wrapper de la nouvelle instance, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable. La valeur de retour doit être désencapsulée pour accéder à l'objet réel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur cette méthode, consultez la <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (méthode).  
  
 Lorsque le <xref:System.AppDomain.CreateInstanceFrom%2A> méthode est utilisée pour créer une instance dans un domaine d’application cible autre que le domaine d’application à partir duquel l’appel est effectué, l’assembly est chargé dans le domaine d’application cible. Toutefois, si l’instance est désencapsulée dans le domaine d’application appelant, à l’aide de cette instance de certaines façons peut entraîner l’assembly à charger dans le domaine d’application appelant. Par exemple, une fois que l’instance est désencapsulée, ses informations de type peuvent être demandées, afin d’appeler ses méthodes à liaison tardive. Quand l’assembly est chargé dans le domaine d’application appelant, des exceptions peuvent se produire.  
  
-   Si une autre version du même assembly a été précédemment chargée dans le domaine d’application appelant, ou si le chemin de chargement du domaine d’application appelant est différent de celui du domaine d’application cible, exceptions, tel que <xref:System.MissingMethodException> peut se produire.  
  
-   Si le domaine d’application appelant effectue des appels à liaison anticipée au type d’instance, <xref:System.InvalidCastException> peut être levée lorsqu’une tentative est effectuée pour effectuer un cast de l’instance.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.  
  
- ou - 
 <paramref name="securityAttributes" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="securityAttributes" /> doit être <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NullReferenceException">L’instance est <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une instance d'un type spécifié défini dans le fichier d'assembly déterminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>L'objet demandé, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Pour plus d'informations, voir la méthode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur sans paramètre public n'a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly (consultez la propriété <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre concerne les objets activés par le client. L’activation par le client est une technologie héritée qui a été conservée pour la compatibilité descendante. Toutefois, elle n’est pas recommandée pour les nouveaux développements. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>L'objet demandé, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Cette méthode appelle le constructeur par défaut `typeName`.  
  
 Pour plus d’informations sur cette méthode, consultez la <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur sans paramètre public n'a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d’assembly spécifié, en indiquant si la casse du nom de type est ignorée ; les attributs de liaison et le binder utilisés pour sélectionner le type à créer ; les arguments du constructeur ; la culture et les attributs d’activation.</summary>
        <returns>L'objet demandé, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur cette méthode, consultez la <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom de fichier et chemin d’accès à l’assembly qui définit le type demandé.</param>
        <param name="typeName">Nom qualifié complet du type demandé, y compris l'espace de noms mais pas l'assembly, tel qu'il est retourné par la propriété <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Valeur bouléenne spécifiant s'il convient d'effectuer ou non une recherche qui respecte la casse.</param>
        <param name="bindingAttr">Combinaison de zéro ou plusieurs bits indicateurs qui affectent la recherche du constructeur <c>typeName</c>. Si <c>bindingAttr</c> a la valeur zéro, une recherche de constructeurs publics qui respecte la casse est effectuée.</param>
        <param name="binder">Objet qui active la liaison, la contrainte de types d'arguments, l'appel des membres et la récupération d'objets <see cref="T:System.Reflection.MemberInfo" /> par la réflexion. Si <c>binder</c> a la valeur null, le Binder par défaut est utilisé.</param>
        <param name="args">Arguments à passer au constructeur. Ce tableau d'arguments doit posséder les mêmes nombre, ordre et type que les paramètres du constructeur à appeler. Si vous préférez utiliser le constructeur par défaut, <c>args</c> doit être un tableau vide ou null.</param>
        <param name="culture">Informations propres à la culture qui définissent la contrainte de <c>args</c> pour les types formels déclarés du constructeur <c>typeName</c>. Si <c>culture</c> a la valeur <see langword="null" />, le <see cref="T:System.Globalization.CultureInfo" /> du thread actuel est utilisé.</param>
        <param name="activationAttributes">Tableau à un ou plusieurs attributs pouvant participer à l'activation. En général, tableau contenant un seul objet <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> qui spécifie l'URL nécessaire pour activer un objet distant.  
  
Ce paramètre est lié aux objets activés par le client. L'activation des clients est une technologie héritée qui est conservée pour la compatibilité descendante, mais elle n'est pas recommandée pour un nouveau développement. Les applications distribuées doivent à la place utiliser Windows Communication Foundation.</param>
        <param name="securityAttributes">Informations utilisées pour autoriser la création de <c>typeName</c>.</param>
        <summary>Crée une instance du type spécifié défini dans le fichier d'assembly déterminé.</summary>
        <returns>L'objet demandé, ou <see langword="null" /> si <paramref name="typeName" /> est introuvable.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Il s’agit d’une méthode pratique qui combine <xref:System.AppDomain.CreateInstanceFrom%2A> et <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur cette méthode, consultez la <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.  
  
- ou - 
 <paramref name="typeName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">L’appelant ne peut pas fournir d’attributs d’activation pour un objet qui n’hérite pas de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> est introuvable dans <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Aucun constructeur public correspondant n’a été trouvé.</exception>
        <exception cref="T:System.MethodAccessException">L’appelant n’a pas les autorisations suffisantes pour appeler ce constructeur.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du Common Language Runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">Pour pouvoir lire le fichier contenant le manifeste d’assembly. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le domaine d'application actuel pour le <see cref="T:System.Threading.Thread" /> actuel.</summary>
        <value>Domaine d'application actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant crée un nouveau domaine d’application. Le <xref:System.AppDomain.CurrentDomain%2A> propriété est utilisée pour obtenir un <xref:System.AppDomain> objet qui représente le domaine d’application actuel. Le <xref:System.AppDomain.FriendlyName%2A> fournit le nom du domaine d’application actuel, qui est ensuite affiché sur la ligne de commande.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Définit un assembly dynamique dans le domaine d'application actuel.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès de l'assembly dynamique.</param>
        <summary>Définit un assembly dynamique avec le nom et le mode d'accès spécifiés.</summary>
        <returns>un assembly dynamique avec le nom et le mode d'accès spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès de l'assembly dynamique.</param>
        <param name="assemblyAttributes">Une liste enumérable d'attributs à appliquer à l'assembly, ou <see langword="null" /> s'il n'y a pas d'attributs.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès et les attributs personnalisés spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique. Par exemple, sécurité attributs tels que <xref:System.Security.SecurityTransparentAttribute> et <xref:System.Security.SecurityCriticalAttribute> ne fonctionnent pas correctement si elles sont ajoutées après la création d’un assembly dynamique.  
  
 Cette méthode doit être utilisée uniquement pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations sur cette restriction, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
 Cette surcharge de méthode a été introduite dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 L’exemple de code suivant montre comment créer un assembly dynamique qui a le <xref:System.Security.SecurityTransparentAttribute>. L’attribut doit être spécifié en tant qu’élément d’un tableau de <xref:System.Reflection.Emit.CustomAttributeBuilder> objets.  
  
 La première étape de création de la <xref:System.Reflection.Emit.CustomAttributeBuilder> consiste à obtenir un constructeur de l’attribut. Le constructeur n’a aucun paramètre, donc la <xref:System.Type.GetConstructor%2A> méthode est appelée avec un tableau vide de <xref:System.Type> objets pour représenter les types des paramètres. La deuxième étape consiste à passer résultant <xref:System.Reflection.ConstructorInfo> objet au constructeur pour le <xref:System.Reflection.Emit.CustomAttributeBuilder> (classe), ainsi que d’un tableau vide de type <xref:System.Object> pour représenter les arguments.  
  
 Résultant <xref:System.Reflection.Emit.CustomAttributeBuilder> est ensuite transmise à la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode en tant que le seul élément d’un tableau.  
  
 L’exemple de code définit un module et un type dans le nouvel assembly dynamique, puis affiche les attributs de l’assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès et la preuve spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Confiance uniquement suffisant pour les appelants peuvent fournir leurs `evidence` lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir une valeur null de confiance partielle `evidence`. Si `evidence` est `null`, le runtime copie les jeux d’autorisations, autrement dit, actuel grant et deny des jeux, à partir de l’appelant <xref:System.Reflection.Assembly> la dynamique <xref:System.Reflection.Assembly> actuellement défini et marque la stratégie comme résolue.  
  
 Si la dynamique <xref:System.Reflection.Assembly> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <xref:System.Reflection.Assembly> a été enregistré.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> (méthode) et le <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Tout d’abord, l’exemple de code essaie de créer une instance de `MyDynamicType` en appelant le <xref:System.AppDomain.CreateInstance%2A> méthode avec un nom d’assembly non valide et intercepte l’exception résultante.  
  
 L’exemple de code ajoute ensuite un gestionnaire d’événements pour le <xref:System.AppDomain.AssemblyResolve> événement et réessaie de créer une instance de`MyDynamicType`. Pendant l’appel à <xref:System.AppDomain.CreateInstance%2A>, le <xref:System.AppDomain.AssemblyResolve> événement est déclenché pour l’assembly non valide. Le Gestionnaire d’événements crée un assembly dynamique qui contient un type nommé `MyDynamicType`, lui donne un constructeur sans paramètre et retourne le nouvel assembly dynamique. L’appel à <xref:System.AppDomain.CreateInstance%2A> puis s’achève correctement et le constructeur de `MyDynamicType` affiche un message sur la console.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly doit être enregistré. Si <c>dir</c> a la valeur <see langword="null" />, le répertoire actif est utilisé comme répertoire par défaut.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès et le répertoire de stockage spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès de l'assembly dynamique.</param>
        <param name="assemblyAttributes">Une liste enumérable d'attributs à appliquer à l'assembly, ou <see langword="null" /> s'il n'y a pas d'attributs.</param>
        <param name="securityContextSource">Source du contexte de sécurité.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès et les attributs personnalisés spécifiés, à l'aide de la source indiquée pour son contexte de sécurité.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique. Par exemple, sécurité attributs tels que <xref:System.Security.SecurityTransparentAttribute> et <xref:System.Security.SecurityCriticalAttribute> ne fonctionnent pas correctement si elles sont ajoutées après la création d’un assembly dynamique.  
  
 Cette méthode doit être utilisée uniquement pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations sur cette restriction, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">La valeur de <paramref name="securityContextSource" /> ne correspondait pas à une des valeurs d'énumération.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly doit être enregistré. Si <c>dir</c> a la valeur <see langword="null" />, le répertoire actif est utilisé comme répertoire par défaut.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage et la preuve spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Confiance uniquement suffisant pour les appelants peuvent fournir leurs `evidence` lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir une valeur null de confiance partielle `evidence`. Si `evidence` est `null`, le runtime copie les jeux d’autorisations, autrement dit, actuel grant et deny des jeux, à partir de l’appelant <xref:System.Reflection.Assembly> la dynamique <xref:System.Reflection.Assembly> actuellement défini et marque la stratégie comme résolue.  
  
 Si la dynamique <xref:System.Reflection.Assembly> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <xref:System.Reflection.Assembly> a été enregistré.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès et les demandes d'autorisations spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les demandes d’autorisation spécifiées pour `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` ne sont pas utilisés, sauf si l’assembly dynamique a été enregistré et rechargé en mémoire. Pour spécifier des demandes d’autorisation pour un assembly transitoire qui n’est jamais enregistré sur disque, utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve ainsi que demandées autorisations et offre une <xref:System.Security.Policy.Evidence> objet.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré. Si <c>dir</c> est <see langword="null" />, le répertoire actif est utilisé.</param>
        <param name="isSynchronized">
          <see langword="true" /> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <see langword="false" />.</param>
        <param name="assemblyAttributes">Une liste enumérable d'attributs à appliquer à l'assembly, ou <see langword="null" /> s'il n'y a pas d'attributs.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage et l’option de synchronisation spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique. Par exemple, sécurité attributs tels que <xref:System.Security.SecurityTransparentAttribute> et <xref:System.Security.SecurityCriticalAttribute> ne fonctionnent pas correctement si elles sont ajoutées après la création d’un assembly dynamique.  
  
 Si `isSynchronized` est `true`, les méthodes suivantes de résultant <xref:System.Reflection.Emit.AssemblyBuilder> seront synchronisés : <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, et <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si deux de ces méthodes sont appelées sur des threads différents, une se bloquera jusqu'à ce que l’autre est terminée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès, la preuve et les demandes d'autorisations spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les demandes d’autorisation spécifiées pour `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` sont utilisées uniquement si `evidence` est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Confiance uniquement suffisant pour les appelants peuvent fournir leurs `evidence` lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir une valeur null de confiance partielle `evidence`. Si `evidence` est `null`, le runtime copie les jeux d’autorisations, autrement dit, actuel grant et deny des jeux, à partir de l’appelant <xref:System.Reflection.Assembly> la dynamique <xref:System.Reflection.Assembly> actuellement défini et marque la stratégie comme résolue.  
  
 Si la dynamique <xref:System.Reflection.Assembly> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <xref:System.Reflection.Assembly> a été enregistré.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly doit être enregistré. Si <c>dir</c> a la valeur <see langword="null" />, le répertoire actif est utilisé comme répertoire par défaut.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage et les demandes d'autorisations spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les demandes d’autorisation spécifiées pour `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` ne sont pas utilisés, sauf si l’assembly dynamique a été enregistré et rechargé en mémoire. Pour spécifier des demandes d’autorisation pour un assembly transitoire qui n’est jamais enregistré sur disque, utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve ainsi que demandées autorisations et offre une <xref:System.Security.Policy.Evidence> objet.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé que vous utilisez une surcharge de la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode qui spécifie la preuve et les autorisations, fournir la preuve que vous souhaitez que l’assembly dynamique et d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly doit être enregistré. Si <c>dir</c> a la valeur <see langword="null" />, le répertoire actif est utilisé comme répertoire par défaut.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d'accès, le répertoire de stockage, la preuve et les demandes d'autorisations spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les demandes d’autorisation spécifiées pour `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` sont utilisées uniquement si `evidence` est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Confiance uniquement suffisant pour les appelants peuvent fournir leurs `evidence` lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir une valeur null de confiance partielle `evidence`. Si `evidence` est `null`, le runtime copie les jeux d’autorisations, autrement dit, actuel grant et deny des jeux, à partir de l’appelant <xref:System.Reflection.Assembly> la dynamique <xref:System.Reflection.Assembly> actuellement défini et marque la stratégie comme résolue.  
  
 Si la dynamique <xref:System.Reflection.Assembly> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <xref:System.Reflection.Assembly> a été enregistré.  
  
 Cette méthode doit uniquement être utilisée pour définir un assembly dynamique dans le domaine d’application actuel. Pour plus d’informations, consultez le <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré. Si <c>dir</c> a la valeur <see langword="null" />, le répertoire actif est utilisé comme répertoire par défaut.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <param name="isSynchronized">
          <see langword="true" /> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <see langword="false" />.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage, la preuve, les demandes d’autorisations et l’option de synchronisation spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les demandes d’autorisation spécifiées pour `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` sont utilisées uniquement si `evidence` est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.  
  
> [!NOTE]
>  Pendant le développement de code qui émet des assemblys dynamiques, il est recommandé d’inclure <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> dans `refusedPermissions`. Y compris <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> dans le `refusedPermissions` paramètre garantit que le code MSIL est vérifié. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> levée lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Seuls les appelants de confiance suffisant peuvent fournir leurs preuves lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir de confiance partielle `null` pour le `evidence` paramètre. Si `evidence` est `null`, le runtime copie les jeux d’autorisations, autrement dit, actuel grant et deny des jeux, à partir de l’appelant <xref:System.Reflection.Assembly> la dynamique <xref:System.Reflection.Assembly> actuellement défini et marque la stratégie comme résolue.  
  
 Si la dynamique <xref:System.Reflection.Assembly> est enregistré sur le disque, les chargements suivants obtiennent des autorisations en fonction des stratégies associées à l’emplacement où le <xref:System.Reflection.Assembly> a été enregistré.  
  
 Si `isSynchronized` est `true`, les méthodes suivantes de résultant <xref:System.Reflection.Emit.AssemblyBuilder> seront synchronisés : <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, et <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si deux de ces méthodes sont appelées sur des threads différents, une se bloquera jusqu'à ce que l’autre se termine.  
  
   
  
## Examples  
 L’exemple suivant montre comment la <xref:System.AppDomain.DefineDynamicAssembly%2A> méthode et <xref:System.AppDomain.AssemblyResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Identité unique de l'assembly dynamique.</param>
        <param name="access">Mode d'accès à l'assembly dynamique.</param>
        <param name="dir">Nom du répertoire dans lequel l'assembly dynamique doit être enregistré. Si <c>dir</c> est <see langword="null" />, le répertoire actif est utilisé.</param>
        <param name="evidence">Preuve fournie pour l'assembly dynamique. La preuve est utilisée non modifiée en tant qu’ensemble de preuves final pour la résolution de stratégie.</param>
        <param name="requiredPermissions">Demande d'autorisations requises.</param>
        <param name="optionalPermissions">Demande d'autorisations facultatives.</param>
        <param name="refusedPermissions">Demande d'autorisations refusées.</param>
        <param name="isSynchronized">
          <see langword="true" /> pour synchroniser la création de modules, de types et de membres dans l'assembly dynamique ; sinon, <see langword="false" />.</param>
        <param name="assemblyAttributes">Une liste enumérable d'attributs à appliquer à l'assembly, ou <see langword="null" /> s'il n'y a pas d'attributs.</param>
        <summary>Définit un assembly dynamique avec le nom, le mode d’accès, le répertoire de stockage, la preuve, les demandes d’autorisations, l’option de synchronisation et les attributs personnalisés spécifiés.</summary>
        <returns>Assembly dynamique avec le nom et les fonctionnalités spécifiés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge de méthode pour spécifier les attributs qui ne fonctionnent pas correctement, sauf si elles sont appliquées lors de la création d’un assembly dynamique. Par exemple, sécurité attributs tels que <xref:System.Security.SecurityTransparentAttribute> et <xref:System.Security.SecurityCriticalAttribute> ne fonctionnent pas correctement si elles sont ajoutées après la création d’un assembly dynamique.  
  
 Les demandes d’autorisation spécifiées pour le `requiredPermissions`, `optionalPermissions`, et `refusedPermissions` paramètres sont utilisés uniquement si le `evidence` paramètre est également fourni, ou si l’assembly dynamique est enregistré et rechargé en mémoire.  
  
> [!NOTE]
>  Lorsque vous développez du code qui émet des assemblys dynamiques, nous vous recommandons d’inclure le <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> indicateur dans le `refusedPermissions` paramètre. L’inclusion de cet indicateur garantit que le Microsoft intermediate language (MSIL) est vérifiée. Cette technique détecte la génération involontaire de code non vérifiable, qui est très difficile à détecter. Une limitation de cette technique est qu’elle entraîne également <xref:System.Security.SecurityException> devant être levé lorsqu’il est utilisé avec le code qui demande la confiance totale.  
  
 Seuls les appelants de confiance totale peuvent fournir une preuve lors de la définition dynamique <xref:System.Reflection.Assembly>. Le runtime mappe la <xref:System.Security.Policy.Evidence> via la stratégie de sécurité pour déterminer les autorisations accordées. Les appelants doivent fournir de confiance partielle `null` pour le `evidence` paramètre. Si `evidence` est `null`, le runtime copie les jeux d’autorisations (c'est-à-dire, l’allocation en cours et refuser de jeux) à partir de l’assembly de l’appelant vers l’assembly dynamique qui est défini et marque la stratégie comme résolue.  
  
 Si l’assembly dynamique est enregistré sur disque, suivante charges obtiennent des autorisations en fonction des stratégies qui sont associés à l’emplacement où l’assembly dynamique a été enregistré.  
  
 Si `isSynchronized` est `true`, les méthodes suivantes de résultant <xref:System.Reflection.Emit.AssemblyBuilder> seront synchronisés : <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, et <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Si deux de ces méthodes sont appelées sur des threads différents, une se bloquera jusqu'à ce que l’autre est terminée.  
  
 Cette surcharge de méthode a été introduite dans le [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see langword="Name" /> de <paramref name="name" /> a la valeur <see langword="null" />.  
  
- ou - 
La propriété <see langword="Name" /> de <paramref name="name" /> commence par un espace blanc ou bien contient une barre oblique ou une barre oblique inverse.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Délégué qui spécifie une méthode à appeler.</param>
        <summary>Exécute le code dans un autre domaine d'application identifié par le délégué spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` peut spécifier un marshalés par valeur, <xref:System.MarshalByRefObject>, ou <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation statique <xref:System.AppDomain.DoCallBack%2A> (méthode).  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomain.DoCallBack%2A> méthode par valeur.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomain.DoCallBack%2A> méthode par référence.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> est <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le gestionnaire de domaine qui a été fourni par l'hôte quand le domaine d'application a été initialisé.</summary>
        <value>Objet qui représente le gestionnaire de domaine fourni par l'hôte quand le domaine d'application a été initialisé, ou <see langword="null" /> si aucun gestionnaire de domaine n'a été fourni.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un hôte non managé du common language runtime (CLR) peut fournir un gestionnaire de domaine. Le Gestionnaire de domaine peut participer à l’initialisation du nouveau domaine d’application et fournir des autres gestionnaires, comme un <xref:System.Security.HostSecurityManager>, qui participent aux opérations du domaine d’application.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand <see cref="T:System.AppDomain" /> est sur le point d'être déchargé.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.EventHandler> délégué de cet événement peut effectuer toute activité d’arrêt avant que le domaine d’application soit déchargé.  
  
 Chaque domaine d’application qui a besoin d’effectuer le traitement quand il est déchargé doit inscrire un gestionnaire d’événements pour cet événement. Un gestionnaire d’événements partagé ne doit pas être utilisé, car le <xref:System.EventHandler> délégué n’identifie pas le domaine qui est en cours de déchargement.  
  
> [!NOTE]
>  Cet événement n’est jamais déclenché dans le domaine d’application par défaut.  
  
 Ne faites pas d’hypothèses sur le thread de sur que l’événement est déclenché. L’événement peut être déclenché sur un thread différent de celui qui a appelé le <xref:System.AppDomain.Unload%2A> (méthode).  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le répertoire utilisé par le programme de résolution d'assembly pour détecter les assemblys créés de manière dynamique.</summary>
        <value>Répertoire utilisé par le programme de résolution d'assembly pour détecter les assemblys créés de manière dynamique.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour définir le répertoire dynamique, affectez un chemin d’accès du répertoire de base pour le <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriété de la <xref:System.AppDomainSetup> objet qui sera utilisé pour créer le nouveau domaine d’application. Le chemin d’accès de répertoire de base que vous affectez à la propriété est modifiée par l’ajout d’un sous-répertoire dont le nom simple est le code de hachage de la chaîne que vous affectez à la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriété, donc le format du répertoire de base est *chemin d’accès d’origine* \\ *le code de hachage*. Le répertoire dynamique est un sous-répertoire de ce répertoire de base. Son nom simple est la valeur de la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriété, donc son format est *chemin d’accès d’origine*\\*le code de hachage*\\*nom de l’application*.  
  
   
  
## Examples  
 L’exemple suivant crée un domaine d’application avec un répertoire pour les assemblys dynamiques, émet un assembly dynamique et le stocke dans le répertoire dynamique, charge l’assembly dans le nouveau domaine d’application et l’utilise.  
  
 L’exemple crée un <xref:System.AppDomainSetup> objet et définit son <xref:System.AppDomainSetup.ApplicationName%2A> propriété à « Exemple » et ses <xref:System.AppDomainSetup.DynamicBase%2A> propriété à « C:\DynamicAssemblyDir ». L’exemple affiche ensuite le <xref:System.AppDomainSetup.DynamicBase%2A> propriété, pour montrer que le code de hachage du nom de l’application a été ajouté en tant que sous-répertoire du chemin qui a été affecté à l’origine.  
  
> [!NOTE]
>  Le répertoire de base dans cet exemple est destiné à être à l’extérieur du chemin de recherche pour l’exemple d’application. Veillez à compiler l’exemple dans un autre emplacement. Supprimer le répertoire de base et tous ses sous-répertoires chaque fois que vous exécutez l’exemple.  
  
 L’exemple crée un nouveau domaine d’application, à l’aide de la <xref:System.AppDomainSetup> objet. L’exemple utilise le <xref:System.AppDomain.DynamicDirectory%2A> propriété pour récupérer le nom du répertoire, donc il peut créer le répertoire. (L’exemple pourrait tout aussi facilement créer le répertoire au préalable en concaténant le chemin d’accès d’origine, le code de hachage du nom d’application, le nom de l’application.)  
  
 L’exemple a un `GenerateDynamicAssembly` méthode qui émet un assembly nommé `DynamicHelloWorld.dll` et le stocke dans le répertoire dynamique du nouveau domaine d’application. L’assembly dynamique contient un seul type, `HelloWorld`, qui a une méthode statique (`Shared` méthode en Visual Basic) nommée `HelloFromAD`. Appel de cette méthode affiche le nom du domaine d’application.  
  
 Le `Example` dérive de la classe <xref:System.MarshalByRefObject>, de sorte que l’exemple peut créer une instance de la classe dans le nouveau domaine d’application et appelez ses `Test` (méthode). Le `Test` méthode charge l’assembly dynamique par son nom d’affichage et appelle la méthode statique `HelloFromAD` (méthode).  
  
 Vous pouvez afficher que le répertoire dynamique est recherché après les chemins de détection normaux en écrivant du code pour un assembly nommé `DynamicHelloWorld.dll` et en le compilant dans le même répertoire que cet exemple. L’assembly doit avoir une classe nommée `HelloWorld` avec une méthode statique nommée `HelloFromAD`. Cette méthode n’a pas d’avoir les mêmes fonctionnalités que celui de l’exemple ; Il peut simplement afficher une chaîne dans la console. L’assembly doit également avoir un <xref:System.Reflection.AssemblyVersionAttribute> attribut qui définit sa version à 1.0.0.0. Lorsque vous exécutez l’exemple, l’assembly que vous avez compilé dans le répertoire actif est trouvé avant que le répertoire dynamique est recherché.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le <see cref="T:System.Security.Policy.Evidence" /> associé à ce domaine d'application.</summary>
        <value>La preuve associée à ce domaine d'application.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute l'assembly contenu dans le fichier spécifié.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <summary>Exécute l'assembly contenu dans le fichier spécifié.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
 Pour créer le <xref:System.AppDomain> pour charger et exécuter, utilisez la <xref:System.AppDomain.CreateDomain%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Exécute l'assembly contenu dans le fichier spécifié à l'aide de la preuve spécifiée.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Le <xref:System.AppDomain.ExecuteAssembly%2A> méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <param name="args">Arguments pour le point d’entrée de l’assembly.</param>
        <summary>Exécute l’assembly contenu dans le fichier spécifié à l’aide des arguments spécifiés.</summary>
        <returns>Valeur qui est retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <param name="assemblySecurity">Preuve fournie pour l'assembly.</param>
        <param name="args">Arguments pour le point d’entrée de l’assembly.</param>
        <summary>Exécute l’assembly contenu dans le fichier spécifié à l’aide de la preuve et des arguments spécifiés.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="assemblySecurity" /> doit être <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <param name="args">Arguments pour le point d’entrée de l’assembly.</param>
        <param name="hashValue">Représente la valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</param>
        <summary>Exécute l’assembly contenu dans le fichier spécifié à l’aide des arguments, de la valeur et de l’algorithme de hachage spécifiés.</summary>
        <returns>Valeur qui est retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyFile" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Nom du fichier contenant l'assembly à exécuter.</param>
        <param name="assemblySecurity">Preuve fournie pour l'assembly.</param>
        <param name="args">Arguments pour le point d’entrée de l’assembly.</param>
        <param name="hashValue">Représente la valeur du code de hachage calculé.</param>
        <param name="hashAlgorithm">Représente l'algorithme de hachage utilisé par le manifeste d'assembly.</param>
        <summary>Exécute l’assembly contenu dans le fichier spécifié à l’aide de la preuve, des arguments, de la valeur et de l’algorithme de hachage spécifiés.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Cette méthode charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode). Vous pouvez également exécuter des assemblys à l’aide de la <xref:System.AppDomain.ExecuteAssemblyByName%2A> (méthode), qui charge les assemblys à l’aide de la <xref:System.Reflection.Assembly.Load%2A> (méthode).  
  
   
  
## Examples  
 Exemple de réticules du centre montre comment utiliser une des surcharges de <xref:System.AppDomain.ExecuteAssembly%2A> sur deux domaines différents.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyFile" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="assemblySecurity" /> doit être <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Exécute un assembly.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Charge un assembly en fonction de son nom complet.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 Pour créer le <xref:System.AppDomain> pour charger et exécuter, utilisez la <xref:System.AppDomain.CreateDomain%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Objet <see cref="T:System.Reflection.AssemblyName" /> représentant le nom de l'assembly.</param>
        <param name="args">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <summary>Exécute l'assembly à partir d'un <see cref="T:System.Reflection.AssemblyName" />, à l'aide des arguments spécifiés.</summary>
        <returns>Valeur qui est retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Exécute un assembly en fonction de son nom complet, à l'aide de la preuve spécifiée.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
> [!NOTE]
>  Lorsque vous utilisez le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <summary>Exécute l’assembly en fonction de son nom complet, à l’aide des arguments spécifiés.</summary>
        <returns>Valeur qui est retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
 <paramref name="assemblyName" /> a été compilé avec une version du Common Language Runtime ultérieure à la version actuellement chargée.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Objet <see cref="T:System.Reflection.AssemblyName" /> représentant le nom de l'assembly.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <param name="args">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <summary>Exécute l'assembly à partir d'un <see cref="T:System.Reflection.AssemblyName" />, à l'aide de la preuve et des arguments spécifiés.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
> [!NOTE]
>  Lorsque vous utilisez le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="assemblySecurity" /> doit être <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <param name="args">Arguments de ligne de commande à passer au moment du démarrage du processus.</param>
        <summary>Exécute l’assembly en fonction de son nom complet, à l’aide de la preuve et des arguments spécifiés.</summary>
        <returns>Valeur retournée par le point d'entrée de l'assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode fournit une fonctionnalité similaire à la <xref:System.AppDomain.ExecuteAssembly%2A> (méthode), mais spécifie l’assembly par nom d’affichage ou <xref:System.Reflection.AssemblyName> plutôt que par l’emplacement du fichier. Par conséquent, <xref:System.AppDomain.ExecuteAssemblyByName%2A> charge les assemblys avec la <xref:System.Reflection.Assembly.Load%2A> méthode plutôt qu’avec la <xref:System.Reflection.Assembly.LoadFile%2A> (méthode).  
  
 L’assembly commence l’exécution au point d’entrée spécifié dans l’en-tête de .NET Framework.  
  
 Cette méthode ne crée pas un nouveau processus ou le domaine d’application, et il n’exécute pas la méthode de point d’entrée sur un nouveau thread.  
  
> [!NOTE]
>  Lorsque vous utilisez le <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode avec un <xref:System.Security.Policy.Evidence> paramètre, les preuves sont fusionnées. Preuves fournies en tant qu’argument à la <xref:System.AppDomain.ExecuteAssemblyByName%2A> méthode annulent et remplacent les preuves fournies par le chargeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">L’assembly spécifié par <paramref name="assemblyName" /> est introuvable.</exception>
        <exception cref="T:System.IO.FileLoadException">L’assembly spécifié par <paramref name="assemblyName" /> a été trouvé, mais ne peut pas être chargé.</exception>
        <exception cref="T:System.BadImageFormatException">L’assembly spécifié par <paramref name="assemblyName" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyName" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="assemblySecurity" /> doit être <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">L’assembly spécifié n’a aucun point d’entrée.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire, pour l’accès aux informations dans le chemin d’accès lui-même et pour rediriger un nom d’affichage pour un chemin d’accès. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour accéder à un site Web, lorsqu’un nom d’affichage est redirigé vers une URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Pour exécuter une application console. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une exception est levée dans le code managé, avant que l'exécution ne recherche un gestionnaire d'exceptions dans la pile des appels du domaine d'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement est uniquement une notification. Gestion de cet événement ne gérer l’exception ni affecter les exceptions suivantes en aucune façon. Une fois que l’événement a été déclenché et les gestionnaires d’événements ont été appelées, le common language runtime (CLR) commence à rechercher un gestionnaire pour l’exception. <xref:System.AppDomain.FirstChanceException> fournit le domaine d’application avec une première opportunité d’examiner les exceptions gérées.  
  
 L’événement peut être géré par domaine d’application. Si un thread passe par plusieurs domaines d’application lors de l’exécution d’un appel, l’événement est déclenché dans chaque domaine d’application qui a inscrit un gestionnaire d’événements, avant que le CLR commence à rechercher un gestionnaire d’exceptions correspondant dans ce domaine d’application. Une fois que l’événement a été géré, une recherche est effectuée pour un gestionnaire d’exceptions correspondant dans ce domaine d’application. Si aucun n’est trouvé, l’événement est déclenché dans le domaine d’application suivant.  
  
 Vous devez gérer toutes les exceptions qui se produisent dans l’événement gestionnaire pour la <xref:System.AppDomain.FirstChanceException> événement. Sinon, <xref:System.AppDomain.FirstChanceException> est déclenché de manière récursive. Cela peut entraîner un débordement de pile et l’arrêt de l’application. Nous vous recommandons d’implémenter des gestionnaires d’événements pour cet événement en tant que régions d’exécution limitée (CER), pour conserver les exceptions liées à infrastructure tels que de dépassement de capacité de mémoire insuffisante ou de la pile d’affecter la machine virtuelle, tandis que la notification d’exception est en cours de traitement.  
  
 Cet événement n’est pas déclenché pour les exceptions qui indiquent l’altération de l’état du processus, telles que des violations d’accès, sauf si le Gestionnaire d’événements est critique de sécurité et a la <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribut.  
  
 Le common language runtime interrompt les abandons de thread pendant que cet événement de notification est géré.  
  
   
  
## Examples  
 L’exemple suivant crée une série de domaines d’application nommé `AD0` via `AD3`, avec un `Worker` objet dans chaque domaine d’application. Chaque `Worker` objet a une référence à la `Worker` de l’objet dans le domaine d’application suivant, à l’exception de la `Worker` dans le dernier domaine d’application. Le <xref:System.AppDomain.FirstChanceException> événement est géré dans tous les domaines d’application à l’exception `AD1`.  
  
> [!NOTE]
>  En plus de cet exemple, ce qui explique les notifications des exceptions de première chance dans plusieurs domaines d’application, vous pouvez trouver des cas d’usage simples dans [Comment : recevoir des Notifications des exceptions de première Chance](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Lorsque les domaines d’application ont été créées, le domaine d’application par défaut appelle la `TestException` méthode pour le premier domaine d’application. Chaque `Worker` object appelle le `TestException` méthode pour le domaine d’application suivant, jusqu'à ce que le dernier `Worker` lève une exception qui est gérée ou non prise en charge. Par conséquent, le thread actuel traverse tous les domaines d’application, et `TestException` est ajouté à la pile dans chaque domaine d’application.  
  
 Lors de la dernière `Worker` objet gère l’exception, le <xref:System.AppDomain.FirstChanceException> événement est déclenché uniquement dans le dernier domaine d’application. Les autres domaines d’application aucune chance pour gérer l’exception, donc l’événement n’est pas déclenché.  
  
 Lors de la dernière `Worker` objet ne gère pas l’exception, le <xref:System.AppDomain.FirstChanceException> événement est déclenché dans chaque domaine d’application qui a un gestionnaire d’événements. À l’issue de chaque gestionnaire d’événements, la pile continue à dérouler jusqu'à ce que l’exception est interceptée par le domaine d’application par défaut.  
  
> [!NOTE]
>  Pour voir comment l’affichage de la pile augmente à mesure que l’événement est déclenché plus proche et le plus proche du domaine d’application par défaut, remplacez `e.Exception.Message` à `e.Exception` dans le `FirstChanceHandler` gestionnaires d’événements. Notez que lorsque `TestException` est appelée sur les limites du domaine d’application, il apparaît deux fois : une fois pour le proxy et une fois pour le stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom convivial de ce domaine d'application.</summary>
        <value>Nom convivial de ce domaine d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom convivial du domaine d’application par défaut est le nom de fichier de l’exécutable du processus. Par exemple, si l’exécutable utilisé pour démarrer le processus est `"c:\MyAppDirectory\MyAssembly.exe"`, le nom convivial du domaine d’application par défaut est `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.AppDomain.FriendlyName%2A> propriété à obtenir le nom convivial du domaine d’application actuel. Pour le domaine d’application par défaut, le nom convivial est le nom du fichier exécutable de l’application. L’exemple de code affiche également des informations supplémentaires sur le domaine d’application.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient les assemblys qui ont été chargés dans le contexte d'exécution de ce domaine d'application.</summary>
        <returns>Tableau d'assemblys de ce domaine d'application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Le code suivant exemple utilise le <xref:System.AppDomain.GetAssemblies%2A> méthode pour obtenir une liste de tous les assemblys qui ont été chargés dans le domaine d’application. Les assemblys sont ensuite affichés sur la console.  
  
 Pour exécuter cet exemple de code, vous devez créer un assembly nommé `CustomLibrary.dll`, ou modifiez le nom de l’assembly qui est passé à la <xref:System.AppDomain.GetAssemblies%2A> (méthode).  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient l'identificateur du thread actuel.</summary>
        <returns>Entier signé 32 bits qui correspond à l'identificateur du thread actuel.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propriété, qui est stable même lorsque le .NET Framework est hébergé par un environnement qui prend en charge des fibres (autrement dit, les threads légers).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour appeler cette méthode. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une propriété de domaine d'application prédéfinie ou nom d'une propriété de domaine d'application que vous avez définie.</param>
        <summary>Obtient la valeur stockée dans le domaine d'application actuel pour le nom spécifié.</summary>
        <returns>Valeur de la propriété <paramref name="name" />, ou <see langword="null" /> si elle n'existe pas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour récupérer la valeur d’une entrée dans un cache interne de paires nom / données qui décrivent les propriétés de cette instance de <xref:System.AppDomain>. Notez que la comparaison de `name` par le nom de paires clé-valeur respecte la casse.  
  
 Le cache contient automatiquement des entrées de système prédéfinis qui sont insérées lorsque le domaine d’application est créé. Vous pouvez vérifier leurs valeurs avec le <xref:System.AppDomain.GetData%2A> (méthode), ou l’équivalent <xref:System.AppDomainSetup> propriétés.  
  
 Vous pouvez insérer ou modifier vos propres paires de nom / données définies par l’utilisateur avec le <xref:System.AppDomain.SetData%2A> méthode et examiner leurs valeurs avec le <xref:System.AppDomain.GetData%2A> (méthode).  
  
 Le tableau suivant décrit les `name` de chacun d’eux prédéfinis entrée du système et son <xref:System.AppDomainSetup> propriété.  
  
|Valeur de 'name'|Property|  
|---------------------|--------------|  
|« APPBASE »|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|« APP_CONFIG_FILE »|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|« APP_LAUNCH_URL »|(aucune propriété)<br /><br /> « APP_LAUNCH_URL » représente l’URL initialement demandée par l’utilisateur, avant toute redirection. Il est disponible uniquement lorsque l’application a été lancée avec un navigateur tel qu’Internet Explorer. Certains navigateurs ne prennent cette valeur.|  
|« APP_NAME »|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|« BINPATH_PROBE_ONLY »|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|« CACHE_BASE »|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|« CODE_DOWNLOAD_DISABLED »|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|« DEV_PATH »|(aucune propriété)|  
|« DISALLOW_APP »|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|« DISALLOW_APP_BASE_PROBING »|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|« DISALLOW_APP_REDIRECTS »|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|« DYNAMIC_BASE »|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|« FORCE_CACHE_INSTALL »|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|« LICENSE_FILE », ou une chaîne spécifique à l’application|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|« LOADER_OPTIMIZATION »|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|« LOCATION_URI »|(aucune propriété)|  
|« PRIVATE_BINPATH »|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|« REGEX_DEFAULT_MATCH_TIMEOUT »|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> « REGEX_DEFAULT_MATCH_TIMEOUT » n’est pas une entrée de système, et sa valeur peut être définie en appelant le <xref:System.AppDomain.SetData%2A> (méthode).|  
|« SHADOW_COPY_DIRS »|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 L’exemple suivant crée un nouveau domaine d’application définit une valeur fournie par le système pour le domaine et ajoute une nouvelle paire de valeur pour le domaine. L’exemple montre ensuite comment utiliser le <xref:System.AppDomain.GetData%2A> méthode pour récupérer les données de ces paires de valeur et les afficher dans la console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même, si la propriété s’applique à un chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient le type de l'instance actuelle.</summary>
        <returns>Type de l'instance actuelle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un entier qui identifie de façon unique le domaine d'application au sein du processus.</summary>
        <value>Entier qui identifie le domaine d'application.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant crée un deuxième domaine d’application et affiche des informations sur le domaine par défaut et le nouveau domaine.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Donne à <see cref="T:System.AppDomain" /> une durée de vie infinie en empêchant toute création de bail.</summary>
        <returns>Toujours <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Commutateur de compatibilité à tester.</param>
        <summary>Obtient une valeur booléenne Nullable qui indique si les commutateurs de compatibilité sont définis, et si tel est le cas, si le commutateur de compatibilité spécifié est défini.</summary>
        <returns>Une référence null (<see langword="Nothing" /> en Visual Basic) si aucun commutateur de compatibilité n'est défini ; sinon, une valeur booléenne qui indique si le commutateur de compatibilité spécifié par <paramref name="value" /> est défini.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode vérifie si le commutateur de compatibilité spécifié a été défini pour le domaine d’application actuel. Commutateurs de compatibilité restaurer généralement un comportement (telles que les façon dont les chaînes sont triées) qui a été modifié entre les versions du .NET Framework.  Elles sont définies en appelant le <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> méthode avant de créer un domaine d’application.  
  
 Le tableau suivant fournit des exemples de commutateurs de compatibilité qui peuvent être définies pour restaurer le comportement des versions antérieures du .NET Framework.  
  
|Basculer|Signification|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Sécurité accès du code (CAS) pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application. Consultez [ &lt;NetFx40_LegacySecurityPolicy&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|« NetFx40_Legacy20SortingBehavior »|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] sont activées dans ce domaine d’application. Son succès nécessite sort00001000.dll soit installé. Consultez [ &lt;CompatSortNLSVersion&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|« NetFx40_Legacy40SortingBehavior »|Chaîne de tri des valeurs par défaut pour le [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]et Unicode 5.0 sont activées dans ce domaine d’application. Son succès nécessite sort00060101.dll doit être installé.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> mise en forme de comportement pour le [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] est activé dans ce domaine d’application.  Consultez [ &lt;TimeSpan_LegacyFormatMode&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) et la section « Restauration hérité TimeSpan mise en forme » de la <xref:System.TimeSpan> rubrique.|  
|« UseRandomizedStringHashAlgorithm »|Le runtime calcule les codes de hachage pour les chaînes sur un par domaine d’application au lieu d’utiliser un algorithme de hachage unique qui produit un code de hachage cohérent entre domaines d’application. Consultez [ &lt;UseRandomizedStringHashAlgorithm&gt; élément](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne une valeur qui indique si le domaine d'application est le domaine d'application par défaut du processus.</summary>
        <returns>
          <see langword="true" /> si l'objet <see cref="T:System.AppDomain" /> en cours représente le domaine d'application par défaut du processus ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chaque processus managé a un domaine d’application par défaut. Début de l’exécution dans le domaine par défaut.  
  
   
  
## Examples  
 L’exemple de code suivant crée un deuxième domaine d’application et affiche des informations sur le domaine par défaut et le nouveau domaine.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indique si le déchargement de ce domaine d'application est en cours et si les objets qu'il contient sont en cours de finalisation par le Common Language Runtime.</summary>
        <returns>
          <see langword="true" /> si le déchargement du domaine d'application est en cours et que le Common Language Runtime a commencé à appeler les finaliseurs ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La méthode de finalisation d’un objet fournit une opportunité d’effectuer des opérations de nettoyage nécessaires avant que l’objet soit par le garbage collecté. Après la finalisation, l’objet est accessible, mais dans un état non valide et est donc inutilisable. Finalement, le garbage collection se termine et libère l’objet.  
  
 Méthode de finalisation d’un objet est appelée dans une des situations suivantes : pendant le garbage collection, lorsque le common language runtime s’arrête, ou lorsque le domaine d’application qui contient l’objet est déchargé. Le <xref:System.AppDomain.IsFinalizingForUnload%2A> retourne de la méthode `true` uniquement dans le dernier cas ; elle ne retourne pas `true` si la finalisation des résultats à partir de la routine de nettoyage ou d’arrêt du CLR.  
  
> [!NOTE]
>  Pour déterminer si la finalisation est en raison de l’arrêt du CLR, utilisez le <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> propriété. Elle retourne `true` si la finalisation est en raison d’un domaine d’application en cours de déchargement ou au CLR en cours d’arrêt.  
  
 Lors de l’exécution de la méthode de finalisation durant le déchargement du domaine, vous souhaiterez peut-être accéder à un autre objet qui est référencé par un champ statique et possède une méthode de finalisation. Toutefois, vous ne pouvez pas fiable faire, car l’objet accessible peut déjà avoir été finalisé.  
  
> [!NOTE]
>  Une exception à cette règle est la <xref:System.Console> classe, qui contient des champs statiques qui référencent des objets de flux, mais est implémenté spécialement donc vous pouvez toujours écrire dans la console système, même lors de l’arrêt de système ou de déchargement du domaine.  
  
 Utilisez cette méthode dans la méthode de finalisation d’un objet pour déterminer si le domaine d’application qui contient l’objet déchargement est en cours. Si tel est le cas, vous ne pouvez pas accéder de manière fiable n’importe quel objet qui a une méthode de finalisation et est référencé par un champ statique.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si les assemblys chargés dans le domaine d'application actuel s'exécutent avec la confiance totale.</summary>
        <value>
          <see langword="true" /> si les assemblys chargés dans le domaine d'application actuel s'exécutent avec la confiance totale ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne toujours `true` pour le domaine d’application par défaut d’une application qui s’exécute sur le bureau. Elle retourne `false` pour un domaine d’application sandbox qui a été créé à l’aide de la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> surcharge de méthode, à moins que les autorisations sont accordées au domaine d’application sont équivalentes à la confiance totale.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.AppDomain.IsFullyTrusted%2A> propriété et le <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> propriété avec des domaines d’application de confiance totale et confiance partielle. Le domaine d’application de confiance totale est le domaine d’application par défaut pour l’application. Le domaine d’application partiellement approuvée est créé à l’aide de la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> surcharge de méthode.  
  
 L’exemple utilise un `Worker` classe qui dérive de <xref:System.MarshalByRefObject>, donc il peut être marshalée au-delà les limites du domaine d’application. L’exemple crée un `Worker` objet dans le domaine d’application par défaut. Il appelle ensuite la `TestIsFullyTrusted` méthode pour afficher la valeur de propriété du domaine d’application et pour les deux assemblys qui sont chargés dans le domaine d’application : mscorlib, qui fait partie du .NET Framework et l’exemple d’assembly. Le domaine d’application est entièrement fiable, par conséquent, les deux assemblys sont entièrement fiables.  
  
 L’exemple crée un autre `Worker` objet dans un domaine d’application sandbox et appelle de nouveau la `TestIsFullyTrusted` (méthode). Mscorlib est toujours approuvé, même dans un domaine d’application partiellement fiable, mais l’exemple d’assembly est partiellement approuvé.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le domaine d'application actuel dispose d'un jeu d'autorisations accordé à tous les assemblys chargés dans le domaine d'application.</summary>
        <value>
          <see langword="true" /> si le domaine d'application actuel dispose d'un jeu d'autorisations homogène ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété retourne `true` pour les domaines d’application sandbox qui ont été créés à l’aide de la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> surcharge de méthode. Domaines d’application sandbox ont un jeu homogène d’autorisations ; Autrement dit, le même jeu d’autorisations est accordé à tous les assemblys de confiance partielle qui sont chargés dans le domaine d’application. Un domaine d’application sandbox a éventuellement une liste d’assemblys avec nom fort qui sont exempts de cette autorisation, configurer et l’exécuter à la place avec une confiance totale.  
  
 Niveau de confiance suffisant code peut utiliser le <xref:System.AppDomain.PermissionSet%2A> propriété afin de déterminer le jeu d’autorisations homogène d’un domaine d’application sandbox.  
  
 Cette propriété retourne également `true` pour le domaine d’application par défaut d’une application de bureau, car ce domaine d’application accorde une confiance totale à tous les assemblys.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> dans ce domaine d'application.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau de type <see langword="byte" /> qui est une image au format COFF contenant un assembly émis.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> avec l'image au format COFF (Common Object File Format) contenant un <see cref="T:System.Reflection.Assembly" /> émis.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.  
  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objet qui décrit l'assembly à charger.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> en fonction de son <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Si une version de l’assembly demandé est déjà chargée, cette méthode retourne l’assembly chargé, même si une autre version est demandée.  
  
 En fournissant un nom d’assembly partiel pour `assemblyRef` n’est pas recommandée. (Un nom partiel omet un ou plusieurs de culture, version ou jeton de clé publique. Pour les surcharges qui prennent une chaîne au lieu d’un <xref:System.Reflection.AssemblyName> objet, « MyAssembly, Version = 1.0.0.0 » est un exemple d’un nom partiel et « MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47 » est un exemple d’un nom complet.) À l’aide de noms partiels a un effet négatif sur les performances. En outre, un nom d’assembly partiel peut charger un assembly du global assembly cache uniquement s’il existe une copie exacte de l’assembly dans le répertoire de base d’application (<xref:System.AppDomain.BaseDirectory%2A> ou <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Si actuel <xref:System.AppDomain> objet représente le domaine d’application `A`et le <xref:System.AppDomain.Load%2A> méthode est appelée à partir du domaine d’application `B`, l’assembly est chargé dans les deux domaines d’application. Par exemple, le code suivant charge `MyAssembly` dans le nouveau domaine d’application `ChildDomain` et également dans le domaine d’application où le code s’exécute :  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 L’assembly est chargé dans les deux domaines car <xref:System.Reflection.Assembly> ne dérive pas de <xref:System.MarshalByRefObject>et par conséquent, la valeur de retour de la <xref:System.AppDomain.Load%2A> méthode ne peuvent pas être marshalée. Au lieu de cela, le common language runtime tente de charger l’assembly dans le domaine d’application appelant. Les assemblys sont chargés dans les deux domaines d’application peuvent être différents si les paramètres de chemin d’accès pour les deux domaines d’application sont différents.  
  
> [!NOTE]
>  Si les deux le <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriété et la <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriété sont définies, la première tentative de charger l’assembly utilise le nom d’affichage (notamment la version, culture et ainsi de suite, tel que retourné par la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriété). Si le fichier est introuvable, la <xref:System.Reflection.AssemblyName.CodeBase%2A> propriété est utilisée pour rechercher l’assembly. Si l’assembly se trouve à l’aide de <xref:System.Reflection.AssemblyName.CodeBase%2A>, le nom d’affichage est comparé à l’assembly. Si la correspondance échoue, un <xref:System.IO.FileLoadException> est levée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> est <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> en fonction de son nom complet.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">Pour pouvoir accéder à l’emplacement de l’assembly si l’assembly n’est pas local.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau de type <see langword="byte" /> qui est une image au format COFF contenant un assembly émis.</param>
        <param name="rawSymbolStore">Tableau de type <see langword="byte" /> contenant les octets bruts représentant les symboles de l'assembly.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> avec l'image au format COFF (Common Object File Format) contenant un <see cref="T:System.Reflection.Assembly" /> émis. Les octets bruts représentant les symboles de <see cref="T:System.Reflection.Assembly" /> sont également chargés.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.  
  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Net.WebPermission">pour lire un URI qui ne commence pas par « file:// ».</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Objet qui décrit l'assembly à charger.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> en fonction de son <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyRef" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «\\\UNC\dir\\» ou « c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Nom complet de l'assembly. Consultez <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Preuve de chargement de l'assembly.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> en fonction de son nom complet.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> est introuvable.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="assemblyString" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour charger un assembly avec la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «\\\UNC\dir\\» ou « c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Tableau de type <see langword="byte" /> qui est une image au format COFF contenant un assembly émis.</param>
        <param name="rawSymbolStore">Tableau de type <see langword="byte" /> contenant les octets bruts représentant les symboles de l'assembly.</param>
        <param name="securityEvidence">Preuve de chargement de l'assembly.</param>
        <summary>Charge <see cref="T:System.Reflection.Assembly" /> avec l'image au format COFF (Common Object File Format) contenant un <see cref="T:System.Reflection.Assembly" /> émis. Les octets bruts représentant les symboles de <see cref="T:System.Reflection.Assembly" /> sont également chargés.</summary>
        <returns>Assembly chargé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le niveau de confiance d’un assembly est chargé à l’aide de cette méthode est le même que le niveau de confiance du domaine d’application.  
  
 Cette méthode doit être utilisée uniquement pour charger un assembly dans le domaine d’application actuel. Cette méthode est fournie par commodité pour les appelants d’interopérabilité qui ne peuvent pas appeler la méthode statique <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> (méthode). Pour charger des assemblys dans les autres domaines d’application, utilisez une méthode telle que <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Pour plus d’informations qui sont communes à toutes les surcharges de cette méthode, consultez la <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> surcharge de méthode.  
  
   
  
## Examples  
 L’exemple suivant illustre l’utilisation du chargement d’un assembly brut.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> est <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> n’est pas un assembly valide.  
  
- ou - 
La version 2.0 ou ultérieure du common language runtime est actuellement chargée et <paramref name="rawAssembly" /> a été compilé avec une version ultérieure.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <exception cref="T:System.IO.FileLoadException">Un assembly ou un module a été chargé à deux reprises avec deux preuves différentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> n’est pas un <see langword="null" />. Quand la stratégie CAS héritée n’est pas activée, <paramref name="securityEvidence" /> doit être <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour fournir la preuve. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder en lecture à partir d’un fichier ou répertoire et pour l’accès aux informations dans le chemin d’accès lui-même. Énumérations associées : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">pour la lecture d’un chemin d’accès qui n’est pas sous la forme « file:// » ou «\\\UNC\dir\\» ou « c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'analyse de la mémoire et du processeur des domaines d'application est activée pour le processus actuel. Quand l'analyse a été activée pour un processus, elle ne peut plus être désactivée.</summary>
        <value>
          <see langword="true" /> si l'analyse est activée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cela `static` propriété (`Shared` propriété en Visual Basic) contrôle l’UC et surveillance de la mémoire de tous les domaines d’application dans le processus.  
  
 Si vous essayez de définir cette propriété sur `false`, un <xref:System.ArgumentException> exception est levée, même si la valeur actuelle de la propriété est `false`.  
  
 Une fois l’analyse est activée, vous pouvez utiliser la <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, et <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> propriétés pour surveiller l’utilisation du processeur et mémoire des domaines d’application de l’instance.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le processus actuel a essayé d'assigner la valeur <see langword="false" /> à cette propriété.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d’octets qui ont survécu à la dernière collection et qui sont référencés par le domaine d’application actuel.</summary>
        <value>Nombre d'octets survivants.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les statistiques sont mises à jour à chaque garbage collection. Toutefois, ils sont garanties exacte uniquement après un blocage de collection ; complet Autrement dit, une collection qui inclut toutes les générations et qui arrête l’application lors de la collection se produit. Par exemple, le <xref:System.GC.Collect?displayProperty=nameWithType> surcharge de méthode effectue une collecte bloquante complète. (Collections simultanées se produit en arrière-plan et ne bloquent pas l’application.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.AppDomain.MonitoringIsEnabled" /><see langword="static" /> (<see langword="Shared" /> en Visual Basic) a la valeur <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre total d’octets qui ont survécu à la dernière collection pour tous les domaines d’application dans le processus.</summary>
        <value>Nombre total d'octets survivants pour le processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Après une collecte bloquante complète, ce nombre représente le nombre d’octets actuellement maintenu actif sur gérés des segments de mémoire. Il doit être proche du nombre signalé par le <xref:System.GC.GetTotalMemory%2A> (méthode). Après une collection éphémère, ce nombre représente le nombre d’octets actuellement maintenus actifs dans les générations éphémères.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.AppDomain.MonitoringIsEnabled" /><see langword="static" /> (<see langword="Shared" /> en Visual Basic) a la valeur <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la taille totale, en octets, de toutes les allocations de mémoire effectuées par le domaine d'application depuis sa création, sans soustraire la mémoire collectée.</summary>
        <value>Taille totale de toutes les allocations de mémoire.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.AppDomain.MonitoringIsEnabled" /><see langword="static" /> (<see langword="Shared" /> en Visual Basic) a la valeur <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le temps processeur total utilisé par tous les threads pendant leur exécution dans le domaine d'application actuel, depuis le démarrage du processus.</summary>
        <value>Temps processeur total pour le domaine d'application actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La durée totale qui est signalée pour un domaine d’application comprend la durée de chaque thread dans le processus de l’exécution dans ce domaine d’application.  
  
 Un thread qui appelle dans du code non managé est toujours associé à un domaine d’application, et le temps processeur passé dans l’exécution que du code non managé est signalé pour le domaine d’application où l’appel a été effectué.  
  
 Quand un thread est bloqué ou en veille, il ne consomme pas de temps processeur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.AppDomain.MonitoringIsEnabled" /><see langword="static" /> (<see langword="Shared" /> en Visual Basic) a la valeur <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le jeu d'autorisations d'un domaine d'application en mode bac à sable (sandbox).</summary>
        <value>Jeu d'autorisations du domaine d'application en mode bac à sable (sandbox).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domaines d’application sandbox qui ont été créés à l’aide de la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> surcharge de méthode ont un jeu d’autorisations homogène ; autrement dit, le même jeu d’autorisations est accordé à tous les assemblys de confiance partielle qui sont chargés dans le domaine d’application. Un domaine d’application sandbox a éventuellement une liste d’assemblys avec nom fort qui sont exempts de cette autorisation, configurer et l’exécuter à la place avec une confiance totale.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand le processus parent du domaine d'application par défaut s'arrête.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.EventHandler> de cet événement peut effectuer des activités d’arrêt, telle que la fermeture des fichiers, libération de stockage, et ainsi de suite, avant la fin du processus.  
  
 À compter de .NET Framework version 2.0, cet événement est déclenché dans chaque domaine d’application qui inscrit un gestionnaire d’événements.  
  
> [!NOTE]
>  La durée totale d’exécution de tous les <xref:System.AppDomain.ProcessExit> gestionnaires d’événements est limité, tout comme la durée totale d’exécution de tous les finaliseurs est limitée à l’arrêt du processus. La valeur par défaut est de deux secondes. Un hôte non managé peut modifier cette durée d’exécution en appelant le [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) méthode avec le [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valeur d’énumération.  
  
 Dans les versions 1.0 et 1.1 du .NET Framework, cet événement est déclenché uniquement dans le domaine d’application par défaut et uniquement si un gestionnaire d’événements est inscrite dans le domaine d’application par défaut.  
  
 Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <xref:System.Security.SecurityException> est levée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la résolution d’un assembly échoue dans le contexte de réflexion uniquement.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le contexte de réflexion uniquement, les dépendances ne sont pas résolues automatiquement. Ils doivent être préchargées ou retournés par le gestionnaire pour cet événement. Cet événement est déclenché lorsqu’un assembly a une dépendance qui n’est pas déjà chargée dans le contexte de réflexion uniquement. La dépendance manquante est spécifiée par le <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriété. Le <xref:System.ResolveEventHandler> pour cet événement doit retourner un assembly qui satisfait la dépendance. L’assembly retourné doit être chargé dans le contexte de réflexion uniquement.  
  
> [!IMPORTANT]
>  Cet événement est déclenché uniquement pour les dépendances manquantes de l’assembly que vous chargez dans le contexte de réflexion uniquement (par exemple, en utilisant le <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> méthode). Il n’est pas déclenché si l’assembly que vous chargez est introuvable.  
  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriété retourne l’assembly qui a demandé le chargement d’assembly ne peut pas être résolu. Connaître l’identité de l’assembly demandeur peut être utile pour identifier la version correcte de la dépendance, s’il existe plusieurs versions. Pour plus d'informations, consultez <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Pour cet événement, le <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriété retourne le nom de l’assembly avant de la stratégie est appliquée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne les assemblys qui ont été chargés dans le contexte de réflexion uniquement du domaine d'application.</summary>
        <returns>Tableau d'objets <see cref="T:System.Reflection.Assembly" /> qui représentent les assemblys chargés dans le contexte de réflexion uniquement du domaine d'application.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode retourne les assemblys qui ont été chargés dans le contexte de réflexion uniquement. Pour obtenir les assemblys qui ont été chargés pour l’exécution, utilisez le <xref:System.AppDomain.GetAssemblies%2A> (méthode).  
  
   
  
## Examples  
 L’exemple de code suivant charge l’assembly System.dll dans le contexte d’exécution, puis dans le contexte de réflexion uniquement. Le <xref:System.AppDomain.GetAssemblies%2A> et <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> méthodes sont utilisées pour afficher les assemblys chargés dans chaque contexte.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Une tentative d'opération est en cours sur un domaine d'application non chargé.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin d’accès sous le répertoire de base où le programme de résolution d’assembly doit détecter les assemblys privés.</summary>
        <value>Chemin d’accès sous le répertoire de base où le programme de résolution d’assembly doit détecter les assemblys privés.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblys privés sont déployés dans la même structure de répertoire que l’application. Si le chemin d’accès spécifié par le <xref:System.AppDomain.RelativeSearchPath%2A> propriété n’est pas sous <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, il est ignoré.  
  
 Cette propriété retourne la valeur définie à l’aide de <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations du chemin d’accès. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la résolution d’une ressource échoue car la ressource n’est pas une ressource liée ou incorporée valide de l’assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.ResolveEventHandler> pour cet événement peut essayer de localiser l’assembly contenant la ressource et renvoyez-le.  
  
> [!IMPORTANT]
>  Cet événement n’est pas déclenché si la résolution échoue, car aucun fichier peut être trouvé pour une ressource liée valide. Il est déclenché si un flux de ressource de manifeste ne peut pas être trouvé, mais il n’est pas déclenché si une clé de ressource individuelle ne peut pas être trouvée.  
  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriété contient l’assembly qui a demandé la ressource. Pour plus d'informations, consultez <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <xref:System.Security.SecurityException> est levée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Niveau de stratégie de sécurité.</param>
        <summary>Définit le niveau de stratégie de sécurité pour ce domaine d'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez cette méthode avant un assembly est chargé dans le <xref:System.AppDomain> afin que la stratégie de sécurité ait effet.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomain.SetAppDomainPolicy%2A> méthode pour définir le niveau de stratégie de sécurité d’un domaine d’application.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Le niveau de stratégie de sécurité a déjà été défini.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin d’accès qualifié complet à l’emplacement des clichés instantanés.</param>
        <summary>Définit le chemin d’accès du répertoire spécifié comme emplacement pour les clichés instantanés des assemblys.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le chemin d’accès du cache est ignoré si le <xref:System.AppDomainSetup.ApplicationName%2A> propriété n’est pas définie. Voir la propriété <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Assigne une valeur à une propriété de domaine d'application.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une propriété de domaine d'application définie par l'utilisateur à créer ou à changer.</param>
        <param name="data">Valeur de la propriété.</param>
        <summary>Assigne la valeur spécifiée à la propriété du domaine d'application spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour insérer une entrée, ou modifier la valeur d’une entrée dans un cache interne de paires nom / données qui décrivent les propriétés de cette instance de <xref:System.AppDomain>.  
  
 Le cache contient automatiquement des entrées de système prédéfinis qui sont insérées lorsque le domaine d’application est créé. Vous ne pouvez pas insérer ou modifier des entrées de système avec cette méthode. Un appel de méthode qui tente de modifier une entrée du système n’a aucun effet ; la méthode ne lève pas d’exception. Vous pouvez inspecter les valeurs des entrées du système avec la <xref:System.AppDomain.GetData%2A> (méthode), ou l’équivalent <xref:System.AppDomainSetup> propriétés décrites dans <xref:System.AppDomain.GetData%2A>.  
  
 Vous pouvez appeler cette méthode pour définir la valeur de l’intervalle de délai d’expiration par défaut pour l’évaluation des modèles d’expressions régulières par la fourniture « REGEX_DEFAULT_MATCH_TIMEOUT » comme valeur de la `name` argument et un <xref:System.TimeSpan> valeur qui représente le délai d’attente intervalle en tant que la valeur de la `data` argument. Vous pouvez également insérer ou modifier vos propres paires de nom / données définies par l’utilisateur avec cette méthode et examiner leurs valeurs avec le <xref:System.AppDomain.GetData%2A> (méthode).  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> méthode pour créer une nouvelle paire de valeur. L’exemple utilise ensuite la <xref:System.AppDomain.GetData%2A> méthode pour récupérer la valeur et l’affiche dans la console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Nom d'une propriété de domaine d'application définie par l'utilisateur à créer ou à changer.</param>
        <param name="data">Valeur de la propriété.</param>
        <param name="permission">Autorisation à exiger de l'appelant quand la propriété est récupérée.</param>
        <summary>Assigne la valeur spécifiée à la propriété du domaine d'application spécifiée, avec une autorisation spécifiée à exiger de l'appelant quand la propriété est récupérée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour insérer ou modifier vos propres entrées définies par l’utilisateur dans un cache interne de paires nom/données qui décrivent les propriétés du domaine d’application. Lorsque vous insérez une entrée, vous pouvez spécifier une demande d’autorisation à appliquer lors de l’entrée est récupérée. En outre, vous pouvez appeler cette méthode pour définir la valeur de l’intervalle de délai d’expiration par défaut pour l’évaluation des modèles d’expressions régulières par la fourniture « REGEX_DEFAULT_MATCH_TIMEOUT » comme valeur de la `name` argument et un <xref:System.TimeSpan> valeur qui représente le intervalle de délai d’attente en tant que la valeur de la `data` argument.  
  
 Vous ne pouvez pas utiliser cette méthode pour affecter une demande de sécurité à une chaîne de propriété définie par le système.  
  
 Le cache contient automatiquement des entrées de système prédéfinis qui sont insérées lorsque le domaine d’application est créé. Vous ne pouvez pas insérer ou modifier des entrées de système avec cette méthode. Un appel de méthode qui tente de modifier une entrée du système n’a aucun effet ; la méthode ne lève pas d’exception. Vous pouvez inspecter les valeurs des entrées du système avec la <xref:System.AppDomain.GetData%2A> méthode ou l’équivalent <xref:System.AppDomainSetup> propriétés décrites dans la section Notes pour la <xref:System.AppDomain.GetData%2A> (méthode).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> est <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> spécifie une chaîne de propriété définie par le système et <paramref name="permission" /> n'est pas <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin qualifié complet qui est le répertoire de base des sous-répertoires où sont stockés les assemblys dynamiques.</param>
        <summary>Définit le chemin de répertoire spécifié comme répertoire de base des sous-répertoires dans lesquels sont stockés les fichiers générés de manière dynamique et à partir desquels ils sont accessibles.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode définit le <xref:System.AppDomainSetup.DynamicBase%2A> propriété d’interne <xref:System.AppDomainSetup> associé à cette instance.  
  
   
  
## Examples  
 Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement. L’exemple suivant montre comment utiliser l’alternative non obsolète, le <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriété. Pour obtenir une explication de cet exemple, consultez le <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriété ou le <xref:System.AppDomain.DynamicDirectory%2A> propriété.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">L'une des valeurs de <see cref="T:System.Security.Principal.PrincipalPolicy" /> qui spécifie le type de l'objet principal à joindre aux threads.</param>
        <summary>Spécifie la façon dont les objets Principal et Identity doivent être attachés à un thread si celui-ci tente d'établir une liaison vers un principal au moment de l'exécution dans ce domaine d'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Définition de cette valeur uniquement entreront en vigueur si vous la définissez avant d’utiliser le <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propriété. Par exemple, si vous définissez <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> à une entité de sécurité donnée (par exemple, un principal générique) puis utiliser le <xref:System.AppDomain.SetPrincipalPolicy%2A> méthode pour définir le <xref:System.Security.Principal.PrincipalPolicy> à <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, le principal actuel reste le principal générique.  
  
   
  
## Examples  
 L’exemple suivant montre l’effet sur les threads de l’utilisation de la <xref:System.AppDomain.SetPrincipalPolicy%2A> méthode pour modifier la stratégie principale du domaine d’application. Il montre également l’effet de l’utilisation de la <xref:System.AppDomain.SetThreadPrincipal%2A> méthode pour modifier l’entité de sécurité qui est disponible pour l’attachement à des threads dans le domaine d’application.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité de manipuler l’objet principal. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Active les clichés instantanés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Liste de noms de répertoires, où chaque nom est séparé par un point-virgule.</param>
        <summary>Définit le chemin d’accès du répertoire spécifié comme emplacement pour les clichés instantanés des assemblys.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par défaut, un cliché instantané inclut tous les assemblys trouvés par le biais de détection. Le <xref:System.AppDomain.SetShadowCopyPath%2A> méthode restreint le cliché instantané aux assemblys dans les répertoires spécifiés par `path`.  
  
 Le <xref:System.AppDomain.SetShadowCopyPath%2A> méthode ne spécifie pas de répertoires supplémentaires dans lesquels rechercher les assemblys. Assemblys à une copie fantôme doivent déjà se trouver dans le chemin de recherche, par exemple sous <xref:System.AppDomain.BaseDirectory%2A>. Le <xref:System.AppDomain.SetShadowCopyPath%2A> méthode spécifie les chemins de recherche peut être une copie fantôme.  
  
 Cette méthode définit le <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriété d’interne <xref:System.AppDomainSetup> associé à cette instance.  
  
 Pour plus d’informations sur les clichés instantanés, consultez [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Cette méthode est désormais obsolète et ne doit pas être utilisée pour tout nouveau développement.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Objet Principal à attacher aux threads.</param>
        <summary>Définit l'objet Principal par défaut à attacher aux threads si ceux-ci tentent d'établir une liaison vers un principal au moment de l'exécution dans ce domaine d'application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre l’effet de l’utilisation de la <xref:System.AppDomain.SetThreadPrincipal%2A> méthode pour modifier l’entité de sécurité qui est disponible pour attacher aux threads qui sont exécutent dans le domaine d’application. Il montre également l’effet sur les threads de l’utilisation de la <xref:System.AppDomain.SetPrincipalPolicy%2A> méthode pour modifier la stratégie principale du domaine d’application.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> est <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">L'entité de sécurité du thread a déjà été définie.</exception>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour la possibilité de manipuler l’objet principal. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les informations de configuration du domaine d'application pour cette instance.</summary>
        <value>Informations d'initialisation du domaine d'application.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une indication précisant si le domaine d'application est configuré pour effectuer un cliché instantané des fichiers.</summary>
        <value>
          <see langword="true" /> si le domaine d'application est configuré pour effectuer un cliché instantané des fichiers ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations, consultez <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> et [clichés instantanés d’assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">L’opération est tentée sur un domaine d’application non chargé.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="rgszNames">Tableau passé des noms à mapper.</param>
        <param name="cNames">Compte des noms à mapper.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les noms.</param>
        <param name="rgDispId">Tableau alloué par l'appelant et recevant les ID qui correspondent aux noms.</param>
        <summary>Mappe un jeu de noms avec un jeu correspondant d'identificateurs de dispatch.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetIDsOfNames`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Informations de type à retourner.</param>
        <param name="lcid">Identificateur des paramètres régionaux pour les informations de type.</param>
        <param name="ppTInfo">Reçoit un pointeur vers l'objet d'informations de type demandé.</param>
        <summary>Récupère les informations de type pour un objet, qui peuvent être utilisées ensuite pour obtenir les informations de type d'une interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfo`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Pointe vers un emplacement qui reçoit le nombre d'interfaces d'informations de type fourni par l'objet.</param>
        <summary>Récupère le nombre d'interfaces d'informations de type fourni par un objet (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::GetTypeInfoCount`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifie le membre.</param>
        <param name="riid">Réservé à un usage ultérieur. Doit être IID_NULL.</param>
        <param name="lcid">Contexte des paramètres régionaux dans lequel interpréter les arguments.</param>
        <param name="wFlags">Indicateurs décrivant le contexte de l'appel.</param>
        <param name="pDispParams">Pointeur vers une structure qui contient un tableau d’arguments, un tableau d’arguments DISPID pour les arguments nommés et le nombre d’éléments de chaque tableau.</param>
        <param name="pVarResult">Pointeur vers l'emplacement où le résultat doit être stocké.</param>
        <param name="pExcepInfo">Pointeur vers une structure qui contient les informations sur les exceptions.</param>
        <param name="puArgErr">Index du premier argument comportant une erreur.</param>
        <summary>Fournit l'accès aux propriétés et aux méthodes exposées par un objet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet d’accéder aux classes managées à partir de code non managé et ne doit pas être appelée à partir du code managé. Pour plus d’informations sur `IDispatch::Invoke`, consultez MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">L’accès à liaison tardive à l’aide de l’interface <c>IDispatch</c> COM n’est pas pris en charge.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtient une représentation sous forme de chaîne qui inclut le nom convivial du domaine d'application et les stratégies de contexte.</summary>
        <returns>Chaîne formée en concaténant la chaîne littérale « Nom : », le nom convivial du domaine d'application, et les représentations sous forme de chaîne des stratégies de contexte ou la chaîne « Aucune stratégie de contexte ».</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant affiche la valeur de retour de la <xref:System.AppDomain.ToString%2A> (méthode).  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Le domaine d'application représenté par le <see cref="T:System.AppDomain" /> en cours a été déchargé.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand la résolution d’un type échoue.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.AppDomain.TypeResolve> événement se produit lorsque le common language runtime ne peut pas déterminer l’assembly qui peut créer le type demandé. Cela peut se produire si le type est défini dans un assembly dynamique, ou le type n’est pas défini dans un assembly dynamique, mais le runtime ne sait pas quel assembly le type est défini dans. Cette dernière situation peut se produire lorsque <xref:System.Type.GetType%2A?displayProperty=nameWithType> est appelée avec un nom de type qui n’est pas qualifié avec le nom de l’assembly.  
  
 Le <xref:System.ResolveEventHandler> pour cet événement peut essayer de localiser et de créer le type.  
  
 Toutefois, le <xref:System.AppDomain.TypeResolve> événement ne se produit pas si le runtime sait qu’il n’est pas possible de trouver un type dans certains assemblys. Par exemple, cet événement n’a pas lieu si le type est introuvable dans un assembly statique, car le runtime sait types ne peuvent pas être ajoutées dynamiquement aux assemblys statiques.  
  
 Compter les [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], le <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriété contient l’assembly qui a demandé le type. Pour plus d'informations, consultez <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <xref:System.Security.SecurityException> est levée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple suivant montre comment le <xref:System.AppDomain.TypeResolve> événement.  
  
 Pour exécuter cet exemple de code, vous devez fournir le nom d’assembly qualifié complet. Pour plus d’informations sur la façon d’obtenir le nom d’assembly qualifié complet, consultez [noms d’assemblys](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit quand une exception n'est pas interceptée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cet événement fournit une notification d’exceptions non interceptées. Il permet à l’application enregistrer des informations relatives à l’exception avant que le gestionnaire par défaut du système signale l’exception à l’utilisateur et met fin à l’application. Si suffisamment d’informations sur l’état de l’application est disponible, les autres actions peuvent être entreprises, telles que l’enregistrement des données de programme pour la récupération ultérieure. Procédez avec prudence, car les données de programme peuvent être endommagées lorsque les exceptions ne sont pas gérées.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, l’arrêt de l’application et les options de débogage sont signalés à l’utilisateur avant que cet événement est déclenché, plutôt qu’après.  
  
 Cet événement peut être géré dans n’importe quel domaine d’application. Toutefois, l’événement n’est pas nécessairement déclenché dans le domaine d’application où l’exception s’est produite. Une exception n’est pas gérée uniquement si la pile entière pour le thread a été déroulée sans trouver un gestionnaire d’exceptions applicable, par conséquent, le premier endroit où que l’événement peut être déclenché est dans le domaine d’application d'où provient le thread.  
  
> [!NOTE]
>  Dans les versions 1.0 et 1.1 du .NET Framework, cet événement se produit uniquement pour le domaine d’application par défaut qui est créé par le système lorsqu’une application est démarrée. Si une application crée des domaines d’application supplémentaires, en spécifiant un délégué pour cet événement dans ces domaines d’application n’a aucun effet.  
  
 Si le <xref:System.AppDomain.UnhandledException> est géré dans le domaine d’application par défaut, il est déclenché à cet emplacement pour toute exception non gérée dans n’importe quel thread, quel que soit le domaine d’application le thread a démarré. Si le thread est démarré dans un domaine d’application qui a un gestionnaire d’événements <xref:System.AppDomain.UnhandledException>, l’événement est déclenché dans ce domaine d’application. Si ce domaine d’application n’est pas le domaine d’application par défaut, et il existe également un gestionnaire d’événements dans le domaine d’application par défaut, l’événement est déclenché dans les deux domaines d’application.  
  
 Par exemple, supposons qu’un thread démarre dans le domaine d’application « AD1 », appelle une méthode dans le domaine d’application « AD2 » et à partir de là appelle une méthode dans le domaine d’application « AD3 », où elle lève une exception. Le premier domaine d’application dans lequel le <xref:System.AppDomain.UnhandledException> peut être déclenché est « AD1 ». Si ce domaine d’application n’est pas le domaine d’application par défaut, l’événement peut également être déclenché dans le domaine d’application par défaut.  
  
> [!NOTE]
>  Le common language runtime interrompt les abandons de thread lors de gestionnaires d’événements pour le <xref:System.AppDomain.UnhandledException> événement en cours d’exécution.  
  
 Si le Gestionnaire d’événements a un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribut avec les indicateurs appropriés, le Gestionnaire d’événements est traité comme une région d’exécution limitée.  
  
 En commençant par le [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], cet événement n’est pas déclenché pour les exceptions qui endommagent l’état du processus, tels que les débordements de pile ou de violations d’accès, sauf si le Gestionnaire d’événements est critique de sécurité et a la <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribut.  
  
 Dans les versions 1.0 et 1.1 du .NET Framework, une exception non gérée se produit dans un thread autre que le thread d’application principal est interceptée par le runtime et par conséquent, n’entraîne pas l’arrêt de l’application. Par conséquent, il est possible pour le <xref:System.AppDomain.UnhandledException> événement sans l’application ne s’arrête. À compter de .NET Framework version 2.0, cette protection pour les exceptions non gérées dans les threads enfants a été supprimée, car l’effet cumulatif de tels échecs silencieux inclus une dégradation des performances, les données endommagées et les blocages, qui étaient difficiles à déboguer. Pour plus d’informations, notamment une liste de cas dans lequel le runtime ne se termine pas, consultez [Exceptions dans les Threads managés](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Pour inscrire un gestionnaire d’événements pour cet événement, vous devez disposer des autorisations requises, ou un <xref:System.Security.SecurityException> est levée.  
  
 Pour plus d'informations sur la gestion des événements, voir [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Autres événements pour les Exceptions non gérées  
 Pour certains modèles d’application, le <xref:System.AppDomain.UnhandledException> événement peut être interrompu par d’autres événements si l’exception non gérée se produit dans le thread principal de l’application.  
  
 Dans les applications qui utilisent des Windows Forms, exceptions non gérées dans la cause du thread principal de l’application le <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> déclenchement d’événement. Si cet événement est géré, le comportement par défaut est que l’exception non gérée n’arrête pas l’application, bien que l’application reste dans un état inconnu. Dans ce cas, le <xref:System.AppDomain.UnhandledException> événement n’est pas déclenché. Ce comportement peut être modifié en utilisant le fichier de configuration d’application, ou à l’aide de la <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> méthode pour modifier le mode à <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> avant le <xref:System.Windows.Forms.Application.ThreadException> raccordé de gestionnaire d’événements. Cela s’applique uniquement au thread principal de l’application. Le <xref:System.AppDomain.UnhandledException> événement est déclenché pour les exceptions non gérées levées dans d’autres threads.  
  
 À partir de Microsoft Visual Studio 2005, l’infrastructure d’application Visual Basic fournit un autre événement pour les exceptions non gérées dans le thread principal de l’application. Consultez le <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> événement. Cet événement a un objet arguments d’événement avec le même nom que l’objet arguments d’événement utilisé par <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, mais avec des propriétés différentes. En particulier, cet objet arguments d’événement a un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> propriété qui permet à l’application à se poursuivre en cours d’exécution, en ignorant l’exception non gérée (et en laissant l’application dans un état inconnu). Dans ce cas, le <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> événement n’est pas déclenché.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.AppDomain.UnhandledException> événement. Il définit un gestionnaire d’événements, `MyHandler`, qui est appelé chaque fois qu’une exception non gérée est levée dans le domaine d’application par défaut. Ensuite, elle génère deux exceptions. La première est gérée par un **try/catch** bloc. La seconde n’est pas gérée et appelle le `MyHandle` routine avant que l’application se termine.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Domaine d'application à décharger.</param>
        <summary>Décharge le domaine d'application spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dans le .NET Framework version 2.0 est un thread dédié pour le déchargement des domaines d’application. Cela améliore la fiabilité, en particulier lorsque le .NET Framework est hébergé. Lorsqu’un thread appelle <xref:System.AppDomain.Unload%2A>, le domaine cible est marqué pour le déchargement. Le thread dédié essaie de décharger le domaine, et tous les threads dans le domaine sont abandonnées. Si un thread n’abandonne pas, par exemple, car l’exécution de code non managé, ou parce qu’il exécute un `finally` bloc, puis après une période de temps un <xref:System.CannotUnloadAppDomainException> est levée dans le thread qui avait initialement appelé <xref:System.AppDomain.Unload%2A>. Si le thread ne peut pas être interrompu finit par se termine, le domaine cible n’est pas déchargé. Par conséquent, dans le .NET Framework version 2.0 `domain` n’est pas garanti pour décharger, car il ne peut pas être possible de terminer l’exécution de threads.  
  
> [!NOTE]
>  Dans certains cas, l’appel <xref:System.AppDomain.Unload%2A> provoque une immédiate <xref:System.CannotUnloadAppDomainException>, par exemple si elle est appelée dans un finaliseur.  
  
 Les threads dans `domain` se terminent à l’aide de la <xref:System.Threading.Thread.Abort%2A> (méthode), qui lève une <xref:System.Threading.ThreadAbortException> dans le thread. Bien que le thread doit se terminer rapidement, il peut continuer à exécuter pour une durée indéterminée dans un `finally` clause.  
  
## <a name="version-compatibility"></a>Compatibilité des versions  
 Dans le .NET Framework version 1.0 et 1.1 si le thread qui appelle <xref:System.AppDomain.Unload%2A> est en cours d’exécution `domain`, un autre thread est démarré pour effectuer l’opération de déchargement. Si `domain` ne peut pas être déchargé, un <xref:System.CannotUnloadAppDomainException> est levée dans ce thread, pas dans le thread d’origine qui a appelé <xref:System.AppDomain.Unload%2A>. Toutefois, si le thread qui appelle <xref:System.AppDomain.Unload%2A> est en cours d’exécution en dehors de `domain`, que le thread reçoit l’exception.  
  
   
  
## Examples  
 L’exemple de code suivant montre comment décharger un domaine d’application.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> est <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">Le <paramref name="domain" /> n'a pas pu être déchargé.</exception>
        <exception cref="T:System.Exception">Une erreur s'est produite pendant le processus de déchargement.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Pour ajouter un gestionnaire d’événements pour cet événement. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Action de sécurité : <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>