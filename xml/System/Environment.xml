<Type Name="Environment" FullName="System.Environment">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d38348c989ef499a53e5ed5e296d99c5bcf72043" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="64996521" /></Metadata><TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit des informations concernant l'environnement et la plateforme actuels, ainsi que des moyens pour les manipuler. Cette classe ne peut pas être héritée.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Environment> classe à récupérer des informations telles que les arguments de ligne de commande, le code de sortie, les paramètres de variable d’environnement, le contenu de la pile des appels, le temps écoulé depuis le dernier démarrage du système ou la version du common language runtime.  
  
   
  
## Examples  
 L’exemple suivant montre affiche une liste d’informations sur l’environnement actuel.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la ligne de commande pour ce processus.</summary>
        <value>Chaîne contenant les arguments de la ligne de commande.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette propriété fournit l’accès pour le nom du programme et tous les arguments spécifiés sur la ligne de commande lorsque le processus actuel a été démarré.  
  
 Le nom du programme peut inclure des informations de chemin d’accès, mais n’est pas nécessaire de le faire. Utilisez le <xref:System.Environment.GetCommandLineArgs%2A> méthode pour récupérer les informations de ligne de commande analysées et stockées dans un tableau de chaînes.  
  
 La taille maximale de la mémoire tampon de ligne de commande n’est pas définie pour un nombre spécifique de caractères ; Il varie selon le système d’exploitation Windows qui s’exécute sur l’ordinateur.  
  
   
  
## Examples  
 L’exemple suivant affiche sa propre ligne de commande.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement PATH. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le chemin qualifié complet du répertoire de travail actif.</summary>
        <value>Chaîne contenant un chemin d'accès au répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Par définition, si ce processus démarre dans le répertoire racine d’une variable locale ou un lecteur réseau, la valeur de cette propriété est le nom du lecteur suivi d’une barre oblique de fin (par exemple, « C:\\»). Si ce processus démarre dans un sous-répertoire, la valeur de cette propriété est le chemin de lecteur et de sous-répertoire, sans barre oblique de fin (par exemple, « C:\mySubDirectory »).  
  
   
  
## Examples  
 L’exemple suivant montre comment définir le <xref:System.Environment.CurrentDirectory%2A> propriété.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tentative de définition d’une chaîne vide ("").</exception>
        <exception cref="T:System.ArgumentNullException">Tentative de définition de la valeur <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">Une erreur d'E/S s'est produite.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Tentative de définition d’un chemin local qui est introuvable.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation requise.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour écrire dans des fichiers ou répertoires dans une opération ensembliste. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même dans une opération get. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un identificateur unique pour le thread managé actuel.</summary>
        <value>Entier représentant un identificateur unique pour ce thread managé.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="exitCode">Code de sortie à retourner au système d’exploitation. Utilisez 0 (zéro) pour indiquer que le processus s'est terminé correctement.</param>
        <summary>Termine ce processus et retourne un code de sortie au système d’exploitation.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour le `exitCode` paramètre, le nombre d’utiliser une différente de zéro pour indiquer une erreur. Dans votre application, vous pouvez définir vos propres codes d’erreur dans une énumération et renvoyer le code d’erreur approprié selon le scénario. Par exemple, retourner une valeur de 1 pour indiquer que le fichier requis n’est pas présent et la valeur 2 pour indiquer que le fichier est dans un format incorrect. Pour obtenir la liste des codes de sortie utilisé par le système d’exploitation Windows, consultez [Codes d’erreurs système](https://msdn.microsoft.com/library/ms681381.aspx) dans la documentation de Windows.  
  
 Appel de la <xref:System.Environment.Exit%2A> méthode diffère de l’utilisation de votre langage de programmation `return` instruction comme suit :  
  
-   <xref:System.Environment.Exit%2A> toujours met fin à une application. À l’aide de la `return` instruction peut mettre fin à une application uniquement si elle sert de point d’entrée de l’application, comme dans le `Main` (méthode).  
  
-   <xref:System.Environment.Exit%2A> termine une application immédiatement, même si d’autres threads sont en cours d’exécution. Si la `return` instruction est appelée dans le point d’entrée de l’application, elle entraîne l’application mettre fin uniquement après que tous les threads de premier plan sont terminés.  
  
-   <xref:System.Environment.Exit%2A> requiert l’appelant est autorisé à appeler du code non managé. Le `return` n’est pas le cas de l’instruction.  
  
-   Si <xref:System.Environment.Exit%2A> est appelée à partir d’un `try` ou `catch` bloquer, le code dans les `finally` bloc ne s’exécute pas. Si le `return` instruction est utilisée, le code dans le `finally` bloc est exécutée.  
  
-   Si <xref:System.Environment.Exit%2A> est appelée lorsque le code dans un [région d’exécution limitée](~/docs/framework/performance/constrained-execution-regions.md) (CER) est en cours d’exécution, la région d’exécution limitée ne sera pas terminé son exécution. Si la `return` instruction est utilisée, la région d’exécution limitée a été exécutée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant ne dispose pas d’autorisations de sécurité suffisantes pour effectuer cette fonction.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">pour avoir la possibilité d’appeler du code non managé. Énumération associée : <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le code de sortie du processus.</summary>
        <value>Entier signé 32 bits contenant le code de sortie. La valeur par défaut est 0 (zéro), qui indique que le processus s'est terminé correctement.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le `Main` retourne de la méthode `void`, vous pouvez utiliser cette propriété pour définir le code de sortie qui sera retourné à l’environnement appelant. Si `Main` ne retourne pas `void`, cette propriété est ignorée. La valeur initiale de cette propriété est égale à zéro.  
  
> [!WARNING]
>  Le <xref:System.Environment.ExitCode%2A> propriété est un entier 32 bits signé. Pour empêcher la propriété de retourner un code de sortie négatif, vous ne devez pas utiliser des valeurs supérieures ou égales à 0 x 80000000.  
  
 Utilisez un nombre différent de zéro pour indiquer une erreur. Dans votre application, vous pouvez définir vos propres codes d’erreur dans une énumération et renvoyer le code d’erreur approprié selon le scénario. Par exemple, retourner une valeur de 1 pour indiquer que le fichier requis n’est pas présent et la valeur 2 pour indiquer que le fichier est dans un format incorrect. Pour obtenir la liste des codes de sortie utilisé par le système d’exploitation Windows, consultez [Codes d’erreurs système](https://msdn.microsoft.com/library/ms681381\(v=vs.85\)) dans la documentation de Windows.  
  
   
  
## Examples  
 Voici une application simple nommée Double.exe qui double la valeur entière passée comme un argument de ligne de commande. La valeur affecte les codes d’erreur à la <xref:System.Environment.ExitCode%2A> propriété pour indiquer les conditions d’erreur. Notez que vous devez ajouter une référence à l’assembly System.Numerics.dll pour compiler l’exemple.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 L’exemple peut ensuite être appelé à partir d’un fichier de commandes telles que la commande suivante, ce qui rend ses codes d’erreur accessible à l’aide de la `ERRORLEVEL` commande.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 L’exemple suivant montre un exemple de sortie produite en appelant le fichier de commandes.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Notez que le code de Double.exe est identique dans la fonction à l’exemple suivant, à ceci près que l’ancienne base de données définit un point d’entrée nommé `Main` qui n’a aucune valeur de retour, alors que cet exemple définit un point d’entrée nommé `Main` qui retourne un entier.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">Chaîne contenant les noms d'aucune ou plusieurs variables d'environnement. Chaque variable d'environnement est citée avec le signe de pourcentage (%).</param>
        <summary>Remplace le nom de chaque variable d'environnement incorporée dans la chaîne spécifiée par la chaîne équivalente de la valeur de la variable, puis retourne la chaîne qui en résulte.</summary>
        <returns>Chaîne avec chaque variable d'environnement remplacée par sa valeur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Interopérabilité COM permet de récupérer les variables d’environnement du système d’exploitation. Si les variables d’environnement ne peut pas être récupérées en raison d’une erreur COM, la valeur HRESULT qui explique la cause de l’échec est utilisé pour générer une des diverses exceptions ; Autrement dit, l’exception dépend de la valeur HRESULT. Pour plus d’informations sur la façon dont le traitement de HRESULT, consultez la section Notes de la <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> (méthode).  
  
 Remplacement se produit uniquement pour les variables d’environnement sont définies. Par exemple, supposons que `name` est « MyENV = % MyENV % ». Si la variable d’environnement MyENV, a la valeur 42, cette méthode retourne « MyENV = 42 ». Si MyENV n’est pas définie, aucune modification n’intervient ; Cette méthode retourne « MyENV = % MyENV % ».  
  
 La taille de la valeur de retour est limitée à 32 Ko.  
  
   
  
## Examples  
 L’exemple suivant montre comment obtenir le lecteur système et les variables de la racine système.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> a la valeur <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Pour pouvoir accéder aux variables d’environnement dans <paramref name="name" />. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Met immédiatement fin à un processus après avoir écrit un message dans le journal des événements des applications Windows, puis inclut le message et les informations sur les exceptions facultatives dans le rapport d'erreurs à Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Message qui explique pourquoi le processus s'est terminé, ou <see langword="null" /> si aucune explication n'est fournie.</param>
        <summary>Met immédiatement fin à un processus après avoir écrit un message dans le journal des événements des applications Windows, puis inclut le message dans le rapport d'erreurs à Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode met fin à un processus sans exécuter n’importe quel actif `try` / `finally` finaliseurs ou les blocs.  
  
 Le <xref:System.Environment.FailFast%2A> méthode écrit le `message` chaîne dans le journal des événements Windows, crée un dump de votre application, puis termine le processus actuel. Le `message` chaîne est également incluse dans le rapport d’erreurs à Microsoft.  
  
 Utilisez le <xref:System.Environment.FailFast%2A> méthode au lieu du <xref:System.Environment.Exit%2A> méthode pour mettre fin à votre application si l’état de votre application est irréparable et l’exécution de votre application `try` / `finally` finaliseurs et ces blocs endommagera les ressources du programme.  
  
 À l’aide de rapport d’erreurs Windows, les informations sont signalées à Microsoft. Pour plus d’informations, consultez [rapport d’erreurs Windows : Mise en route](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 L’exemple suivant écrit une entrée de journal dans le journal des événements Windows et met fin au processus actuel.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="exception" Type="System.Exception" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">Message qui explique pourquoi le processus s'est terminé, ou <see langword="null" /> si aucune explication n'est fournie.</param>
        <param name="exception">Exception qui représente l'erreur à l'origine de l'arrêt. Il s'agit en général de l'exception dans un bloc <see langword="catch" />.</param>
        <summary>Met immédiatement fin à un processus après avoir écrit un message dans le journal des événements des applications Windows, puis inclut le message et les informations sur les exceptions dans le rapport d'erreurs à Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode met fin au processus sans exécuter n’importe quel actif `try` / `finally` finaliseurs ou les blocs.  
  
 Le <xref:System.Environment.FailFast%2A> méthode écrit le `message` chaîne dans le journal des événements Windows, crée un dump de votre application, puis termine le processus actuel.  
  
 À l’aide de rapport d’erreurs Windows, les informations sont signalées à Microsoft. Pour plus d’informations, consultez [rapport d’erreurs Windows : Mise en route](https://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Rapport d’erreurs à Microsoft inclut `message` et `exception` plus d’informations, qui fournit des détails permet de classifier l’erreur. Bien que `exception` est ne pas géré, car le processus est arrêté, les informations contextuelles qui a déclenché l’exception sont encore obtenues.  
  
 Si `exception` est `null`, ou si `exception` est ne pas levée, cette méthode fonctionne comme le <xref:System.Environment.FailFast%28System.String%29> surcharge de méthode.  
  
 Utilisez le <xref:System.Environment.FailFast%2A> méthode au lieu du <xref:System.Environment.Exit%2A> méthode pour mettre fin à votre application si l’état de votre application est irréparable et l’exécution de votre application `try` / `finally` finaliseurs et ces blocs endommagera les ressources du programme.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requiert une confiance totale pour l’appelant immédiat. Ce membre ne peut pas être utilisé par le code de confiance partielle ou transparent.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau de chaînes contenant les arguments de la ligne de commande pour le processus en cours.</summary>
        <returns>Un tableau de chaînes où chaque élément contient un argument de ligne de commande. Le premier élément est le nom du fichier exécutable et les éventuels éléments suivants contiennent les arguments de la ligne de commande restants.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le premier élément du tableau contient le nom de fichier du programme en cours d’exécution. Si le nom de fichier n’est pas disponible, le premier élément est égal à <xref:System.String.Empty?displayProperty=nameWithType>. Les éléments restants comportent des jetons supplémentaires entrés sur la ligne de commande.  
  
 Le nom de fichier du programme peut, mais n’est pas nécessaire pour inclure des informations de chemin d’accès.  
  
 Arguments de ligne de commande sont délimitées par des espaces. Vous pouvez utiliser des guillemets doubles (") pour inclure des espaces dans un argument. Le guillemet-apostrophe ('), toutefois, ne fournit pas de cette fonctionnalité.  
  
 Si un guillemet double suit deux ou un nombre pair de barres obliques inverses, chaque paire de barre oblique inverse continuer est remplacé par une barre oblique inverse et le guillemet double est supprimé. Si un guillemet double suit un nombre impair de barres obliques inverses, y compris un seul, chaque paire précédente est remplacée par une barre oblique inverse et la barre oblique inverse restante est supprimée ; Toutefois, dans ce cas le guillemet double n’est pas supprimé.  
  
 Le tableau suivant indique comment les arguments de ligne de commande peuvent être délimités et suppose `MyApp` que l’application en cours d’exécution actuelle.  
  
|Entrée à la ligne de commande|Arguments de ligne de commande qui en résulte|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Pour obtenir la ligne de commande sous forme de chaîne unique, utilisez le <xref:System.Environment.CommandLine%2A> propriété.  
  
   
  
## Examples  
 L’exemple suivant affiche les arguments de ligne de commande de l’application.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Le système ne prend pas en charge les arguments de ligne de commande.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement PATH. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Extrait la valeur d'une variable d'environnement.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nom de la variable d'environnement.</param>
        <summary>Récupère la valeur d'une variable d'environnement du processus en cours.</summary>
        <returns>La valeur de la variable d'environnement spécifiée par <paramref name="variable" />, ou <see langword="null" /> si la variable d'environnement n'est pas trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Le <xref:System.Environment.GetEnvironmentVariable%28System.String%29> méthode récupère une variable d’environnement à partir du bloc d’environnement du processus en cours uniquement. Il équivaut à appeler le <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. 

Pour récupérer toutes les variables d’environnement, ainsi que leurs valeurs, appelez le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
Noms de variables d’environnement respectent la casse sur Linux et macOS, mais ne respectent pas la casse sur Windows.  
 
### <a name="on-windows-systems"></a>Sur les systèmes Windows

 Sur les systèmes Windows, le bloc d’environnement du processus actif inclut :
 
- Toutes les variables d’environnement qui sont fournis par le processus parent qui l’a créée. Par exemple, une application .NET lancée à partir d’une fenêtre de console hérite de toutes les variables d’environnement de la fenêtre de console. 

  S’il n’existe aucun processus parent, les variables d’environnement par ordinateur et par utilisateur sont utilisés à la place. Par exemple, une nouvelle fenêtre de console a toutes les variables d’environnement par ordinateur et par utilisateur définies au moment de que son lancement.

- Les variables ajoutées au bloc de processus tandis que le processus est en cours d’exécution en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Ces variables d’environnement persistent jusqu'à ce que l’application .NET se termine.  
  
Si les variables d’environnement sont créés une fois que le processus a démarré, vous pouvez utiliser cette méthode pour récupérer uniquement les variables qui ont été créés en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Sur macOS et Linux

Sur macOS et Linux, le bloc d’environnement de la processus actuel inclut les variables d’environnement suivantes :

- Toutes les variables d’environnement qui sont fournis par le processus parent qui l’a créée. Pour les applications .NET lancées à partir d’un interpréteur de commandes, cela inclut toutes les variables d’environnement définies dans l’interpréteur de commandes.

- Les variables ajoutées au bloc de processus tandis que le processus est en cours d’exécution en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Ces variables d’environnement persistent jusqu'à ce que l’application .NET se termine.  

.NET core sur macOS et Linux ne prend pas en charge les variables d’environnement par ordinateur ou par utilisateur.   
  
## Examples  
 L’exemple suivant utilise le <xref:System.Environment.GetEnvironmentVariable%2A> méthode pour récupérer le `windir` variable d’environnement, qui contient le chemin d’accès du répertoire Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 L’exemple suivant tente de récupérer la valeur d’une variable d’environnement nommée `Test1` à partir du bloc d’environnement de processus. Si la variable n’existe pas, l’exemple crée ses et récupère sa valeur. L’exemple affiche la valeur de la variable. Si l’exemple créé la variable, il appelle également la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> méthode avec chaque membre de la <xref:System.EnvironmentVariableTarget> énumération pour établir que la variable peut être extraites uniquement le bloc d’environnement de processus en cours. Enfin, si l’exemple créé la variable, il la supprime.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire la valeur de <paramref name="variable" />. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nom d'une variable d'environnement.</param>
        <param name="target">Une des valeurs de <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Récupère la valeur d'une variable d'environnement du processus en cours ou de la clé de Registre du système d'exploitation Windows pour l'utilisateur ou l'ordinateur local actuel.</summary>
        <returns>La valeur de la variable d'environnement spécifiée par les paramètres <paramref name="variable" /> et <paramref name="target" />, ou <see langword="null" /> si la variable d'environnement n'est pas trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks 

Pour récupérer toutes les variables d’environnement, ainsi que leurs valeurs, appelez le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
Noms de variables d’environnement respectent la casse sur Linux et macOS, mais ne respectent pas la casse sur Windows. 

### <a name="on-windows-systems"></a>Sur les systèmes Windows

Sur Windows, le `target` paramètre spécifie si la variable d’environnement est récupérée à partir du processus en cours ou à partir de la clé de Registre du système d’exploitation Windows pour l’utilisateur actuel ou l’ordinateur local. Toutes les variables d’environnement par utilisateur et par ordinateur sont automatiquement copiés dans le bloc d’environnement du processus en cours, comme le sont les autres variables d’environnement qui sont disponibles pour le processus parent qui a créé le processus de .NET. Toutefois, les variables d’environnement ajouté uniquement pour le bloc d’environnement du processus en cours en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> persistent uniquement pendant la durée du processus.  
  
### <a name="on-macos-and-linux-systems"></a>Sur macOS et Linux

Sur macOS et Linux, le `GetEnvironmentVariable(String, EnvironmentVariableTarget)` prend en charge de la méthode un `target` valeur <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> uniquement. Appels avec un `target` valeur <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> ou <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ne sont pas prises en charge et retourner `null`. 

Variables d’environnement de chaque processus sont :

- Ceux héritent du processus parent, en général, l’interpréteur de commandes utilisée pour appeler `dotnet.exe` ou pour lancer l’application .NET.

- Ceux définis par un appel le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Ces variables d’environnement persistent uniquement jusqu'à la `dotnet` met fin à l’application .NET ou un processus.   
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour les cibles de processus, utilisateur et ordinateur, vérifie si le Registre du système d’exploitation contient les variables d’environnement utilisateur et ordinateur, puis supprime les variables d’environnement.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> n’est pas une valeur de <see cref="T:System.EnvironmentVariableTarget" /> valide.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire la valeur de <paramref name="variable" /> si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Process" /> (énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
ou 
pour un accès complet aux variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.User" /> ou <see cref="F:System.EnvironmentVariableTarget.Machine" /> (énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère tous les noms des variables d'environnement et leurs valeurs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère tous les noms des variables d'environnement et leurs valeurs à partir du processus en cours.</summary>
        <returns>Dictionnaire qui contient tous les noms des variables d'environnement et leurs valeurs ; sinon, un dictionnaire vide si aucune variable d'environnement n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les noms et valeurs pour les variables d’environnement sont stockés sous forme de paires clé-valeur dans la liste retournée <xref:System.Collections.IDictionary>.  
  
### <a name="on-windows-systems"></a>Sur les systèmes Windows

Sur les systèmes Windows, le `GetEnvironmentVariables` méthode retourne les variables d’environnement suivantes :
  
- Toutes les machine variables d’environnement qui sont définis au moment que le processus est créé, ainsi que leurs valeurs.  
  
- Toutes les variables d’environnement par l’utilisateur qui sont définies au moment où le processus est créé, ainsi que leurs valeurs.  

- Toutes les variables hérités du processus parent à partir duquel l’application .NET a été lancée ou ajoutée au bloc de processus pendant que le processus est en cours d’exécution. Variables d’environnement sont ajoutés pendant le processus est en cours d’exécution en appelant le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> méthode ou le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec un `target` valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  

### <a name="on-macos-and-linux-systems"></a>Sur macOS et Linux

Sur MacOS et Linux, le `GetEnvironmentVariables` méthode récupère le nom et la valeur des variables d’environnement qui sont hérités du processus parent qui a lancé la `dotnet` processus ou qui sont définis dans l’étendue de la `dotnet` traiter lui-même. Une fois la `dotnet` processus se termine, ces variables d’environnement de ce dernier cesse d’exister. 

.NET core ne prend pas en charge les variables d’environnement par ordinateur ou par utilisateur.   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.GetEnvironmentVariables%2A> (méthode).  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération.</exception>
        <exception cref="T:System.OutOfMemoryException">La mémoire tampon est insuffisante.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire les noms et valeurs des variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="target">Une des valeurs de <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Récupère tous les noms des variables d'environnement et leurs valeurs à partir du processus en cours, ou depuis la clé de Registre du système d'exploitation Windows pour l'utilisateur ou l'ordinateur local actuel.</summary>
        <returns>Dictionnaire qui contient tous les noms des variables d'environnement et leurs valeurs à partir de la source spécifiée par le paramètre <paramref name="target" /> ; sinon, un dictionnaire vide si aucune variable d'environnement n'est trouvée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Les noms et valeurs des variables d’environnement sont stockés sous forme de paires clé/valeur dans la liste retournée <xref:System.Collections.IDictionary> objet.  

### <a name="on-windows-systems"></a>Sur les systèmes Windows

Sur les systèmes Windows, le `target` paramètre spécifie si la source est le processus en cours, la clé de Registre pour l’utilisateur actuel ou la clé de Registre pour l’ordinateur local.  

### <a name="on-macos-and-linux-systems"></a>Sur macOS et Linux

Sur macOS et Linux, uniquement un `target` valeur <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> est pris en charge. Variables d’environnement du processus sont hérités du processus parent (généralement l’interpréteur de commandes) utilisé pour lancer le `dotnet` traiter ou sont définis dans l’étendue de la `dotnet` traiter lui-même. Une fois le processus dotnet se termine, ces variables d’environnement de ce dernier cessent d’exister.  

Variables d’environnement par ordinateur et par utilisateur ne sont pas pris en charge. Un `target` valeur <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> ou <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> retourne un tableau vide.
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour les cibles de processus, utilisateur et ordinateur, vérifie si le Registre du système d’exploitation contient les variables d’environnement utilisateur et ordinateur, puis supprime les variables d’environnement.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération pour la valeur spécifiée de <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> contient une valeur non conforme.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour la capacité à lire les noms et valeurs des variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Process" /> (énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), 
ou 
pour un accès complet aux variables d’environnement si <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.User" /> ou <see cref="F:System.EnvironmentVariableTarget.Machine" /> (énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtient le chemin d'accès au dossier spécial du système identifié par l'énumération spécifiée.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Une des valeurs d’énumération identifiant un dossier spécial du système.</param>
        <summary>Obtient le chemin d'accès au dossier spécial du système identifié par l'énumération spécifiée.</summary>
        <returns>Chemin d'accès au dossier spécial du système spécifié, si ce dossier existe physiquement sur votre ordinateur ; sinon, chaîne vide ("").  
  
Un dossier n'existe pas physiquement s'il n'a pas été créé par le système d'exploitation, si le dossier existant a été supprimé ou s'il s'agit d'un dossier virtuel, tel que « Poste de travail », auquel ne correspond aucun chemin d'accès physique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode récupère le chemin d’accès à un dossier spécial du système, tel que Program Files, de programmes, de système ou de démarrage, ce qui peut être utilisé pour accéder aux informations courantes. Dossiers spéciaux sont définis par défaut par le système, ou explicitement par l’utilisateur, lors de l’installation d’une version de Windows.  
  
 Le `folder` paramètre désigne le dossier spécial pour récupérer et doit être une des valeurs dans le <xref:System.Environment.SpecialFolder> énumération ; aucun autre valeur lève une exception.  
  
 Pour plus d’informations sur les dossiers spéciaux, consultez la [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) rubrique de valeurs.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Environment.GetFolderPath%2A> méthode pour retourner et afficher le chemin d’accès associé à le `folder` paramètre.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> n’est pas membre de <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle n’est pas prise en charge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="folder">Une des valeurs d’énumération identifiant un dossier spécial du système.</param>
        <param name="option">Une des valeurs d’énumération spécifiant les options à utiliser pour accéder à un dossier spécial.</param>
        <summary>Obtient le chemin d'accès au dossier spécial du système identifié par l'énumération spécifiée et utilise une option spécifiée pour l'accès aux dossiers spéciaux.</summary>
        <returns>Chemin d'accès au dossier spécial du système spécifié, si ce dossier existe physiquement sur votre ordinateur ; sinon, chaîne vide ("").  
  
Un dossier n'existe pas physiquement s'il n'a pas été créé par le système d'exploitation, si le dossier existant a été supprimé ou s'il s'agit d'un dossier virtuel, tel que « Poste de travail », auquel ne correspond aucun chemin d'accès physique.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode récupère le chemin d’accès à un dossier spécial du système, tel que Program Files, de programmes, de système ou de démarrage, ce qui peut être utilisé pour accéder aux informations courantes. Dossiers spéciaux sont définis par défaut par le système, ou explicitement par l’utilisateur, lors de l’installation d’une version de Windows.  
  
 Le `folder` paramètre désigne le dossier spécial pour récupérer et doit être une des valeurs dans le <xref:System.Environment.SpecialFolder> énumération ; aucun autre valeur lève une exception.  
  
 Pour plus d’informations sur les dossiers spéciaux, consultez la [CSIDL](https://go.microsoft.com/fwlink/?LinkId=116664) rubrique de valeurs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="folder" /> n’est pas membre de <see cref="T:System.Environment.SpecialFolder" />
ou

<paramref name="options" /> n’est pas membre de <see cref="T:System.Environment.SpecialFolderOption" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">La plateforme actuelle n’est pas prise en charge.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne un tableau de chaînes contenant les noms des lecteurs logiques de l'ordinateur actuel.</summary>
        <returns>Tableau de chaînes où chaque élément contient le nom d'un lecteur logique. Par exemple, si le disque dur de l’ordinateur est le premier lecteur logique, le premier élément retourné est « C:\\ ».</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment afficher les lecteurs logiques de l’ordinateur actuel en utilisant le <xref:System.Environment.GetLogicalDrives%2A> (méthode).  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Une erreur d’E/S se produit.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas les autorisations requises.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par cette autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le déchargement du domaine d'application actuel est en cours ou si le Common Language Runtime s'arrête.</summary>
        <value><see langword="true" /> Si le domaine d’application actuel est en cours de déchargement ou le CLR s’arrête ; Sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **.NET framework uniquement**: Lorsque le CLR décharge un domaine d’application, elle exécute des finaliseurs sur tous les objets qui ont une méthode de finaliseur dans ce domaine d’application. Lorsque le CLR s’arrête, il démarre le thread finaliseur sur tous les objets qui ont une méthode de finaliseur. Le <xref:System.Environment.HasShutdownStarted%2A> propriété retourne `true` uniquement une fois que le thread finaliseur a été démarré. Lorsque la propriété retourne `true`, vous pouvez déterminer si un domaine d’application est déchargé ou que le CLR lui-même s’arrête en appelant le <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> (méthode). Cette méthode retourne `true` si les finaliseurs sont appelés, car le déchargement du domaine d’application est en cours ou `false` si le CLR s’arrête.  
  
 Le <xref:System.Environment.HasShutdownStarted%2A> retourne de la propriété `false` si le thread finaliseur n’a pas été démarré.  
  
 À l’aide de cette propriété, vous pouvez déterminer s’il faut accéder à des variables statiques dans votre code de finalisation. Si un domaine d’application ou le CLR s’arrête, vous ne pouvez pas accéder de manière fiable n’importe quel objet qui a une méthode de finalisation et qui est référencé par un champ statique. Il s’agit, car ces objets peuvent avoir déjà été finalisées.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si le système d'exploitation actuel est un système d'exploitation 64 bits.</summary>
        <value><see langword="true" /> s'il s'agit d'un système d'exploitation 64 bits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Détermine si le processus actuel est un processus 64 bits.</summary>
        <value><see langword="true" /> s'il s'agit d'un processus 64 bits ; sinon, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom NetBIOS de cet ordinateur local.</summary>
        <value>Chaîne contenant le nom de cet ordinateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le nom de cet ordinateur est établi au démarrage du système lorsque le nom est lu à partir du Registre. Si cet ordinateur est un nœud dans un cluster, le nom du nœud est retourné.  
  
   
  
## Examples  
 L’exemple suivant affiche le nom de l’ordinateur qui exécute l’exemple de code. (Le nom de l’ordinateur est omis de l’exemple de sortie pour des raisons de sécurité.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Impossible d’obtenir le nom de cet ordinateur.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement COMPUTERNAME. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la chaîne de saut de ligne définie pour cet environnement.</summary>
        <value>Chaîne contenant « \r\n » pour les plateformes non-Unix, ou une chaîne contenant « \n » pour les plateformes Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de propriété <xref:System.Environment.NewLine%2A> est une constante personnalisée spécifiquement pour la plateforme actuelle et l’implémentation du .NET Framework. Pour plus d’informations sur les caractères d’échappement dans la valeur de propriété, consultez [caractères d’échappement](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 La fonctionnalité fournie par <xref:System.Environment.NewLine%2A> est souvent qu’entend-on par les termes du contrat de saut de ligne, saut de ligne, saut de ligne, retour chariot, CRLF et fin de ligne.  
  
 <xref:System.Environment.NewLine%2A> peut être utilisé conjointement avec prise en charge de saut de ligne spécifiques au langage telles que les caractères d’échappement '\r' et '\n' en Microsoft c# et C/C++, ou `vbCrLf` dans Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> est ajouté automatiquement au texte traité par le <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> et <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> méthodes.  
  
   
  
## Examples  
 L’exemple suivant affiche trois lignes séparées par des sauts de ligne.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.OperatingSystem" /> qui contient l'identificateur et le numéro de version de la plateforme actuelle.</summary>
        <value>Objet qui contient l'identificateur et le numéro de version de la plateforme.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Le `Environment.OSVersion` propriété ne fournit pas de manière fiable pour identifier le système d’exploitation et sa version. Par conséquent, nous déconseillons que vous utilisez cette méthode. Au lieu de cela : 

- Pour identifier la plateforme de système d’exploitation, utilisez le <xref:System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform%2A?displayProperty=nameWithType> (méthode). 

- Évitez d’écrire du code qui dépend d’une version du système d’exploitation signalées. Au lieu de cela, vérifiez la disponibilité des fonctionnalités dont votre application a besoin.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Cette propriété n’a pas pu obtenir la version du système.  
  
ou 
L’identificateur de plateforme obtenu n’est pas membre de <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de processeurs de l'ordinateur actuel.</summary>
        <value>Entier signé 32 bits qui spécifie le nombre de processeurs de l'ordinateur actuel. Il n'y a pas de valeur par défaut. Si l'ordinateur actuel contient plusieurs groupes de processeurs, cette propriété retourne le nombre de processeurs logiques disponibles pour le Common Language Runtime (CLR).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour plus d’informations sur les groupes de processeurs et les processeurs logiques, consultez [groupes de processeurs](https://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.ProcessorCount%2A> propriété.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée, modifie ou supprime une variable d'environnement.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="variable">Nom d'une variable d'environnement.</param>
        <param name="value">Valeur à assigner à <paramref name="variable" />.</param>
        <summary>Crée, modifie ou supprime une variable d'environnement stockée dans le processus en cours.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appel de cette méthode équivaut à appeler le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> surcharge avec une valeur de <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> pour le `target` argument.  
  
 Si le `value` argument n’est pas vide (voir la discussion de la suppression d’une variable d’environnement plus loin dans cette section pour la définition d’une valeur vide) et la variable d’environnement nommée par le `variable` paramètre n’existe pas, l’environnement variable est créée et reçoit le contenu de `value`. S’il n’existe pas, sa valeur est modifiée. Étant donné que la variable d’environnement est définie dans le bloc d’environnement du processus actuel uniquement, il ne conserve pas une fois que le processus s’est terminée.  
  
 Si `variable` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont considérés comme le nom de variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont affectés à la variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` est vide et la variable d’environnement nommée par `variable` existe, la variable d’environnement est supprimée. Si `variable` n’existe pas, aucune erreur ne se produit même si l’opération ne peut pas être exécutée. `value` est considéré comme vide si l’une des conditions suivantes :  
  
-   Il est `null`.  
  
-   Il est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il se compose d’un seul caractère dont la valeur est U + 0000.  
  
   
  
## Examples  
 L’exemple suivant teste si une variable d’environnement nommée `APPDOMAIN` existe dans le processus en cours. Si elle n’est pas le cas, il crée et définit sa valeur sur « True ». Si la valeur de la `APPDOMAIN` variable d’environnement est « True », elle appelle le `Message.Display` méthode dans un nouveau domaine d’application. Sinon, il exécute la `Message.Display` méthode dans le domaine d’application actuel.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 Si vous exécutez l’exemple pour la première fois, le message « En cours d’exécution dans le domaine domaine2 » s’affiche dans la console. Si vous définissez la variable d’environnement à partir de la ligne de commande à l’aide de la commande :  
  
 `Set AppDomain=False`  
  
 l’exemple affiche le message « l’exécution dans le domaine *nom-exe*.exe », où *nom-exe* est le nom de l’exécutable.  
  
 L’exemple suivant tente de récupérer la valeur d’une variable d’environnement nommée `Test1` à partir du bloc d’environnement de processus. Si la variable n’existe pas, l’exemple crée la variable et récupère sa valeur. L’exemple affiche la valeur de la variable. Si l’exemple créé la variable, il appelle également la <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> méthode avec chaque membre de la <xref:System.EnvironmentVariableTarget> énumération pour établir que la variable peut être extraites uniquement le bloc d’environnement de processus en cours. Enfin, si l’exemple créé la variable, il la supprime.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> contient une chaîne de longueur nulle, un caractère zéro hexadécimal initial (0x00) ou un signe égal (« = »).  
  
ou 
La longueur de <paramref name="variable" /> ou <paramref name="value" /> est supérieure ou égale à 32 767 caractères.  
  
ou 
Une erreur s’est produite lors de l’exécution de cette opération.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet aux variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="variable">Nom d'une variable d'environnement.</param>
        <param name="value">Valeur à assigner à <paramref name="variable" />.</param>
        <param name="target">Une des valeurs d'énumération qui spécifie l'emplacement de la variable d'environnement.</param>
        <summary>Crée, modifie ou supprime une variable d'environnement stockée dans le processus en cours ou dans la clé de Registre du système d'exploitation Windows réservée pour l'utilisateur ou l'ordinateur local actuel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode vous permet de définir une variable d’environnement qui est disponible pour le processus en cours (la <xref:System.EnvironmentVariableTarget.Process> valeur). Variables d’environnement qui sont uniques pour le bloc d’environnement de processus en cours persistent uniquement jusqu'à ce que le processus se termine.

En outre, sur les systèmes Windows uniquement, le <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode vous permet de définir une variable d’environnement qui est disponible pour tous les processus qui s’exécutent sur un ordinateur (le <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> valeur) et à tous les processus exécutés par un utilisateur (le <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> valeur). Variables d’environnement par ordinateur et par utilisateur sont copiés dans le bloc d’environnement du processus en cours.  
 
Sur .NET Core sur macOS et les systèmes Linux, les appels à la <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> méthode avec la valeur <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> ou <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> sont ignorés. 
  
 Si le `value` argument n’est pas vide (voir la discussion de la suppression d’une variable d’environnement plus loin dans cette section pour la définition d’une valeur vide) et la variable d’environnement nommée par le `variable` argument n’existe pas, l’environnement variable est créée et reçoit le contenu de `value`.  S’il n’existe pas, sa valeur est modifiée.  
  
 Si `variable` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont considérés comme le nom de variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` contient un non initiale zéro caractère hexadécimal, les caractères avant le caractère zéro sont affectés à la variable d’environnement et tous les caractères suivants sont ignorés.  
  
 Si `value` est vide et la variable d’environnement nommée par `variable` existe, la variable d’environnement est supprimée. `value` est considéré comme vide si l’une des conditions suivantes :  
  
-   Il est `null`.  
  
-   Il est <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Il se compose d’un seul caractère dont la valeur est U + 0000.  
  
 Si `variable` n’existe pas, aucune erreur ne se produit même si l’opération ne peut pas être effectuée. Soyez prudent quand `target` est <xref:System.EnvironmentVariableTarget.Machine>, car vous pouvez supprimer accidentellement une variable d’environnement qui affecte l’ordinateur local entier, et pas seulement le processus en cours ou un utilisateur.  

### <a name="environmentvariabletargetmachine-and-environmentvariabletargetuser-on-windows-systems"></a>EnvironmentVariableTarget.Machine et EnvironmentVariableTarget.User sur les systèmes Windows

Si `target` est <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, la variable d’environnement est stockée dans la clé HKEY_CURRENT_USER\Environment du Registre de l’ordinateur local. Il est également copié dans les instances de l’Explorateur de fichiers qui sont en cours d’exécution en tant que l’utilisateur actuel. La variable d’environnement est ensuite héritée par tous les processus lancés par l’utilisateur à partir de l’Explorateur de fichiers.  
  
 De même, si `target` est <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, la variable d’environnement est stockée dans la clé HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment du Registre de l’ordinateur local. Il est également copié dans toutes les instances de l’Explorateur de fichiers. La variable d’environnement est ensuite héritée par tous les processus qui sont lancées à partir de l’Explorateur de fichiers.  
  
 Si `target` est <xref:System.EnvironmentVariableTarget.User> ou <xref:System.EnvironmentVariableTarget.Machine>, autres applications sont averties de l’opération définie par un Windows `WM_SETTINGCHANGE` message.  
  
 Si `target` est <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> ou <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, il est recommandé que la longueur de `value` être inférieure à 2 048 caractères.  
  
## Examples  
 L’exemple suivant crée des variables d’environnement pour le <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, et <xref:System.EnvironmentVariableTarget.Machine> cible, vérifie si le Registre du système d’exploitation contient les variables d’environnement machine, puis supprime l’environnement variables.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="variable" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="variable" /> contient une chaîne de longueur nulle, un caractère zéro hexadécimal initial (0x00) ou un signe égal (« = »).  
  
ou 
La longueur de <paramref name="variable" /> est supérieure ou égale à 32 767 caractères.  
  
ou 
 <paramref name="target" /> n’est pas membre de l’énumération <see cref="T:System.EnvironmentVariableTarget" />.  
  
ou 
 <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Machine" /> ou <see cref="F:System.EnvironmentVariableTarget.User" />, et la longueur de <paramref name="variable" /> est supérieure ou égale à 255.  
  
ou 
 <paramref name="target" /> est <see cref="F:System.EnvironmentVariableTarget.Process" />, et la longueur de <paramref name="value" /> est supérieure ou égale à 32 767 caractères.  
  
ou 
Une erreur s’est produite lors de l’exécution de cette opération.</exception>
        <exception cref="T:System.Security.SecurityException">L’appelant n’a pas l’autorisation nécessaire pour effectuer cette opération.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet aux variables d’environnement. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient les informations actuelles sur la trace de la pile.</summary>
        <value>Chaîne contenant les informations de trace de la pile. Cette valeur peut être <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.StackTrace%2A> propriété répertorie les appels de méthode dans l’ordre chronologique inverse, autrement dit, l’appel de méthode la plus récente est décrit en premier, et une ligne d’informations de trace de pile est répertoriée pour chaque appel de méthode sur la pile. Toutefois, le <xref:System.Environment.StackTrace%2A> propriété peut ne pas rapporter autant d’appels de méthode comme prévu en raison des transformations de code qui se produisent pendant l’optimisation.  
  
> [!NOTE]
>  Pour obtenir une vue hiérarchique des informations de trace de pile par classe, utilisez la <xref:System.Diagnostics.StackTrace> classe.  
  
 Le <xref:System.Environment.StackTrace%2A> propriété formate les informations de trace de pile pour chaque appel de méthode comme suit :  
  
 « à `FullClassName`.`MethodName` (`MethodParams`) dans `FileName` : ligne `LineNumber` »  
  
 Le littéral « à » est précédé de trois espaces, et que l’intégralité de la sous-chaîne commençant par « in » est omis si les symboles de débogage ne sont pas disponibles. Les espaces réservés, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, et `LineNumber`, sont remplacés par les valeurs réelles et sont définis comme suit :  
  
 FullClassName  
 Le nom complet de la classe, y compris l’espace de noms.  
  
 `MethodName`  
 Nom de la méthode.  
  
 `MethodParams`  
 La liste de paires type/nom de paramètre. Chaque paire est séparée par une virgule («, »). Ces informations sont omises si `MethodName` n’accepte aucun paramètre.  
  
 `FileName`  
 Le nom de la source de fichier où le `MethodName` méthode est déclarée. Ces informations sont omises si les symboles de débogage ne sont pas disponibles.  
  
 `LineNumber`  
 Le numéro de la ligne dans `FileName` qui contient le code source à partir de `MethodName` pour obtenir des instructions qui se trouve sur la pile des appels. Ces informations sont omises si les symboles de débogage ne sont pas disponibles.  
  
 Le <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> chaîne termine à chaque ligne de la trace de pile.  
  
   
  
## Examples  
 L’exemple suivant montre le <xref:System.Environment.StackTrace%2A> propriété.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par l’autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le chemin qualifié complet du répertoire du système.</summary>
        <value>Chaîne contenant un chemin d'accès au répertoire.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un exemple de la valeur retournée est la chaîne « C:\WinNT\System32 ».  
  
   
  
## Examples  
 L’exemple suivant affiche le répertoire système de l’ordinateur qui exécute l’exemple de code. (Le répertoire système est omis de l’exemple de sortie pour des raisons de sécurité.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Pour accéder aux informations dans le chemin d’accès lui-même. Énumération associée : <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'octets figurant dans la page mémoire du système d'exploitation.</summary>
        <value>Nombre d'octets dans la page de mémoire système.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ces informations peuvent être utiles pour déterminer s’il faut utiliser le <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> option lorsque vous travaillez avec des fichiers mappés en mémoire.  
  
 Dans Windows, cette valeur est la `dwPageSize` membre dans le `SYSTEM_INFO` structure.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Pour accéder aux variables d’environnement système et utilisateur. Exception associée : 
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre de millisecondes écoulées depuis le démarrage du système.</summary>
        <value>Entier signé 32 bits contenant la durée écoulée en millisecondes depuis le dernier démarrage de l'ordinateur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La valeur de cette propriété est dérivée de l’horloge système et est stockée comme un entier signé 32 bits. Notez que, car elle est dérivée de l’horloge système, la résolution de la <xref:System.Environment.TickCount%2A> propriété est limitée à la résolution de l’horloge système, qui se trouve généralement dans la plage de 10 à 16 millisecondes.  
  
> [!IMPORTANT]
>  Étant donné que la valeur de la <xref:System.Environment.TickCount%2A> valeur de propriété est un entier signé 32 bits, si le système s’exécute en continu, <xref:System.Environment.TickCount%2A> incrémente de zéro à <xref:System.Int32.MaxValue?displayProperty=nameWithType> pendant environ 24,9 jours, puis atteindre <xref:System.Int32.MinValue?displayProperty=nameWithType>, qui est un nombre négatif, incrémenter puis remettre à zéro pendant les 24,9 jours. Vous pouvez contourner ce problème en appelant le Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) (fonction), ce qui remet à zéro après environ 49,7 jours, ou en appelant le [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) (fonction).  
  
 <xref:System.Environment.TickCount%2A> diffère la <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> propriété, qui est le nombre d’intervalles de 100 nanosecondes écoulés depuis le 1/1/0001 12:00 am.  
  
 Utilisez le <xref:System.DateTime.Now%2A?displayProperty=nameWithType> propriété pour obtenir la date du jour et l’heure sur cet ordinateur.  
  
   
  
## Examples  
 L’exemple suivant montre comment récupérer la plage positive des valeurs retournées par la <xref:System.Environment.TickCount%2A> propriété. Le <xref:System.Environment.TickCount%2A> propriété cycles entre <xref:System.Int32.MinValue?displayProperty=nameWithType>, qui est un nombre négatif, et <xref:System.Int32.MaxValue?displayProperty=nameWithType> tous les 49,8 jours. Cet exemple de code supprime le bit de signe pour produire un nombre non négatif qui alterne entre zéro et <xref:System.Int32.MaxValue> tous les 24,9 jours.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom de domaine réseau associé à l'utilisateur actuel.</summary>
        <value>Nom de domaine réseau associé à l'utilisateur actuel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les informations d’identification du compte de domaine pour un utilisateur sont mis en forme en tant que nom de domaine de l’utilisateur, le «\\' nom d’utilisateur et les caractères. Utilisez le <xref:System.Environment.UserDomainName%2A> propriété pour obtenir le nom de domaine de l’utilisateur sans le nom d’utilisateur et le <xref:System.Environment.UserName%2A> propriété pour obtenir le nom d’utilisateur sans le nom de domaine.  Par exemple, si le nom d’utilisateur et le nom de domaine de l’utilisateur sont CORPORATENETWORK\john, le <xref:System.Environment.UserDomainName%2A> propriété retourne « CORPORATENETWORK ».  
  
 Le <xref:System.Environment.UserDomainName%2A> propriété tente tout d’abord obtenir le composant de nom de domaine du nom de compte Windows pour l’utilisateur actuel. Si cette tentative échoue, cette propriété essaie d’obtenir le nom de domaine associé au nom d’utilisateur fourni par le <xref:System.Environment.UserName%2A> propriété. Si cette tentative échoue, car l’ordinateur hôte n’est pas joint à un domaine, le nom d’ordinateur hôte est retourné.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Le système d’exploitation ne prend pas en charge la récupération du nom de domaine réseau.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de récupérer le nom de domaine réseau.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement USERDOMAIN. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si le processus en cours est exécuté en mode interactif avec l'utilisateur.</summary>
        <value><see langword="true" /> si le processus en cours est exécuté en mode interactif avec l'utilisateur ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Environment.UserInteractive%2A> propriété rapports `false` pour un processus Windows ou un service comme IIS qui s’exécute sans interface utilisateur. Si cette propriété est `false`, ne pas afficher les boîtes de dialogue modales ou boîtes de message, car il n’existe aucune interface utilisateur graphique pour l’utilisateur d’interagir avec.  
  
   
  
## Examples  
 L’exemple suivant affiche si le processus actuel est en cours d’exécution en mode utilisateur interactif.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom d’utilisateur de la personne qui est actuellement connectée au système d’exploitation.</summary>
        <value>Le nom d’utilisateur de la personne qui a ouvert une session le système d’exploitation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser le <xref:System.Environment.UserName%2A> propriété pour identifier l’utilisateur sur le thread actuel, le système et l’application pour des raisons de sécurité ou d’accès. Il peut également servir à personnaliser une application particulière pour chaque utilisateur.  
 
 Sur Windows le <xref:System.Environment.UserName%2A> propriété encapsule un appel vers le Windows [GetUserName](https://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) (fonction). Les informations d’identification du compte de domaine pour un utilisateur sont mis en forme en tant que nom de domaine de l’utilisateur, le «\\' nom d’utilisateur et les caractères. Utilisez le <xref:System.Environment.UserDomainName%2A> propriété pour obtenir le nom de domaine de l’utilisateur et le <xref:System.Environment.UserName%2A> propriété pour obtenir le nom d’utilisateur.  
 
 Sur les plateformes Unix le <xref:System.Environment.UserName%2A> propriété encapsule un appel à la `getpwuid_r` (fonction).
 
 Si une application ASP.NET s’exécute dans un environnement de développement, le <xref:System.Environment.UserName%2A> propriété retourne le nom de l’utilisateur actuel. Dans une application ASP.NET publiée, cette propriété retourne le nom du compte de pool d’applications (par exemple, le pool d’applications par défaut).  
  
   
  
## Examples  
 L’exemple suivant affiche le nom d’utilisateur de la personne qui a démarré le thread actuel.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour l’accès en lecture à la variable d’environnement de nom d’utilisateur. Énumération associée : <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet <see cref="T:System.Version" /> décrivant le numéro principal, le numéro secondaire, le numéro de build et le numéro de révision du Common Language Runtime.</summary>
        <value>Objet qui affiche la version du Common Language Runtime.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pour .NET Framework versions 4, 4.5, 4.5.1 et 4.5.2, la propriété <xref:System.Environment.Version%2A?displayProperty=nameWithType> retourne un objet <xref:System.Version> dont la représentation sous forme de chaîne se présente sous la forme `4.0.30319.xxxxx`. Pour le .NET Framework 4.6 et les versions ultérieures, il présente sous la forme `4.0.30319.42000`.  
  
> [!WARNING]
>  Pour le [!INCLUDE[net_v45](~/includes/net-v45-md.md)] et versions ultérieures, nous déconseillons l’utilisation du <xref:System.Environment.Version%2A> propriété pour détecter la version du runtime ; au lieu de cela, vous pouvez déterminer la version du common language runtime en interrogeant le Registre. Pour plus d'informations, voir [Procédure : pour déterminer les versions du .NET Framework installées](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Pour plus d’informations sur la version du common language runtime est installé avec chaque version du .NET Framework, consultez [Versions et dépendances](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 L’exemple suivant affiche la version du common language runtime. (La version est omise à partir de l’exemple de sortie pour des raisons de sécurité).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la quantité de mémoire physique mappée au contexte du processus.</summary>
        <value>Entier signé 64 bits contenant le nombre d'octets de mémoire physique mappée au contexte du processus.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant affiche la taille de la plage de travail de l’ordinateur qui exécute l’exemple de code.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">pour un accès complet à la ressource protégée par cette autorisation. Énumération associée : <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>