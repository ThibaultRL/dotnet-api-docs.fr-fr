<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ab3de59502fe957363509d5475cd5ab42eaf2dc1" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="fr-FR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39729090" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <TypeSignature Language="F#" Value="type MessageQueue = class&#xA;    inherit Component&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.MessageQueueInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Messaging.MessagingDescription("MessageQueueDesc")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permet d'accéder à une file d'attente sur un serveur Message Queuing.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La technologie Message Queuing permet aux applications en cours d’exécution à des moments différents de communiquer sur des réseaux hétérogènes et les systèmes qui peuvent être temporairement hors connexion. Envoient des applications, de recevoir ou de lire (lire sans supprimer) des messages des files d’attente. Message Queuing est un composant facultatif de [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] et Windows NT et doit être installé séparément.  
  
 Le <xref:System.Messaging.MessageQueue> classe est un wrapper autour de Message Queuing. Il existe plusieurs versions de Message Queuing et à l’aide de la <xref:System.Messaging.MessageQueue> classe peut entraîner un comportement légèrement différent, selon le système d’exploitation que vous utilisez. Pour plus d’informations sur les fonctionnalités spécifiques de chaque version de Message Queuing, consultez la rubrique « Nouveautés dans Message Queuing » dans le SDK de plateforme dans MSDN.  
  
 Le <xref:System.Messaging.MessageQueue> classe fournit une référence à une file d’attente Message Queuing. Vous pouvez spécifier un chemin d’accès dans le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur pour se connecter à une ressource existante, ou vous pouvez créer une file d’attente sur le serveur. Avant de pouvoir appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, vous devez associer la nouvelle instance de la <xref:System.Messaging.MessageQueue> classe avec une file d’attente existante. À ce stade, vous pouvez manipuler les propriétés de la file d’attente comme <xref:System.Messaging.MessageQueue.Category%2A> et <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> prend en charge deux types de récupération des messages : synchrones et asynchrones. Les méthodes synchrones, <xref:System.Messaging.MessageQueue.Peek%2A> et <xref:System.Messaging.MessageQueue.Receive%2A>, provoquer le thread de processus à attendre un intervalle de temps spécifié pour un nouveau message arrive dans la file d’attente. Les méthodes asynchrones, <xref:System.Messaging.MessageQueue.BeginPeek%2A> et <xref:System.Messaging.MessageQueue.BeginReceive%2A>, permettent aux tâches de l’application principale continuer dans un thread distinct, jusqu'à ce qu’un message arrive dans la file d’attente. Ces méthodes fonctionnent à l’aide des objets de rappel et les objets d’état pour communiquer des informations entre les threads.  
  
 Lorsque vous créez une nouvelle instance de la <xref:System.Messaging.MessageQueue> (classe), vous ne créez pas une nouvelle file d’attente Message Queuing. Au lieu de cela, vous pouvez utiliser la <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, et <xref:System.Messaging.MessageQueue.Purge%2A> méthodes pour gérer les files d’attente sur le serveur.  
  
 Contrairement aux <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> et <xref:System.Messaging.MessageQueue.Delete%28System.String%29> sont `static` membres, vous pouvez les appeler sans créer une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe.  
  
 Vous pouvez définir le <xref:System.Messaging.MessageQueue> l’objet <xref:System.Messaging.MessageQueue.Path%2A> propriété avec l’une des trois noms : le nom convivial, le <xref:System.Messaging.MessageQueue.FormatName%2A>, ou le <xref:System.Messaging.MessageQueue.Label%2A>. Le nom convivial, ce qui est défini par la file d’attente <xref:System.Messaging.MessageQueue.MachineName%2A> et <xref:System.Messaging.MessageQueue.QueueName%2A> propriétés, est <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> pour une file d’attente publique, et <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> pour une file d’attente privée. Le <xref:System.Messaging.MessageQueue.FormatName%2A> propriété autorise l’accès hors connexion aux files d’attente de message. Enfin, vous pouvez utiliser la file d’attente <xref:System.Messaging.MessageQueue.Label%2A> propriété à définir la file d’attente <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de <xref:System.Messaging.MessageQueue>, consultez le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur.  
  
   
  
## Examples  
 L’exemple de code suivant crée de nouveaux <xref:System.Messaging.MessageQueue> objets à l’aide de divers types de syntaxe de nom de chemin d’accès. Dans chaque cas, il envoie un message à la file d’attente dont le chemin est défini dans le constructeur.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 L’exemple de code suivant envoie un message à une file d’attente et reçoit un message d’une file d’attente, à l’aide d’une classe spécifique à l’application appelée `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Uniquement la <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> méthode est thread-safe.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" />. Une fois la nouvelle instance initialisée par le constructeur, vous devez définir sa propriété <see cref="P:System.Messaging.MessageQueue.Path" /> avant de pouvoir l'utiliser.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe qui n’est pas immédiatement liée à une file d’attente sur le serveur Message Queuing. Avant d’utiliser cette instance, vous devez le connecter à une file d’attente Message Queuing existante en définissant le <xref:System.Messaging.MessageQueue.Path%2A> propriété. Vous pouvez également définir le <xref:System.Messaging.MessageQueue> font référence à la <xref:System.Messaging.MessageQueue.Create%28System.String%29> valeur de retour de la méthode, créant ainsi une nouvelle file d’attente Message Queuing.  
  
 Le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur instancie une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe ; il ne crée pas une nouvelle file d’attente Message Queuing.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.MessageQueue>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.MessagePropertyFilter> classe. Toutes les valeurs de filtre sont définies sur `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 L’exemple de code suivant crée un nouveau <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" /> qui fait référence à la file d'attente Message Queuing dans le chemin d'accès spécifié.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge lorsque vous souhaitez lier le nouveau <xref:System.Messaging.MessageQueue> instance à une file d’attente Message Queuing particulière, dont vous connaissez le chemin d’accès, le nom de format ou l’étiquette. Si vous souhaitez accorder un accès exclusif à la première application qui fait référence à la file d’attente, vous devez définir le <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriété `true` ou utilisez le constructeur qui passe un paramètre de restriction d’accès en lecture.  
  
 Le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur instancie une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe ; il ne crée pas une nouvelle file d’attente Message Queuing. Pour créer une file d’attente dans Message Queuing, utilisez <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La syntaxe de le `path` paramètre dépend du type de file d’attente il références, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
|File d’attente du journal|`MachineName`\\`QueueName`\\`Journal$`|  
|File d’attente du journal machine|`MachineName`\\`Journal$`|  
|File d’attente de lettres mortes machine|`MachineName`\\`Deadletter$`|  
|File d’attente de lettres mortes transactionnelle machine|`MachineName`\\`XactDeadletter$`|  
  
 Vous pouvez également utiliser le <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> pour décrire le chemin d’accès de la file d’attente, comme indiqué dans le tableau suivant.  
  
|Référence|Syntaxe|Exemple|  
|---------------|------------|-------------|  
|Nom du format|`FormatName:` [ *nom de format* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Ajouter des contrôles|`Label:` [ *étiquette* ]|`Label:` TheLabel|  
  
 Pour travailler hors connexion, vous devez utiliser la syntaxe du nom de format, pas la syntaxe de nom de chemin d’accès pour le constructeur. Sinon, une exception est levée, car le contrôleur de domaine principal n’est pas disponible pour résoudre le chemin d’accès au nom de format.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.MessageQueue>. Ces valeurs sont basées sur les propriétés de la file d’attente Message Queuing avec le chemin d’accès spécifié par le `path` paramètre.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, si le paramètre de niveau de confidentialité du Message Queuing de file d’attente est « Corps » ; Sinon, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|La valeur de propriété de nom d’ordinateur du Message Queuing de file d’attente.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, si ce n’est pas définie par le constructeur.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, si ce n’est pas définie par le constructeur.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, si le paramètre de journal de l’objet Message Queuing est activé ; Sinon, `false`.|  
  
   
  
## Examples  
 L’exemple de code suivant crée de nouveaux <xref:System.Messaging.MessageQueue> objets à l’aide de divers types de syntaxe de nom de chemin d’accès. Dans chaque cas, il envoie un message à la file d’attente dont le chemin est défini dans le constructeur.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'est pas valide ; elle n'a probablement pas été définie.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />. Cela peut correspondre à "." pour l'ordinateur local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> pour accorder un accès en lecture exclusif à la première application qui accède à la file d'attente ; sinon, <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" /> qui fait référence à la file d'attente Message Queuing dans le chemin d'accès et avec la restriction d'accès en lecture spécifiés.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge lorsque vous souhaitez lier le nouveau <xref:System.Messaging.MessageQueue> à une file d’attente Message Queuing particulière, dont vous connaissez le chemin d’accès, le nom de format ou l’étiquette. Si vous souhaitez accorder un accès exclusif à la première application qui fait référence à la file d’attente, définissez la `sharedModeDenyReceive` paramètre `true`. Sinon, la valeur `sharedModeDenyReceive` à `false` ou utilisez le constructeur qui a uniquement un `path` paramètre.  
  
 Paramètre `sharedModeDenyReceive` à `true` affecte tous les objets qui accèdent à la file d’attente Message Queuing, y compris les autres applications. Les effets du paramètre ne sont pas limitées à cette application.  
  
 Le <xref:System.Messaging.MessageQueue.%23ctor%2A> le constructeur crée une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe ; il ne crée pas une nouvelle file d’attente Message Queuing. Pour créer une file d’attente dans Message Queuing, utilisez <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La syntaxe de le `path` paramètre varie selon le type de file d’attente.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
|File d’attente du journal|`MachineName`\\`QueueName`\\`Journal$`|  
|File d’attente du journal machine|`MachineName`\\`Journal$`|  
|File d’attente de lettres mortes machine|`MachineName`\\`Deadletter$`|  
|File d’attente de lettres mortes transactionnelle machine|`MachineName`\\`XactDeadletter$`|  
  
 Vous pouvez également utiliser le nom de format ou l’étiquette d’une file d’attente Message Queuing pour décrire le chemin d’accès de la file d’attente.  
  
|Référence|Syntaxe|Exemple|  
|---------------|------------|-------------|  
|Nom du format|`FormatName:` [ *nom de format* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Ajouter des contrôles|`Label:` [ *étiquette* ]|`Label:` TheLabel|  
  
 Pour travailler hors connexion, vous devez utiliser la syntaxe de nom de format, plutôt que la syntaxe du nom convivial. Sinon, une exception est levée, car le contrôleur de domaine principal (sur lequel Active Directory réside) n’est pas disponible pour résoudre le chemin d’accès au nom de format.  
  
 Si un <xref:System.Messaging.MessageQueue> ouvre une file d’attente avec le `sharedModeDenyReceive` paramètre défini sur `true`, n’importe quel <xref:System.Messaging.MessageQueue> que par la suite tente de lire à partir de la file d’attente génère un <xref:System.Messaging.MessageQueueException> en raison d’une violation de partage. Un <xref:System.Messaging.MessageQueueException> est également levée si un <xref:System.Messaging.MessageQueue> tente d’accéder à la file d’attente en mode exclusif, alors qu’un autre <xref:System.Messaging.MessageQueue> possède déjà un accès non exclusif à la file d’attente.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.MessageQueue>. Ces valeurs sont basées sur les propriétés de la file d’attente Message Queuing, avec le chemin d’accès spécifié par le `path` paramètre.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, si le paramètre de niveau de confidentialité du Message Queuing de file d’attente est « Corps » ; Sinon, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|La valeur de propriété de nom d’ordinateur du Message Queuing de file d’attente.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Les valeurs définies par le constructeur par défaut de la <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, si ce n’est pas définie par le constructeur.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, si ce n’est pas définie par le constructeur.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Valeur du paramètre `sharedModeDenyReceive`.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, si le paramètre de journal de l’objet Message Queuing est activé ; Sinon, `false`.|  
  
   
  
## Examples  
 L’exemple de code suivant crée un nouveau <xref:System.Messaging.MessageQueue> avec un accès exclusif, définit son chemin d’accès et envoie un message à la file d’attente.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'est pas valide ; elle n'a probablement pas été définie.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />. Cela peut correspondre à "." pour l'ordinateur local.</param>
        <param name="accessMode">Une des valeurs de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />. Cela peut correspondre à "." pour l'ordinateur local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> pour accorder un accès en lecture exclusif à la première application qui accède à la file d'attente ; sinon, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> pour créer et utiliser un cache de connexions, sinon <see langword="false" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple de code suivant crée un nouveau <xref:System.Messaging.MessageQueue> avec un accès en lecture exclusif et avec la mise en cache de connexion est activée.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberSignature Language="F#" Value="new System.Messaging.MessageQueue : string * bool * bool * System.Messaging.QueueAccessMode -&gt; System.Messaging.MessageQueue" Usage="new System.Messaging.MessageQueue (path, sharedModeDenyReceive, enableCache, accessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />. Cela peut correspondre à "." pour l'ordinateur local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> pour accorder un accès en lecture exclusif à la première application qui accède à la file d'attente ; sinon, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> pour créer et utiliser un cache de connexions, sinon <see langword="false" />.</param>
        <param name="accessMode">Une des valeurs de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessMode : System.Messaging.QueueAccessMode" Usage="System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique le mode d'accès pour la file d'attente.</summary>
        <value>Une des valeurs de <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le mode d’accès par défaut pour une file d’attente est `QueueAccessMode.SendAndReceive`, sauf indication contraire lors de l’appel du constructeur.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Authenticate : bool with get, set" Usage="System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la file d'attente accepte uniquement les messages authentifiés.</summary>
        <value>
          <see langword="true" /> si la file d'attente accepte uniquement les messages authentifiés ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’authentification de message fournit un moyen de garantir l’intégrité des messages et pour vérifier qui a envoyé le message. Pour demander l’authentification, l’application émettrice définit le niveau d’authentification du message.  
  
 Lorsque vous définissez <xref:System.Messaging.MessageQueue.Authenticate%2A> à `true`, vous pouvez réserver l’accès à la file d’attente sur le serveur, pas uniquement à ce <xref:System.Messaging.MessageQueue> instance. Tous les clients utilisant la même file d’attente Message Queuing seront affectés.  
  
 Une file d’attente accepte uniquement les messages authentifiés rejette un message non authentifié. Pour demander une notification de rejet du message, une application émettrice peut définir le <xref:System.Messaging.Message.AcknowledgeType%2A> propriété du message. Car il n’existe aucune indication de rejet du message, l’application émettrice peut perdre le message, sauf si vous demandez qu’il est envoyé à la file d’attente de lettres mortes.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.Authenticate%2A> propriété.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int16 with get, set" Usage="System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la priorité de base utilisée par Message Queuing pour acheminer les messages d'une file d'attente publique sur le réseau.</summary>
        <value>Priorité de base unique pour tous les messages envoyés à la file d'attente (publique). La valeur par défaut est zéro (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Priorité de base d’une file d’attente message spécifie comment un message en cours de route à cette file d’attente est traitée lorsqu’elles transitent via le réseau. Vous pouvez définir le <xref:System.Messaging.MessageQueue.BasePriority%2A> propriété permet de conférer une priorité supérieure ou inférieure à tous les messages envoyés à la file d’attente spécifiée à celles envoyées aux autres files d’attente. Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification.  
  
 Une file d’attente de message <xref:System.Messaging.MessageQueue.BasePriority%2A> n’est pas lié à la <xref:System.Messaging.Message.Priority%2A> propriété d’un message, qui spécifie l’ordre dans lequel un message entrant est placé dans la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> s’applique uniquement à public files d’attente dont les chemins sont spécifiés en utilisant le nom de format. La priorité de base d’une file d’attente privée est toujours zéro (0).  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.BasePriority%2A> propriété.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la priorité de base est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <summary>Lance une opération de lecture asynchrone en demandant à Message Queuing de commencer la lecture d'un message et d'avertir le gestionnaire d'événements lorsqu'elle aura terminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : unit -&gt; IAsyncResult" Usage="messageQueue.BeginPeek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance une opération de lecture asynchrone n'ayant pas de délai d'attente. L'opération n'est pas terminée tant qu'un message n'est pas disponible dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement lorsqu’un message est disponible dans la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginPeek%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginPeek%2A> lance une opération de lecture asynchrone ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.PeekCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginPeek%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginPeek%2A> est asynchrone, vous pouvez appeler pour lire la file d’attente sans bloquer le thread en cours d’exécution. Pour lire la file d’attente de manière synchrone, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginPeek%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’événement d’achèvement est déclenché, mais une exception sera levée lors de l’appel <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée un gestionnaire d’événements nommé `MyPeekCompleted`, attache à la <xref:System.Messaging.MessageQueue.PeekCompleted> délégué de gestionnaire d’événements et les appels <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour lancer une opération de lecture asynchrone sur la file d’attente qui se trouve dans le chemin d’accès ». \myQueue ». Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché, l’exemple lit le message et écrit son corps à l’écran. L’exemple appelle ensuite <xref:System.Messaging.MessageQueue.BeginPeek%2A> à nouveau pour lancer une nouvelle opération de lecture asynchrone.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginPeek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <summary>Lance une opération de lecture asynchrone ayant un délai d'attente spécifique. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginPeek%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginPeek%2A> lance une opération de lecture asynchrone ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.PeekCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginPeek%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginPeek%2A> est asynchrone, vous pouvez appeler pour lire la file d’attente sans bloquer le thread en cours d’exécution. Pour lire la file d’attente de manière synchrone, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginPeek%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Cette surcharge spécifie un délai d’attente. Si l’intervalle spécifié par le `timeout` paramètre expire, ce composant déclenche le <xref:System.Messaging.MessageQueue.PeekCompleted> événement. Étant donné que n’existe aucun message, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lève une exception.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’événement d’achèvement est déclenché, mais une exception sera levée lors de l’appel <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une opération de lecture asynchrone, en utilisant le chemin d’accès de la file d’attente ». \myQueue ». Il crée un gestionnaire d’événements, `MyPeekCompleted`et l’attache à la <xref:System.Messaging.MessageQueue.PeekCompleted> délégué de gestionnaire d’événements. <xref:System.Messaging.MessageQueue.BeginPeek%2A> est appelée avec un délai d’attente d’une minute, pour lancer l’opération de lecture asynchrone. Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché ou le délai expire, le message est extrait s’il en existe un, et son corps est écrit à l’écran. Puis <xref:System.Messaging.MessageQueue.BeginPeek%2A> est rappelée pour lancer une nouvelle opération de lecture asynchrone avec le même délai d’attente.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="stateObject">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <summary>Lance une opération de lecture asynchrone avec un délai et un objet d'état spécifiés, permettant ainsi de disposer de données associées pendant toute la durée de vie de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Utilisez cette surcharge pour associer à l’opération qui est conservée pendant toute la durée de l’opération. Le Gestionnaire d’événements peut accéder à ces informations en examinant le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> qui est associé à l’opération.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginPeek%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginPeek%2A> lance une opération de lecture asynchrone ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.PeekCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginPeek%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginPeek%2A> est asynchrone, vous pouvez appeler pour lire la file d’attente sans bloquer le thread en cours d’exécution. Pour lire la file d’attente de manière synchrone, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retourne un <xref:System.IAsyncResult> qui identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Cette surcharge spécifie un délai d’attente et un objet d’état. Si l’intervalle spécifié par le `timeout` paramètre expire, ce composant déclenche le <xref:System.Messaging.MessageQueue.PeekCompleted> événement. Étant donné que n’existe aucun message, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lève une exception.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez. Pour obtenir une illustration de ce scénario, consultez la section exemple.  
  
 Vous pouvez également utiliser l’objet d’état pour passer des informations sur les threads de processus. Si un thread est démarré, mais le rappel est sur un thread différent dans un scénario asynchrone, l’objet d’état est marshalé et passé avec les informations à partir de l’événement.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’événement d’achèvement est déclenché, mais une exception sera levée lors de l’appel <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une opération de lecture asynchrone, en utilisant le chemin d’accès de la file d’attente ». \myQueue ». Il crée un gestionnaire d’événements, `MyPeekCompleted`et l’attache à la <xref:System.Messaging.MessageQueue.PeekCompleted> délégué de gestionnaire d’événements. <xref:System.Messaging.MessageQueue.BeginPeek%2A> est appelé, avec un délai d’attente d’une minute. Chaque appel à <xref:System.Messaging.MessageQueue.BeginPeek%2A> a un entier unique qui identifie cette opération spécifique. Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché ou que le délai d’attente expire, le message, s’il en existe, est récupéré et son corps et l’identificateur entier de spécifiques à l’opération sont écrits dans l’écran. Puis <xref:System.Messaging.MessageQueue.BeginPeek%2A> est rappelée pour lancer une nouvelle opération de lecture asynchrone avec le même délai d’attente et l’entier associé à l’opération simplement terminée.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="stateObject">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> qui recevra la notification de la fin de l'opération asynchrone.</param>
        <summary>Lance une opération de lecture asynchrone avec un délai et un objet d'état spécifiés, permettant ainsi de disposer de données associées pendant toute la durée de vie de l'opération. Cette surcharge reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez cette surcharge, le rappel spécifié dans le paramètre de rappel est appelé directement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré ; le <xref:System.Messaging.MessageQueue.PeekCompleted> événement n’est pas déclenché. Les autres surcharges de <xref:System.Messaging.MessageQueue.BeginPeek%2A> s’appuient sur ce composant pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.BeginPeek%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginPeek%2A> est asynchrone, vous pouvez appeler pour lire la file d’attente sans bloquer le thread en cours d’exécution. Pour lire la file d’attente de manière synchrone, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retourne un <xref:System.IAsyncResult> qui identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une opération de lecture asynchrone. L’exemple de code envoie un message à une file d’attente locale, puis appelle <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, en passant : une valeur de délai d’attente de dix secondes, un entier unique qui identifie ce message particulier ; et une nouvelle instance de <xref:System.AsyncCallback> qui identifie le Gestionnaire d’événements `MyPeekCompleted`. Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché, le Gestionnaire d’événements lit le message et écrit le corps du message et l’identificateur de message entier dans l’écran.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginPeek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginPeek (timeout, cursor, action, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <param name="action">Une des valeurs de <see cref="T:System.Messaging.PeekAction" />. Indique s'il faut lire le message en cours dans la file d'attente ou le message suivant.</param>
        <param name="state">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <summary>Initialise une opération de lecture asynchrone qui a un délai d'expiration spécifié et utilise un curseur spécifié, une action de lecture spécifiée et un objet d'état spécifié. L'objet d'état fournit des informations associées pendant la durée de vie de l'opération. Cette surcharge reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez cette surcharge, le rappel spécifié dans le paramètre de rappel est appelé directement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré. Le <xref:System.Messaging.MessageQueue.PeekCompleted> événement n’est pas déclenché. Les autres surcharges de <xref:System.Messaging.MessageQueue.BeginPeek%2A> s’appuient sur ce composant pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.BeginPeek%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginPeek%2A> est asynchrone, vous pouvez appeler pour lire la file d’attente sans bloquer le thread en cours d’exécution. Pour lire la file d’attente de manière synchrone, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Retourne un <xref:System.IAsyncResult> qui identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur autre que <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> a été spécifiée pour le paramètre <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="cursor" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <summary>Lance une opération de réception asynchrone, en demandant à Message Queuing de commencer la réception d'un message et d'avertir le gestionnaire d'événements lorsqu'elle aura terminé.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : unit -&gt; IAsyncResult" Usage="messageQueue.BeginReceive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lance une opération de réception asynchrone n'ayant pas de délai d'attente. L'opération n'est pas terminée tant qu'un message n'est pas disponible dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginReceive%2A> pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement lorsqu’un message a été supprimé de la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginReceive%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginReceive%2A> lance une réception asynchrone une opération ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginReceive%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginReceive%2A> est asynchrone, vous pouvez l’appeler pour recevoir un message à partir de la file d’attente sans bloquer le thread en cours d’exécution. Pour recevoir un message de façon synchrone, utilisez la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginReceive%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’événement d’achèvement est déclenché, mais une exception sera levée lors de l’appel <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 N’utilisez pas l’appel asynchrone <xref:System.Messaging.MessageQueue.BeginReceive%2A> avec des transactions. Si vous souhaitez effectuer une opération asynchrone transactionnelle, appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A>et placez la transaction et (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> méthode dans le Gestionnaire d’événements que vous créez pour l’opération de lecture. Votre gestionnaire d’événements peut contenir des fonctionnalités comme indiqué dans le code c# suivant.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant associe plusieurs demandes asynchrones. Il suppose une file d’attente sur l’ordinateur local, appelé « myQueue ». Le `Main` fonction commence l’opération asynchrone qui est gérée par le `MyReceiveCompleted` routine. `MyReceiveCompleted` traite le message en cours et commence une nouvelle asynchrone opération de réception.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 L’exemple de code suivant files d’attente des demandes asynchrones. L’appel à <xref:System.Messaging.MessageQueue.BeginReceive%2A> utilise le <xref:System.IAsyncResult.AsyncWaitHandle%2A> dans sa valeur de retour. Le `Main` routine attend que toutes les opérations asynchrones être terminés avant de quitter.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan -&gt; IAsyncResult" Usage="messageQueue.BeginReceive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <summary>Lance une opération de réception asynchrone ayant un délai d'attente spécifique. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginReceive%2A> pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginReceive%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginReceive%2A> lance une réception asynchrone une opération ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginReceive%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginReceive%2A> est asynchrone, vous pouvez l’appeler pour recevoir un message à partir de la file d’attente sans bloquer le thread en cours d’exécution. Pour recevoir un message de façon synchrone, utilisez la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’événement d’achèvement est déclenché, mais une exception sera levée lors de l’appel <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginReceive%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Cette surcharge spécifie un délai d’attente. Si l’intervalle spécifié par le `timeout` paramètre expire, ce composant déclenche le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement. Étant donné que n’existe aucun message, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lève une exception.  
  
 N’utilisez pas l’appel asynchrone <xref:System.Messaging.MessageQueue.BeginReceive%2A> avec des transactions. Si vous souhaitez effectuer une opération asynchrone transactionnelle, appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A>et placez la transaction et (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> méthode dans le Gestionnaire d’événements que vous créez pour l’opération de lecture. Votre gestionnaire d’événements peut contenir des fonctionnalités comme indiqué dans le code c# suivant.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une commande asynchrone opération de réception. L’exemple de code crée un gestionnaire d’événements, `MyReceiveCompleted`et l’attache à la <xref:System.Messaging.MessageQueue.ReceiveCompleted> délégué de gestionnaire d’événements. L’exemple de code envoie un message à une file d’attente locale, puis appelle <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, en passant une valeur de délai d’attente de dix secondes. Quand un <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché, le Gestionnaire d’événements reçoit le message et écrit le corps du message à l’écran.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide ; il s'agit probablement d'un nombre négatif.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="stateObject">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <summary>Lance une opération de réception asynchrone avec un délai et un objet d'état spécifiés, permettant ainsi de disposer de données associées pendant toute la durée de vie de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lors du traitement asynchrone, vous utilisez <xref:System.Messaging.MessageQueue.BeginReceive%2A> pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Utilisez cette surcharge pour associer à l’opération qui est conservée pendant toute la durée de l’opération. Le Gestionnaire d’événements peut détecter ces informations en examinant le <xref:System.IAsyncResult.AsyncState%2A> propriété de la <xref:System.IAsyncResult> qui est associé à l’opération.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginReceive%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginReceive%2A> lance une réception asynchrone une opération ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginReceive%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginReceive%2A> est asynchrone, vous pouvez l’appeler pour recevoir un message à partir de la file d’attente sans bloquer le thread en cours d’exécution. Pour recevoir un message de façon synchrone, utilisez la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginReceive%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 Cette surcharge spécifie un délai d’attente et un objet d’état. Si l’intervalle spécifié par le `timeout` paramètre expire, ce composant déclenche le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement. Étant donné que n’existe aucun message, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lève une exception.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginReceive%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez.  
  
 Vous pouvez également utiliser l’objet d’état pour passer des informations sur les threads de processus. Si un thread est démarré, mais le rappel est sur un thread différent dans un scénario asynchrone, l’objet d’état est marshalé et passé avec les informations à partir de l’événement.  
  
 N’utilisez pas l’appel asynchrone <xref:System.Messaging.MessageQueue.BeginReceive%2A> avec des transactions. Si vous souhaitez effectuer une opération asynchrone transactionnelle, appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A>et placez la transaction et (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> méthode dans le Gestionnaire d’événements que vous créez pour l’opération de lecture. Votre gestionnaire d’événements peut contenir des fonctionnalités comme indiqué dans le code c# suivant.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une commande asynchrone opération de réception. L’exemple de code crée un gestionnaire d’événements, `MyReceiveCompleted`et l’attache à la <xref:System.Messaging.MessageQueue.ReceiveCompleted> délégué de gestionnaire d’événements. L’exemple de code envoie un message à une file d’attente locale, puis appelle <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, en passant une valeur de délai d’attente de dix secondes et un entier unique qui identifie ce message particulier. Quand un <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché, le Gestionnaire d’événements reçoit le message et écrit le corps du message et l’identificateur de message entier dans l’écran.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, stateObject, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="stateObject">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> qui recevra la notification de la fin de l'opération asynchrone.</param>
        <summary>Lance une opération de réception asynchrone avec un délai et un objet d'état spécifiés, permettant ainsi de disposer de données associées pendant toute la durée de vie de l'opération. Cette surcharge reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez cette surcharge, le rappel spécifié dans le paramètre de rappel est appelé directement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré ; le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement n’est pas déclenché. Les autres surcharges de <xref:System.Messaging.MessageQueue.BeginReceive%2A> s’appuient sur ce composant pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginReceive%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginReceive%2A> lance une réception asynchrone une opération ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginReceive%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginReceive%2A> est asynchrone, vous pouvez l’appeler pour recevoir un message à partir de la file d’attente sans bloquer le thread en cours d’exécution. Pour recevoir un message de façon synchrone, utilisez la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginReceive%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, vous utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginReceive%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez.  
  
 Vous pouvez également utiliser l’objet d’état pour passer des informations sur les threads de processus. Si un thread est démarré, mais le rappel est sur un thread différent dans un scénario asynchrone, l’objet d’état est marshalé et passé avec les informations à partir de l’événement.  
  
 N’utilisez pas l’appel asynchrone <xref:System.Messaging.MessageQueue.BeginReceive%2A> avec des transactions. Si vous souhaitez effectuer une opération asynchrone transactionnelle, appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A>et placez la transaction et (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> méthode dans le Gestionnaire d’événements que vous créez pour l’opération de lecture. Votre gestionnaire d’événements peut contenir des fonctionnalités comme indiqué dans le code c# suivant.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée une commande asynchrone opération de réception. L’exemple de code envoie un message à une file d’attente locale, puis appelle <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, en passant : une valeur de délai d’attente de dix secondes, un entier unique qui identifie ce message particulier ; et une nouvelle instance de <xref:System.AsyncCallback> qui identifie le Gestionnaire d’événements `MyReceiveCompleted`. Quand un <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché, le Gestionnaire d’événements reçoit le message et écrit le corps du message et l’identificateur de message entier dans l’écran.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : TimeSpan * System.Messaging.Cursor * obj * AsyncCallback -&gt; IAsyncResult" Usage="messageQueue.BeginReceive (timeout, cursor, state, callback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente pour qu'un message soit disponible.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <param name="state">Objet d'état, spécifié par l'application, qui comporte les données associées à l'opération asynchrone.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> qui reçoit la notification de la fin de l'opération asynchrone.</param>
        <summary>Lance une opération de réception asynchrone qui a un délai d'attente spécifié et utilise un curseur spécifié et un objet d'état spécifié. L'objet d'état fournit des informations associées pendant la durée de vie de l'opération. Cette surcharge reçoit, via un rappel, la notification de l'identité du gestionnaire d'événements de l'opération. L'opération ne se termine que lorsqu'un message est disponible dans la file ou lorsque le délai d'attente a expiré.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> qui identifie la requête asynchrone publiée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous utilisez cette surcharge, le rappel spécifié dans le paramètre de rappel est appelé directement lorsqu’un message est disponible dans la file d’attente ou lorsque l’intervalle de temps spécifié a expiré ; le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement n’est pas déclenché. Les autres surcharges de <xref:System.Messaging.MessageQueue.BeginReceive%2A> s’appuient sur ce composant pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> est également déclenché si un message existe déjà dans la file d’attente.  
  
 Pour utiliser <xref:System.Messaging.MessageQueue.BeginReceive%2A>, créez un gestionnaire d’événements qui traite les résultats de l’opération asynchrone et associez-le à votre délégué d’événement. <xref:System.Messaging.MessageQueue.BeginReceive%2A> lance une réception asynchrone une opération ; le <xref:System.Messaging.MessageQueue> est prévenu via le déclenchement de le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement, lorsqu’un message arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue> peut alors accéder au message en appelant <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou en récupérant le résultat à l’aide de la <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 Le <xref:System.Messaging.MessageQueue.BeginReceive%2A> méthode est retournée immédiatement, mais l’opération asynchrone n’est pas terminée tant que le Gestionnaire d’événements est appelé.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.BeginReceive%2A> est asynchrone, vous pouvez l’appeler pour recevoir un message à partir de la file d’attente sans bloquer le thread en cours d’exécution. Pour recevoir un message de façon synchrone, utilisez la <xref:System.Messaging.MessageQueue.Receive%2A> (méthode).  
  
 Une fois qu’une opération asynchrone se termine, vous pouvez appeler <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau dans le Gestionnaire d’événements pour continuer à recevoir les notifications.  
  
 Le <xref:System.IAsyncResult> qui <xref:System.Messaging.MessageQueue.BeginReceive%2A> retourne identifie l’opération asynchrone lancée par la méthode. Vous pouvez utiliser cette <xref:System.IAsyncResult> tout au long de la durée de vie de l’opération, bien que vous généralement ne l’utilisez pas jusqu'à ce que <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est appelée. Toutefois, si vous démarrez plusieurs opérations asynchrones, vous pouvez placer leurs <xref:System.IAsyncResult> valeurs dans un tableau et spécifier s’il faut attendre que toutes les opérations ou de toute opération se termine. Dans ce cas, utilisez le <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriété de la <xref:System.IAsyncResult> pour identifier l’opération terminée.  
  
 L’objet d’état associe des informations d’état de l’opération. Par exemple, si vous appelez <xref:System.Messaging.MessageQueue.BeginReceive%2A> plusieurs fois afin de lancer plusieurs opérations, vous pouvez identifier chaque opération via un objet d’état distinct que vous définissez.  
  
 Vous pouvez également utiliser l’objet d’état pour passer des informations sur les threads de processus. Si un thread est démarré, mais le rappel est sur un thread différent dans un scénario asynchrone, l’objet d’état est marshalé et passé avec les informations à partir de l’événement.  
  
 N’utilisez pas l’appel asynchrone <xref:System.Messaging.MessageQueue.BeginReceive%2A> avec des transactions. Si vous souhaitez effectuer une opération asynchrone transactionnelle, appelez <xref:System.Messaging.MessageQueue.BeginPeek%2A>et placez la transaction et (synchrone) <xref:System.Messaging.MessageQueue.Receive%2A> méthode dans le Gestionnaire d’événements que vous créez pour l’opération de lecture. Votre gestionnaire d’événements peut contenir des fonctionnalités comme indiqué dans le code c# suivant.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="cursor" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Messaging.MessageQueue" /> peut être lu.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Messaging.MessageQueue" /> existe et que l'application peut lire à partir de celui-ci, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Indique si l’application est en mesure de lire ou recevoir des messages à partir de la file d’attente. Si <xref:System.Messaging.MessageQueue.CanRead%2A> est `true`, le <xref:System.Messaging.MessageQueue> peut recevoir ou lire des messages à partir de la file d’attente. Sinon, il ne peut pas.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> est `false` si une file d’attente est déjà ouverte avec un accès en lecture exclusif (ou si elle est ouverte avec un accès non exclusif et cela <xref:System.Messaging.MessageQueue> demande un accès exclusif), ou si l’application n’a pas de droits suffisants pour y accéder. Si votre application tente de lire à partir d’une file d’attente lorsque <xref:System.Messaging.MessageQueue.CanRead%2A> est `false`, l’accès est refusé.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.CanRead%2A> propriété.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si <see cref="T:System.Messaging.MessageQueue" /> peut être accessible en écriture.</summary>
        <value>
          <see langword="true" /> si <see cref="T:System.Messaging.MessageQueue" /> existe et que l'application peut écrire dans celui-ci ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Indique si l’application est en mesure d’envoyer des messages à la file d’attente. Si <xref:System.Messaging.MessageQueue.CanWrite%2A> est `true`, le <xref:System.Messaging.MessageQueue> peut envoyer des messages à la file d’attente. Sinon, il ne peut pas.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> est `false` si une file d’attente est déjà ouvert avec accès en écriture exclusif (ou si elle est ouverte avec un accès non exclusif et cela <xref:System.Messaging.MessageQueue> demande un accès exclusif), ou si l’application n’a pas de droits suffisants pour y accéder. Si votre application tente d’écrire dans une file d’attente lorsque <xref:System.Messaging.MessageQueue.CanWrite%2A> est `false`, l’accès est refusé.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.CanWrite%2A> propriété.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.Category : Guid with get, set" Usage="System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la catégorie de la file d'attente.</summary>
        <value>
          <see cref="T:System.Guid" /> qui représente la catégorie de file d'attente (identificateur de type Message Queuing) qui permet à une application de classer par catégorie ses files d'attente. La valeur par défaut est <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La catégorie de file d’attente permet à une application classer par catégorie ses files d’attente. Par exemple, vous pouvez placer toutes les files d’attente de facturation dans une catégorie et toutes les files d’attente de commande dans un autre.  
  
 Le <xref:System.Messaging.MessageQueue.Category%2A> propriété fournit l’accès à la propriété ID de Type Message Queuing (qui est en lecture/écriture), accessible via la **propriétés de la file d’attente** boîte de dialogue dans la Console de gestion d’ordinateur. Vous pouvez définir une nouvelle catégorie. Bien que vous puissiez utiliser <xref:System.Guid.NewGuid%2A> pour créer une valeur de catégorie qui est unique dans l’ensemble <xref:System.Guid> valeurs, une telle action n’est pas nécessaire. La valeur de catégorie doit être distingués uniquement à partir d’autres catégories, pas à partir de tous les autres <xref:System.Guid> valeurs. Par exemple, vous pouvez affecter {00000000-0000-0000-0000-000000000001} en tant que le <xref:System.Messaging.MessageQueue.Category%2A> pour un ensemble de files d’attente et {00000000-0000-0000-0000-000000000002} comme le <xref:System.Messaging.MessageQueue.Category%2A> pour un autre ensemble.  
  
 Il n’est pas nécessaire de définir le <xref:System.Messaging.MessageQueue.Category%2A>. La valeur peut être `null`.  
  
 Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.Category%2A> propriété.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La catégorie de file d'attente définie est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberSignature Language="F#" Value="static member ClearConnectionCache : unit -&gt; unit" Usage="System.Messaging.MessageQueue.ClearConnectionCache " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Vide le cache de connexion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, les noms de format stockés dans le cache sont supprimés et les handles ouverts et stockés dans le cache sont fermés.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant appelle <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageQueue.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources allouées par <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> Libère toutes les ressources associées à un <xref:System.Messaging.MessageQueue>, y compris des ressources partagées si nécessaire. Le système acquiert une nouvelle fois ces ressources automatiquement si elles sont toujours disponibles, par exemple lorsque vous appelez le <xref:System.Messaging.MessageQueue.Send%28System.Object%29> méthode, comme dans le code c# suivant.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Lorsque vous appelez <xref:System.Messaging.MessageQueue.Close%2A>, tous les <xref:System.Messaging.MessageQueue> propriétés qui accèdent directement à la file d’attente Message Queuing sont effacées. Le <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, et <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> tous les restent telles qu’elles étaient.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> ne pas toujours libérer la lecture handles et d’écriture à une file d’attente, car ils peuvent être partagés. Vous pouvez utiliser une des étapes suivantes pour vous assurer que <xref:System.Messaging.MessageQueue.Close%2A> libère les handles de lecture et d’écriture à une file d’attente :  
  
-   Créer le <xref:System.Messaging.MessageQueue> avec un accès exclusif. Pour ce faire, appelez le <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> ou <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> et ensemble la `sharedModeDenyReceive` paramètre `true`.  
  
-   Créer le <xref:System.Messaging.MessageQueue> avec connexion mise en cache désactivée. Pour ce faire, appelez le <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> constructeur et définissez le `enableConnectionCache` paramètre `false`.  
  
-   Désactiver la mise en cache de connexion. Pour ce faire, définissez la <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriété `false`.  
  
 Vous devez appeler <xref:System.Messaging.MessageQueue.Close%2A> pour une file d’attente avant de supprimer la file d’attente sur le serveur Message Queuing. Sinon, les messages envoyés à la file d’attente peuvent lever des exceptions ou s’affichent dans la file d’attente de lettres mortes.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant ferme une file d’attente Message Queuing.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée une nouvelle file d'attente dans le chemin d'accès spécifié sur le serveur Message Queuing.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Chemin de la file d'attente à créer.</param>
        <summary>Crée une file d'attente Message Queuing non transactionnelle dans le chemin d'accès spécifié.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> qui représente la nouvelle file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer une file d’attente Message Queuing non transactionnelle.  
  
 Pour créer une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe dans votre application et le lier à une file d’attente existante, utilisez le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur. Pour créer une file d’attente dans Message Queuing, appelez <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La syntaxe pour le `path` paramètre dépend du type de file d’attente il références, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
  
 Utilisez «. » pour l’ordinateur local. Pour plus de syntaxe, consultez le <xref:System.Messaging.MessageQueue.Path%2A> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant crée des files d’attente publiques et privées. Il envoie un message aux files d’attente sélectionnées.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est <see langword="null" /> ou une chaîne vide ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une file d'attente existe déjà au niveau du chemin spécifié.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberSignature Language="F#" Value="static member Create : string * bool -&gt; System.Messaging.MessageQueue" Usage="System.Messaging.MessageQueue.Create (path, transactional)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Chemin de la file d'attente à créer.</param>
        <param name="transactional">
          <see langword="true" /> pour créer une file d'attente transactionnelle ; <see langword="false" /> pour créer une file d'attente non transactionnelle.</param>
        <summary>Crée une file d'attente Message Queuing transactionnelle ou non transactionnelle dans le chemin d'accès spécifié.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueue" /> qui représente la nouvelle file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser cette surcharge pour créer une file d’attente transactionnelle dans Message Queuing. Vous pouvez créer une file d’attente non transactionnelle, en définissant le `transactional` paramètre `false` ou en appelant l’autre surcharge de <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Pour créer une nouvelle instance de la <xref:System.Messaging.MessageQueue> classe dans votre application et le lier à une file d’attente existante, utilisez le <xref:System.Messaging.MessageQueue.%23ctor%2A> constructeur. Pour créer une file d’attente dans Message Queuing, appelez <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 La syntaxe pour le `path` paramètre dépend du type de file d’attente il références, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
  
 Utilisez «. » pour l’ordinateur local. Pour plus de syntaxe, consultez le <xref:System.Messaging.MessageQueue.Path%2A> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant crée des files d’attente transactionnelles publiques et privées. Il envoie un message aux files d’attente sélectionnées.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est <see langword="null" /> ou une chaîne vide ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une file d'attente existe déjà au niveau du chemin spécifié.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberSignature Language="F#" Value="member this.CreateCursor : unit -&gt; System.Messaging.Cursor" Usage="messageQueue.CreateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un <see cref="T:System.Messaging.Cursor" /> pour la file d'attente de messages active.</summary>
        <returns>Nouveau <see cref="T:System.Messaging.Cursor" /> pour la file d'attente de messages active. Ce curseur est utilisé pour conserver un emplacement spécifique dans la file d'attente lors de la lecture des messages de la file d'attente.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateTime : DateTime" Usage="System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'heure et la date de création de la file d'attente dans Message Queuing.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui représente la date et l'heure de création de la file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> fait référence à la file d’attente sur le serveur Message Queuing, pas le <xref:System.Messaging.MessageQueue> instance.  
  
 Si la file d’attente existe, cette propriété représente la création de la file d’attente, ajustée à l’heure locale du serveur sur lequel se trouve la file d’attente.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.CreateTime%2A> propriété.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPropertiesToSend : System.Messaging.DefaultPropertiesToSend with get, set" Usage="System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les valeurs de propriétés de message par défaut à utiliser lorsque l'application envoie des messages vers la file d'attente.</summary>
        <value>
          <see cref="T:System.Messaging.DefaultPropertiesToSend" /> qui contient les valeurs de propriétés de message Message Queuing par défaut utilisées lorsque l'application envoie des objets autres que des instances de <see cref="T:System.Messaging.Message" /> dans la file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous envoyez un objet qui n’est pas de type <xref:System.Messaging.Message> à la file d’attente, le <xref:System.Messaging.MessageQueue> insère l’objet dans un Message message Queuing. À ce stade, le <xref:System.Messaging.MessageQueue> s’applique au message les valeurs de propriété que vous spécifiez dans le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété. À l’inverse, si vous envoyez un <xref:System.Messaging.Message> à la file d’attente, ces propriétés sont déjà spécifiées pour l’instance elle-même, par conséquent, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> est ignoré pour le <xref:System.Messaging.Message>.  
  
 Bien que vous définissez les propriétés via la <xref:System.Messaging.MessageQueue> objet, le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> fait référence aux propriétés des messages qui sont envoyés à la file d’attente, pas à la file d’attente elle-même.  
  
 Les valeurs par défaut pour les propriétés sont affichées dans le tableau suivant.  
  
|Property|Valeur par défaut|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|zéro (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|une chaîne vide ( » »)|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant utilise la priorité d’un message pour déterminer les propriétés par défaut à envoyer pour le message.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Les propriétés par défaut de la file d'attente n'ont pas pu être définies. Une des propriétés n'est sans doute pas valide.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Messaging.MessageQueue.Delete path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente à supprimer.</param>
        <summary>Supprime une file d'attente sur un serveur Message Queuing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La syntaxe pour le `path` paramètre varie selon le type de file d’attente.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
  
 Pour plus de syntaxe, consultez le <xref:System.Messaging.MessageQueue.Path%2A> propriété.  
  
 Vous pouvez également utiliser le <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> pour décrire le chemin d’accès de la file d’attente.  
  
|Référence|Syntaxe|  
|---------------|------------|  
|Nom du format|Nom de format : [ *nom de format* ]|  
|Ajouter des contrôles|Étiquette : [ *étiquette* ]|  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant supprime une file d’attente Message Queuing, si elle existe.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="path" /> est <see langword="null" /> ou une chaîne vide ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La syntaxe du paramètre <paramref name="path" /> n'est pas valide.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DenySharedReceive : bool with get, set" Usage="System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si ce <see cref="T:System.Messaging.MessageQueue" /> a un droit d'accès exclusif pour la réception des messages de la file d'attente Message Queuing.</summary>
        <value>
          <see langword="true" /> si ce <see cref="T:System.Messaging.MessageQueue" /> a des droits exclusifs pour la réception des messages de la file d'attente ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Spécifie le mode partagé de la file d’attente référencée par ce <xref:System.Messaging.MessageQueue>. Définissez <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> à `true` pour indiquer que seul ce <xref:System.Messaging.MessageQueue> doivent avoir accès pour lire ou recevoir des messages à partir de la file d’attente avec la valeur <xref:System.Messaging.MessageQueue.Path%2A>. Si un autre <xref:System.Messaging.MessageQueue> ou une autre application est associée à la même ressource de file d’attente, cette instance ou application ne sera pas en mesure de lire ou recevoir des messages, mais il peut toujours vous les envoyer.  
  
 Si <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> est `false`, la file d’attente est disponible pour plusieurs applications pour envoyer, lire ou recevoir des messages.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriété.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageQueue.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> pour libérer les ressources managées et non managées ; <see langword="false" /> pour ne libérer que les ressources non managées.</param>
        <summary>Libère les ressources (autres que la mémoire) utilisées par <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appelez la méthode <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> une fois que vous avez terminé d'utiliser <xref:System.Messaging.MessageQueue>. La méthode <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> rend le <xref:System.Messaging.MessageQueue> inutilisable. Après avoir appelé <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, vous devez libérer toutes les références à la <xref:System.Messaging.MessageQueue> afin que la mémoire occupée peut être récupérée par le garbage collection.  
  
 Vous devez appeler <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> avant de libérer votre dernière référence à la <xref:System.Messaging.MessageQueue>. Sinon, les ressources du <xref:System.Messaging.MessageQueue> est ne seront pas libérées jusqu'à ce que le garbage collection appelle le <xref:System.Messaging.MessageQueue> destructeur de l’objet.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableConnectionCache : bool with get, set" Usage="System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'application conservera un cache de connexions.</summary>
        <value>
          <see langword="true" /> pour créer et utiliser un cache de connexions, sinon <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un cache de connexions est une liste de références à des structures qui contiennent les lire ou écrire des handles aux files d’attente. Lorsque <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> est `true`, le <xref:System.Messaging.MessageQueue> emprunte gère à partir du cache à chaque fois que vous appelez <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, au lieu d’ouvrir de nouveaux handles. Cela peut améliorer les performances. À l’aide d’un cache de connexions isole également le <xref:System.Messaging.MessageQueue> contre les modifications dans la topologie du réseau.  
  
 Si vous créez une nouvelle connexion à une file d’attente lorsque le cache de connexion est plein, le <xref:System.Messaging.MessageQueue> remplace la structure moins récemment consultée par la nouvelle connexion. Vous pouvez effacer le cache entièrement en appelant <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, par exemple, si les noms de formats, vous travaillez avec des files d’attente ont été modifiées afin que le précédent lire et écrire des handles ne sont plus valides.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriété.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionRequired : System.Messaging.EncryptionRequired with get, set" Usage="System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si la file d'attente accepte uniquement les messages non privés (non chiffrés).</summary>
        <value>Une des valeurs de <see cref="T:System.Messaging.EncryptionRequired" />. La valeur par défaut est <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous spécifiez que le chiffrement est requis pour les messages envoyés à une file d’attente, les corps des messages sont chiffrés. Les autres membres (par exemple, le <xref:System.Messaging.Message.Label%2A> et <xref:System.Messaging.Message.SenderId%2A> propriétés) ne peut pas être chiffrée.  
  
 Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification.  
  
 Chiffrement d’un message fait un message privé. Vous pouvez spécifier d’exigence de chiffrement de la file d’attente pour être `None`, `Body`, ou `Optional` en définissant le <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriété correctement. Le <xref:System.Messaging.Message.UseEncryption%2A> paramètre du message doit correspondre à l’exigence de chiffrement de la file d’attente. Si le message n’est pas chiffré, mais la file d’attente spécifie `Body`, ou si le message est chiffré mais que la file d’attente spécifie `None`, le message est rejeté par la file d’attente. Si l’application émettrice demande un message d’accusé de réception négatif dans ce cas, Message Queuing indique rejet du message à l’application émettrice. Si le <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriété est `true`, un message qui échoue de chiffrement est envoyé à la file d’attente de lettres mortes. Sinon, le message est perdu.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriété.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndPeek : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndPeek asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> qui identifie l'opération de lecture asynchrone à terminer, et à partir de laquelle un résultat final doit être récupéré.</param>
        <summary>Termine l'opération de lecture asynchrone spécifiée.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> associé à l'opération asynchrone terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> termine l’opération qui a été démarrée par le <xref:System.Messaging.MessageQueue.BeginPeek%2A> appeler. Pour ce faire, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lit le message.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> peut spécifier un délai d’attente, ce qui provoque le <xref:System.Messaging.MessageQueue.PeekCompleted> événement à signaler si le délai d’expiration se produit avant un message s’affiche dans la file d’attente. Lorsqu’un délai d’attente se produit sans un message arrive dans la file d’attente, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lève une exception.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> est utilisé pour lire le message qui a provoqué la <xref:System.Messaging.MessageQueue.PeekCompleted> déclenchement d’événement.  
  
 Si vous souhaitez continuer à lire des messages en mode asynchrone, vous pouvez appeler à nouveau <xref:System.Messaging.MessageQueue.BeginPeek%2A> après avoir appelé <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant crée un gestionnaire d’événements nommé `MyPeekCompleted`, attache à la <xref:System.Messaging.MessageQueue.PeekCompleted> délégué de gestionnaire d’événements et les appels <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour lancer une opération de lecture asynchrone sur la file d’attente qui se trouve dans le chemin d’accès ». \myQueue ». Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché, l’exemple lit le message et écrit son corps à l’écran. L’exemple appelle ensuite <xref:System.Messaging.MessageQueue.BeginPeek%2A> à nouveau pour lancer une nouvelle opération de lecture asynchrone.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="asyncResult" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; System.Messaging.Message" Usage="messageQueue.EndReceive asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> qui identifie l'opération de réception asynchrone à terminer, et à partir de laquelle un résultat final doit être récupéré.</param>
        <summary>Termine l'opération de réception asynchrone spécifiée.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> associé à l'opération asynchrone terminée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> termine l’opération qui a été démarrée par le <xref:System.Messaging.MessageQueue.BeginReceive%2A> appeler. Pour ce faire, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> reçoit le message.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> peut spécifier un délai d’attente, ce qui provoque le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement à signaler si le délai d’expiration se produit avant un message s’affiche dans la file d’attente. Lorsqu’un délai d’attente se produit sans un message arrive dans la file d’attente, un appel ultérieur à <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lève une exception.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> est utilisé pour lire (en supprimant de la file d’attente) le message qui a provoqué la <xref:System.Messaging.MessageQueue.ReceiveCompleted> déclenchement d’événement.  
  
 Si vous souhaitez continuer à recevoir des messages de façon asynchrone, vous pouvez appeler à nouveau <xref:System.Messaging.MessageQueue.BeginReceive%2A> après avoir appelé <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant associe plusieurs demandes asynchrones. Il suppose une file d’attente sur l’ordinateur local, appelé « myQueue ». Le `Main` fonction commence l’opération asynchrone qui est gérée par le `MyReceiveCompleted` routine. `MyReceiveCompleted` traite le message en cours et commence une nouvelle asynchrone opération de réception.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="asyncResult" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La syntaxe du paramètre <paramref name="asyncResult" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Messaging.MessageQueue.Exists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Emplacement de la file d'attente à rechercher.</param>
        <summary>Détermine si une file d'attente Message Queuing existe dans le chemin d'accès spécifié.</summary>
        <returns>
          <see langword="true" /> si une file d'attente existe dans le chemin d'accès spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.Exists%28System.String%29> méthode détermine si une file d’attente Message Queuing existe dans un chemin d’accès spécifié. Il n’existe aucune méthode pour déterminer l’existence d’une file d’attente avec un nom de format spécifié. Pour plus d’informations sur la syntaxe de nom de format et d’autres formes de syntaxe de chemin d’accès, consultez le <xref:System.Messaging.MessageQueue.Path%2A> propriété.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> est une opération coûteuse. Utilisez-le uniquement lorsque cela est nécessaire au sein de l’application.  
  
> [!NOTE]
>  Le <xref:System.Messaging.MessageQueue.Exists%28System.String%29> méthode ne prend pas en charge la <xref:System.Messaging.MessageQueue.FormatName%2A> préfixe.  
  
 La syntaxe pour le `path` paramètre varie selon le type de file d’attente, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> ne peut pas être appelée pour vérifier l’existence d’une file d’attente privée distante.  
  
 Pour plus de syntaxe, consultez le <xref:System.Messaging.MessageQueue.Path%2A> propriété.  
  
 Vous pouvez également utiliser le <xref:System.Messaging.MessageQueue.Label%2A> pour décrire le chemin d’accès de la file d’attente.  
  
|Référence|Syntaxe|  
|---------------|------------|  
|Ajouter des contrôles|Étiquette : [ `label` ]|  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant vérifie si une file d’attente Message Queuing existe, puis le supprime.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La syntaxe <paramref name="path" /> n'est pas valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.  
  
- ou - 
La méthode <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> est appelée sur une file d'attente privée distante.</exception>
        <exception cref="T:System.InvalidOperationException">L'application a utilisé une syntaxe de nom de format pour vérifier l'existence de la file d'attente.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FormatName : string" Usage="System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nom unique que Message Queuing a généré pour la file d'attente lors de sa création.</summary>
        <value>Nom de la file d'attente. Il s'agit d'un nom unique sur le réseau.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.FormatName%2A> propriété contient le nom de format de la file d’attente. Message Queuing utilise le nom de format pour identifier la file d’attente pour ouvrir et comment y accéder. Contrairement à la plupart des caractéristiques d’une file d’attente, le nom de format n’est pas une propriété Message Queuing de file d’attente d’application, donc vous ne pouvez pas y accéder via l’outil de gestion de Message Queuing. Le nom de format est simplement un nom unique pour la file d’attente que Message Queuing génère lorsqu’il crée la file d’attente ou que l’application génère plus tard.  
  
 Si vous spécifiez un chemin d’accès à l’aide de la syntaxe de nom de chemin d’accès (tel que `myComputer\myQueue`) au lieu d’utiliser la syntaxe de nom de format lorsque vous lisez ou écrivez à la file d’attente, le contrôleur de domaine principal (qui utilise Active Directory) se traduit par la <xref:System.Messaging.MessageQueue.Path%2A> dans le associé<xref:System.Messaging.MessageQueue.FormatName%2A> avant d’accéder à la file d’attente. Si votre application fonctionne en mode hors connexion, vous devez utiliser la syntaxe de nom de format ; Sinon, le contrôleur de domaine principal ne sera pas disponible pour effectuer la traduction de chemin d’accès.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.FormatName%2A> propriété.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> n’est pas défini.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le formateur utilisé pour sérialiser un objet dans le corps d'un message lu ou écrit dans la file d'attente, ou pour désérialiser l'objet à partir de celui-ci.</summary>
        <value>Le <see cref="T:System.Messaging.IMessageFormatter" /> qui produit un flux à écrire dans le corps du message ou à lire à partir de celui-ci. La valeur par défaut est <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.Formatter%2A> propriété contient une instance d’un objet formateur qui transforme les messages lorsque votre application lit ou écrit dans la file d’attente.  
  
 Lorsque l’application envoie un message à la file d’attente, le formateur sérialise l’objet dans un flux et l’insère dans le corps du message. Lors de la lecture à partir d’une file d’attente, le formateur désérialise les données du message dans le <xref:System.Messaging.Message.Body%2A> propriété d’un <xref:System.Messaging.Message>.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> couplage peu étroit, donc il n’est pas nécessaire d’avoir le même objet de type sur l’expéditeur et le destinataire lors de l’utilisation de ce format. Le <xref:System.Messaging.ActiveXMessageFormatter> et <xref:System.Messaging.BinaryMessageFormatter> sérialiser les données en représentation binaire. Le <xref:System.Messaging.ActiveXMessageFormatter> sert à envoyer ou recevoir des composants COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> et <xref:System.Messaging.ActiveXMessageFormatter> fournir un débit plus rapide que le <xref:System.Messaging.XmlMessageFormatter>. Le <xref:System.Messaging.ActiveXMessageFormatter> permet l’interopérabilité avec les applications Visual Basic 6.0 Message Queuing.  
  
 Lorsque votre application envoie des messages à la file d’attente, le <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> s’applique uniquement aux messages qui utilisent les propriétés de message par défaut, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Si vous envoyez un <xref:System.Messaging.Message> à la file d’attente Message Queuing utilise le formateur défini dans le <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété à sérialiser le corps du message.  
  
 Le <xref:System.Messaging.MessageQueue> classe utilisent toujours un <xref:System.Messaging.Message> pour recevoir ou lire un message à partir de la file d’attente. Le message est désérialisé à l’aide de la <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberSignature Language="F#" Value="member this.GetAllMessages : unit -&gt; System.Messaging.Message[]" Usage="messageQueue.GetAllMessages " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne tous les messages qui figurent dans la file d'attente.</summary>
        <returns>Tableau de type <see cref="T:System.Messaging.Message" /> qui représente tous les messages de la file d'attente, dans le même ordre que celui qui est utilisé dans la file d'attente Message Queuing.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Retourne un instantané statique des messages figurant dans la file d’attente, non des liaisons dynamiques aux messages. Par conséquent, vous ne pouvez pas utiliser le tableau à modifier les messages dans la file d’attente. Si vous souhaitez une interaction en temps réel et dynamique avec la file d’attente (par exemple, la possibilité de supprimer des messages), appelez le <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> (méthode), qui retourne une liste dynamique des messages dans la file d’attente.  
  
 Étant donné que <xref:System.Messaging.MessageQueue.GetAllMessages%2A> retourne une copie des messages dans la file d’attente au moment où la méthode a été appelée, le tableau ne reflète pas les nouveaux messages qui arrivent dans la file d’attente ou des messages sont supprimés de la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> récupère uniquement les propriétés non éliminées par filtrage par le <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="messageQueue.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Énumère les messages d'une file d'attente. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> est déconseillé. Il est préférable d'utiliser <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> qui fournit une connexion dynamique aux messages de la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetMachineId : string -&gt; Guid" Usage="System.Messaging.MessageQueue.GetMachineId machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nom de l’ordinateur sur lequel se trouve la file d’attente, sans les deux barres obliques inverses initiales (\\\\).</param>
        <summary>Obtient l'identificateur de l'ordinateur sur lequel figure la file d'attente à laquelle ce <see cref="T:System.Messaging.MessageQueue" /> fait référence.</summary>
        <returns>
          <see cref="T:System.Guid" /> qui représente un identificateur unique pour l'ordinateur sur lequel figure la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser un identificateur global unique pour deux raisons, entre autres : pour lire le journal de l’ordinateur et pour définir les certificats de sécurité. Toutefois, vous ne pouvez pas appeler <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> pour un ordinateur distant lorsque vous travaillez hors connexion, car l’application doit avoir accès au service d’annuaire sur le contrôleur de domaine.  
  
 L’identificateur de l’ordinateur (ou identificateur de machine) est un <xref:System.Guid> créé par Message Queuing lorsqu’un ordinateur est ajouté à l’entreprise. Message Queuing associe l’identificateur de l’ordinateur avec le `Machine` et `Journal` mots clés pour créer le nom de format de journal machine, qui a la syntaxe `Machine=<computeridentifier>;Journal`. Le journal de l’ordinateur, ce qui est également connu en tant que la file d’attente du journal, est une file d’attente système qui stocke des copies des générés par l’application messages lorsque le <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propriété est `true`.  
  
 Cette syntaxe pour le journal est valide uniquement lors de la construction du nom de format pour la file d’attente. La syntaxe de nom de chemin d’accès est `MachineName` \\ `Journal$`.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant appelle <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">L'identificateur de l'ordinateur n'a pas pu être récupéré. Le service d'annuaire n'est peut-être pas disponible, par exemple, si vous travaillez en mode hors connexion.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Obsolete("This method returns a MessageEnumerator that implements RemoveCurrent family of methods incorrectly. Please use GetMessageEnumerator2 instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet énumérateur pour tous les messages figurant dans la file d'attente. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> est déconseillé. Il est préférable d'utiliser <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> contenant tous les messages de la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Crée une liste dynamique de tous les messages dans une file d’attente. Vous pouvez supprimer à partir de la file d’attente le message à la position actuelle de l’énumérateur en appelant <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> pour le <xref:System.Messaging.MessageEnumerator> qui <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> retourne.  
  
 Étant donné que le curseur est associé à la liste dynamique de messages dans la file d’attente, l’énumération reflète toute modification apportée aux messages dans la file d’attente, si le message est au delà de la position actuelle du curseur. Par exemple, l’énumérateur peut accéder automatiquement à un message de priorité inférieure placé au-delà de la position du curseur en cours, mais pas un message de priorité plus élevée inséré avant cette position. Toutefois, vous pouvez réinitialiser l’énumération, ainsi placer le curseur en début de la liste, en appelant <xref:System.Messaging.MessageEnumerator.Reset%2A> pour le <xref:System.Messaging.MessageEnumerator>.  
  
 L’ordre des messages dans l’énumération reflète leur ordre dans la file d’attente pour les messages de priorité plus élevée seront affichés avant ceux de priorité inférieure.  
  
 Si vous souhaitez un instantané statique des messages dans la file d’attente plutôt qu’une connexion dynamique à eux, appelez <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Cette méthode retourne un tableau de <xref:System.Messaging.Message> objets qui représentent les messages au moment de la méthode a été appelée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant obtient une liste dynamique de messages dans une file d’attente et compte tous les messages avec la <xref:System.Messaging.Message.Priority%2A> propriété définie sur <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberSignature Language="F#" Value="member this.GetMessageEnumerator2 : unit -&gt; System.Messaging.MessageEnumerator" Usage="messageQueue.GetMessageEnumerator2 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crée un objet énumérateur pour tous les messages figurant dans la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> contenant tous les messages de la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Crée une liste dynamique de tous les messages dans une file d’attente. Vous pouvez supprimer à partir de la file d’attente le message à la position actuelle de l’énumérateur en appelant <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> pour le <xref:System.Messaging.MessageEnumerator> qui <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> retourne.  
  
 Étant donné que le curseur est associé à la liste dynamique de messages dans la file d’attente, l’énumération reflète toute modification apportée aux messages dans la file d’attente, si le message est au delà de la position actuelle du curseur. Par exemple, l’énumérateur peut accéder automatiquement à un message de priorité inférieure placé au-delà de la position du curseur en cours, mais pas un message de priorité plus élevée inséré avant cette position. Toutefois, vous pouvez réinitialiser l’énumération, ainsi placer le curseur en début de la liste, en appelant <xref:System.Messaging.MessageEnumerator.Reset%2A> pour le <xref:System.Messaging.MessageEnumerator>.  
  
 L’ordre des messages dans l’énumération reflète leur ordre dans la file d’attente pour les messages de priorité plus élevée seront affichés avant ceux de priorité inférieure.  
  
 Si vous souhaitez un instantané statique des messages dans la file d’attente plutôt qu’une connexion dynamique à eux, appelez <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Cette méthode retourne un tableau de <xref:System.Messaging.Message> objets qui représentent les messages au moment de la méthode a été appelée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Crée un objet énumérateur pour une liste dynamique des files d'attente publiques d'un réseau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : unit -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit des sémantiques de curseur avant uniquement pour l'énumération de toutes les files d'attente publiques sur le réseau.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueueEnumerator" /> qui fournit une liste dynamique de toutes les files d'attente de messages publiques sur le réseau.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retourne une énumération de toutes les files d’attente publiques sur le réseau.  
  
 Étant donné que le curseur est associé à une liste dynamique, l’énumération reflète toute modification apportée à une liste de file d’attente pour les files d’attente supprimées ou ajoutées au-delà de la position du curseur en cours. Ajout ou la suppression de files d’attente situées avant la position actuelle du curseur ne sont pas reflétées. Par exemple, l’énumérateur peut accéder automatiquement à une file d’attente ajoutée après la position du curseur, mais pas une inséré avant cette position. Toutefois, vous pouvez réinitialiser l’énumération, ainsi placer le curseur en début de la liste, en appelant <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> pour le <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Il n’existe pas de classement défini des files d’attente dans un réseau. Un énumérateur ne pas classe ces derniers, par exemple, par ordinateur, une étiquette, état public ou privé ou tout autre critère accessible.  
  
 Si vous souhaitez un instantané statique sur le réseau plutôt que sur une connexion dynamique vers les files d’attente, appelez <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Chacune de ces deux méthodes retourne un tableau de <xref:System.Messaging.MessageQueue> objets qui représentent les files d’attente au moment de la méthode a été appelée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant effectue une itération dans toutes les files d’attente de message dans le réseau et examine le chemin d’accès pour chaque file d’attente. Enfin, il affiche le nombre de files d’attente publiques sur le réseau.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetMessageQueueEnumerator : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueueEnumerator" Usage="System.Messaging.MessageQueue.GetMessageQueueEnumerator criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" /> qui contient les critères utilisés pour filtrer les files d'attente de messages disponibles.</param>
        <summary>Fournit des sémantiques de curseur avant uniquement pour l'énumération de toutes les files d'attente publiques sur le réseau qui correspondent aux critères spécifiés.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageQueueEnumerator" /> qui fournit une liste dynamique des files d'attente de messages publiques sur le réseau qui sont conformes aux restrictions spécifiées par le paramètre <paramref name="criteria" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette surcharge de <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> renvoie une liste de toutes les files d’attente publiques sur le réseau qui répondent aux critères définis dans l’application. Vous pouvez spécifier les critères à inclure, par exemple, la file d’attente heure de création ou la modification, nom de l’ordinateur, une étiquette, catégorie ou n’importe quelle combinaison de ces.  
  
 Étant donné que le curseur est associé à une liste dynamique, l’énumération reflète toute modification apportée à une file d’attente qui se produit au-delà de la position du curseur en cours. Modifications apportées aux files d’attente situées avant la position actuelle du curseur ne sont pas reflétées. Par exemple, l’énumérateur peut accéder automatiquement à une file d’attente ajoutée après la position du curseur, mais pas une inséré avant cette position. Toutefois, vous pouvez réinitialiser l’énumération, ainsi placer le curseur en début de la liste, en appelant <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> pour le <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Il n’existe pas de classement défini des files d’attente dans un réseau. Un énumérateur ne pas classe ces derniers, par exemple, par ordinateur, une étiquette, état public ou privé ou tout autre critère accessible.  
  
 Si vous souhaitez un instantané statique des files d’attente sur le réseau plutôt qu’une connexion dynamique leur, spécifiez les critères pour <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou appelez <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Chacune de ces deux méthodes retourne un tableau de <xref:System.Messaging.MessageQueue> objets qui représentent les files d’attente au moment de la méthode a été appelée. Appel <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> fournit les mêmes résultats que si vous appelez <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> avec les critères de filtrage de <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, et <xref:System.Messaging.MessageQueue.MachineName%2A>, respectivement.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant effectue une itération dans les files d’attente et affiche le chemin d’accès de chaque file d’attente qui a été créé dans le dernier jour et qui existe sur l’ordinateur « Monordinateur ».  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPrivateQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPrivateQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Ordinateur à partir duquel seront récupérées les files d'attente privées.</param>
        <summary>Récupère toutes les files d'attente privées sur l'ordinateur spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> faisant référence aux files d'attente privées récupérées.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> Récupère un instantané statique des files d’attente sur un ordinateur spécifié.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="machineName" /> est <see langword="null" /> ou une chaîne vide ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Récupère toutes les files d'attente publiques du réseau.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : unit -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère toutes les files d'attente publiques du réseau.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> faisant référence aux files d'attente publiques récupérés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge si vous souhaitez obtenir la liste complète de toutes les files d’attente publiques sur le réseau. Si vous souhaitez limiter la liste par certains critères, tels que <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, ou de l’heure de dernière modification utiliser une autre surcharge de cette méthode. (Vous pouvez également utiliser <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Récupère un instantané statique des files d’attente. Pour interagir avec une liste dynamique de files d’attente, utilisez <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueues : System.Messaging.MessageQueueCriteria -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueues criteria" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">
          <see cref="T:System.Messaging.MessageQueueCriteria" /> qui contient les critères utilisés pour filtrer les files d'attente.</param>
        <summary>Récupère toutes les files d'attente publiques du réseau qui correspondent aux critères spécifiés.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> faisant référence aux files d'attente publiques récupérés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si vous souhaitez filtrer toutes les files d’attente publiques sur le réseau par étiquette, catégorie ou nom de l’ordinateur, le <xref:System.Messaging.MessageQueue> classe contient des méthodes spécifiques qui offrent cette fonctionnalité (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, et <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectivement). Utilisez cette surcharge pour obtenir une liste de toutes les files d’attente publiques sur le réseau qui répondent à plus d’un de ces critères (par exemple, si vous souhaitez spécifier une étiquette et une catégorie). Vous pouvez également filtrer par critères de message autre que <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, et <xref:System.Messaging.MessageQueue.MachineName%2A>. Par exemple, vous utilisez cette surcharge pour filtrer par heure de dernière modification d’une file d’attente. Créez simplement une nouvelle instance de la <xref:System.Messaging.MessageQueueCriteria> classe, définissez les propriétés appropriées dans l’instance et passer l’instance en tant que le `criteria` paramètre.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> Récupère un instantané statique des files d’attente. Pour interagir avec une liste dynamique de files d’attente, utilisez <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByCategory : Guid -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByCategory category" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">
          <see cref="T:System.Guid" /> qui regroupe le jeu de files d'attente à récupérer.</param>
        <summary>Récupère toutes les files d'attente publiques du réseau qui appartiennent à la catégorie spécifiée.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> faisant référence aux files d'attente publiques récupérés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour filtrer les files d’attente publiques par catégorie. Le <xref:System.Messaging.MessageQueue.Category%2A> propriété fournit l’accès à la propriété Message Queuing type ID (qui est en lecture/écriture) d’une file d’attente particulière. Bien que vous puissiez utiliser <xref:System.Guid.NewGuid%2A> pour créer une valeur de catégorie qui est unique dans l’ensemble <xref:System.Guid> valeurs, il n’est pas nécessaire. La valeur de catégorie doit être distingués uniquement à partir d’autres catégories, pas à partir de tous les autres <xref:System.Guid> valeurs. Par exemple, vous pouvez affecter {00000000-0000-0000-0000-000000000001} en tant que le <xref:System.Messaging.MessageQueue.Category%2A> pour un ensemble de files d’attente et {00000000-0000-0000-0000-000000000002} comme le <xref:System.Messaging.MessageQueue.Category%2A> pour un autre ensemble.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> Récupère un instantané statique des files d’attente. Pour interagir avec une liste dynamique de files d’attente, utilisez <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Vous pouvez spécifier la catégorie dans le cadre de la <xref:System.Messaging.MessageQueueCriteria> vous passez à la méthode.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByLabel : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByLabel label" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Étiquette qui regroupe le jeu de files d'attente à récupérer.</param>
        <summary>Récupère toutes les files d'attente publiques du réseau qui sont dotées de l'étiquette spécifiée.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> faisant référence aux files d'attente publiques récupérés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour filtrer les files d’attente publiques par étiquette.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> Récupère un instantané statique des files d’attente. Pour interagir avec une liste dynamique de files d’attente, utilisez <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Vous pouvez spécifier l’étiquette dans le cadre de la <xref:System.Messaging.MessageQueueCriteria> vous passez à la méthode.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="label" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetPublicQueuesByMachine : string -&gt; System.Messaging.MessageQueue[]" Usage="System.Messaging.MessageQueue.GetPublicQueuesByMachine machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nom de l'ordinateur contenant le jeu de files d'attente publiques à récupérer.</param>
        <summary>Récupère toutes les files d'attente publiques qui résident sur l'ordinateur spécifié.</summary>
        <returns>Tableau d'objets <see cref="T:System.Messaging.MessageQueue" /> qui référencent les files d'attente publiques sur l'ordinateur.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour filtrer les files d’attente publiques par ordinateur.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> Récupère un instantané statique des files d’attente. Pour interagir avec une liste dynamique de files d’attente, utilisez <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Vous pouvez spécifier le nom d’ordinateur dans le cadre de la <xref:System.Messaging.MessageQueueCriteria> vous passez à la méthode.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Non|  
|Ordinateur local et le nom de format direct|Non|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant récupère les listes de files d’attente.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le paramètre <paramref name="machineName" /> possède une syntaxe incorrecte.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberSignature Language="F#" Value="static member GetSecurityContext : unit -&gt; System.Messaging.SecurityContext" Usage="System.Messaging.MessageQueue.GetSecurityContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Récupère le contexte de sécurité que MSMQ associe à l'utilisateur actuel (identité de thread) au moment de cet appel.</summary>
        <returns>Objet <see cref="T:System.Messaging.SecurityContext" /> qui contient le contexte de sécurité.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : Guid" Usage="System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur unique de Message Queuing pour la file d'attente.</summary>
        <value>
          <see cref="P:System.Messaging.MessageQueue.Id" /> qui représente l'identificateur de message généré par l'application Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing définit le <xref:System.Messaging.MessageQueue.Id%2A> propriété lorsqu’il crée la file d’attente. Cette propriété est uniquement disponible pour les files d’attente publiques.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.Id%2A> propriété.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteQueueSize : int64" Usage="System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie qu'il n'existe aucune restriction de taille pour la file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce membre est fréquemment utilisé lors de la définition <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> ou <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membre.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie qu'il n'existe pas de délai d'attente pour les méthodes qui lisent ou reçoivent les messages.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> prend en charge deux types de récupération des messages : synchrones et asynchrones. Les méthodes synchrones, <xref:System.Messaging.MessageQueue.Peek%2A> et <xref:System.Messaging.MessageQueue.Receive%2A>, provoquer le thread de processus à attendre un intervalle de temps spécifié pour un nouveau message arrive dans la file d’attente. Si l’intervalle de temps spécifié est <xref:System.Messaging.MessageQueue.InfiniteTimeout>, le thread de processus est bloqué jusqu'à ce qu’un nouveau message est disponible. En revanche, <xref:System.Messaging.MessageQueue.BeginPeek%2A> et <xref:System.Messaging.MessageQueue.BeginReceive%2A> (les méthodes asynchrones), permettent aux tâches de l’application principale continuer dans un thread distinct, jusqu'à ce qu’un message arrive dans la file d’attente.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Messaging.MessageQueue.InfiniteTimeout> membre.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la description de la file d'attente.</summary>
        <value>Étiquette de la file d'attente de messages. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La longueur maximale d’une étiquette de file d’attente de message est de 124 caractères.  
  
 Le <xref:System.Messaging.MessageQueue.Label%2A> propriété ne doit pas être unique parmi toutes les files d’attente. Toutefois, si plusieurs files d’attente partagent le même <xref:System.Messaging.MessageQueue.Label%2A>, vous ne pouvez pas utiliser le <xref:System.Messaging.MessageQueue.Send%28System.Object%29> méthode pour diffuser un message à tous les éléments. Si vous utilisez la syntaxe de l’étiquette pour le <xref:System.Messaging.MessageQueue.Path%2A> propriété lorsque vous envoyez le message, une exception est levée si le <xref:System.Messaging.MessageQueue.Label%2A> n’est pas unique.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.Label%2A> propriété.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de l'étiquette est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.LastModifyTime : DateTime" Usage="System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'heure à laquelle les propriétés d'une file d'attente ont été modifiées pour la dernière fois.</summary>
        <value>
          <see cref="T:System.DateTime" /> qui indique l'heure de la dernière modification des propriétés d'une file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’heure de dernière modification inclut lors de la création de la file d’attente et n’importe quel <xref:System.Messaging.MessageQueue> propriété qui modifie la file d’attente Message Queuing, tel que <xref:System.Messaging.MessageQueue.BasePriority%2A>. La valeur de la <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriété représente l’heure système de l’ordinateur local.  
  
 Vous devez appeler <xref:System.Messaging.MessageQueue.Refresh%2A> avant d’obtenir le <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriété ; sinon, l’heure de modification associé à cet <xref:System.Messaging.MessageQueue> peut ne pas être en cours.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriété.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom de l'ordinateur où se trouve la file d'attente Message Queuing.</summary>
        <value>Nom de l'ordinateur où se trouve la file d'attente. La valeur par défaut de Message Queuing est ".", ce qui correspond à l'ordinateur local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.MachineName%2A> est un composant intégral de la syntaxe du nom convivial de la file d’attente <xref:System.Messaging.MessageQueue.Path%2A>. Le tableau suivant présente la syntaxe à utiliser pour une file d’attente d’un type spécifié lorsque vous souhaitez identifier le chemin d’accès de file d’attente à l’aide de son nom convivial.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
|File d’attente du journal|`MachineName`\\`QueueName`\\`Journal$`|  
|File d’attente du journal machine|`MachineName`\\`Journal$`|  
|File d’attente de lettres mortes machine|`MachineName`\\`Deadletter$`|  
|File d’attente de lettres mortes transactionnelle machine|`MachineName`\\`XactDeadletter$`|  
  
 Utilisez «. » pour l’ordinateur local lorsque vous spécifiez le <xref:System.Messaging.MessageQueue.MachineName%2A>. Le nom d’ordinateur est reconnu pour cette propriété, par exemple, `Server0`. Le <xref:System.Messaging.MessageQueue.MachineName%2A> propriété ne prend pas en charge le format d’adresse IP.  
  
 Si vous définissez la <xref:System.Messaging.MessageQueue.Path%2A> en termes de la <xref:System.Messaging.MessageQueue.MachineName%2A>, l’application lève une exception lorsque vous travaillez hors connexion, car le contrôleur de domaine est requis pour convertir le chemin d’accès. Par conséquent, vous devez utiliser le <xref:System.Messaging.MessageQueue.FormatName%2A> pour le <xref:System.Messaging.MessageQueue.Path%2A> syntaxe lorsque vous travaillez hors connexion.  
  
 Le <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, et <xref:System.Messaging.MessageQueue.QueueName%2A> propriétés sont liées. Modification de la <xref:System.Messaging.MessageQueue.MachineName%2A> propriété entraîne le <xref:System.Messaging.MessageQueue.Path%2A> propriété à modifier. Il est construit à partir de la nouvelle <xref:System.Messaging.MessageQueue.MachineName%2A> et <xref:System.Messaging.MessageQueue.QueueName%2A>. Modification de la <xref:System.Messaging.MessageQueue.Path%2A> (par exemple, pour utiliser la syntaxe de nom de format) réinitialise le <xref:System.Messaging.MessageQueue.MachineName%2A> et <xref:System.Messaging.MessageQueue.QueueName%2A> propriétés pour faire référence à la nouvelle file d’attente. Si le <xref:System.Messaging.MessageQueue.QueueName%2A> propriété est vide, le <xref:System.Messaging.MessageQueue.Path%2A> est défini sur la file d’attente du Journal de l’ordinateur que vous spécifiez.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.MachineName%2A> propriété.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nom de l'ordinateur n'est pas valide. La syntaxe utilisée est sans doute incorrecte.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumJournalSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale du journal de file d'attente.</summary>
        <value>Taille maximale du journal de file d'attente, en kilo-octets. La valeur par défaut Message Queuing spécifie qu'il n'existe aucune limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> fournit l’accès à la limite de stockage de journal de Message Queuing. Il est pertinente uniquement lorsque <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> est `true`. Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification  
  
 Si vous stockez des messages dans un journal ou une file d’attente de lettres mortes, vous devez effacer régulièrement la file d’attente pour supprimer les messages qui ne sont plus nécessaires. Nombre de messages dans une file d’attente dans le quota de message pour l’ordinateur où se trouve la file d’attente. (L’administrateur définit le quota de l’ordinateur.)  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> propriété.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur de la taille maximale du journal de file d'attente est non valide.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumQueueSize : int64 with get, set" Usage="System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.SizeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la taille maximale de la file d'attente.</summary>
        <value>Taille maximale de la file d'attente, en kilo-octets. La valeur par défaut Message Queuing spécifie qu'il n'existe aucune limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fournit l’accès à la limite de le stockage de message Message Queuing, qui est distincte de quota de messages de l’ordinateur que l’administrateur définit. Pour plus d’informations sur le quota de messages, consultez <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification  
  
 Si une tentative est faite pour dépasser la taille maximale de file d’attente ou le quota de l’ordinateur, les messages peuvent être perdus. Lorsque le quota de file d’attente est atteint, Message Queuing avertit la file d’attente d’administration de l’application émettrice pour indiquer que la file d’attente est pleine, en retournant un message d’accusé de réception négatif. Message Queuing continue d’envoyer des accusés de réception négatif jusqu'à ce que la taille totale des messages dans la file d’attente tombe au-dessous de la limite.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> propriété.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La taille maximale de la file d'attente contient une valeur négative.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MessageReadPropertyFilter : System.Messaging.MessagePropertyFilter with get, set" Usage="System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le filtre appliqué aux propriétés lors de la réception ou de la lecture de messages.</summary>
        <value>
          <see cref="T:System.Messaging.MessagePropertyFilter" /> utilisé par la file d'attente pour filtrer les propriétés reçues ou lues pour chaque message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ce filtre est un ensemble de valeurs booléennes en limitant les propriétés de message qui le <xref:System.Messaging.MessageQueue> reçoit ou lit. Lorsque le <xref:System.Messaging.MessageQueue> reçoit ou lit un message à partir de la file d’attente du serveur, il récupère uniquement les propriétés pour lesquelles la <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valeur est `true`.  
  
 L’exemple suivant montre les valeurs initiales des propriétés pour le <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriété. Ces paramètres sont identiques à l’appel <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> sur un <xref:System.Messaging.MessagePropertyFilter>.  
  
|Property|Valeur par défaut|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1 024 octets|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 octets|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 octets|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> pour restreindre les propriétés du message reçues.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le filtre est <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastAddress : string with get, set" Usage="System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Présentation dans MSMQ 3.0. Obtient ou définit l'adresse multicast associée à la file d'attente.</summary>
        <value>
          <see cref="T:System.String" /> qui contient une adresse multicast valide (au format présenté ci-dessous) ou <see langword="null" />, indiquant que la file d'attente n'est pas associée à une adresse multicast.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriété est utilisée pour associer une file d’attente non transactionnelle à une adresse de multidiffusion qui peut être utilisée lors de l’envoi de messages. Vous ne pouvez pas associer une file d’attente transactionnelle avec une adresse de multidiffusion. Lorsque l’application émettrice envoie des messages à une adresse de multidiffusion, Message Queuing envoie une copie du message à chaque file d’attente associée à cette adresse.  
  
 Multidiffusion IP adresses doivent être dans la plage de la classe D comprise entre 224.0.0.0 et 239.255.255.255, ce qui correspond au paramètre de valeur égale à 1110 les quatre premiers bits de poids fort. Toutefois, seules certaines plages d’adresses de cette plage sont non réservées et disponibles pour l’envoi de messages de multidiffusion. Pour obtenir la liste des adresses de multidiffusion réservées, consultez le [nombre autorité IANA (Internet Assigned) des adresses de multidiffusion Internet](http://go.microsoft.com/fwlink/?linkid=3859) page Web. Il n’existe aucune restriction sur le numéro de port.  
  
 Si plusieurs ordinateurs sources envoient des messages de multidiffusion et que vous souhaitez une file d’attente spécifique pour recevoir des messages à partir d’un seul ordinateur source, chaque ordinateur source doit envoyer des messages à une combinaison différente de l’adresse IP et port numéro.  
  
 Pour dissocier une file d’attente à partir d’une adresse de multidiffusion, définissez le <xref:System.Messaging.MessageQueue.MulticastAddress%2A> en une chaîne de longueur nulle. Ne la définissez pas sur `null`, car cela entraîne une <xref:System.ArgumentNullException>.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Path : string with get, set" Usage="System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le chemin d'accès de la file d'attente. Le paramétrage de <see cref="P:System.Messaging.MessageQueue.Path" /> force <see cref="T:System.Messaging.MessageQueue" /> à pointer vers une nouvelle file d'attente.</summary>
        <value>File d'attente référencée par <see cref="T:System.Messaging.MessageQueue" />. La valeur par défaut varie en fonction du constructeur <see cref="M:System.Messaging.MessageQueue.#ctor" /> utilisé. Elle est égale à <see langword="null" /> ou elle est spécifiée par le paramètre <paramref name="path" /> du constructeur.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La syntaxe pour le <xref:System.Messaging.MessageQueue.Path%2A> propriété varie selon le type de file d’attente il points to, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
|File d’attente du journal|`MachineName`\\`QueueName`\\`Journal$`|  
|File d’attente du journal machine|`MachineName`\\`Journal$`|  
|File d’attente de lettres mortes machine|`MachineName`\\`Deadletter$`|  
|File d’attente de lettres mortes transactionnelle machine|`MachineName`\\`XactDeadletter$`|  
  
 Utilisez «. » pour représenter l’ordinateur local.  
  
 Le <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, et <xref:System.Messaging.MessageQueue.QueueName%2A> propriétés sont liées. Modification de la <xref:System.Messaging.MessageQueue.MachineName%2A> propriété entraîne le <xref:System.Messaging.MessageQueue.Path%2A> propriété à modifier. Il est construit à partir de la nouvelle <xref:System.Messaging.MessageQueue.MachineName%2A> et <xref:System.Messaging.MessageQueue.QueueName%2A>. Modification de la <xref:System.Messaging.MessageQueue.Path%2A> (par exemple, pour utiliser la syntaxe de nom de format) réinitialise le <xref:System.Messaging.MessageQueue.MachineName%2A> et <xref:System.Messaging.MessageQueue.QueueName%2A> propriétés pour faire référence à la nouvelle file d’attente.  
  
 Vous pouvez également utiliser le <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> pour décrire le chemin d’accès de la file d’attente, comme indiqué dans le tableau suivant.  
  
|Référence|Syntaxe|Exemple|  
|---------------|------------|-------------|  
|Nom du format|`FormatName:` [ *nom de format* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Ajouter des contrôles|`Label:` [ *étiquette* ]|`Label:` TheLabel|  
  
 Si vous utilisez la syntaxe de l’étiquette pour le <xref:System.Messaging.MessageQueue.Path%2A> propriété lorsque vous envoyez le message, une exception est levée si le <xref:System.Messaging.MessageQueue.Label%2A> n’est pas unique.  
  
 Pour travailler hors connexion, vous devez utiliser la syntaxe de nom de format, plutôt que la syntaxe du nom convivial de la première table. Sinon, une exception est levée, car le contrôleur de domaine principal (sur lequel Active Directory réside) n’est pas disponible pour résoudre le chemin d’accès au nom de format.  
  
 Définition d’un nouveau chemin d’accès ferme la file d’attente et libère tous les handles.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Oui|  
  
> [!NOTE]
>  En mode de groupe de travail, vous pouvez uniquement utiliser des files d’attente privées. Vous spécifiez le chemin d’accès à l’aide de la syntaxe de la file d’attente privée `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 L’exemple de code suivant crée de nouveaux <xref:System.Messaging.MessageQueue> objets à l’aide de divers types de syntaxe de nom de chemin d’accès. Dans chaque cas, il envoie un message à la file d’attente dont le chemin est défini dans le constructeur.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le chemin d'accès n'est pas valide. La syntaxe utilisée est sans doute incorrecte.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <summary>Retourne une copie du premier message dans la file d'attente, sans supprimer le message de la file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; System.Messaging.Message" Usage="messageQueue.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retourne (lit) le premier message figurant dans la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" /> sans le supprimer. La méthode <see cref="M:System.Messaging.MessageQueue.Peek" /> étant synchrone, elle bloque le thread en cours jusqu'à ce qu'un message soit disponible.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> représentant le premier message dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour lire une file d’attente ou d’attendre un message existe dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode lit, mais ne supprime pas le premier message de la file d’attente. Par conséquent, les appels répétés à <xref:System.Messaging.MessageQueue.Peek%2A> retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), quant à eux, lit et supprime le premier message à partir de la file d’attente. Les appels répétés à <xref:System.Messaging.MessageQueue.Receive%2A>, par conséquent, renvoyer différents messages.  
  
 Message Queuing classe les messages dans la file d’attente en fonction de l’heure d’arrivée et de priorité. Un nouveau message est placé avant un ancien uniquement s’il s’agit d’une priorité plus élevée.  
  
 Utilisez <xref:System.Messaging.MessageQueue.Peek%2A> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Étant donné que cette surcharge ne spécifie pas un délai d’attente, l’application risque d’attendre indéfiniment. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchrone. Vous pouvez également spécifier un délai d’expiration pour un message arrive dans la file d’attente à l’aide de la surcharge de <xref:System.Messaging.MessageQueue.Peek%2A> qui spécifie un délai d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 Les exemples suivants utilisent la <xref:System.Messaging.MessageQueue.Peek%2A> méthode sur une file d’attente.  
  
 Dans le premier exemple, l’application attend un message est disponible dans la file d’attente. Notez que le premier exemple n’accède pas au message qui arrive ; il suspend simplement le traitement jusqu'à l’arrivée d’un message. Si un message existe déjà dans la file d’attente, elle retournera immédiatement.  
  
 Dans le deuxième exemple, un message qui contient un défini par l’application `Order` classe est envoyé à la file d’attente et puis lu à partir de la file d’attente.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Peek timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique le délai maximal à attendre pour l'arrivée d'un message dans la file d'attente.</param>
        <summary>Retourne (lit) le premier message figurant dans la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" /> sans le supprimer. La méthode <see cref="M:System.Messaging.MessageQueue.Peek" /> étant synchrone, elle bloque le thread en cours jusqu'à ce qu'un message soit disponible ou que le délai spécifié expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> représentant le premier message dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour lire une file d’attente ou à attendre une période spécifiée jusqu'à ce qu’un message existe dans la file d’attente. La méthode retourne immédiatement si un message existe déjà dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode lit, mais ne supprime pas le premier message de la file d’attente. Par conséquent, les appels répétés à <xref:System.Messaging.MessageQueue.Peek%2A> retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), quant à eux, lit et supprime le premier message à partir de la file d’attente. Les appels répétés à <xref:System.Messaging.MessageQueue.Receive%2A>, par conséquent, renvoyer différents messages.  
  
 Message Queuing classe les messages dans la file d’attente en fonction de l’heure d’arrivée et de priorité. Un nouveau message est placé avant un ancien uniquement s’il s’agit d’une priorité plus élevée.  
  
 Utilisez <xref:System.Messaging.MessageQueue.Peek%2A> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Le thread reste bloqué durant la période spécifiée, ou indéfiniment si vous avez indiqué <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchrone.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 Le code suivant exemple utilise le <xref:System.Messaging.MessageQueue.Peek%2A> méthode avec un délai d’attente de zéro pour vérifier si la file d’attente est vide.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberSignature Language="F#" Value="member this.Peek : TimeSpan * System.Messaging.Cursor * System.Messaging.PeekAction -&gt; System.Messaging.Message" Usage="messageQueue.Peek (timeout, cursor, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique le délai maximal à attendre pour l'arrivée d'un message dans la file d'attente.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <param name="action">Une des valeurs de <see cref="T:System.Messaging.PeekAction" />. Indique s'il faut lire le message en cours dans la file d'attente ou le message suivant.</param>
        <summary>Retourne (lit) le message actuel ou le message suivant de la file d'attente sans le supprimer, à l'aide du curseur spécifié. La méthode <see cref="M:System.Messaging.MessageQueue.Peek" /> étant synchrone, elle bloque le thread en cours jusqu'à ce qu'un message soit disponible ou que le délai spécifié expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> qui représente un message dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour lire une file d’attente ou à attendre une période spécifiée jusqu'à ce qu’un message existe dans la file d’attente. La méthode retourne immédiatement si un message existe déjà dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode lit, mais ne supprime pas un message à partir de la file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> (méthode), quant à eux, lit et supprime un message à partir de la file d’attente.  
  
 Utilisez <xref:System.Messaging.MessageQueue.Peek%2A> lorsque le thread en cours peut faire l'objet d'un blocage en attendant l'arrivée d'un message dans la file d'attente. Le thread est bloqué jusqu'à la période spécifiée, ou indéfiniment si vous avez indiqué <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Si vous souhaitez que le traitement de l'application se poursuive sans attendre, utilisez la méthode <xref:System.Messaging.MessageQueue.BeginPeek%2A> asynchrone.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Une valeur autre que <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> a été spécifiée pour le paramètre <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="cursor" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il est possible que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lit un message qui correspond à un identificateur de corrélation donné.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à lire.</param>
        <summary>Lit le message qui correspond à l'identificateur de corrélation donné et lève immédiatement une exception si la file ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Si aucun message ne correspondant est trouvé le `correlationID` paramètre, une exception est levée.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes vous permettent de lire des messages dans une file d’attente. Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message qui contient une commande vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="correlationId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à lire.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <summary>Lit le message qui correspond à l'identificateur de corrélation donné puis attend qu'un message ayant l'identificateur spécifié soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Si aucun message ne correspondant est trouvé le `correlationID` paramètre et aucun nouveau message arrive dans la file d’attente au sein de la période spécifiée par le `timeout` paramètre, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.CorrelationId%2A> du nouveau message pour voir si elle correspond à la `correlationId` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.CorrelationId%2A> correspond à la `correlationId` paramètre.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes vous permettent de lire des messages dans une file d’attente. Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le message ayant le paramètre <paramref name="correlationId" /> spécifié n'existe pas dans la file d'attente et n'est pas arrivé avant l'expiration du délai d'attente.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Un message n'est pas arrivé avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retourne une copie du message portant l'identificateur de message spécifié, sans supprimer le message de la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string -&gt; System.Messaging.Message" Usage="messageQueue.PeekById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à lire.</param>
        <summary>Lit le message dont l'identificateur de message correspond au paramètre <paramref name="id" />.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> à lire, sans le supprimer à partir de la file d’attente, un message comportant un identificateur de message connu. L’identificateur d’un message est unique au sein de l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre. Cette surcharge lève une exception si la file d’attente ne contient pas actuellement le message.  
  
 Deux autres méthodes vous permettent de lire des messages dans une file d’attente : <xref:System.Messaging.MessageQueue.Peek%2A> et <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne le premier message dans la file d’attente ; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> renvoie un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Il n'existe aucun message avec le paramètre <paramref name="id" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.PeekById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.PeekById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à lire.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <summary>Lit le message dont l'identificateur de message correspond au paramètre <paramref name="id" />. Attend que le message s'affiche dans la file d'attente ou que le délai expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> à lire, sans le supprimer à partir de la file d’attente, un message comportant un identificateur de message connu. L’identificateur d’un message est unique au sein de l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre. Cette surcharge lève une exception si la file d’attente ne contient le message et un nouveau message n’arrive pas avant l’expiration du délai.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.Id%2A> du nouveau message pour voir si elle correspond à la `id` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.Id%2A> correspond à la `id` paramètre.  
  
 Deux autres méthodes vous permettent de lire des messages dans une file d’attente : <xref:System.Messaging.MessageQueue.Peek%2A> et <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne le premier message dans la file d’attente ; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> renvoie un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le message avec le paramètre <paramref name="id" /> spécifié n'existe pas dans la file d'attente et n'est pas arrivé avant l'expiration du délai d'attente spécifié par le paramètre <paramref name="timeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Présentation dans MSMQ 3.0. Lit un message spécifique de la file d'attente. Le message peut être spécifié par un identificateur de recherche ou par sa position au début ou à la fin de la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Propriété <see cref="P:System.Messaging.Message.LookupId" /> du message à lire.</param>
        <summary>Présentation dans MSMQ 3.0. Lit le message qui correspond à l'identificateur de recherche donné d'une file d'attente non transactionnelle.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.LookupId" /> correspond au paramètre <paramref name="lookupId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur de recherche connu sans le supprimer de la file d’attente. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété d’un message unique à la file d’attente où réside le message, il y aura au plus un message dans la file d’attente qui correspond à la donnée `lookupId` paramètre.  
  
 Pour lire un message avec un identificateur de recherche spécifié et le supprime de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (méthode).  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="lookupId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="F#" Value="member this.PeekByLookupId : System.Messaging.MessageLookupAction * int64 -&gt; System.Messaging.Message" Usage="messageQueue.PeekByLookupId (action, lookupId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">L'une des valeurs <see cref="T:System.Messaging.MessageLookupAction" />, spécifiant comment le message est lu dans la file d'attente. Spécifiez l'une des valeurs suivantes : 
 <see langword="MessageLookupAction.Current" /> : affiche un aperçu du message spécifié par <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" /> : affiche un aperçu du message qui suit le message spécifié par <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" /> : affiche un aperçu du message qui précède le message spécifié par <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" /> : lit le premier message de la file d'attente. Le paramètre <c>lookupId</c> doit avoir la valeur 0.  
  
 <see langword="MessageLookupAction.Last" /> : lit le dernier message de la file d'attente. Le paramètre <c>lookupId</c> doit avoir la valeur 0.</param>
        <param name="lookupId">Propriété <see cref="P:System.Messaging.Message.LookupId" /> du message à lire ou 0. 0 est utilisé lors de l'accès au premier ou dernier message de la file d'attente.</param>
        <summary>Présentation dans MSMQ 3.0. Lit un message spécifique de la file d'attente. Le message peut être spécifié par un identificateur de recherche ou par sa position au début ou à la fin de la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> spécifié par les paramètres <paramref name="action" /> et <paramref name="lookupId" /> passés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur de recherche connu sans le supprimer de la file d’attente. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété d’un message unique à la file d’attente où réside le message, il y aura au plus un message dans la file d’attente qui correspond à la donnée `lookupId` paramètre.  
  
 Pour lire un message avec l’identificateur spécifié et le supprime de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (méthode).  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="lookupId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="action" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberSignature Language="F#" Value="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " Usage="member this.PeekCompleted : System.Messaging.PeekCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un message est lu sans être supprimé de la file d'attente. Cela se produit lors de l'opération asynchrone résultant de la méthode <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> est utilisé dans le traitement asynchrone pour déclencher le <xref:System.Messaging.MessageQueue.PeekCompleted> événement lorsqu’un message est disponible dans la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> permet de terminer l’opération lancée par un appel à <xref:System.Messaging.MessageQueue.BeginPeek%2A> et de lire le message lorsque le <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché.  
  
 Lorsque vous créez un délégué <xref:System.Messaging.PeekCompletedEventHandler>, vous identifiez la méthode qui gérera l'événement. Pour associer l'événement au gestionnaire d'événements, ajoutez une instance du délégué à l'événement. Le gestionnaire d'événements est appelé chaque fois qu'un événement se produit, sauf si vous supprimez le délégué. Pour plus d’informations sur les délégués de gestionnaire d’événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un gestionnaire d’événements nommé `MyPeekCompleted`, attache à la <xref:System.Messaging.MessageQueue.PeekCompleted> délégué de gestionnaire d’événements et les appels <xref:System.Messaging.MessageQueue.BeginPeek%2A> pour lancer une opération de lecture asynchrone sur la file d’attente qui se trouve dans le chemin d’accès ». \myQueue ». Quand un <xref:System.Messaging.MessageQueue.PeekCompleted> événement est déclenché, l’exemple lit le message et écrit son corps à l’écran. L’exemple appelle ensuite <xref:System.Messaging.MessageQueue.BeginPeek%2A> à nouveau pour lancer une nouvelle opération de lecture asynchrone  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberSignature Language="F#" Value="member this.Purge : unit -&gt; unit" Usage="messageQueue.Purge " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime tous les messages contenus dans la file d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Provoque la purge de la file d’attente Message Queuing définir l’indicateur de modification de file d’attente, ce qui affecte le <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriété. Les messages qui sont purgés de la file d’attente sont perdus ; elles ne sont pas envoyées à la file d’attente de lettres mortes ou de la file d’attente du journal.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.QueueName : string with get, set" Usage="System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom convivial qui identifie la file d'attente.</summary>
        <value>Nom identifiant la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />. La valeur doit être différente de <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez combiner la <xref:System.Messaging.MessageQueue.QueueName%2A> avec la <xref:System.Messaging.MessageQueue.MachineName%2A> pour créer un convivial <xref:System.Messaging.MessageQueue.Path%2A> nom de la file d’attente. La syntaxe de nom convivial de la <xref:System.Messaging.MessageQueue.Path%2A> propriété varie selon le type de file d’attente, comme indiqué dans le tableau suivant.  
  
|Type de file d’attente|Syntaxe|  
|----------------|------------|  
|File d’attente publique|`MachineName`\\`QueueName`|  
|File d’attente privée|`MachineName`\\`Private$`\\`QueueName`|  
|File d’attente du journal|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Utilisez «. » pour représenter l’ordinateur local.  
  
 Modification de la <xref:System.Messaging.MessageQueue.QueueName%2A> propriété affecte le <xref:System.Messaging.MessageQueue.Path%2A> propriété. Si vous définissez la <xref:System.Messaging.MessageQueue.QueueName%2A> sans paramètre la <xref:System.Messaging.MessageQueue.MachineName%2A> propriété, le <xref:System.Messaging.MessageQueue.Path%2A> propriété devient.\\ `QueueName`. Sinon, le <xref:System.Messaging.MessageQueue.Path%2A> devient `MachineName` \\ `QueueName`.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Oui|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.QueueName%2A> propriété.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Le nom de la file d'attente est <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadHandle : nativeint" Usage="System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle natif utilisé pour la lecture des messages à partir de la file d'attente de messages.</summary>
        <value>Handle de l'objet file d'attente natif utilisé pour la lecture et la réception des messages à partir de la file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.ReadHandle%2A> fournit un handle Windows natif pour l’objet de file d’attente de messages qui est utilisé pour la lecture et la réception des messages à partir de la file d’attente. Si vous modifiez le chemin d’accès de la file d’attente, le handle est fermé et rouverte avec une nouvelle valeur.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <summary>Reçoit (et supprime) le premier message figurant dans la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberSignature Language="F#" Value="member this.Receive : unit -&gt; System.Messaging.Message" Usage="messageQueue.Receive " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reçoit le premier message disponible dans la file référencée par <see cref="T:System.Messaging.MessageQueue" />. Cet appel synchrone bloque le thread d'exécution en cours jusqu'à ce qu'un message soit disponible.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente, ou attendre jusqu'à ce qu’il existe des messages dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente ou des messages de priorité plus élevée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Étant donné que cette surcharge de la <xref:System.Messaging.MessageQueue.Receive%2A> méthode spécifie un délai d’attente infini, l’application risque d’attendre indéfiniment. Si le traitement de l’application doit se poursuivre sans attendre le message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un message à partir d’une file d’attente et génère des informations sur ce message à l’écran.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le premier message disponible dans la file d'attente transactionnelle référencée par <see cref="T:System.Messaging.MessageQueue" />. Cet appel synchrone bloque le thread d'exécution en cours jusqu'à ce qu'un message soit disponible.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente transactionnelle en utilisant le contexte de transaction interne défini par le `transaction` paramètre ou attendez qu’il existe des messages dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y aurait rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Étant donné que cette surcharge de la <xref:System.Messaging.MessageQueue.Receive%2A> méthode spécifie un délai d’attente infini, l’application risque d’attendre indéfiniment. Si le traitement de l’application doit se poursuivre sans attendre le message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à une file d’attente transactionnelle sur l’ordinateur local et envoie un message à la file d’attente. Ensuite, il reçoit le message qui contient une commande. S’il rencontre une file d’attente non transactionnelle, il lève exception et restaure la transaction.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.  
  
- ou - 
La file d'attente n'est pas transactionnelle.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le premier message disponible dans la file référencée par <see cref="T:System.Messaging.MessageQueue" />. Cet appel synchrone bloque le thread d'exécution en cours jusqu'à ce qu'un message soit disponible.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente à l’aide d’un contexte de transaction défini par le `transactionType` paramètre ou attendez qu’il existe des messages dans la file d’attente.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y aurait rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Étant donné que cette surcharge de la <xref:System.Messaging.MessageQueue.Receive%2A> méthode spécifie un délai d’attente infini, l’application risque d’attendre indéfiniment. Si le traitement de l’application doit se poursuivre sans attendre le message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.Receive timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <summary>Reçoit le premier message disponible dans la file d'attente référencée par <see cref="T:System.Messaging.MessageQueue" /> et attend qu'un message soit disponible dans la file ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message et effectuer un retour dans un délai spécifié si la file d'attente ne contient aucun message.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, la suppression de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente ou des messages de priorité plus élevée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Le thread sera bloqué pendant la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre. Si le traitement de l’application doit se poursuivre sans attendre de message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant reçoit un message à partir d’une file d’attente et génère des informations sur ce message à l’écran. L’exemple suspend l’exécution pendant cinq secondes en attendant un message arrive dans la file d’attente.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <summary>Reçoit le message en cours dans la file d'attente, à l'aide d'un curseur spécifié. Si aucun message n'est disponible, cette méthode attend qu'un message soit disponible ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing. 
Utilisez cette surcharge pour recevoir un message et effectuer un retour dans un délai spécifié si la file d'attente ne contient aucun message.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le premier message disponible dans la file d'attente transactionnelle référencée par <see cref="T:System.Messaging.MessageQueue" /> et attend qu'un message soit disponible dans la file d'attente ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente transactionnelle en utilisant le contexte de transaction interne défini par le `transaction` paramètre et le retourner dans une période spécifiée s’il en existe aucun message dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y aurait rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Le thread sera bloqué pendant la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre. Si le traitement de l’application doit se poursuivre sans attendre de message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le premier message disponible dans la file référencée par <see cref="T:System.Messaging.MessageQueue" />. Cet appel est synchrone et attend qu'un message soit disponible dans la file d'attente ou que le délai expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> référençant le premier message disponible dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente à l’aide d’un contexte de transaction défini par le `transactionType` paramètre et retour dans une période spécifiée s’il en existe aucun message dans la file d’attente.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire le premier message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Le <xref:System.Messaging.MessageQueue.Peek%2A> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y aurait rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Le thread sera bloqué pendant la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre. Si le traitement de l’application doit se poursuivre sans attendre de message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de cette méthode.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le message en cours dans la file d'attente, à l'aide d'un curseur spécifié. Si aucun message n'est disponible, cette méthode attend qu'un message soit disponible ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> qui référence un message dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente transactionnelle en utilisant le contexte de transaction interne défini par le `transaction` paramètre et le retourner dans une période spécifiée s’il en existe aucun message dans la file d’attente.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire un message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y a rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Le thread est bloqué pour la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre. Si le traitement de l’application doit se poursuivre sans attendre de message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="cursor" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il est possible que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Receive : TimeSpan * System.Messaging.Cursor * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.Receive (timeout, cursor, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="cursor">
          <see cref="T:System.Messaging.Cursor" /> qui conserve une position spécifique dans la file d'attente de messages.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> qui décrit le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le message en cours dans la file d'attente, à l'aide d'un curseur spécifié. Si aucun message n'est disponible, cette méthode attend qu'un message soit disponible ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> qui référence un message dans la file d'attente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour recevoir un message d’une file d’attente à l’aide d’un contexte de transaction défini par le `transactionType` paramètre et retour dans une période spécifiée s’il en existe aucun message dans la file d’attente.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode permet la lecture synchrone d’un message, en le supprimant de la file d’attente. Les appels suivants à <xref:System.Messaging.MessageQueue.Receive%2A> retourne les messages qui suivent dans la file d’attente.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire un message dans une file d’attente sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.Peek%2A> (méthode). Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.Peek%2A>. Étant donné que <xref:System.Messaging.MessageQueue.Peek%2A> ne supprime aucun message dans la file d’attente, il n’y a rien à restaurer par un appel à <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Utilisez un appel à <xref:System.Messaging.MessageQueue.Receive%2A> quand il est acceptable pour le thread en cours peut être bloquée pendant qu’il attend un message arrive dans la file d’attente. Le thread est bloqué pour la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre. Si le traitement de l’application doit se poursuivre sans attendre de message, envisagez d’utiliser la méthode asynchrone, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="cursor" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il est possible que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <threadsafe>La méthode n’est pas thread-safe.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reçoit un message qui correspond à un identificateur de corrélation donné.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId correlationId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné (à partir d'une file d'attente non transactionnelle), et lève immédiatement une exception si la file ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente non transactionnelle référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Si aucun message ne correspondant est trouvé le `correlationID` paramètre, une exception est levée. Sinon, le message est supprimé de la file d’attente et renvoyé à l’application.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode récupère un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message qui contient une commande vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="correlationId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné (à partir d'une file d'attente transactionnelle), et lève immédiatement une exception si la file ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente transactionnelle référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Si aucun message ne correspondant est trouvé le `correlationID` paramètre, une exception est levée. Sinon, le message est supprimé de la file d’attente et renvoyé à l’application à l’aide du contexte de transaction interne défini par le `transaction` paramètre.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="correlationId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné et lève immédiatement une exception si la file d'attente ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Si aucun message ne correspondant est trouvé le `correlationID` paramètre, une exception est levée. Sinon, le message est supprimé de la file d’attente et renvoyé à l’application à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="correlationId" /> spécifié.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné, (à partir d'une file non transactionnelle), puis attend qu'un message ayant cet identificateur soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente non transactionnelle référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Cette méthode retourne immédiatement si le message avec l’identificateur de corrélation spécifié par le `correlationId` paramètre figure dans la file d’attente. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.CorrelationId%2A> du nouveau message pour voir si elle correspond à la `correlationId` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.CorrelationId%2A> correspond à la `correlationId` paramètre.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le message ayant le paramètre <paramref name="correlationId" /> spécifié n'existe pas dans la file d'attente et n'est pas arrivé avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné, (à partir d'une file d'attente transactionnelle), puis attend qu'un message ayant cet identificateur soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente transactionnelle référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Cette méthode retourne immédiatement si le message avec l’identificateur de corrélation spécifié par le `correlationId` paramètre figure dans la file d’attente, en utilisant le contexte de transaction interne défini par le `transaction` paramètre. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.CorrelationId%2A> du nouveau message pour voir si elle correspond à la `correlationId` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.CorrelationId%2A> correspond à la `correlationId` paramètre.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le message ayant le paramètre <paramref name="correlationId" /> spécifié n'existe pas dans la file d'attente et n'est pas arrivé avant l'expiration du délai d'attente.  
  
- ou - 
La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByCorrelationId : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByCorrelationId (correlationId, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">Propriété <see cref="P:System.Messaging.Message.CorrelationId" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le message qui correspond à l'identificateur de corrélation donné, puis attend qu'un message ayant l'identificateur spécifié soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.CorrelationId" /> correspond au paramètre <paramref name="correlationId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode recherche dans la file d’attente référencée par le <xref:System.Messaging.MessageQueue> pour un message dont <xref:System.Messaging.Message.CorrelationId%2A> correspond à spécifié `correlationId` paramètre. Cette méthode retourne immédiatement si le message avec l’identificateur de corrélation spécifié par le `correlationId` paramètre figure dans la file d’attente, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.CorrelationId%2A> du nouveau message pour voir si elle correspond à la `correlationId` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.CorrelationId%2A> correspond à la `correlationId` paramètre. Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Le <xref:System.Messaging.Message.CorrelationId%2A> propriété est utilisée pour lier un message envoyé à la file d’attente des messages de réponse, un rapport ou d’accusé de réception sont associés.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> méthode est utilisée pour récupérer un message en spécifiant son identificateur unique.  
  
 Pour lire un message avec un identificateur de corrélation spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="correlationId" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="correlationId" /> spécifié.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Le message ayant le paramètre <paramref name="correlationId" /> spécifié n'existe pas dans la file d'attente et n'est pas arrivé avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Reçoit le message qui correspond à l'identificateur donné et le supprime de la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <summary>Reçoit le message qui correspond à l'identificateur spécifié à partir d'une file d'attente non transactionnelle, et lève immédiatement une exception si la file ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="id" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le message qui correspond à l'identificateur spécifié (à partir d'une file d'attente transactionnelle), et lève immédiatement une exception si la file ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente, en utilisant le contexte de transaction interne défini par le `transaction` paramètre. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="id" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le message qui correspond à l'identificateur spécifié et lève immédiatement une exception si la file d'attente ne contient aucun message correspondant à cet identificateur.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente. Sinon, le message est supprimé de la file d’attente et renvoyé à l’application à l’aide d’un contexte de transaction défini par le `transactionType` paramètre.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre. Si le message avec l’identificateur spécifié est dans une file d’attente autre que celui associé à cet <xref:System.Messaging.MessageQueue> instance, le message sera introuvable.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="id" /> spécifié.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <summary>Reçoit le message qui correspond à l'identificateur donné (à partir d'une file d'attente non transactionnelle), puis attend qu'un message ayant cet identificateur soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente. Cette méthode retourne immédiatement si le message avec l’identificateur spécifié par le `id` paramètre figure dans la file d’attente. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.Id%2A> du nouveau message pour voir si elle correspond à la `id` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.Id%2A> correspond à la `id` paramètre.  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre.  
  
 Utilisez cette surcharge de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quand il est acceptable pour le thread en cours peut être bloqué en tant que nouveaux messages continuent d’arriver dans la file d’attente dans le délai d’attente spécifié par le `timeout` paramètre. Le thread sera bloqué pendant au moins la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre, ou si de nouveaux messages continuent d’arriver dans la file d’attente dans le délai d’attente spécifié par le `timeout` paramètre.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message possédant le paramètre <paramref name="id" /> spécifié n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Reçoit le message qui correspond à l'identificateur donné (à partir d'une file d'attente transactionnelle), puis attend qu'un message ayant cet identificateur soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente, en utilisant le contexte de transaction interne défini par le `transaction` paramètre. Cette méthode retourne immédiatement si le message avec l’identificateur spécifié par le `id` paramètre figure dans la file d’attente. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.Id%2A> du nouveau message pour voir si elle correspond à la `id` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.Id%2A> correspond à la `id` paramètre.  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre.  
  
 Utilisez cette surcharge de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quand il est acceptable pour le thread en cours peut être bloqué en tant que nouveaux messages continuent d’arriver dans la file d’attente dans le délai d’attente spécifié par le `timeout` paramètre. Le thread sera bloqué pendant au moins la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre, ou si de nouveaux messages continuent d’arriver dans la file d’attente dans le délai spécifié par le `timeout` paramètre.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message possédant le paramètre <paramref name="id" /> spécifié n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
La file d'attente n'est pas transactionnelle.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveById : string * TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveById (id, timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">Propriété <see cref="P:System.Messaging.Message.Id" /> du message à recevoir.</param>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> qui indique la durée d'attente avant qu'un nouveau message ne soit accessible pour consultation.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Reçoit le message qui correspond à l'identificateur donné, puis attend qu'un message ayant l'identificateur spécifié soit disponible dans la file d'attente, ou que le délai d'attente expire.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.Id" /> correspond au paramètre <paramref name="id" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur connu et le supprimer de la file d’attente. Cette méthode retourne immédiatement si le message avec l’identificateur spécifié par le `id` paramètre figure dans la file d’attente, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Sinon, la méthode attend pendant la période donnée pour un nouveau message arrive. Si un nouveau message n’arrive pas avant l’expiration du délai d’attente, une exception est levée.  
  
 Le `timeout` paramètre ne spécifie pas le temps pour cette méthode d’exécution total. Au lieu de cela, il spécifie la durée d’attente pour un nouveau message arrive dans la file d’attente. Chaque fois qu’un nouveau message arrive, cette méthode examine les <xref:System.Messaging.Message.Id%2A> du nouveau message pour voir si elle correspond à la `id` paramètre. Si ce n’est pas le cas, cette méthode recommence le délai d’attente et attend un autre nouveau message arrive. Par conséquent, si de nouveaux messages continuent d’arriver dans le délai d’attente, il est possible pour cette méthode pour continuer à s’exécuter indéfiniment, jusqu'à ce que le délai d’attente expire sans aucun nouveau message, ou jusqu'à l’arrivée d’un message dont la propriété <xref:System.Messaging.Message.Id%2A> correspond à la `id` paramètre.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Le <xref:System.Messaging.Message.Id%2A> propriété d’un message est unique dans l’entreprise Message Queuing, il y aura au plus un message dans la file d’attente qui correspond à la donnée `id` paramètre. Si le message avec l’identificateur spécifié est dans une file d’attente autre que celui associé à cet <xref:System.Messaging.MessageQueue> instance, le message sera introuvable.  
  
 Utilisez cette surcharge de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quand il est acceptable pour le thread en cours peut être bloqué en tant que nouveaux messages continuent d’arriver dans la file d’attente dans le délai d’attente spécifié par le `timeout` paramètre. Le thread sera bloqué pendant au moins la période donnée, ou indéfiniment si vous avez spécifié la valeur <xref:System.Messaging.MessageQueue.InfiniteTimeout> pour le `timeout` paramètre, ou si de nouveaux messages continuent d’arriver dans la file d’attente dans le délai d’attente spécifié par le `timeout` paramètre.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Deux autres méthodes permettent de recevoir des messages à partir d’une file d’attente. Le <xref:System.Messaging.MessageQueue.Receive%2A> méthode retourne le premier message dans la file d’attente et le <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> méthode est utilisée pour récupérer un accusé de réception, un rapport ou un message de réponse générés par l’application qui a été créé à la suite d’un message envoyé à la file d’attente.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> (méthode). Le <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> méthode retourne toujours le premier message dans la file d’attente, les appels suivants à la méthode retournent le même message, sauf si un message de priorité plus élevé arrive dans la file d’attente. Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Étant donné que <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ne supprime aucun message dans la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="id" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour le paramètre <paramref name="timeout" /> n'est pas valide. Il se peut que <paramref name="timeout" /> soit inférieur à <see cref="F:System.TimeSpan.Zero" /> ou supérieur à <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Aucun message possédant le paramètre <paramref name="id" /> spécifié n'est arrivé dans la file d'attente avant l'expiration du délai d'attente.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Présentation dans MSMQ 3.0. Reçoit un message spécifique de la file d'attente. Le message peut être spécifié par un identificateur de recherche ou par sa position au début ou à la fin de la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : int64 -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId lookupId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">Propriété <see cref="P:System.Messaging.Message.LookupId" /> du message à recevoir.</param>
        <summary>Présentation dans MSMQ 3.0. Reçoit le message qui correspond à l'identificateur de recherche donné d'une file d'attente non transactionnelle.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> dont la propriété <see cref="P:System.Messaging.Message.LookupId" /> correspond au paramètre <paramref name="lookupId" /> passé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur de recherche connu et le supprimer de la file d’attente. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété d’un message unique à la file d’attente où réside le message, il y aura au plus un message dans la file d’attente qui correspond à la donnée `lookupId` paramètre.  
  
 Pour lire un message avec un identificateur de recherche spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (méthode).  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="lookupId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">L'une des valeurs <see cref="T:System.Messaging.MessageLookupAction" />, spécifiant comment le message est lu dans la file d'attente. Spécifiez l'une des valeurs suivantes : 
 <see langword="MessageLookupAction.Current" /> : reçoit le message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.Next" /> : reçoit le message qui suit message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.Previous" /> : reçoit le message qui précède le message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.First" /> : reçoit le premier message de la file d'attente et le supprime de la file. Le paramètre <c>lookupId</c> doit avoir la valeur 0.  
  
 <see langword="MessageLookupAction.Last" /> : reçoit le dernier message de la file d'attente et le supprime de la file. Le paramètre <c>lookupId</c> doit avoir la valeur 0.</param>
        <param name="lookupId">Propriété <see cref="P:System.Messaging.Message.LookupId" /> du message à recevoir ou 0. 0 est utilisé lors de l'accès au premier ou dernier message de la file d'attente.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Présentation dans MSMQ 3.0. Reçoit un message spécifique d'une file d'attente transactionnelle. Le message peut être spécifié par un identificateur de recherche ou par sa position au début ou à la fin de la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> spécifié par les paramètres <paramref name="lookupId" /> et <paramref name="action" /> passés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur de recherche connu et le supprimer de la file d’attente, à l’aide d’un contexte de transaction défini par le `transaction` paramètre. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété d’un message unique à la file d’attente où réside le message, il y aura au plus un message dans la file d’attente qui correspond à la donnée `lookupId` paramètre.  
  
 Étant donné que cette méthode est appelée sur une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (méthode). Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> ne supprime pas tous les messages à partir de la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="lookupId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.  
  
- ou - 
La file d'attente n'est pas transactionnelle.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="action" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.ReceiveByLookupId : System.Messaging.MessageLookupAction * int64 * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageQueue.ReceiveByLookupId (action, lookupId, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">L'une des valeurs <see cref="T:System.Messaging.MessageLookupAction" />, spécifiant comment le message est lu dans la file d'attente. Spécifiez l'une des valeurs suivantes : 
 <see langword="MessageLookupAction.Current" /> : reçoit le message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.Next" /> : reçoit le message qui suit message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.Previous" /> : reçoit le message qui précède le message spécifié par <c>lookupId</c> et le supprime de la file d’attente.  
  
 <see langword="MessageLookupAction.First" /> : reçoit le premier message de la file d'attente et le supprime de la file. Le paramètre <c>lookupId</c> doit avoir la valeur 0.  
  
 <see langword="MessageLookupAction.Last" /> : reçoit le dernier message de la file d'attente et le supprime de la file. Le paramètre <c>lookupId</c> doit avoir la valeur 0.</param>
        <param name="lookupId">Propriété <see cref="P:System.Messaging.Message.LookupId" /> du message à recevoir ou 0. 0 est utilisé lors de l'accès au premier ou dernier message de la file d'attente.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Présentation dans MSMQ 3.0. Reçoit un message spécifique de la file d'attente, à l'aide du contexte de transaction spécifié. Le message peut être spécifié par un identificateur de recherche ou par sa position au début ou à la fin de la file d'attente.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> spécifié par les paramètres <paramref name="action" /> et <paramref name="lookupId" /> passés.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette méthode pour lire un message avec un identificateur de recherche connu et le supprimer de la file d’attente, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Cette méthode lève immédiatement une exception si le message n’est pas dans la file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété d’un message unique à la file d’attente où réside le message, il y aura au plus un message dans la file d’attente qui correspond à la donnée `lookupId` paramètre.  
  
 Pour lire un message avec l’identificateur spécifié sans le supprimer de la file d’attente, utilisez la <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> (méthode). Il n’existe aucun contexte de transaction associé à un message retourné par un appel à <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Étant donné que <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> ne supprime pas tous les messages à partir de la file d’attente, il n’y aurait rien à annulée si la transaction a été abandonnée.  
  
 Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour recevoir le message. Spécifiez `Single` si vous souhaitez recevoir le message comme une seule transaction interne. Vous pouvez spécifier `None` si vous souhaitez recevoir un message d’une file d’attente transactionnelle en dehors d’un contexte de transaction.  
  
 Si cette méthode est appelée pour recevoir un message à partir d’une file d’attente transactionnelle, le message est reçu est retourné à la file d’attente si la transaction est abandonnée. Le message n’est pas définitivement supprimé de la file d’attente jusqu'à ce que la transaction est validée.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Impossible de trouver le message avec le paramètre <paramref name="lookupId" /> spécifié.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="action" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageLookupAction" />.  
  
- ou - 
Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberSignature Language="F#" Value="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " Usage="member this.ReceiveCompleted : System.Messaging.ReceiveCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se produit lorsqu'un message a été supprimé de la file d'attente. Cet événement est déclenché par l'opération asynchrone <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> est utilisé dans le traitement asynchrone pour déclencher le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement lorsqu’un message est disponible dans la file d’attente.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> permet de terminer l’opération lancée par un appel à <xref:System.Messaging.MessageQueue.BeginReceive%2A> et de lire le message lorsque le <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché.  
  
 Lorsque vous créez un délégué <xref:System.Messaging.ReceiveCompletedEventHandler>, vous identifiez la méthode qui gérera l'événement. Pour associer l'événement au gestionnaire d'événements, ajoutez une instance du délégué à l'événement. Le gestionnaire d'événements est appelé chaque fois qu'un événement se produit, sauf si vous supprimez le délégué. Pour plus d’informations sur les délégués de gestionnaire d’événements, consultez [gestion et déclenchement d’événements](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 L’exemple de code suivant crée un gestionnaire d’événements nommé `MyReceiveCompleted`, attache à la <xref:System.Messaging.MessageQueue.ReceiveCompleted> délégué de gestionnaire d’événements et les appels <xref:System.Messaging.MessageQueue.BeginReceive%2A> pour lancer une opération de réception asynchrone sur la file d’attente qui se trouve dans le chemin d’accès ». \myQueue ». Quand un <xref:System.Messaging.MessageQueue.ReceiveCompleted> événement est déclenché, l’exemple reçoit le message et écrit son corps à l’écran. L’exemple appelle ensuite <xref:System.Messaging.MessageQueue.BeginReceive%2A> à nouveau pour lancer une nouvelle asynchrone opération de réception.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="messageQueue.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Actualise les propriétés présentées par <see cref="T:System.Messaging.MessageQueue" /> pour refléter l'état actuel de la ressource.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> synchronise les propriétés d’un <xref:System.Messaging.MessageQueue> avec les ressources serveur de Message Queuing qui lui sont associées. Si n’importe quelle propriété, tel que <xref:System.Messaging.MessageQueue.Label%2A> ou <xref:System.Messaging.MessageQueue.Category%2A>, a été modifié sur le serveur depuis le le <xref:System.Messaging.MessageQueue> a été créé, <xref:System.Messaging.MessageQueue.Refresh%2A> mises à jour le <xref:System.Messaging.MessageQueue> avec les nouvelles informations.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberSignature Language="F#" Value="member this.ResetPermissions : unit -&gt; unit" Usage="messageQueue.ResetPermissions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Réinitialise la liste des autorisations à l'aide des valeurs par défaut du système d'exploitation. Supprime les autorisations sur des files d'attente ajoutées à la liste par défaut.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous appelez <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, retourner de la liste des autorisations à ses valeurs par défaut. En général, il accorde le créateur de la file d’attente toutes les autorisations et donne au groupe tout le monde les droits suivants :  
  
-   Obtenir les propriétés de la file d’attente.  
  
-   Obtenir les autorisations de file d’attente.  
  
-   Écrire dans la file d’attente.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Envoie un objet dans la file d'attente.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="member this.Send : obj -&gt; unit" Usage="messageQueue.Send obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <summary>Envoie un objet à la file d'attente non transactionnelle référencée par ce <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente référencée par le <xref:System.Messaging.MessageQueue>. L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message> ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message.  
  
 Si vous utilisez cette surcharge pour envoyer un message à une file d’attente transactionnelle, le message sera envoyé à la file d’attente de lettres mortes. Si vous souhaitez que le message fasse partie d’une transaction qui contient d’autres messages, utilisez une surcharge qui accepte un <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> en tant que paramètre.  
  
 Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> et du message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant se connecte à une file d’attente et envoie un message à la file d’attente.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 L’exemple de code suivant envoie un défini par l’application `Order` classe à une file d’attente, puis reçoit un message à partir de cette file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envoie un objet à la file d'attente transactionnelle référencée par ce <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente transactionnelle référencée par le <xref:System.Messaging.MessageQueue>, à l’aide d’un contexte de transaction interne défini par le `transaction` paramètre. L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message> ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message.  
  
 Si vous utilisez cette surcharge pour envoyer un message à une file d’attente non transactionnelle, le message peut être envoyé à la file d’attente de lettres mortes sans lever d’exception.  
  
 Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> et du message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 <xref:System.Messaging.MessageQueueTransaction> cloisonnement prenant en charge, par conséquent si votre état de cloisonnement est `STA`, vous ne pouvez pas utiliser la transaction dans plusieurs threads. Visual Basic définit l’état du thread principal à `STA`, de sorte que vous devez appliquer le <xref:System.MTAThreadAttribute> dans le `Main` sous-routine. Sinon, l'envoi d'un message transactionnel qui utilise un autre thread lève une exception <xref:System.Messaging.MessageQueueException>. Vous appliquez le <xref:System.MTAThreadAttribute> en utilisant le fragment suivant.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L’exemple de code suivant envoie une chaîne vers une file d’attente transactionnelle et puis reçoit un message à partir de cette file d’attente.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
L'application Message Queuing a signalé une utilisation erronée de la transaction.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Envoie un objet à la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente référencée par le <xref:System.Messaging.MessageQueue>, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour envoyer le message. Spécifiez `Single` si vous souhaitez envoyer le message comme une transaction interne unique. Vous pouvez spécifier `None` si vous souhaitez envoyer un message transactionnel à un thread non transactionnel.  
  
 L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message> ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message.  
  
 Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> et du message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string -&gt; unit" Usage="messageQueue.Send (obj, label)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <param name="label">Étiquette du message.</param>
        <summary>Envoie un objet à la file d'attente non transactionnelle référencée par ce <see cref="T:System.Messaging.MessageQueue" /> et spécifie une étiquette pour le message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente référencée par le <xref:System.Messaging.MessageQueue>. Avec cette surcharge, vous pouvez spécifier l’étiquette de chaîne qui identifie le message. L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message>, une structure, un objet de données ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message.  
  
 L’étiquette du message est différent de l’étiquette de file d’attente de message, mais les deux sont dépendants de l’application et n’ont pas hériter de signification particulière pour Message Queuing.  
  
 Si vous utilisez cette surcharge pour envoyer un message à une file d’attente transactionnelle, le message sera envoyé à la file d’attente de lettres mortes. Si vous souhaitez que le message fasse partie d’une transaction qui contient d’autres messages, utilisez une surcharge qui accepte un <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> en tant que paramètre.  
  
 Le <xref:System.Messaging.MessageQueue.Path%2A> propriété pour ce <xref:System.Messaging.MessageQueue> instance doit être spécifiée avant d’envoyer le message. Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> et du message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="label" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransaction -&gt; unit" Usage="messageQueue.Send (obj, label, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <param name="label">Étiquette du message.</param>
        <param name="transaction">Objet <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envoie un objet à la file d'attente transactionnelle référencée par ce <see cref="T:System.Messaging.MessageQueue" /> et spécifie une étiquette pour le message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente transactionnelle référencée par le <xref:System.Messaging.MessageQueue>, à l’aide d’un contexte de transaction interne défini par le `transaction` paramètre. Avec cette surcharge, vous pouvez spécifier l’étiquette de chaîne qui identifie le message. L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message>, une structure, un objet de données ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message.  
  
 L’étiquette du message est différent de l’étiquette de file d’attente de message, mais les deux sont dépendants de l’application et n’ont pas hériter de signification particulière pour Message Queuing.  
  
 Si vous utilisez cette surcharge pour envoyer un message à une file d’attente non transactionnelle, le message peut être envoyé à la file d’attente de lettres mortes sans lever d’exception.  
  
 Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> et du message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété  
  
 <xref:System.Messaging.MessageQueueTransaction> cloisonnement prenant en charge, par conséquent si votre état de cloisonnement est `STA`, vous ne pouvez pas utiliser la transaction dans plusieurs threads. Visual Basic définit l’état du thread principal à `STA`, de sorte que vous devez appliquer le <xref:System.MTAThreadAttribute> dans le `Main` sous-routine. Sinon, l'envoi d'un message transactionnel qui utilise un autre thread lève une exception <xref:System.Messaging.MessageQueueException>. Vous appliquez le <xref:System.MTAThreadAttribute> en utilisant le fragment suivant.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="label" /> a la valeur <see langword="null" />.  
  
- ou - 
Le paramètre <paramref name="transaction" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
L'application Message Queuing a signalé une utilisation erronée de la transaction.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.Send : obj * string * System.Messaging.MessageQueueTransactionType -&gt; unit" Usage="messageQueue.Send (obj, label, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Objet à envoyer à la file d'attente.</param>
        <param name="label">Étiquette du message.</param>
        <param name="transactionType">Une des valeurs de <see cref="T:System.Messaging.MessageQueueTransactionType" /> décrivant le type de contexte de transaction à associer au message.</param>
        <summary>Envoie un objet à la file d'attente référencée par ce <see cref="T:System.Messaging.MessageQueue" /> et spécifie une étiquette pour le message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour envoyer un message qui contient le `obj` paramètre à la file d’attente référencée par le <xref:System.Messaging.MessageQueue>, à l’aide d’un contexte de transaction défini par le `transactionType` paramètre. Spécifiez `Automatic` pour le `transactionType` paramètre si un contexte de transaction externe est déjà attaché au thread que vous souhaitez utiliser pour envoyer le message. Spécifiez `Single` si vous souhaitez envoyer le message comme une transaction interne unique. Vous pouvez spécifier `None` si vous souhaitez envoyer un message transactionnel à un thread non transactionnel.  
  
 L’objet que vous envoyez à la file d’attente peut être un <xref:System.Messaging.Message> ou tout objet managé. Si vous envoyez un objet autre qu’un <xref:System.Messaging.Message>, l’objet est sérialisé et inséré dans le corps du message. Avec cette surcharge, vous pouvez spécifier l’étiquette de chaîne qui identifie le message.  
  
 L’étiquette du message est différent de l’étiquette de file d’attente de message, mais les deux sont dépendants de l’application et n’ont pas hériter de signification particulière pour Message Queuing.  
  
 Si vous ne définissez pas la <xref:System.Messaging.MessageQueue.Formatter%2A> propriété avant d’appeler <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, le formateur par défaut est le <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété s’applique à n’importe quel objet autre qu’un <xref:System.Messaging.Message>. Si vous spécifiez, par exemple, une étiquette ou une priorité à l’aide de la <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membre, ces valeurs s’appliquent à n’importe quel message qui contient un objet qui n’est pas de type <xref:System.Messaging.Message> lorsque votre application l’envoie à la file d’attente. Lors de l’envoi un <xref:System.Messaging.Message>, les valeurs de propriété définies pour le <xref:System.Messaging.Message> sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>et le message <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriété est prioritaire sur la file d’attente <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriété.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Le paramètre <paramref name="label" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">L'application Message Queuing a signalé une utilisation erronée de la transaction.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Le paramètre <paramref name="transactionType" /> ne fait pas partie des membres <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">La propriété <see cref="P:System.Messaging.MessageQueue.Path" /> n'a pas été définie.  
  
- ou - 
Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute des autorisations au jeu en cours. Ceci permet de contrôler les utilisateurs ayant des droits d'accès aux propriétés de la file d'attente ainsi qu'aux messages de la file.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.AccessControlList -&gt; unit" Usage="messageQueue.SetPermissions dacl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">
          <see cref="T:System.Messaging.AccessControlList" /> qui contient une ou plusieurs entrées du contrôle d'accès spécifiant les tiers de confiance et les autorisations à accorder.</param>
        <summary>Assigne les droits d'accès à la file d'attente en fonction du contenu d'une liste de contrôle d'accès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour accorder, refuser ou révoquer les droits à l’aide d’une collection d’entrées de contrôle d’accès pour spécifier les informations de tiers de confiance et les autorisations. Ceci est utilisé, par exemple, pour accorder des autorisations à plusieurs utilisateurs en même temps.  
  
 Le tiers de confiance que vous spécifiez lorsque vous construisez le `ace` paramètre peut être un utilisateur individuel, un groupe d’utilisateurs ou un ordinateur. Si le tiers de confiance est un individu, utilisez le format `DOMAIN` \\ `user`. Vous pouvez spécifier «. » pour le tiers de confiance indiquer l’ordinateur local.  
  
 Les autorisations assignées via <xref:System.Messaging.MessageQueue.SetPermissions%2A> ajouter des droits à la liste existante. Par défaut, le créateur d’une file d’attente publique ou privée a le contrôle total, et le groupe de domaine tout le monde a l’autorisation d’obtenir les propriétés de la file d’attente, obtenir les autorisations et écrire dans la file d’attente. Lorsque vous appelez <xref:System.Messaging.MessageQueue.SetPermissions%2A>, les informations utilisateur et les autorisations sont ajoutées au bas de la liste existante.  
  
 Le système examine chaque <xref:System.Messaging.AccessControlEntry> dans l’ordre jusqu'à ce qu’un des événements suivants se produit :  
  
-   Refus d’accès <xref:System.Messaging.AccessControlEntry> refuse explicitement des droits d’accès demandé à un tiers de confiance répertoriés dans le jeton d’accès du thread.  
  
-   Un ou plusieurs autorisation d’accès <xref:System.Messaging.AccessControlEntry> éléments de confiance répertoriés dans le jeton d’accès du thread explicitement accorder les droits d’accès demandé.  
  
-   Tous les <xref:System.Messaging.AccessControlEntry> éléments ont été vérifiés et il existe toujours au moins un droit d’accès demandé qui n’a pas été accordé de manière explicite, dans ce cas, l’accès est refusé implicitement.  
  
 Lorsque vous construisez le `dacl` paramètre, vous ajoutez <xref:System.Messaging.AccessControlEntry> instances à votre <xref:System.Messaging.AccessControlList> collection. Lorsque vous construisez chaque entrée de contrôle d’accès, vous pouvez spécifier des droits d’accès génériques ou standard. Les droits à une file d’attente peuvent être n’importe quelle combinaison des éléments suivants :  
  
-   Supprimer  
  
-   Sécurité de lecture  
  
-   Sécurité d’écriture  
  
-   Synchroniser  
  
-   Modifier le propriétaire  
  
-   Lecture  
  
-   Write  
  
-   Exécuter  
  
-   Obligatoire  
  
-   Tous  
  
-   Aucun.  
  
 Ces droits sont un ensemble de drapeaux de bit que vous pouvez associer à l’aide de l’opérateur de bits OR.  
  
-   Contrôle total  
  
-   Supprimer le Message  
  
-   Message de réception  
  
-   Lire le Message  
  
-   Recevoir le Message Journal  
  
-   Obtenir les propriétés de la file d’attente  
  
-   Définir les propriétés de la file d’attente  
  
-   Obtenir les autorisations  
  
-   Définir des autorisations  
  
-   Prendre possession de la file d’attente  
  
-   Écrire un Message  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : System.Messaging.MessageQueueAccessControlEntry -&gt; unit" Usage="messageQueue.SetPermissions ace" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">
          <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> qui spécifie un utilisateur, un type d'accès ou un type d'autorisation.</param>
        <summary>Assigne des droits d'accès à la file d'attente en fonction du contenu d'une entrée du contrôle d'accès.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour accorder, refuser ou révoquer les droits à l’aide d’une entrée de contrôle d’accès pour spécifier les tiers de confiance et des informations sur les droits.  
  
 Le tiers de confiance que vous spécifiez lorsque vous construisez le `ace` paramètre peut être un utilisateur individuel, un groupe d’utilisateurs ou un ordinateur. Si le tiers de confiance est un individu, utilisez le format `DOMAIN` \\ `user`. Vous pouvez spécifier «. » pour le tiers de confiance indiquer l’ordinateur local.  
  
 Les autorisations assignées via <xref:System.Messaging.MessageQueue.SetPermissions%2A> ajouter des droits à la liste existante. Par défaut, le créateur d’une file d’attente publique ou privée a le contrôle total, et le groupe de domaine tout le monde a l’autorisation d’obtenir les propriétés de la file d’attente, obtenir les autorisations et écrire dans la file d’attente. Lorsque vous appelez <xref:System.Messaging.MessageQueue.SetPermissions%2A>, les informations utilisateur et les autorisations sont ajoutées au bas de la liste existante.  
  
 Le système examine chaque <xref:System.Messaging.AccessControlEntry> dans l’ordre jusqu'à ce qu’un des événements suivants se produit :  
  
-   Refus d’accès <xref:System.Messaging.AccessControlEntry> refuse explicitement des droits d’accès demandé à un tiers de confiance répertoriés dans le jeton d’accès du thread.  
  
-   Un ou plusieurs autorisation d’accès <xref:System.Messaging.AccessControlEntry> éléments de confiance répertoriés dans le jeton d’accès du thread explicitement accorder les droits d’accès demandé.  
  
-   Tous les <xref:System.Messaging.AccessControlEntry> éléments ont été vérifiés et il existe toujours au moins un droit d’accès demandé qui n’a pas été accordé de manière explicite, dans ce cas, l’accès est refusé implicitement.  
  
 Les droits à une file d’attente, que vous spécifiez dans le `rights` paramètre lorsque vous construisez votre <xref:System.Messaging.MessageQueueAccessControlEntry>, peut être n’importe quelle combinaison des éléments suivants :  
  
-   Contrôle total  
  
-   Supprimer le Message  
  
-   Message de réception  
  
-   Lire le Message  
  
-   Recevoir le Message Journal  
  
-   Obtenir les propriétés de la file d’attente  
  
-   Définir les propriétés de la file d’attente  
  
-   Obtenir les autorisations  
  
-   Définir des autorisations  
  
-   Prendre possession de la file d’attente  
  
-   Écrire un Message  
  
 Le `rights` paramètre que vous spécifiez dans le constructeur pour le `ace` paramètre est un indicateur de la <xref:System.Messaging.MessageQueueAccessRights> énumération. Il représente un ensemble de drapeaux de bit que vous pouvez associer à l’aide de l’opérateur au niveau du bit ou lorsque vous générez le `rights` paramètre.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights -&gt; unit" Usage="messageQueue.SetPermissions (user, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">L'individu, le groupe ou l'ordinateur obtenant des droits d'accès supplémentaires à la file d'attente.</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" /> qui indique l’ensemble des droits d’accès à la file d’attente affectés par Message Queuing au <c>user</c> passé.</param>
        <summary>Donne les droits d'accès spécifiés à un ordinateur, un groupe ou un utilisateur.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour accorder des droits spécifiés à un utilisateur individuel. L’utilisateur peut être n’importe quel tiers de confiance valide inclut des utilisateurs, groupes d’utilisateurs ou un ordinateur. Si l’utilisateur est un individu, utilisez le format `DOMAIN` \\ `user` pour le `user` paramètre. Vous pouvez spécifier «. » pour le `user` paramètre pour indiquer l’ordinateur local.  
  
 Les autorisations assignées via <xref:System.Messaging.MessageQueue.SetPermissions%2A> ajouter des droits à la liste existante. Par défaut, le créateur d’une file d’attente publique ou privée a le contrôle total, et le groupe de domaine tout le monde a l’autorisation d’obtenir les propriétés de la file d’attente, obtenir les autorisations et écrire dans la file d’attente. Lorsque vous appelez <xref:System.Messaging.MessageQueue.SetPermissions%2A>, les informations utilisateur et les autorisations sont ajoutées au bas de la liste existante.  
  
 Le système examine chaque <xref:System.Messaging.AccessControlEntry> dans l’ordre jusqu'à ce qu’un des événements suivants se produit :  
  
-   Refus d’accès <xref:System.Messaging.AccessControlEntry> refuse explicitement des droits d’accès demandé à un tiers de confiance répertoriés dans le jeton d’accès du thread.  
  
-   Un ou plusieurs autorisation d’accès <xref:System.Messaging.AccessControlEntry> éléments de confiance répertoriés dans le jeton d’accès du thread explicitement accorder les droits d’accès demandé.  
  
-   Tous les <xref:System.Messaging.AccessControlEntry> éléments ont été vérifiés et il existe toujours au moins un droit d’accès demandé qui n’a pas été accordé de manière explicite, dans ce cas, l’accès est refusé implicitement.  
  
 Les droits à une file d’attente, spécifié dans le `rights` paramètre, peut être n’importe quelle combinaison des éléments suivants :  
  
-   Contrôle total  
  
-   Supprimer le Message  
  
-   Message de réception  
  
-   Lire le Message  
  
-   Recevoir le Message Journal  
  
-   Obtenir les propriétés de la file d’attente  
  
-   Définir les propriétés de la file d’attente  
  
-   Obtenir les autorisations  
  
-   Définir des autorisations  
  
-   Prendre possession de la file d’attente  
  
-   Écrire un Message  
  
 Le <xref:System.Messaging.MessageQueueAccessRights> énumération représente un ensemble de drapeaux de bit que vous pouvez associer à l’aide de l’opérateur au niveau du bit ou pour créer le `rights` paramètre.  
  
 Avec cette surcharge, vous pouvez uniquement accorder des autorisations ; Vous ne pouvez pas révoquer ou refuser les. Vous devez utiliser une surcharge différente pour accorder explicitement les <xref:System.Messaging.AccessControlEntryType> autre que `Allow`.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> a la valeur <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberSignature Language="F#" Value="member this.SetPermissions : string * System.Messaging.MessageQueueAccessRights * System.Messaging.AccessControlEntryType -&gt; unit" Usage="messageQueue.SetPermissions (user, rights, entryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">L'individu, le groupe ou l'ordinateur obtenant des droits d'accès supplémentaires à la file d'attente.</param>
        <param name="rights">
          <see cref="T:System.Messaging.MessageQueueAccessRights" /> qui indique l’ensemble des droits d’accès à la file d’attente affectés par Message Queuing au <c>user</c> passé.</param>
        <param name="entryType">
          <see cref="T:System.Messaging.AccessControlEntryType" /> qui spécifie si les autorisations spécifiées par le paramètre <c>rights</c> doivent être accordées, refusées ou révoquées.</param>
        <summary>Accorde à un ordinateur, à un groupe ou à un utilisateur les droits d'accès spécifiés, avec le type de contrôle d'accès spécifié (allow, deny, revoke ou set).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour accorder, refuser ou révoquer les droits spécifiés pour un utilisateur individuel. L’utilisateur peut être n’importe quel tiers de confiance valide inclut des utilisateurs, groupes d’utilisateurs ou un ordinateur. Si l’utilisateur est un individu, utilisez le format `DOMAIN` \\ `user` pour le `user` paramètre. Vous pouvez spécifier «. » pour le `user` paramètre pour indiquer l’ordinateur local.  
  
 Les autorisations assignées via <xref:System.Messaging.MessageQueue.SetPermissions%2A> ajouter des droits à la liste existante. Par défaut, le créateur d’une file d’attente publique ou privée a le contrôle total, et le groupe de domaine tout le monde a l’autorisation d’obtenir les propriétés de la file d’attente, obtenir les autorisations et écrire dans la file d’attente. Lorsque vous appelez <xref:System.Messaging.MessageQueue.SetPermissions%2A>, les informations utilisateur et les autorisations sont ajoutées au bas de la liste existante.  
  
 Le système examine chaque <xref:System.Messaging.AccessControlEntry> dans l’ordre jusqu'à ce qu’un des événements suivants se produit :  
  
-   Refus d’accès <xref:System.Messaging.AccessControlEntry> refuse explicitement des droits d’accès demandé à un tiers de confiance répertoriés dans le jeton d’accès du thread.  
  
-   Un ou plusieurs autorisation d’accès <xref:System.Messaging.AccessControlEntry> éléments de confiance répertoriés dans le jeton d’accès du thread explicitement accorder les droits d’accès demandé.  
  
-   Tous les <xref:System.Messaging.AccessControlEntry> éléments ont été vérifiés et il existe toujours au moins un droit d’accès demandé qui n’a pas été accordé de manière explicite, dans ce cas, l’accès est refusé implicitement.  
  
 Les droits à une file d’attente, spécifié dans le `rights` paramètre, peut être n’importe quelle combinaison des éléments suivants :  
  
-   Contrôle total  
  
-   Supprimer le Message  
  
-   Message de réception  
  
-   Lire le Message  
  
-   Recevoir le Message Journal  
  
-   Obtenir les propriétés de la file d’attente  
  
-   Définir les propriétés de la file d’attente  
  
-   Obtenir les autorisations  
  
-   Définir des autorisations  
  
-   Prendre possession de la file d’attente  
  
-   Écrire un Message  
  
 Le <xref:System.Messaging.MessageQueueAccessRights> énumération représente un ensemble de drapeaux de bit que vous pouvez associer à l’aide de l’opérateur au niveau du bit ou pour créer le `rights` paramètre.  
  
 Le tableau suivant indique si cette méthode est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L'exemple de code suivant montre l'utilisation de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'objet utilisé pour marshaler l'appel du gestionnaire d'événements consécutif à un événement <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> qui représente l'objet utilisé pour marshaler l'appel au gestionnaire d'événements consécutif à un événement <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" />. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Messaging.MessageQueue.ReceiveCompleted> ou <xref:System.Messaging.MessageQueue.PeekCompleted> événement se produit à partir d’un <xref:System.Messaging.MessageQueue.BeginReceive%2A> ou <xref:System.Messaging.MessageQueue.BeginPeek%2A> demander, respectivement, à un thread spécifique. En règle générale, le <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> est définie lorsque le composant associé est placé à l’intérieur d’un contrôle ou un formulaire, car ces composants sont liés à un thread spécifique.  
  
 En règle générale, l’objet de synchronisation marshale un appel de méthode en un seul thread.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Transactional : bool" Usage="System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si la file d'attente prend en charge les transactions uniquement.</summary>
        <value>
          <see langword="true" /> si la file d'attente accepte uniquement les messages envoyés dans le cadre d'une transaction ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La messagerie transactionnelle correspond au couplage de plusieurs messages connexes dans une même transaction. Envoi de messages comme partie d’une transaction garantit que les messages sont remis dans l’ordre, remis une seule fois et a été récupéré à partir de leur file d’attente de destination.  
  
 Si une file d’attente est transactionnelle, il accepte uniquement les messages qui sont envoyés en tant que partie d’une transaction. Toutefois, un message non transactionnel peut être envoyé ou reçu à partir d’une file d’attente de transaction locale sans utilisation explicite transactionnelle <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, et <xref:System.Messaging.MessageQueueTransaction.Abort%2A> syntaxe. Si un message non transactionnel est envoyé à une file d’attente transactionnelle, ce composant crée une transaction de message unique, sauf dans le cas faisant référence à une file d’attente sur un ordinateur distant à l’aide d’un nom de format direct. Dans ce cas, si vous ne spécifiez pas un contexte de transaction lors de l’envoi d’un message, n’est créée pour vous et le message sera envoyé à la file d’attente de lettres mortes.  
  
 Si vous envoyez un message non transactionnel à une file d’attente transactionnelle, vous ne serez pas en mesure de restaurer le message en cas d’exception.  
  
 <xref:System.Messaging.MessageQueueTransaction> cloisonnement prenant en charge, par conséquent si votre état de cloisonnement est `STA`, vous ne pouvez pas utiliser la transaction dans plusieurs threads. Visual Basic définit l’état du thread principal à `STA`, de sorte que vous devez appliquer le <xref:System.MTAThreadAttribute> dans le `Main` sous-routine. Sinon, l'envoi d'un message transactionnel qui utilise un autre thread lève une exception <xref:System.Messaging.MessageQueueException>. Vous appliquez le <xref:System.MTAThreadAttribute> en utilisant le fragment suivant.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.Transactional%2A> propriété.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Messaging.MessagingDescription("MQ_UseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si les messages reçus sont copiés dans le journal de file d'attente.</summary>
        <value>
          <see langword="true" /> si les messages reçus de la file d'attente sont copiés dans le journal de file d'attente associée ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque l’application Message Queuing crée une nouvelle file d’attente de l’application, il crée automatiquement une file d’attente du journal associé au même emplacement. La file d’attente du journal est utilisé pour effectuer le suivi des messages supprimés à partir d’une file d’attente. Définition de cette propriété modifie la file d’attente Message Queuing. Par conséquent, n’importe quel autre <xref:System.Messaging.MessageQueue> instances sont affectées par la modification.  
  
 La file d’attente du journal ne suit pas les messages supprimés de la file d’attente, car leur minuteur de délai de réception a expiré, ni celui des messages supprimés de la file d’attente à l’aide d’un service d’annuaire Message Queuing (Information Store ou Active Directory).  
  
 Les applications ne peuvent pas envoyer des messages aux files d’attente du journal ; ils sont limités à un accès en lecture seule de ces files d’attente. En outre, Message Queuing supprime jamais les messages des files d’attente du journal. L’application à l’aide de la file d’attente doit effacer ces messages par leur réception ou par une purge de la file d’attente.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Non|  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’une file d’attente de message <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propriété.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Une erreur s'est produite lors de l'accès à une méthode Message Queuing.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteHandle : nativeint" Usage="System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0">
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le handle natif utilisé pour l'envoi des messages vers la file d'attente de messages.</summary>
        <value>Handle de l'objet file d'attente natif utilisé pour l'envoi des messages vers la file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.MessageQueue.WriteHandle%2A> fournit un handle Windows natif pour l’objet de file d’attente de messages qui est utilisé pour envoyer des messages à la file d’attente. Si vous modifiez le chemin d’accès de la file d’attente, le handle est fermé et rouverte avec une nouvelle valeur.  
  
 Le tableau suivant indique si cette propriété est disponible dans différents modes de groupe de travail.  
  
|Mode groupe de travail|Disponible|  
|--------------------|---------------|  
|Ordinateur local|Oui|  
|Ordinateur local et le nom de format direct|Oui|  
|Ordinateur distant|Non|  
|Ordinateur distant et le nom de format direct|Oui|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">La file d'attente de messages n'est pas accessible en écriture.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>