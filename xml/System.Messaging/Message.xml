<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc03691103b3147a26fd9044a8094613cb513bea" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55401708" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fournit l'accès aux propriétés nécessaires à la définition d'un message de Message Queuing.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez la <xref:System.Messaging.Message> classe pour lire ou recevoir des messages à partir d’une file d’attente, ou pour avoir un contrôle précis sur les propriétés de message lors de l’envoi d’un message à une file d’attente.  
  
 <xref:System.Messaging.MessageQueue> utilise le <xref:System.Messaging.Message> classe lorsqu’elle lit ou reçoit des messages de files d’attente, car à la fois le <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> et <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> méthodes créent une nouvelle instance de la <xref:System.Messaging.Message> classe et définissez les propriétés de l’instance. Le <xref:System.Messaging.Message> les propriétés en lecture seule de la classe s’appliquent à la récupération des messages à partir d’une file d’attente, tandis que les propriétés en lecture/écriture s’appliquent à l’envoi et la récupération des messages. Lorsque <xref:System.Messaging.MessageQueue> lit ou reçoit un message à partir d’une file d’attente, son <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriété détermine laquelle des propriétés du message sont récupérés.  
  
 Le <xref:System.Messaging.MessageQueue> la classe <xref:System.Messaging.MessageQueue.Send%2A> méthode vous permet de spécifier tout type d’objet pour un message envoyé à cette file d’attente. Vous pouvez utiliser la <xref:System.Messaging.MessageQueue> l’instance <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété pour spécifier les paramètres des messages génériques envoyés à la file d’attente. Les types de paramètres incluent le formateur, étiquette, le chiffrement et l’authentification. Vous pouvez également spécifier des valeurs appropriées <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membres lorsque vous coordonnez votre application de messagerie pour répondre aux messages d’accusé de réception et de rapport. À l’aide un <xref:System.Messaging.Message> instance pour envoyer un message à la file d’attente vous donne la flexibilité pour accéder et modifier un grand nombre de ces propriétés - pour un message unique ou sur une base de message par message. <xref:System.Messaging.Message> propriétés sont prioritaires sur <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Les données de message sont stockées dans le <xref:System.Messaging.Message.Body%2A> propriété et dans une moindre mesure, le <xref:System.Messaging.Message.AppSpecific%2A> et <xref:System.Messaging.Message.Extension%2A> propriétés. Lorsque les données de message sont chiffrées, sérialisées ou désérialisées, seul le contenu de la <xref:System.Messaging.Message.Body%2A> propriété sont affectés.  
  
 Le contenu de la <xref:System.Messaging.Message.Body%2A> propriété sont sérialisées lorsque le message est envoyé, à l’aide de la <xref:System.Messaging.Message.Formatter%2A> propriété que vous spécifiez. Le contenu sérialisé se trouvent dans le <xref:System.Messaging.Message.BodyStream%2A> propriété. Vous pouvez également définir le <xref:System.Messaging.Message.BodyStream%2A> propriété directement, par exemple, pour envoyer un fichier en tant que le contenu des données d’un message. Vous pouvez modifier le <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriétés à tout moment avant d’envoyer le message et les données seront sérialisées de manière appropriée lorsque vous appelez <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Les propriétés définies par le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> propriété s’applique uniquement aux messages qui ne sont pas de type <xref:System.Messaging.Message>. Si vous spécifiez le <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriété pour un <xref:System.Messaging.MessageQueue>, les propriétés dans un nom identique un <xref:System.Messaging.Message> instance envoyées à cette file d’attente, ces propriétés par défaut doivent être ignorés.  
  
 Pour obtenir la liste des valeurs initiales des propriétés d’une instance de <xref:System.Messaging.Message>, consultez le <xref:System.Messaging.Message.%23ctor%2A> constructeur.  
  
   
  
## Examples  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.Message" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.Message" /> avec un corps vide.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer une nouvelle instance de la <xref:System.Messaging.Message> classe qui a un corps vide.  
  
 Spécifiez soit le <xref:System.Messaging.Message.Body%2A> propriété ou le <xref:System.Messaging.Message.BodyStream%2A> avant d’envoyer le <xref:System.Messaging.Message> objet. Le <xref:System.Messaging.Message.Body%2A> propriété peut être n’importe quel objet qui peut être sérialisée, comme une chaîne de texte, un objet de structure, une instance de classe ou un objet incorporé.  
  
 Sauf si vous écrivez le contenu du message directement à la <xref:System.Messaging.Message.BodyStream%2A> propriété, définissez le <xref:System.Messaging.Message.Formatter%2A> propriété avant d’envoyer le message. Le corps est sérialisé à l’aide de la <xref:System.Messaging.Message.Formatter%2A> valeur de la propriété au moment où le <xref:System.Messaging.MessageQueue.Send%2A> méthode est appelée sur le <xref:System.Messaging.MessageQueue> instance.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> couplage peu étroit, donc il n’est pas nécessaire d’avoir le même objet de type sur l’expéditeur et le destinataire lors de l’utilisation de ce format. Le <xref:System.Messaging.ActiveXMessageFormatter> et <xref:System.Messaging.BinaryMessageFormatter> sérialiser les données en représentation binaire. Le <xref:System.Messaging.ActiveXMessageFormatter> sert à envoyer ou recevoir des composants COM.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.Message>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 L’exemple de code suivant envoie deux messages de priorités différentes à la file d’attente et les récupère.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Objet à sérialiser dans le corps du message.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.Message" />, à l'aide de <see cref="T:System.Messaging.XmlMessageFormatter" /> pour sérialiser l'objet spécifié dans le corps du message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer une nouvelle instance de la <xref:System.Messaging.Message> classe qui contient le <xref:System.Messaging.Message.Body%2A> spécifié par le `body` paramètre. Le `body` paramètre peut être n’importe quel objet qui peut être sérialisée, comme une chaîne de texte, un objet de structure, une instance de classe ou un objet incorporé. Le corps est sérialisé à l’aide de la <xref:System.Messaging.XmlMessageFormatter> , sauf si vous modifiez le <xref:System.Messaging.Message.Formatter%2A> propriété avant le <xref:System.Messaging.Message> est envoyé. Si vous modifiez le <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriété à tout moment avant d’appeler <xref:System.Messaging.MessageQueue.Send%2A>, le message est sérialisé en fonction de la nouvelle valeur de propriété.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> couplage peu étroit, donc il n’est pas nécessaire d’avoir le même objet de type sur l’expéditeur et le destinataire lors de l’utilisation de ce format. Le <xref:System.Messaging.ActiveXMessageFormatter> et <xref:System.Messaging.BinaryMessageFormatter> sérialiser les données en représentation binaire. Le <xref:System.Messaging.ActiveXMessageFormatter> sert à envoyer ou recevoir des composants COM.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.Message>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Paramètre `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 L’exemple de code suivant crée une nouvelle file d’attente, envoie un message qui contient une commande à ce dernier, puis le récupère.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Objet à sérialiser dans le corps du message.</param>
        <param name="formatter"><see cref="T:System.Messaging.IMessageFormatter" /> qui spécifie le formateur permettant de sérialiser le corps du message.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Messaging.Message" />, à l'aide du formateur spécifié pour sérialiser l'objet spécifié dans le corps du message.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez cette surcharge pour créer une nouvelle instance de la <xref:System.Messaging.Message> classe qui contient le <xref:System.Messaging.Message.Body%2A> spécifié par le `body` paramètre et qui utilise tout formateur valide pour sérialiser le corps. Le `body` paramètre est un objet qui peut être sérialisé, comme une chaîne de texte, un objet de structure, une instance de classe ou un objet incorporé. Si vous modifiez le <xref:System.Messaging.Message.Body%2A> ou <xref:System.Messaging.Message.Formatter%2A> propriété à tout moment avant d’appeler <xref:System.Messaging.MessageQueue.Send%2A>, le message est sérialisé en fonction de la nouvelle valeur de propriété.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> couplage peu étroit, donc il n’est pas nécessaire d’avoir le même objet de type sur l’expéditeur et le destinataire lors de l’utilisation de ce format. Le <xref:System.Messaging.ActiveXMessageFormatter> et <xref:System.Messaging.BinaryMessageFormatter> sérialiser les données en représentation binaire. Le <xref:System.Messaging.ActiveXMessageFormatter> sert à envoyer ou recevoir des composants COM.  
  
 Le tableau suivant montre les valeurs initiales des propriétés d’une instance de <xref:System.Messaging.Message>.  
  
|Property|Valeur initiale|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider version 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|Paramètre `body`.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.Formatter%2A>|Paramètre `formatter`.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Une chaîne vide ( » »)|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Un tableau de longueur nulle d’octets|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de message d'accusé de réception à retourner à l'application émettrice.</summary>
        <value>Une des valeurs <see cref="T:System.Messaging.AcknowledgeTypes" /> qui représentent les types de messages d'accusé de réception que le système publie dans la file d'attente d'administration et les conditions dans lesquelles les accusés de réception sont retournés à l'application source. La valeur par défaut est <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.AcknowledgeType%2A> propriété spécifie le type de message d’accusé de réception demandé par l’application émettrice. Définir le <xref:System.Messaging.Message.AcknowledgeType%2A> avant d’envoyer le message pour demander une notification de certaines occurrences - par exemple, un message atteint sa file d’attente de destination, un message en cours de récupération ou un délai d’attente qui empêche un message d’atteindre ou récupérée à partir de la file d’attente de destination.  
  
 Message Queuing retourne la notification en envoyant des messages d’accusé de réception pour le <xref:System.Messaging.Message.AdministrationQueue%2A> propriété spécifiée par le message d’origine. Un message d’accusé de réception <xref:System.Messaging.Message.Acknowledgment%2A> propriété indique le type d’accusé de réception qu’il représente. Par exemple, si un message d’accusé de réception a été envoyé, car un message n’a pas atteint la destination avant la <xref:System.Messaging.Message.TimeToReachQueue%2A> intervalle a expiré, le <xref:System.Messaging.Message.Acknowledgment%2A> propriété du message d’accusé de réception contient la valeur `ReachQueueTimeout`.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message contenant un ordre vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message est filtré pour ignorer la propriété <see cref="P:System.Messaging.Message.AcknowledgeType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la classification de l'accusé de réception représenté par ce message.</summary>
        <value>Une des valeurs d'énumération <see cref="T:System.Messaging.Acknowledgment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque vous recevez un message à partir d’une file d’attente d’administration, lisez le <xref:System.Messaging.Message.Acknowledgment%2A> propriété pour vérifier l’état du message d’origine.  
  
 Lorsqu’un message est envoyé à sa file d’attente de destination, Message Queuing peut être demandé pour publier un message d’accusé de réception. Un tel message peut indiquer, par exemple, si le message est arrivé et a été récupéré dans les délais spécifiés, ou il peut indiquer la cause du problème dans le cas d’échec de remise. La file d’attente de destination renvoie l’accusé de réception des messages et les publie dans la file d’attente d’administration spécifié dans le message d’origine <xref:System.Messaging.Message.AdministrationQueue%2A> propriété. Le <xref:System.Messaging.Message.Id%2A> propriété d’un message d’accusé de réception identifie le message d’accusé de réception, pas le message d’origine. Vous trouverez l’identificateur du message d’origine dans l’accusé de réception <xref:System.Messaging.Message> l’instance <xref:System.Messaging.Message.CorrelationId%2A> propriété.  
  
 Si cette <xref:System.Messaging.Message> instance représente un message d’accusé de réception, le <xref:System.Messaging.Message.Acknowledgment%2A> propriété spécifie le type d’accusé de réception. Sinon, le <xref:System.Messaging.Message.Acknowledgment%2A> propriété contient la valeur `Normal`.  
  
 Utilisez le <xref:System.Messaging.Message.AcknowledgeType%2A> propriété du message d’origine pour spécifier les circonstances dans lesquelles les accusés de réception seront retournés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la file d'attente utilisée pour les messages d'accusé de réception générés par Message Queuing.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> qui spécifie la file d'attente d'administration utilisée pour les messages d'accusé de réception générés par le système. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La file d’attente spécifié dans le <xref:System.Messaging.Message.AdministrationQueue%2A> propriété peut être une file d’attente non transactionnelle. Les messages d'accusé de réception envoyés à la file d'attente d'administration peuvent indiquer si le message d'origine a atteint la file d'attente de destination et s'il en a été supprimé.  
  
 Lorsque le <xref:System.Messaging.Message.AcknowledgeType%2A> propriété a une valeur autre que `None`, l’application émettrice doit spécifier la file d’attente à utiliser en tant que la file d’attente d’administration.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message contenant un ordre vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.AdministrationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit des informations supplémentaires spécifiques à l'application.</summary>
        <value>Informations spécifiques à l'application. La valeur par défaut est zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.AppSpecific%2A> propriété contient des informations spécifiques à l’application que vous pouvez utiliser pour organiser les différents types de messages. Par exemple, vous pouvez utiliser des index spécifiques à l'application. Il incombe à l’application pour interpréter <xref:System.Messaging.Message.AppSpecific%2A> informations de propriété.  
  
 Si possible, vous devez inclure les données de message dans le corps du message plutôt que <xref:System.Messaging.Message.AppSpecific%2A> propriété.  
  
 Lorsque vous travaillez avec des files d’attente, utilisez le <xref:System.Messaging.Message.Extension%2A> propriété pour spécifier les propriétés de message qui n’existent pas dans Message Queuing. Comme avec la <xref:System.Messaging.Message.AppSpecific%2A> propriété, il incombe à l’application pour comprendre le contenu de la <xref:System.Messaging.Message.Extension%2A> propriété.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.AppSpecific" />.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'heure à laquelle le message est arrivé dans la file d'attente de destination.</summary>
        <value><see cref="T:System.DateTime" /> qui représente l'heure d'arrivée du message dans la file d'attente de destination. L'heure est définie à l'heure locale de l'ordinateur sur lequel la file d'attente de destination réside, par rapport à GMT.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le message <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété indique la vitesse à laquelle le message doit être reçu à partir de la file d’attente de destination. Le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété démarre lorsque le message est envoyé, pas lorsque le message arrive dans la file d’attente.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.ArrivedTime%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.ArrivedTime" />.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si l'ID de l'expéditeur doit être attaché au message.</summary>
        <value><see langword="true" /> si le <see cref="P:System.Messaging.Message.SenderId" /> doit être attaché au message ; sinon, <see langword="false" />. La valeur par défaut est <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.SenderId%2A> propriété est un tableau d’octets qui représente l’identificateur de l’utilisateur expéditeur. L’ID d’expéditeur est définie par Message Queuing et est utilisé par le Gestionnaire de file d’attente cible pour vérifier si l’expéditeur dispose des droits d’accès à une file d’attente.  
  
 Des droits de l’absence de l’expéditeur QU'ID est une indication par l’application émettrice que Message Queuing ne doit pas valider l’expéditeur du message ni vérifier l’accès de l’expéditeur à la file d’attente de réception. Le <xref:System.Messaging.Message.SenderId%2A> est digne de confiance uniquement si le message a été authentifié lorsqu’il atteint la file d’attente de destination. Le message est rejeté lorsqu’il atteint la file d’attente de destination si la file d’attente accepte uniquement les messages authentifiés et le <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> ou <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> propriété est `false`.  
  
> [!CAUTION]
>  Si un message est rejeté, il est envoyé à la file d’attente de lettres mortes (si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> est `true`), ou elle est ignorée. Vous pouvez demander des accusés de réception lorsqu’un message ne parvient pas à atteindre une file d’attente. Sinon, lorsque <xref:System.Messaging.Message.UseDeadLetterQueue%2A> est `false` le message est peut-être perdu sans avertissement.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.AttachSenderId%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.AttachSenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le message a été authentifié.</summary>
        <value><see langword="true" /> si l'authentification a été demandée pour le message lors de son arrivée dans la file d'attente ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.Authenticated%2A> propriété est utilisée uniquement par l’application lorsqu’elle interagit avec le message et essaie de déterminer si l’authentification a été demandée. Si le message est dans la file d’attente, le message a été authentifié. À l’inverse, si le <xref:System.Messaging.Message.Authenticated%2A> propriété est `true`, le Gestionnaire de file d’attente de réception a authentifié le message lorsqu’il a reçu ce message.  
  
 Vous ne pouvez pas déterminer si un message d’échec de l’authentification en examinant ses propriétés. Message Queuing rejette les messages qui ne respectent pas l’authentification lorsqu’ils sont remis à la file d’attente. Toutefois, vous pouvez demander qu’un message d’accusé de réception est envoyé si un échec de remise empêche le message d’arriver dans la file d’attente.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.Authenticated%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Authenticated" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le nom du fournisseur de services de chiffrement utilisé pour générer la signature numérique du message.</summary>
        <value>Nom du fournisseur de services de chiffrement utilisé pour générer la signature numérique du message. Le fournisseur par défaut est Fournisseur de services de chiffrement de base Microsoft version 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement le <xref:System.Messaging.Message.AuthenticationProviderName%2A> lorsque vous travaillez avec des files d’attente. Message Queuing requiert le nom du fournisseur d’authentification et le type de fournisseur d’authentification du fournisseur de services de chiffrement (fournisseur d’authentification) pour valider les signatures numériques des messages envoyés à une file d’attente étrangère et les messages transmis au Message Queuing à partir d’une file d’attente à l’étranger.  
  
 Lorsque vous envoyez un message, vous devez toujours définir le <xref:System.Messaging.Message.AuthenticationProviderName%2A> et <xref:System.Messaging.Message.ConnectorType%2A> ensemble de propriétés. Lorsque le message est envoyé, Message Queuing ignore le nom du fournisseur d’authentification si le type de connecteur n’est pas également défini.  
  
 Le <xref:System.Messaging.Message.AuthenticationProviderName%2A> propriété ne peut pas être `null`, mais il peut être une chaîne vide ( » »).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> n'a pas pu être définie.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.AuthenticationProviderName" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de fournisseur de services de chiffrement utilisé pour générer la signature numérique du message.</summary>
        <value>Une des valeurs de <see cref="T:System.Messaging.CryptographicProviderType" />. La valeur par défaut est <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous utilisez généralement le <xref:System.Messaging.Message.AuthenticationProviderType%2A> propriété lorsque vous travaillez avec des files d’attente pour spécifier le fournisseur de services de chiffrement associé à un message. Message Queuing requiert le nom du fournisseur d’authentification et le type de fournisseur d’authentification du fournisseur de services de chiffrement (fournisseur d’authentification) pour valider les signatures numériques des messages envoyés à une file d’attente étrangère et les messages transmis au Message Queuing à partir d’une file d’attente à l’étranger.  
  
 Uniquement `RsaFull` est destinée à être utilisée avec la messagerie.  
  
 Lorsque vous envoyez un message, vous devez toujours définir le <xref:System.Messaging.Message.AuthenticationProviderType%2A> et <xref:System.Messaging.Message.ConnectorType%2A> ensemble de propriétés. Lorsque le message est envoyé, Message Queuing ignore le type de fournisseur d’authentification si le type de connecteur n’est pas également défini.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> n'a pas pu être définie.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.AuthenticationProviderType" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contenu du message.</summary>
        <value>Objet qui spécifie le contenu du message. L'objet peut être une chaîne, une date, une devise, un nombre, un tableau d'octets ou tout objet managé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le message <xref:System.Messaging.Message.Body%2A> propriété contient généralement les données associées au message. Bien que vous pouvez également envoyer des données spécifiques à l’application le <xref:System.Messaging.Message.AppSpecific%2A> et <xref:System.Messaging.Message.Extension%2A> propriétés, vous devez inclure les données de message dans la <xref:System.Messaging.Message.Body%2A> du message chaque fois que possible. Uniquement la <xref:System.Messaging.Message.Body%2A> contenu de la propriété est sérialisé ou chiffré.  
  
 Le <xref:System.Messaging.Message.Body%2A> propriété peut contenir tout objet dont la taille ne dépasse pas 4 Mo. Si vous utilisez <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> pour envoyer un objet qui n’est pas de type <xref:System.Messaging.Message> à la <xref:System.Messaging.MessageQueue>, cet objet se trouve dans le <xref:System.Messaging.Message.Body%2A> propriété de la <xref:System.Messaging.Message> instance retournée par <xref:System.Messaging.MessageQueue.Peek%2A> ou <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 L’argument de chaîne dans `MessageQueue.Send("hello.")` est un exemple de cet objet générique.  
  
 Le <xref:System.Messaging.Message.BodyType%2A> propriété indique le type d’informations qui sont stockées dans le corps du message. Message Queuing utilise ces informations pour identifier le type de la <xref:System.Messaging.Message.Body%2A> contenu de la propriété.  
  
 Spécifiez soit le <xref:System.Messaging.Message.Body%2A> propriété ou le <xref:System.Messaging.Message.BodyStream%2A> avant d’envoyer le <xref:System.Messaging.Message> objet. Le <xref:System.Messaging.Message.Body%2A> propriété peut être n’importe quel objet sérialisable, telle qu’une chaîne de texte, un objet de structure, une instance de classe ou un objet incorporé.  
  
 Sauf si vous écrivez le contenu du message directement à la <xref:System.Messaging.Message.BodyStream%2A> propriété, définissez le <xref:System.Messaging.Message.Formatter%2A> propriété avant d’envoyer le message. Lorsque le <xref:System.Messaging.MessageQueue.Send%2A> méthode est appelée sur le <xref:System.Messaging.MessageQueue> instance, le corps est sérialisé à l’aide du formateur contenu dans le <xref:System.Messaging.Message.Formatter%2A> propriété. Si vous envoyez le message sans spécifier de valeur pour le <xref:System.Messaging.Message.Formatter%2A> propriété, le formateur par défaut est <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Tente de définir le corps d’un message à <xref:System.Decimal.MaxValue> entraîne une <xref:System.OverflowException> lorsque le `Send` méthode de la <xref:System.Messaging.MessageQueue> classe est appelée et le <xref:System.Messaging.ActiveXMessageFormatter> est utilisé.  
  
   
  
## Examples  
 L’exemple de code suivant envoie deux messages de priorités différentes à la file d’attente et les récupère.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La propriété <see cref="P:System.Messaging.Message.Formatter" /> a la valeur <see langword="null" />.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit les informations dans le corps du message.</summary>
        <value><see cref="T:System.IO.Stream" /> qui contient les informations sérialisées incluses dans le <see cref="P:System.Messaging.Message.Body" /> du message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le corps d’un message peut se composer de n’importe quel type d’informations - par exemple, une chaîne, une date, une devise, un nombre, un tableau d’octets ou tout objet managé. Ces informations sont sérialisées dans un <xref:System.IO.Stream> à passer à la file d’attente.  
  
 Spécifiez soit le <xref:System.Messaging.Message.Body%2A> propriété ou le <xref:System.Messaging.Message.BodyStream%2A> avant d’envoyer le <xref:System.Messaging.Message> objet. Si vous définissez la <xref:System.Messaging.Message.Body%2A> propriété, le contenu est sérialisé dans le <xref:System.Messaging.Message.BodyStream%2A> propriété. Toutefois, vous pouvez choisir d’écrire le <xref:System.Messaging.Message.BodyStream%2A> propriété directement. Cela est utile, par exemple, lorsque vous souhaitez ouvrir une connexion à un fichier et lire son contenu en tant que du corps de votre message.  
  
 Sauf si vous écrivez le contenu du message directement à la <xref:System.Messaging.Message.BodyStream%2A> propriété, définissez le <xref:System.Messaging.Message.Formatter%2A> propriété avant d’envoyer le message. Lorsque le <xref:System.Messaging.MessageQueue.Send%2A> méthode est appelée sur le <xref:System.Messaging.MessageQueue> instance, le corps est sérialisé à l’aide du formateur contenu dans le <xref:System.Messaging.Message.Formatter%2A> propriété. Si vous envoyez le message sans spécifier de valeur pour le <xref:System.Messaging.Message.Formatter%2A> propriété, le formateur par défaut est <xref:System.Messaging.XmlMessageFormatter>.  
  
 Si vous définissez la <xref:System.Messaging.Message.UseEncryption%2A> propriété `true` pour le corps de ce message, le message est chiffré lorsqu’il est envoyé, pas lorsque vous définissez le <xref:System.Messaging.Message.Body%2A> propriété. Par conséquent, le <xref:System.Messaging.Message.BodyStream%2A> propriété n’est jamais chiffrée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le type de données contenu dans le corps du message.</summary>
        <value>Le type réel du corps du message, tel qu'une chaîne, une date, une devise ou un nombre.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing reconnaît le contenu du corps comme un objet ou un flux sérialisé. Le <xref:System.Messaging.Message.BodyType%2A> propriété indique le type de l’objet dans le <xref:System.Messaging.Message.Body%2A> propriété du message.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> effectue une liaison entre les types natifs et l’objet dans un corps de message. Si vous utilisez le <xref:System.Messaging.XmlMessageFormatter>, il définit le <xref:System.Messaging.Message.BodyType%2A> propriété pour vous.  
  
 Autres formateurs peuvent fournir des fonctionnalités de liaison en outre, comme indiqué dans le code C# suivant.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.BodyType%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Body" />.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique que certaines propriétés de message généralement définies par Message Queuing ont été définies par l'application source.</summary>
        <value><see cref="T:System.Guid" /> défini par l'application et utilisé en conjonction avec les applications de connexion ou le chiffrement du message. Ce <see cref="T:System.Guid" /> permet à une application réceptrice d'interpréter les propriétés de message définies par l'application émettrice, mais qui sont d'ordinaire définies par Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing requiert le <xref:System.Messaging.Message.ConnectorType%2A> propriété être définie chaque fois qu’une application définit une propriété de message qui est généralement définie par Message Queuing. Une application utilise généralement un <xref:System.Messaging.Message.ConnectorType%2A> dans les deux cas suivants :  
  
-   Chaque fois qu’une application de connexion transmet un message. La <xref:System.Messaging.Message.ConnectorType%2A> indique les applications émettrices et réceptrices comment interpréter les propriétés de sécurité et d’accusé de réception du message.  
  
-   Chaque fois que l’application émettrice, plutôt que Message Queuing, chiffre un message. Le <xref:System.Messaging.Message.ConnectorType%2A> indique à Message Queuing à utiliser le <xref:System.Messaging.Message.DestinationSymmetricKey%2A> valeur de propriété à déchiffrer le message.  
  
 Vous devez définir le <xref:System.Messaging.Message.ConnectorType%2A> propriété si vous définissez les propriétés suivantes (sinon, la file d’attente ignore ces propriétés lorsque le message est envoyé) :  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.ConnectorType" />.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'identificateur de message utilisé par les messages d'accusé de réception, de rapport et de réponse en référence au message d'origine.</summary>
        <value>L'identificateur de message spécifié par la propriété <see cref="P:System.Messaging.Message.Id" /> du message d'origine. L'identificateur de corrélation est utilisé par Message Queuing lorsqu'il génère un message d'accusé de réception ou de rapport et par une application lorsqu'elle génère un message de réponse.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lorsque Message Queuing génère un message d’accusé de réception ou un rapport, il utilise la propriété d’identificateur de corrélation pour spécifier l’identificateur de message du message d’origine. De cette manière, l'identificateur de corrélation lie un message de rapport ou d'accusé de réception au message d'origine.  
  
 L’application émettrice peut mettre en correspondre l’accusé de réception ou un rapport avec le message d’origine à l’aide de la <xref:System.Messaging.Message.CorrelationId%2A> propriété pour identifier le message d’origine <xref:System.Messaging.Message.Id%2A> propriété.  
  
 Les applications de connexion doivent également définir le <xref:System.Messaging.Message.CorrelationId%2A> propriété des messages d’accusé de réception et de rapport à l’identificateur de message du message d’origine.  
  
 Lorsque votre application envoie un message de réponse à l’application émettrice, vous pouvez définir le <xref:System.Messaging.Message.CorrelationId%2A> propriété de message de réponse à l’identificateur de message du message d’origine. L’application émettrice peut alors faire correspondre votre message de réponse au message qui a été envoyé.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message qui contient une commande vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.CorrelationId" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la file d'attente de destination prévue pour un message.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> qui spécifie la file d'attente de destination prévue pour le message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.DestinationQueue%2A> propriété est couramment utilisée pour déterminer la destination d’origine d’un message est arrivé dans une file d’attente du journal ou de lettres mortes. En règle générale, il est inutile de consulter cette propriété, car vous en général, récupérez le message à partir de sa file d’attente de destination.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.DestinationQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.DestinationQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la clé symétrique utilisée pour chiffrer les messages chiffrés par l'application ou les messages envoyés aux files d'attente externes.</summary>
        <value>Un tableau des valeurs d'octets qui spécifie la clé symétrique de destination utilisée pour chiffrer le message. La valeur par défaut est un tableau de longueur zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Deux scénarios vous obligent à utiliser le <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriété. La première est lorsque votre application, plutôt que Message Queuing, chiffre un message. Le second est lorsque vous envoyez un message chiffré à un système de file d’attente autre que Message Queuing.  
  
 Avant de définir cette propriété, vous devez chiffrer la clé symétrique avec la clé publique du Gestionnaire de file d’attente de réception. Lorsque vous envoyez un message chiffrés par l’application, le Gestionnaire de file d’attente de réception utilise la clé symétrique pour déchiffrer le message avant de l’envoyer à sa file d’attente de destination.  
  
 Si vous envoyez un message à une file d’attente à l’étranger, le message est tout d’abord reçu par l’application connecteur approprié, qui transfère le message chiffré avec la clé symétrique attachée à l’application réceptrice. Il est ensuite la responsabilité de l’application réceptrice pour déchiffrer le message à l’aide de la clé symétrique.  
  
 Lorsque vous définissez la <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriété, vous devez également définir le <xref:System.Messaging.Message.ConnectorType%2A> propriété. Lorsque le message est envoyé, Message Queuing ignore le <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriété si le <xref:System.Messaging.Message.ConnectorType%2A> propriété n’est pas également définie.  
  
 Le <xref:System.Messaging.Message.DestinationSymmetricKey%2A> propriété a une taille de tableau maximale de 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.DestinationSymmetricKey" />.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la signature numérique utilisée par Message Queuing pour authentifier le message.</summary>
        <value>Un tableau de valeurs d'octets qui spécifie la signature numérique de Message Queuing 1.0 utilisée pour authentifier le message. La valeur par défaut est un tableau de longueur zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing utilise la signature numérique lors de l’authentification des messages qui ont été envoyés par Message Queuing version 1.0. Dans la plupart des cas, Message Queuing génère et définit le <xref:System.Messaging.Message.DigitalSignature%2A> propriété lorsque l’application émettrice demande l’authentification. L’application réceptrice utilise cette propriété pour récupérer la signature numérique attachée au message.  
  
 Vous pouvez uniquement utiliser le <xref:System.Messaging.Message.DigitalSignature%2A> propriété lors de l’exécution de Message Queuing version 2.0. L’application émettrice doit spécifier les signatures Message Queuing version 1.0 lors de la demande d’authentification. Si l’application émettrice envoie une signature de Message Queuing version 2.0, cette propriété contient une mémoire tampon de quatre octets, chacun contenant zéro.  
  
 Le <xref:System.Messaging.Message.DigitalSignature%2A> propriété, avec le <xref:System.Messaging.Message.SenderCertificate%2A> propriété, est également utilisée par les applications de connexion lorsqu’un message est envoyé. Dans ce scénario, le connecteur application - plutôt que Message Queuing - génère la signature numérique, elle est basée sur le certificat de l’utilisateur expéditeur du message.  
  
 Le <xref:System.Messaging.Message.DigitalSignature%2A> propriété a une taille de tableau maximale de 256.  
  
 Lorsque vous définissez la <xref:System.Messaging.Message.DigitalSignature%2A> propriété, vous devez également définir le <xref:System.Messaging.Message.ConnectorType%2A> propriété. Lorsqu’un message est envoyé, Message Queuing ignore le <xref:System.Messaging.Message.DigitalSignature%2A> propriété si le <xref:System.Messaging.Message.ConnectorType%2A> propriété n’est pas également définie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.DigitalSignature" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Messaging.Message.DigitalSignature" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'algorithme de chiffrement utilisé pour chiffrer le corps d'un message privé.</summary>
        <value>Une des valeurs d'énumération <see cref="T:System.Messaging.EncryptionAlgorithm" />. La valeur par défaut est <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un message est privé (chiffré), il est chiffré avant son envoi et déchiffré à la réception. Le <xref:System.Messaging.Message.EncryptionAlgorithm%2A> propriété spécifie l’algorithme utilisé pour chiffrer le corps d’un message privé.  
  
 Une file d’attente peut nécessiter entrants messages être chiffrés. Si une application envoie un message non chiffré de (non privé) à une file d’attente accepte uniquement les messages privés, ou si elle envoie un message privé à une file d’attente qui accepte uniquement les messages non privés, la file d’attente rejette le message. L’application émettrice peut demander qu’un message d’accusé de réception négatif soit renvoyé dans ce cas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.EncryptionAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit des informations supplémentaires définies par l'application qui sont associées au message.</summary>
        <value>Un tableau des valeurs d'octets qui fournit des informations définies par l'application qui sont associées au message. La valeur par défaut est un tableau de longueur zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.Extension%2A> propriété fournit des informations définies par l’application, comme un objet binaire volumineux, ce qui est associé au message. Il incombe à l’application réceptrice d’interpréter le contenu de la <xref:System.Messaging.Message.Extension%2A> propriété.  
  
 Si possible, vous devez inclure les données de message dans le <xref:System.Messaging.Message.Body%2A> propriété du message plutôt que <xref:System.Messaging.Message.Extension%2A> propriété.  
  
 Lorsque vous travaillez avec des files d’attente, utilisez le <xref:System.Messaging.Message.Extension%2A> propriété pour spécifier les propriétés de message qui n’existent pas dans Message Queuing.  
  
 Il existe une file d’attente étrangère dans un file d’attente système autre que Microsoft Message Queuing. Message Queuing communique avec ces files d’attente par le biais d’un connecteur.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Extension" />.</exception>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Messaging.Message.Extension" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le formateur utilisé pour sérialiser un objet dans le corps du message ou le désérialiser.</summary>
        <value>Le <see cref="T:System.Messaging.IMessageFormatter" /> qui produit un flux à écrire dans le corps du message ou à lire à partir de celui-ci. La valeur par défaut est <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilisez le <xref:System.Messaging.Message.Formatter%2A> propriété lecture / écriture d’un message. Lorsqu’un message est envoyé à la file d’attente, le formateur sérialise les <xref:System.Messaging.Message.Body%2A> propriété dans un flux qui peut être envoyé à la file d’attente. Lors de la lecture à partir d’une file d’attente, le formateur désérialise les données du message dans le <xref:System.Messaging.Message.Body%2A> propriété.  
  
 Sauf si vous écrivez le contenu du message directement à la <xref:System.Messaging.Message.BodyStream%2A> propriété, définissez le <xref:System.Messaging.Message.Formatter%2A> propriété avant d’envoyer le message. Lorsque le <xref:System.Messaging.MessageQueue.Send%2A> méthode est appelée sur le <xref:System.Messaging.MessageQueue> instance, le corps est sérialisé à l’aide du formateur contenu dans le <xref:System.Messaging.Message.Formatter%2A> propriété. Si vous envoyez le message sans spécifier de valeur pour le <xref:System.Messaging.Message.Formatter%2A> propriété, le formateur par défaut est <xref:System.Messaging.XmlMessageFormatter>.  
  
 Le <xref:System.Messaging.XmlMessageFormatter> couplage peu étroit, donc il n’est pas nécessaire d’avoir le même objet de type sur l’expéditeur et le destinataire lors de l’utilisation de ce format. Le <xref:System.Messaging.ActiveXMessageFormatter> et <xref:System.Messaging.BinaryMessageFormatter> sérialiser les données en représentation binaire. Le <xref:System.Messaging.ActiveXMessageFormatter> sert à envoyer ou recevoir des composants COM.  
  
   
  
## Examples  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 L’exemple de code suivant montre un corps de message à l’aide de la mise en forme <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">La propriété <see cref="P:System.Messaging.Message.Formatter" /> a la valeur <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit l'algorithme de hachage utilisé par Message Queuing lors de l'authentification d'un message ou la création d'une signature numérique pour un message.</summary>
        <value>Une des valeurs d'énumération <see cref="T:System.Messaging.HashAlgorithm" />. Pour Windows XP, la valeur par défaut est <see langword="SHA" />. Sinon, la valeur par défaut est <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sur l’ordinateur source, Message Queuing utilise l’algorithme de hachage lors de la création d’une signature numérique pour un message. La Gestionnaire de file d’attente cible utilise ensuite le même algorithme de hachage pour authentifier le message lorsqu’il est reçu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.HashAlgorithm" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur du message.</summary>
        <value>L'identificateur unique du message généré par Message Queuing.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing génère un identificateur de message lorsque le message est envoyé. L’identificateur est composé de 20 octets et comprend deux éléments : la machine <xref:System.Guid> de l’ordinateur source et un identificateur unique pour le message sur l’ordinateur. La combinaison des deux éléments a pour résultat un identificateur de message, unique sur le réseau.  
  
 Message Queuing génère des identificateurs de message pour tous les messages - y compris les messages d’accusé de réception et de rapport. Un message d’accusé de réception est généralement envoyé par Message Queuing en réaction à l’arrivée ou l’échec d’un message d’origine, envoyé. Vous pouvez trouver la <xref:System.Messaging.Message.Id%2A> valeur de la propriété du message d’origine dans le <xref:System.Messaging.Message.CorrelationId%2A> propriété d’un message d’accusé de réception.  
  
 Vous pouvez également utiliser le <xref:System.Messaging.Message.Id%2A> propriété lors de l’envoi d’un message de réponse à une file d’attente de réponse. Pour inclure l’identificateur du message d’origine dans un message de réponse, définissez la <xref:System.Messaging.Message.CorrelationId%2A> propriété de message de réponse à la <xref:System.Messaging.Message.Id%2A> propriété du message d’origine. L’application qui lit le message de réponse peut ensuite utiliser l’identificateur de corrélation du message de réponse pour identifier le message d’origine.  
  
   
  
## Examples  
 L’exemple de code suivant envoie et reçoit un message contenant un ordre vers et depuis une file d’attente. Il demande spécifiquement un accusé de réception positif lorsque le message d’origine atteint ou est récupéré à partir de la file d’attente.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Id" />.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Spécifie qu'il n'y a pas de délai d'attente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> et <xref:System.Messaging.Message.TimeToReachQueue%2A> requièrent une valeur qui spécifie un délai d’attente. Dans le premier cas, le délai d’attente est la durée maximale autorisée pour un message en provenance de la file d’attente. Pour ce dernier, le délai d’attente est la durée autorisée pour un message atteindre la file d’attente. Dans les deux cas, vous pouvez spécifier le délai d’attente en tant que nombre de secondes ou utiliser <xref:System.Messaging.Message.InfiniteTimeout> pour indiquer qu’aucun délai d’attente n’existe.  
  
   
  
## Examples  
 L’exemple de code suivant illustre l’utilisation de la <xref:System.Messaging.Message.InfiniteTimeout> champ.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le message était le premier message envoyé dans une transaction.</summary>
        <value><see langword="true" /> si le message était le premier message envoyé dans une transaction ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applications réceptrices utilisent la <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriété pour vérifier qu’un message a été le premier message envoyé dans une transaction unique à une file d’attente unique.  
  
 Cette propriété est disponible uniquement avec Message Queuing version 2.0 et versions ultérieures.  
  
 Pour vérifier les limites de transaction, vous pouvez utiliser la <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriété, ainsi que deux autres propriétés : <xref:System.Messaging.Message.IsLastInTransaction%2A> et <xref:System.Messaging.Message.TransactionId%2A>. Utilisez la première pour vérifier si un message était le dernier message envoyé dans la transaction et ce dernier pour récupérer l’identificateur de la transaction.  
  
 Si seul un message est envoyé dans une transaction, le <xref:System.Messaging.Message.IsFirstInTransaction%2A> et <xref:System.Messaging.Message.IsLastInTransaction%2A> propriétés sont toutes deux définies sur `true`.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.IsFirstInTransaction%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.IsFirstInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur qui indique si le message était le dernier message envoyé dans une transaction.</summary>
        <value><see langword="true" /> si le message était le dernier message envoyé dans une transaction unique ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applications réceptrices utilisent la <xref:System.Messaging.Message.IsLastInTransaction%2A> propriété pour vérifier qu’un message était le dernier message envoyé dans une transaction unique à une file d’attente unique.  
  
 Cette propriété est disponible uniquement avec Message Queuing version 2.0 et versions ultérieures.  
  
 Pour vérifier les limites de transaction, vous pouvez utiliser la <xref:System.Messaging.Message.IsLastInTransaction%2A> propriété, ainsi que deux autres propriétés : <xref:System.Messaging.Message.IsFirstInTransaction%2A> et <xref:System.Messaging.Message.TransactionId%2A>. Utilisez la première pour vérifier si un message a été le premier message envoyé dans la transaction et ce dernier pour récupérer l’identificateur de la transaction.  
  
 Si seul un message est envoyé dans une transaction, le <xref:System.Messaging.Message.IsFirstInTransaction%2A> et <xref:System.Messaging.Message.IsLastInTransaction%2A> propriétés sont toutes deux définies sur `true`.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.IsLastInTransaction%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.IsLastInTransaction" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une chaîne Unicode définie par l'application qui décrit le message.</summary>
        <value>Étiquette du message. La valeur par défaut est une chaîne vide ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vous pouvez utiliser une étiquette de message à plusieurs fins. Par exemple, vous pouvez l'utiliser dans un but d'affichage ou pour traiter de manière sélective les messages basés sur la valeur de l'étiquette. L’étiquette n’a pas besoin être unique parmi les messages.  
  
 La file d'attente et les étiquettes de messages représentent une valeur définie par l'application qui peut aider à identifier la file d'attente ou le message en termes compréhensibles par l'être humain. Il incombe à l’application pour interpréter le contenu de l’étiquette, qui n’ont aucune signification intrinsèque à l’application Message Queuing.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.Label%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Label" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Présentation dans MSMQ 3.0. Obtient l'identificateur de la recherche du message.</summary>
        <value>Identificateur de recherche du message qui est généré par Message Queuing, et est unique dans la file d'attente où se trouve le message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété fournit l’accès en lecture seule à l’identificateur de recherche d’un message. L’identificateur de recherche, introduit dans MSMQ 3.0, est un identificateur 64 bits qui est généré par Message Queuing et assigné à chaque message lorsque le message est placé dans la file d’attente. L’identificateur de recherche n’est pas identique à l’identificateur de message qui est générée lorsque le message est envoyé.  
  
 Message Queuing génère un identificateur de recherche pour tous les messages sont placés dans une file d’attente, y compris générés par l’application de destination, l’administration et files d’attente de rapports, ainsi générés par le système ' s journal, lettres mortes, connecteur et les files d’attente sortantes. En d’autres termes, cela inclut les deux messages envoyés par les applications émettrices et par Message Queuing. L’identificateur de recherche est unique pour la file d’attente et n’a aucune signification en dehors de la file d’attente.  
  
 Si un message est envoyé à plusieurs files d’attente de destination, ou si une copie d’un message est stockée dans un journal de l’ordinateur ou d’un journal de file d’attente, chaque copie du message aura son propre identificateur de recherche lorsqu’il est placé dans sa file d’attente.  
  
 Le <xref:System.Messaging.Message.LookupId%2A> propriété ne peut être lue que sur les messages récupérés à partir d’une file d’attente.  
  
 Un identificateur de recherche est utilisé pour lire un message spécifique dans la file d’attente. Une fois que l’identificateur de recherche d’un message est connu, l’application réceptrice peut appeler le <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> ou <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> (fonction) pour accéder directement à ce message et de lire ou de le récupérer à partir de la file d’attente, contrairement aux curseurs qui doit commencer au début de la file d’attente et naviguer vers la fin de la file d’attente  
  
 Obtenir les identificateurs de recherche des messages dans la file d’attente est la responsabilité de l’application. Une manière possible d’obtenir les identificateurs de recherche consiste à créer un déclencheur pour la file d’attente de destination qui appelle un composant qui met en cache les identificateurs de chaque message lorsqu’ils sont placés dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">MSMQ 3.0 n'est pas installé.</exception>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.LookupId" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le type du message : <see langword="Normal" />, <see langword="Acknowledgment" /> ou <see langword="Report" />.</summary>
        <value>Une des valeurs de <see cref="P:System.Messaging.Message.MessageType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Message Queuing définit généralement cette propriété lorsqu’il envoie le message. Un message Message Queuing peut être de l'un des types suivants :   
  
-   `Normal`, qui est soit un message classique envoyé à partir d’une application à une file d’attente ou un message de réponse retourné à l’application émettrice.  
  
-   `Acknowledgement`, que Message Queuing génère chaque fois que l’application émettrice le demande. Par exemple, Message Queuing peut générer des messages positifs ou négatifs pour indiquer que le message d'origine est arrivé ou a été lu. Message Queuing retourne le message d'accusé de réception approprié à la file d'attente d'administration spécifiée par l'application émettrice.  
  
-   `Report`, que Message Queuing génère chaque fois qu’une file d’attente de rapports est définie par le Gestionnaire de file d’attente source. Lorsque le traçage est activé, Message Queuing envoie un message de rapports à la file d'attente de rapports de Message Queuing chaque fois que le message d'origine entre ou quitte un serveur Message Queuing.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.MessageType%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.MessageType" />.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la priorité du message, qui détermine la position du message dans la file d'attente.</summary>
        <value>Une des valeurs <see cref="T:System.Messaging.MessagePriority" /> qui représentent les niveaux de priorité des messages non transactionnels. La valeur par défaut est <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.Priority%2A> propriété affecte la façon dont Message Queuing gère le message alors qu’il est en cours d’acheminement et une fois qu’il n’atteigne sa destination. Les messages dont la priorité est la plus élevée sont prioritaires pendant le routage et sont insérés au début de la file d'attente de destination. Les messages de priorité identique sont placés dans la file d'attente en fonction de leur heure d'arrivée.  
  
 Vous pouvez définir une priorité significative uniquement pour les messages non transactionnels. Message Queuing définit automatiquement la priorité des messages transactionnels à `Lowest`, ce qui entraîne leur priorité doivent être ignorés.  
  
   
  
## Examples  
 L’exemple de code suivant envoie deux messages de priorités différentes à la file d’attente et les récupère.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Priority" />.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le message est toujours remis, même en cas de défaillance de l'ordinateur ou du réseau.</summary>
        <value><see langword="true" /> si la remise du message est garantie (grâce à la sauvegarde du message sur le disque pendant le routage) ; <see langword="false" /> si la remise n'est pas assurée. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.Recoverable%2A> propriété indique si la remise d’un message est garantie - même si un ordinateur tombe en panne pendant le routage vers la file d’attente de destination.  
  
 Si la remise d’un message est garantie, le message est stocké localement à chaque étape sur l’itinéraire, jusqu'à ce que le message est transféré avec succès à l’ordinateur suivant. Définition de la <xref:System.Messaging.Message.Recoverable%2A> propriété `true` peut affecter le débit.  
  
 Si le message est transactionnel, Message Queuing le traite automatiquement comme étant récupérable, indépendamment de la valeur de la <xref:System.Messaging.Message.Recoverable%2A> propriété.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.Recoverable%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.Recoverable" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit la file d'attente qui reçoit les messages de réponse générés par l'application.</summary>
        <value>Le <see cref="T:System.Messaging.MessageQueue" /> auquel les messages de réponse générés par l'application sont retournés. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.ResponseQueue%2A> propriété identifie la file d’attente qui reçoit les messages de réponse générés par l’application, que l’application réceptrice retourne à l’application émettrice. L'application émettrice spécifie les files d'attente de réponses lors de l'envoi des messages. Toute file d'attente disponible peut être spécifiée comme file d'attente de réponses.  
  
 Les messages retournés à la file d'attente de réponses sont spécifiques à l'application. L'application doit définir le contenu des messages ainsi que l'action à entreprendre à réception d'un message.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.ResponseQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.ResponseQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le contexte de sécurité d'un message.</summary>
        <value>Objet <see cref="T:System.Messaging.SecurityContext" /> qui contient le contexte de sécurité pour un message si la propriété a été définie précédemment ; sinon, NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le certificat de sécurité utilisé pour authentifier des messages.</summary>
        <value>Un tableau des valeurs d'octets qui représente un certificat de sécurité, que Message Queuing utilise pour vérifier l'expéditeur du message. La valeur par défaut est un tableau de longueur zéro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’application de réception utilise le <xref:System.Messaging.Message.SenderCertificate%2A> propriété lorsque le message inclut un certificat de sécurité externes.  
  
 Message Queuing peut authentifier un message en utilisant un certificat de sécurité interne ou externe. Message Queuing fournit des certificats internes qui sont utilisées pour vérifier l’intégrité des messages. Une autorité de certification fournit un certificat externe, vous pouvez accéder via le <xref:System.Messaging.Message.SenderCertificate%2A> propriété du message. En plus de permettre à Message Queuing authentifier le message, un certificat externe permet à l’application réceptrice de vérifier l’expéditeur. Il n’y a aucune valeur utilisable pour une application de réception pour un certificat interne.  
  
 Un certificat externe doit être inscrit avec le service d’annuaire du système Message Queuing. Un certificat externe contient des informations sur l’autorité de certification, l’utilisateur du certificat, la période de validité du certificat, la clé publique de l’utilisateur du certificat et de signature de l’autorité de certification.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.SenderCertificate" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur de l'utilisateur expéditeur.</summary>
        <value>Un tableau des valeurs d'octets qui identifie l'expéditeur. Le Gestionnaire de files d'attente de destination utilise l'identificateur lors de l'authentification du message, pour vérifier l'expéditeur du message et les droits d'accès de ce dernier à la file d'attente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si le <xref:System.Messaging.Message.AttachSenderId%2A> propriété est `false`, l’identificateur d’expéditeur spécifié dans le <xref:System.Messaging.Message.SenderId%2A> propriété n’est pas attachée au message lorsqu’il est envoyé. Cela indique à Message Queuing que l’expéditeur ne doit pas être validé lorsqu’il envoie le message à la file d’attente de destination. Si le <xref:System.Messaging.Message.AttachSenderId%2A> propriété est `true`, le <xref:System.Messaging.Message.SenderId%2A> valeur de propriété est digne de confiance uniquement si le message a été authentifié. Utilisez le <xref:System.Messaging.Message.Authenticated%2A> propriété conjointement avec la <xref:System.Messaging.Message.SenderId%2A> propriété pour vérifier les droits d’accès de l’expéditeur.  
  
 Une application de connexion est une application qui utilise un serveur de connecteur pour assurer la communication entre Message Queuing et d’autres systèmes de file d’attente. Message Queuing nécessite des applications de connexion pour fournir une identification de l’expéditeur. Vous devez définir le <xref:System.Messaging.Message.ConnectorType%2A> propriété lors de l’envoi d’un message via une application de connexion.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.SenderId" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la version de Message Queuing utilisée pour envoyer le message.</summary>
        <value>La version de Message Queuing utilisée pour envoyer le message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.SenderVersion%2A> propriété est importante pour certaines fonctionnalités. Par exemple, traitement des transactions est pris en charge uniquement par Message Queuing 2.0 et versions ultérieures, et les signatures numériques sont utilisées pour authentifier les messages envoyés par MSMQ 1.0.  
  
 Les jeux de gestionnaire de file d’attente émettrice le <xref:System.Messaging.Message.SenderVersion%2A> propriété lorsque le message est envoyé.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.SenderVersion%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.SenderVersion" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la date et l'heure de l'ordinateur source auxquelles le message a été envoyé par le Gestionnaire de files d'attente source.</summary>
        <value><see cref="T:System.DateTime" /> qui représente l'heure à laquelle le message a été envoyé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.SentTime%2A> propriété est ajustée à l’heure locale de l’ordinateur sur lequel l’instance de la <xref:System.Messaging.Message> classe a été créée. Ce fuseau horaire peut être différent de ceux des files d’attente source et de destination.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.SentTime%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.SentTime" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'ordinateur d'origine du message.</summary>
        <value>Nom de l'ordinateur à partir duquel le message a été envoyé.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le format de la <xref:System.Messaging.Message.SourceMachine%2A> propriété n’est pas précédé de deux barres obliques (\\\\). Par exemple, `myServer` n’est valide <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.SourceMachine%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.SourceMachine" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Impossible d'accéder aux informations de l'ordinateur ni au service d'annuaire.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délai d'attente pour la réception du message à partir de la file d'attente de destination.</summary>
        <value>La durée totale pour la réception d'un message à partir de la file d'attente de destination. La valeur par défaut est <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété spécifie la durée totale pour un message en provenance de la file d’attente de destination. La limite de temps inclut le temps passé à la file d’attente de destination et le temps passé à attendre dans la file d’attente avant que le message est reçu.  
  
> [!CAUTION]
>  Lorsque vous utilisez des ordinateurs clients dépendants, veillez à ce que l’horloge sur l’ordinateur client est synchronisée avec l’horloge sur le serveur exécutant Message Queuing. Sinon, un comportement imprévisible peut en résulter lors de l’envoi d’un message dont <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété n’est pas <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Si l’intervalle spécifié par le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété expire avant que le message est supprimé de la file d’attente, Message Queuing ignore le message de deux manières. Si la propriété du message <xref:System.Messaging.Message.UseDeadLetterQueue%2A> a la valeur `true`, le message est envoyé dans la file d'attente de lettres mortes. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> est `false`, le message est ignoré.  
  
 Vous pouvez définir le message <xref:System.Messaging.Message.AcknowledgeType%2A> sauvegarder de propriété pour demander que Message Queuing envoie un message d’accusé de réception négatif à l’application émettrice si le message n’est pas récupéré avant l’expiration du minuteur.  
  
 Si la valeur spécifiée par le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété est inférieure à la valeur spécifiée par le <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété, <xref:System.Messaging.Message.TimeToBeReceived%2A> est prioritaire.  
  
 Lorsque plusieurs messages sont envoyés dans une transaction unique, Message Queuing utilise le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété du premier message.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.TimeToBeReceived" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour <see cref="P:System.Messaging.Message.TimeToBeReceived" /> n'est pas valide.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit le délai accordé à un message pour atteindre la file d'attente.</summary>
        <value>Le délai en secondes accordé au message pour atteindre la file d'attente de destination, à compter de l'heure d'envoi du message. La valeur par défaut est <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si l’intervalle spécifié par le <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété expire avant que le message n’atteigne sa destination, Message Queuing ignore le message de deux manières. Si la propriété du message <xref:System.Messaging.Message.UseDeadLetterQueue%2A> a la valeur `true`, le message est envoyé dans la file d'attente de lettres mortes. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> est `false`, le message est ignoré.  
  
 Vous pouvez définir du message <xref:System.Messaging.Message.AcknowledgeType%2A> sauvegarder de propriété pour demander que Message Queuing envoie un message d’accusé de réception négatif à l’application émettrice si le message n’est pas arrivé avant l’expiration du minuteur.  
  
 Si le <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété est définie sur 0 seconde, Message Queuing essaie une fois envoyer le message vers sa destination - si la file d’attente est en attente pour le message. Si la file d’attente est locale, le message atteint toujours.  
  
 Si la valeur spécifiée par le <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété est supérieure à la valeur spécifiée par le <xref:System.Messaging.Message.TimeToBeReceived%2A> propriété, <xref:System.Messaging.Message.TimeToBeReceived%2A> est prioritaire.  
  
 Lorsque plusieurs messages sont envoyés dans une transaction unique, Message Queuing utilise le <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété du premier message.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.TimeToReachQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.TimeToReachQueue" />.</exception>
        <exception cref="T:System.ArgumentException">La valeur spécifiée pour <see cref="P:System.Messaging.Message.TimeToReachQueue" /> n'est pas valide. Il peut s'agir d'un nombre négatif.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient l'identificateur pour la transaction dont faisait partie le message.</summary>
        <value>L'identificateur pour la transaction associée au message.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Applications réceptrices utilisent la <xref:System.Messaging.Message.TransactionId%2A> propriété pour vérifier qu’un message a été envoyé en tant que partie d’une transaction spécifique. L’identificateur de transaction contient l’identificateur de l’ordinateur émetteur (première 16 bits), suivie d’un numéro de séquence de transaction de 4 octets.  
  
 Cette propriété est uniquement disponible pour Message Queuing version 2.0 et versions ultérieures.  
  
 Ne sont pas garantis que les identificateurs de transaction soient uniques, car les numéros de séquence de transaction ne sont pas persistants et ils recommencent à 2 <sup>20</sup>. Message Queuing garantit uniquement que les transactions suivantes auront des numéros de séquence de transaction différent.  
  
 Vous pouvez utiliser la <xref:System.Messaging.Message.TransactionId%2A> propriété avec le <xref:System.Messaging.Message.IsFirstInTransaction%2A> et <xref:System.Messaging.Message.IsLastInTransaction%2A> propriétés pour vérifier les limites de transaction.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.TransactionId%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.TransactionId" />.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la file d'attente des statuts de transaction sur l'ordinateur source.</summary>
        <value>La file d'attente des statuts de transaction sur l'ordinateur source, qui est utilisée pour retourner les messages d'accusé de réception à l'application source. La valeur par défaut est <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.TransactionStatusQueue%2A> propriété identifie la file d’attente transactionnelle sur l’ordinateur source qui reçoit les accusés de réception de lecture à partir d’applications de connecteur. Message Queuing définit la propriété, et les applications de connecteur la propriété lors de la récupération des messages transactionnels envoyés aux files d’attente externes.  
  
 Il existe une file d’attente étrangère dans un file d’attente système autre que Microsoft Message Queuing. Message Queuing communique avec ces files d’attente par le biais d’un connecteur.  
  
 L’application connecteur peut utiliser la file d’attente du statut de transaction pour envoyer des messages d’accusé de réception à l’application émettrice. La file d’attente du statut de transaction doit recevoir ces accusés de réception même si l’application émettrice ne demande pas d’autres accusés de réception.  
  
   
  
## Examples  
 L’exemple de code suivant affiche la valeur d’un message <xref:System.Messaging.Message.TransactionStatusQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Le message n'a pas été envoyé. Cette propriété ne peut être lue que sur les messages récupérés à partir d'une file d'attente.  
  
ou 
La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.TransactionStatusQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le message a été (ou doit être) authentifié avant son envoi.</summary>
        <value><see langword="true" /> si l'application source a demandé l'authentification du message ; sinon, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.UseAuthentication%2A> propriété spécifie si le message doit être authentifié. Si l’application émettrice demande l’authentification, Message Queuing crée une signature numérique et l’utilise pour signer le message lorsqu’il est envoyé et authentifier le message lorsqu’il est reçu.  
  
 Si <xref:System.Messaging.Message.UseAuthentication%2A> est `false` et un message est envoyé à une file d’attente accepte uniquement les messages authentifiés, le message est rejeté lorsqu’il atteint la file d’attente.  
  
 Vous ne pouvez pas déterminer si un message d’échec de l’authentification en examinant ses propriétés. Message Queuing élimine ces messages avant qu’ils sont remis à la file d’attente. Toutefois, vous pouvez demander qu’un message d’accusé de réception est envoyé si un échec de remise empêche un message d’arriver dans la file d’attente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.UseAuthentication" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une copie du message non remis doit être envoyée dans une file d'attente de lettres mortes.</summary>
        <value><see langword="true" /> si l'échec de remise d'un message doit avoir pour résultat l'envoi d'une copie du message dans une file d'attente de lettres mortes ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.UseJournalQueue%2A> et <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriétés spécifient la façon dont Message Queuing assure le suivi d’un message. Si <xref:System.Messaging.Message.UseDeadLetterQueue%2A> est `true`, provoque l’échec de remise (d’un message non transactionnel), le message à envoyer à la file d’attente de lettres mortes non transactionnelle sur l’ordinateur qui ne pourrait pas remettre le message. Échec de remise peut être dû à un minuteur de message arrive à expiration, par exemple.  
  
 Dans le cas d’échec de remise pour un message transactionnel, Message Queuing envoie le message à la file d’attente de lettres mortes transactionnelle sur la machine source dans tous les cas négatifs et incertaine.  
  
 Lorsque vous stockez des messages dans une file d’attente de lettres mortes, vous devez effacer la file d’attente régulièrement pour supprimer les messages qui ne sont plus nécessaires. Messages stockés dans le nombre de files d’attente de lettres mortes par rapport au quota de taille pour l’ordinateur où se trouve la file d’attente. Le quota de l’ordinateur est défini par l’administrateur et fait référence à la taille allouée pour stocker les messages sur l’ordinateur entier, pas seulement dans une file d’attente unique.  
  
 Vous ne créez pas un journal ou une file d’attente de lettres mortes. Il s’agit des files d’attente système que Message Queuing génère.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.UseDeadLetterQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si le message doit être privé.</summary>
        <value><see langword="true" /> pour demander le chiffrement du message par Message Queuing ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si un message est privé, son corps est chiffré avant son envoi et déchiffrée lorsqu’elles sont reçues. Pour envoyer un message privé, l’application émettrice doit spécifier que le chiffrement est utilisé et, éventuellement, l’algorithme de chiffrement.  
  
 Lors de l’envoi de messages privés, votre application n’a pas besoin effectuer le chiffrement du message. Message Queuing peut chiffrer le corps du message pour vous si votre application envoie les messages dans une entreprise de Microsoft Windows 2000, qui a accès au service d’annuaire. Lors de la réception de messages privés, le Gestionnaire de file d’attente de réception déchiffre toujours le corps du message.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.UseEncryption%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.UseEncryption" />.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si une copie du message doit être conservée dans un journal sur l'ordinateur d'origine.</summary>
        <value><see langword="true" /> pour demander qu'une copie d'un message soit conservée dans le journal de l'ordinateur d'origine suite à la transmission réussie du message (de l'ordinateur d'origine vers le serveur suivant) ; sinon, <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.UseJournalQueue%2A> et <xref:System.Messaging.Message.UseDeadLetterQueue%2A> propriétés spécifient la façon dont Message Queuing assure le suivi d’un message. Si <xref:System.Messaging.Message.UseJournalQueue%2A> est `true`, puis une copie est conservée dans le journal de l’ordinateur d’origine à chaque étape qu’un message est transmis.  
  
 Le message envoyé est uniquement copié dans la file d’attente du journal si la file d’attente de destination se trouve sur un ordinateur distant. Si la destination se trouve sur l’ordinateur local, le message est envoyé directement à la file d’attente ; Il n’existe pas d’étapes intermédiaires pour exiger la journalisation.  
  
 Lorsque vous stockez des messages dans une file d’attente du journal, désactivez la file d’attente régulièrement pour supprimer les messages qui ne sont plus nécessaires. Messages stockés dans le nombre de files d’attente de journal sur le quota pour l’ordinateur où se trouve la file d’attente. (Le quota d’ordinateur est défini par l’administrateur).  
  
 Vous ne créez pas un journal ou une file d’attente de lettres mortes. Il s’agit des files d’attente système que Message Queuing génère.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.UseJournalQueue%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.UseJournalQueue" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient ou définit une valeur qui indique si un message doit être suivi lors de son transfert vers la file d'attente de destination correspondante.</summary>
        <value><see langword="true" /> si chaque étape intermédiaire effectuée par le message d'origine acheminé vers la file d'attente de destination génère un rapport à envoyer à la file d'attente de rapports du système ; sinon <see langword="false" />. La valeur par défaut est <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le <xref:System.Messaging.Message.UseTracing%2A> propriété spécifie s’il faut suivre l’itinéraire d’un message vers sa file d’attente de destination. Si `true`, un message de rapport (généré par Message Queuing) est envoyé à une file d’attente de rapports chaque fois que le message passe par un serveur de routage Message Queuing. La file d’attente de rapports est spécifiée par le Gestionnaire de file d’attente source. Files d’attente de rapports ne sont pas limitées aux messages de rapport générés par Message Queuing ; vos messages générés par l’application peuvent également être envoyés aux files d’attente de rapports.  
  
 Utilisation du suivi implique la configuration d’Active Directory et en spécifiant une file d’attente de rapports pour l’entreprise Message Queuing. L’administrateur configure ces paramètres.  
  
   
  
## Examples  
 L’exemple de code suivant obtient et définit la valeur d’un message <xref:System.Messaging.Message.UseTracing%2A> propriété.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">La file d'attente des messages est filtrée pour ignorer la propriété <see cref="P:System.Messaging.Message.UseTracing" />.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>