<Type Name="BlockingCollection&lt;T&gt;" FullName="System.Collections.Concurrent.BlockingCollection&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4cb534b672d54a536214323db969d50427033481" /><Meta Name="ms.sourcegitcommit" Value="662f143e6be46d519ff8ab4451d543d91e651478" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="fr-FR" /><Meta Name="ms.lasthandoff" Value="12/18/2018" /><Meta Name="ms.locfileid" Value="53569160" /></Metadata><TypeSignature Language="C#" Value="public class BlockingCollection&lt;T&gt; : IDisposable, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BlockingCollection`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.BlockingCollection`1" />
  <TypeSignature Language="VB.NET" Value="Public Class BlockingCollection(Of T)&#xA;Implements ICollection, IDisposable, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BlockingCollection : IDisposable, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type BlockingCollection&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IDisposable&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}, Type = {m_collection}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Type des éléments de la collection.</typeparam>
    <summary>Fournit des fonctions bloquantes et englobantes pour les collections thread-safe qui implémentent <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Concurrent.BlockingCollection%601> est une classe de collection thread-safe qui offre les avantages suivants :  
  
-   Une implémentation du modèle producteur/consommateur ; <xref:System.Collections.Concurrent.BlockingCollection%601> est un wrapper pour le <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> interface.  
  
-   Ajout simultané et la suppression d’éléments à partir de plusieurs threads avec le <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> et <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> méthodes.  
  
-   Une collection limitée qui bloque <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> et <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> opérations lors de la collection est vide ou complète.  
  
-   L’annulation de <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> opérations à l’aide un <xref:System.Threading.CancellationToken> de l’objet dans le <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> (méthode).  
  
> [!IMPORTANT]
>  Ce type implémente le <xref:System.IDisposable> interface. Lorsque vous avez fini d’utiliser le type, vous devez supprimer il directement ou indirectement. Pour supprimer le type directement, appelez sa <xref:System.IDisposable.Dispose%2A> méthode dans un `try` / `catch` bloc. Pour supprimer indirectement, utiliser une construction de langage tel que `using` (en c#) ou `Using` (en Visual Basic). Pour plus d’informations, consultez la section « À l’aide un objet qui implémente IDisposable » dans le <xref:System.IDisposable> rubrique de l’interface. Notez également que le <xref:System.Collections.Concurrent.BlockingCollection%601.Dispose> (méthode) n’est pas thread-safe. Tous les autres membres publics et protégés de <xref:System.Collections.Concurrent.BlockingCollection%601> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.  
  
 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> représente une collection qui permet l’ajout de thread-safe et la suppression de données. <xref:System.Collections.Concurrent.BlockingCollection%601> est utilisé comme un wrapper pour un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> de l’instance, ainsi que de tentatives de suppression de la collection bloquer jusqu'à ce que les données sont disponibles pour être supprimé. De même, vous pouvez créer un <xref:System.Collections.Concurrent.BlockingCollection%601> pour appliquer une limite supérieure sur le nombre d’éléments de données autorisés dans les <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>; tentatives d’ajout à la collection puis peuvent se bloquer jusqu'à ce que l’espace est suffisant stocker les éléments ajoutés. De cette manière, <xref:System.Collections.Concurrent.BlockingCollection%601> est similaire à une structure de données de file d’attente bloquante traditionnelle, à ceci près que le mécanisme de stockage de données sous-jacent est abstrait, comme un <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601> prend en charge la délimitation et le blocage. Délimitation signifie que vous pouvez définir la capacité maximale de la collection. Délimitation est importante dans certains scénarios, car elle vous permet de contrôler la taille maximale de la collection en mémoire, et il empêche les threads producteur de se déplacer trop loin avant les threads consommateur. Plusieurs threads ou tâches peuvent ajouter des éléments à la collection simultanément, et si la collection atteint sa capacité maximale spécifiée, les threads producteurs se bloquent jusqu'à ce qu’un élément est supprimé. Plusieurs consommateurs peuvent supprimer des éléments simultanément, et si la collection devient vide, les threads consommateur se bloquent jusqu’à ce qu’un producteur ajoute un élément. Un thread producteur peut appeler le <xref:System.Collections.Concurrent.BlockingCollection%601.CompleteAdding%2A> méthode pour indiquer qu’aucun autre élément ne sera ajouté. Les consommateurs surveillent la propriété <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> pour savoir quand la collection est vide et quand aucun autre élément ne sera ajouté.  
  
 <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> et <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> opérations sont généralement effectuées dans une boucle. Vous pouvez annuler une boucle en passant un <xref:System.Threading.CancellationToken> de l’objet à la <xref:System.Collections.Concurrent.BlockingCollection%601.TryAdd%2A> ou <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A> (méthode), puis en vérifiant la valeur du jeton de <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> propriété à chaque itération. Si la valeur est `true`, il vous incombe à répondre à la demande d’annulation en nettoyant à toutes les ressources et de quitter la boucle.  
  
 Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier non seulement la capacité limitée, mais également le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 Ne modifiez pas directement la collection sous-jacente. Utilisez <xref:System.Collections.Concurrent.BlockingCollection%601> méthodes pour ajouter ou supprimer des éléments. Le <xref:System.Collections.Concurrent.BlockingCollection%601> objet peut être endommagé Si vous modifiez la collection sous-jacente directement.  
  
   
  
## Examples  
 L’exemple suivant montre comment ajouter et prendre des éléments simultanément à partir d’une collection de blocage :  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#1)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>La méthode Dispose n’est pas thread-safe. Tous les autres membres publics et protégés de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sont thread-safe et peuvent être utilisés simultanément par plusieurs threads.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
    <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
    <related type="Article" href="https://msdn.microsoft.com/library/4c2492de-3876-4873-b5a1-000bb404d770">Procédure : Ajouter et de fonctionnalités à une classe de Collection de blocage</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sans limite supérieure.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sans limite supérieure.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La collection sous-jacente par défaut est un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet, qui fournit tout d’abord, comportement, premier sorti (FIFO).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Collection à utiliser comme magasin de données sous-jacent.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> sans limite supérieure et qui utilise le <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fourni comme magasin de données sous-jacent.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collection" /> a la valeur null.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; boundedCapacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="boundedCapacity">Taille limite de la collection.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> avec la limite supérieure spécifiée.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La collection sous-jacente par défaut est un <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <paramref name="boundedCapacity" /> n'est pas une valeur positive.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BlockingCollection (System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt; collection, int boundedCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt; collection, int32 boundedCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IProducerConsumerCollection(Of T), boundedCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BlockingCollection(System::Collections::Concurrent::IProducerConsumerCollection&lt;T&gt; ^ collection, int boundedCapacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;'T&gt; * int -&gt; System.Collections.Concurrent.BlockingCollection&lt;'T&gt;" Usage="new System.Collections.Concurrent.BlockingCollection&lt;'T&gt; (collection, boundedCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;" />
        <Parameter Name="boundedCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collection">Collection à utiliser comme magasin de données sous-jacent.</param>
        <param name="boundedCapacity">Taille limite de la collection.</param>
        <summary>Initialise une nouvelle instance de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> avec la limite supérieure spécifiée et qui utilise le <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" /> fourni comme magasin de données sous-jacent.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collection" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le <paramref name="boundedCapacity" /> n'est pas une valeur positive.</exception>
        <exception cref="T:System.ArgumentException">La <paramref name="collection" /> fournie contient plus de valeurs que <paramref name="boundedCapacity" /> n'autorise.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute l'élément au <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T -&gt; unit" Usage="blockingCollection.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection. La valeur peut être une référence null.</param>
        <summary>Ajoute l'élément au <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une capacité limitée a été spécifiée quand cette instance de <xref:System.Collections.Concurrent.BlockingCollection%601> a été initialisée, un appel à ajouter peut se bloquer jusqu'à ce que l’espace est suffisant stocker l’élément fourni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Add(`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Add : 'T * System.Threading.CancellationToken -&gt; unit" Usage="blockingCollection.Add (item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection. La valeur peut être une référence null.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Ajoute l'élément au <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une capacité limitée a été spécifiée quand cette instance de <xref:System.Collections.Concurrent.BlockingCollection%601> a été initialisé, un appel à <xref:System.Collections.Concurrent.BlockingCollection%601.Add%2A> peut bloquer jusqu'à ce que l’espace est suffisant stocker l’élément fourni.  
  
 Cette méthode peut retourner au début avec un <xref:System.OperationCanceledException> si le `cancellationToken` est annulée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé ou <see cref="T:System.Threading.CancellationTokenSource" /> qui possède <paramref name="cancellationToken" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ajoute l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <summary>Ajoute l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une capacité limitée a été spécifiée quand toutes les <xref:System.Collections.Concurrent.BlockingCollection%601> instances ont été initialisées, un appel à AddToAny peut se bloquer jusqu'à ce que l’espace est disponible dans une des collections pour stocker l’élément fourni.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="AddToAny">
      <MemberSignature Language="C#" Value="public static int AddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.AddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int AddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member AddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.AddToAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Ajoute l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une capacité limitée a été spécifiée quand toutes les <xref:System.Collections.Concurrent.BlockingCollection%601> instances ont été initialisées, un appel à AddToAny peut se bloquer jusqu'à ce que l’espace est disponible dans une des collections pour stocker l’élément fourni. Cette méthode peut retourner avant que l’élément est ajouté à n’importe quelle collection si la `cancellationToken` est annulé avant que l’espace est disponible.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.ObjectDisposedException">Au moins l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="BoundedCapacity">
      <MemberSignature Language="C#" Value="public int BoundedCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BoundedCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.BoundedCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BoundedCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BoundedCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BoundedCapacity : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.BoundedCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient la capacité limite de cette instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Capacité limite de cette collection, ou int.MaxValue si aucune limite n’a été fournie.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CompleteAdding">
      <MemberSignature Language="C#" Value="public void CompleteAdding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CompleteAdding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" />
      <MemberSignature Language="VB.NET" Value="Public Sub CompleteAdding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CompleteAdding();" />
      <MemberSignature Language="F#" Value="member this.CompleteAdding : unit -&gt; unit" Usage="blockingCollection.CompleteAdding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marque les instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> comme n'acceptant plus d'ajouts.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Une fois une collection a été marquée comme complète pour l’ajout, ajout à la collection n’est pas autorisée et tente de supprimer de la collection n’attendra pas lorsque la collection est vide.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="blockingCollection.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de l'instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
        <param name="index">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie tous les éléments dans l'instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dans un tableau compatible unidimensionnel, en commençant à l'index spécifié du tableau cible.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 CopyTo représente un instantané de la collection à un point précis dans le temps. Si d’autres threads ajoutent ou suppriment des éléments pendant l’exécution de CopyTo, les éléments retournés par CopyTo peut ne pas représentent l’état de la collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="array" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="index" /> est moins que zéro.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="index" /> est égal à ou supérieur à la longueur de l' <paramref name="array" />.  
  
Le tableau de destination est trop petit pour contenir tous les éléments BlockingCcollection.  
  
Le classement de tableau ne correspond pas.  
  
Le type de tableau est incompatible avec le type des éléments BlockingCollection.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient le nombre d'éléments contenus dans <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <value>Nombre d'éléments contenus dans <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si une méthode dans BlockingCollection s’exécute pendant que la propriété Count est un accès, la valeur de retour est approximative. Nombre peut refléter un nombre qui est soit supérieur ou inférieur au nombre réel d’éléments dans un BlockingCollection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="blockingCollection.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libère toutes les ressources utilisées par l'instance actuelle de la classe <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Le `Dispose` (méthode) n’est pas thread-safe.  
  
 Appelez la méthode `Dispose` une fois que vous avez terminé d'utiliser <xref:System.Collections.Concurrent.BlockingCollection%601>. La méthode `Dispose` rend le <xref:System.Collections.Concurrent.BlockingCollection%601> inutilisable. Après avoir appelé `Dispose`, vous devez libérer toutes les références à la <xref:System.Collections.Concurrent.BlockingCollection%601> pour que le garbage collector puisse récupérer la mémoire qui le <xref:System.Collections.Concurrent.BlockingCollection%601> occupée.  
  
 Pour plus d’informations, consultez [de nettoyage des ressources non managées](~/docs/standard/garbage-collection/unmanaged.md) et [implémentation d’une méthode Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Appelez toujours `Dispose` avant de libérer votre dernière référence à <xref:System.Collections.Concurrent.BlockingCollection%601>. Sinon, les ressources utilisées ne seront pas libérées tant que le garbage collector n'aura pas appelé la méthode <xref:System.Collections.Concurrent.BlockingCollection%601> de l'objet `Finalize`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="blockingCollection.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Si la suppression est explicite (True) ou due à un finaliseur (False).</param>
        <summary>Libère les ressources utilisées par l’instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConsumingEnumerable">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fournit un <see cref="T:System.Collections.Generic.IEnumerator`1" /> de consommation pour les éléments de la collection.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConsumingEnumerable () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable();" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : unit -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un <see cref="T:System.Collections.Generic.IEnumerator`1" /> de consommation pour les éléments de la collection.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui supprime et retourne des éléments de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A> méthode :  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#4)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="GetConsumingEnumerable">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; GetConsumingEnumerable (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!T&gt; GetConsumingEnumerable(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.GetConsumingEnumerable(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;T&gt; ^ GetConsumingEnumerable(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetConsumingEnumerable : System.Threading.CancellationToken -&gt; seq&lt;'T&gt;" Usage="blockingCollection.GetConsumingEnumerable cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__2))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Collections.Concurrent.BlockingCollection`1/&lt;GetConsumingEnumerable&gt;d__68))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Fournit un <see cref="T:System.Collections.Generic.IEnumerable`1" /> de consommation pour les éléments de la collection.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerable`1" /> qui supprime et retourne des éléments de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode permet au code client supprimer des éléments de la collection à l’aide d’une boucle foreach (pour chaque en Visual Basic), ou <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> ou une requête PLINQ. L’énumérateur continuera à fournir des éléments (le cas échéant) jusqu'à ce que <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> retourne la valeur true et si <xref:System.Collections.Concurrent.BlockingCollection%601.IsCompleted%2A> a la valeur false la boucle se bloque jusqu'à ce qu’un élément devienne disponible ou jusqu'à ce que le <xref:System.Threading.CancellationToken> est annulée.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a été supprimé</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsAddingCompleted">
      <MemberSignature Language="C#" Value="public bool IsAddingCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAddingCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsAddingCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAddingCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAddingCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAddingCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsAddingCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient si ce <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme ne pouvant plus accepter d'ajout.</summary>
        <value>Si cette collection a été marquée comme ne pouvant plus accepter d’ajout.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient si ce <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme ne pouvant plus accepter d'ajout et est vide.</summary>
        <value>Si cette collection a été marquée comme ne pouvant plus accepter d’ajout et est vide.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un <see cref="T:System.Collections.Generic.IEnumerator`1" /> pour les éléments de la collection.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> pour les éléments de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contrairement aux <xref:System.Collections.Concurrent.BlockingCollection%601.GetConsumingEnumerable%2A>, <xref:System.Collections.Concurrent.BlockingCollection%601.System%23Collections%23Generic%23IEnumerable%7BT%7D%23GetEnumerator%2A?displayProperty=nameWithType> retourne un énumérateur standard qui ne modifie pas la collection sous-jacente. Si d’autres threads sont ajouter ou supprimer des éléments simultanément lorsque GetEnumerator est appelé, les éléments retournés par l’énumérateur peut ne pas représentent l’état actuel de la collection.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tableau unidimensionnel qui constitue la destination des éléments copiés à partir de l'instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />. Ce tableau doit avoir une indexation de base zéro.</param>
        <param name="index">Index de base zéro dans l'<paramref name="array" /> à partir duquel la copie commence.</param>
        <summary>Copie tous les éléments dans l'instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dans un tableau compatible unidimensionnel, en commençant à l'index spécifié du tableau cible.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="array" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">L'argument <paramref name="index" /> est moins que zéro.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="index" /> est égal à ou supérieur à la longueur de l' <paramref name="array" />, le tableau est multidimensionnel, ou le paramètre de type pour la collection ne peut pas être casté automatiquement au type du tableau de destination.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient une valeur indiquant si l'accès à <see cref="T:System.Collections.ICollection" /> est synchronisé (thread-safe).</summary>
        <value>Retourne toujours <see langword="false" /> pour indiquer l’accès n’est pas synchronisé.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.BlockingCollection`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtient un objet qui peut être utilisé pour synchroniser l'accès à <see cref="T:System.Collections.ICollection" />. Cette propriété n'est pas prise en charge.</summary>
        <value>Retourne la valeur NULL.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">La propriété SyncRoot n'est pas prise en charge.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fournit un <see cref="T:System.Collections.IEnumerator" /> pour les éléments de la collection.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> pour les éléments de la collection.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Take">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supprime un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take" />
      <MemberSignature Language="VB.NET" Value="Public Function Take () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take();" />
      <MemberSignature Language="F#" Value="member this.Take : unit -&gt; 'T" Usage="blockingCollection.Take " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Supprime un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Élément supprimé de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
 L'ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l'instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />, ou le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> est vide et la collection a été marquée comme ne pouvant plus accepter d'ajout.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="Take">
      <MemberSignature Language="C#" Value="public T Take (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Take(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.Take(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Take(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Take : System.Threading.CancellationToken -&gt; 'T" Usage="blockingCollection.Take cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Objet pouvant être utilisé pour annuler l'opération Take.</param>
        <summary>Supprime un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>Élément supprimé de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à <xref:System.Collections.Concurrent.BlockingCollection%601.Take%2A> peut bloquer jusqu'à ce qu’un élément est disponible pour être supprimé ou le jeton est annulé.  
  
 L’ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l’instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé le jeton a été annulé.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou BlockingCollection est marqué comme terminé pour l'ajout, ou <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> est vide.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Prend un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <summary>Prend un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> duquel l’élément a été supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> a été appelé dans la collection.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TakeFromAny">
      <MemberSignature Language="C#" Value="public static int TakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TakeFromAny (collections, item, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Prend un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées tout en observant le jeton d'annulation spécifié.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> duquel l’élément a été supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé. La méthode sera retournée rapidement avec une OperationCanceledException si le jeton est annulé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null ou <see cref="M:System.Collections.Concurrent.BlockingCollection`1.CompleteAdding" /> a été appelé dans la collection.</exception>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="blockingCollection.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copie les éléments de l'instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> dans un nouveau tableau.</summary>
        <returns>Tableau contenant les copies des éléments de la collection.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Les éléments copiés ne sont pas supprimés de la collection.  
  
 Si une méthode dans BlockingCollection s’exécute pendant l’exécution de la méthode ToArray, la valeur de retour est approximative. ToArray peut inclure les éléments qui ont déjà été supprimés ou exclure les éléments qui ont déjà été insérés.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAdd">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente d'ajouter l'élément spécifié à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T -&gt; bool" Usage="blockingCollection.TryAdd item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection.</param>
        <summary>Tente d'ajouter l'élément spécifié à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns><see langword="true" /> si <paramref name="item" /> peut être ajouté ; sinon, <see langword="false" />. Si l’élément est un doublon et que la collection sous-jacente n’accepte pas les doublons, une <see cref="T:System.InvalidOperationException" /> est levée.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la collection est une collection limitée et est plein, cette méthode renvoie immédiatement false sans ajouter l’élément.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Tente d'ajouter l'élément spécifié à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> au cours de la période spécifiée.</summary>
        <returns>True si <paramref name="item" /> a pu être ajouté à la collection dans le délai spécifié ; sinon, False. Si l’élément est un doublon et que la collection sous-jacente n’accepte pas les doublons, une <see cref="T:System.InvalidOperationException" /> est levée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * TimeSpan -&gt; bool" Usage="blockingCollection.TryAdd (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Tente d'ajouter l'élément spécifié à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns>True si <paramref name="item" /> a pu être ajouté à la collection dans l'intervalle de temps spécifié ; sinon, False.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAdd(`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'T * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryAdd (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Élément à ajouter à la collection.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Tente d'ajouter l'élément spécifié à <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> au cours de la période spécifiée tout en observant un jeton d'annulation.</summary>
        <returns>True si <paramref name="item" /> a pu être ajouté à la collection dans le délai spécifié ; sinon, False. Si l’élément est un doublon et que la collection sous-jacente n’accepte pas les doublons, une <see cref="T:System.InvalidOperationException" /> est levée.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> sous-jacent a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.InvalidOperationException">Le <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été marqué comme complet en ce qui concerne les additions.  
  
ou 
La collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryAddToAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente d'ajouter l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <summary>Tente d'ajouter l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté, ou -1 si l’élément n’a pas pu être ajouté.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Tente d'ajouter l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté, ou -1 si l’élément n’a pas pu être ajouté.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini. 
- ou - 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryAddToAny (collections As BlockingCollection(Of T)(), item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Tente d'ajouter l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées tout en observant le jeton d'annulation spécifié.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté, ou -1 si l’élément n’a pas pu être ajouté.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cette méthode peut retourner au début si le cancellationToken est annulé avant de l’espace n’était disponible pour l’opération d’ajout.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> ou le <see cref="T:System.Threading.CancellationTokenSource" /> qui a créé <paramref name="cancellationToken" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryAddToAny">
      <MemberSignature Language="C#" Value="public static int TryAddToAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryAddToAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, !T item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryAddToAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryAddToAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryAddToAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] * 'T * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryAddToAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément à ajouter à l’une des collections.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Tente d'ajouter l'élément spécifié à l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> auquel l’élément a été ajouté, ou -1 si l’élément n’a pas pu être ajouté.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, une collection sous-jacente n'a pas accepté l'élément.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini. 
ou 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null, ou au moins, l'une des collections a été marquée comme complète pour l'ajout.</exception>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTake">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente de supprimer un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 L'exemple suivant illustre l'utilisation de la méthode <xref:System.Collections.Concurrent.BlockingCollection%601.TryTake%2A>.  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#2)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  -&gt; bool" Usage="blockingCollection.TryTake item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Élément à supprimer de la collection.</param>
        <summary>Tente de supprimer un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</summary>
        <returns><see langword="true" /> si un élément peut être supprimé ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si la collection est vide, cette méthode renvoie immédiatement false.  
  
 L’ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l’instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Élément à supprimer de la collection.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Tente de supprimer un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> au cours de la période spécifiée.</summary>
        <returns><see langword="true" /> si un élément a pu être supprimé de la collection dans le délai spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l’instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601>, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryTake (ByRef item As T, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * TimeSpan -&gt; bool" Usage="blockingCollection.TryTake (item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="item">Élément à supprimer de la collection.</param>
        <param name="timeout">Objet qui représente le nombre de millièmes de secondes à attendre ou objet qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Tente de supprimer un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> au cours de la période spécifiée.</summary>
        <returns><see langword="true" /> si un élément a pu être supprimé de la collection dans le délai spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l’instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif différent de -1 milliseconde, qui représente un délai d’attente infini. 
ou 
 <paramref name="timeout" /> est supérieur à <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTake">
      <MemberSignature Language="C#" Value="public bool TryTake (out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryTake([out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTake(`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryTake([Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TryTake :  * int * System.Threading.CancellationToken -&gt; bool" Usage="blockingCollection.TryTake (item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="item">Élément à supprimer de la collection.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Tente de supprimer un élément de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> au cours de la période spécifiée tout en observant un jeton d'annulation.</summary>
        <returns><see langword="true" /> si un élément a pu être supprimé de la collection dans le délai spécifié ; sinon, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 L’ordre dans lequel un élément est supprimé dépend du type de collection utilisée pour créer l’instance <xref:System.Collections.Concurrent.BlockingCollection%601>. Lorsque vous créez un <xref:System.Collections.Concurrent.BlockingCollection%601> objet, vous pouvez spécifier le type de collection à utiliser. Par exemple, vous pouvez spécifier un <xref:System.Collections.Concurrent.ConcurrentQueue%601> objet pour le premier entré, premier sorti (FIFO) comportement, ou un <xref:System.Collections.Concurrent.ConcurrentStack%601> objet pour le dernier entré, premier sorti (LIFO) comportement. Vous pouvez utiliser n’importe quelle classe de collection qui implémente l’interface <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>. Le type de collection par défaut pour <xref:System.Collections.Concurrent.BlockingCollection%601> est <xref:System.Collections.Concurrent.ConcurrentQueue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> a été annulé.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimé ou le <see cref="T:System.Threading.CancellationTokenSource" /> sous-jacent a été supprimé.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini.</exception>
        <exception cref="T:System.InvalidOperationException">La collection sous-jacente a été modifiée en dehors de cette instance de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryTakeFromAny">
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tente de supprimer un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <summary>Tente de supprimer un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> dont l’élément a été supprimé, ou -1 si un élément n’a pas pu être supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TryTakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
   
  
## Examples  
 L’exemple suivant montre comment utiliser le <xref:System.Collections.Concurrent.BlockingCollection%601.TryTakeFromAny%2A?displayProperty=nameWithType> méthode :  
  
 [!code-csharp[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/cs/blockingcoll.cs#3)]
 [!code-vb[System.Collections.Concurrent.BlockingCollection#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.blockingcollection/vb/blockingcoll.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <summary>Tente de supprimer un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> dont l’élément a été supprimé, ou -1 si un élément n’a pas pu être supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TryTakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini. 
ou 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryTakeFromAny (collections As BlockingCollection(Of T)(), ByRef item As T, timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * TimeSpan -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> qui représente le nombre de millièmes de secondes à attendre ou <see cref="T:System.TimeSpan" /> qui représente -1 millième de seconde, pour attendre indéfiniment.</param>
        <summary>Tente de supprimer un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> dont l’élément a été supprimé, ou -1 si un élément n’a pas pu être supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TryTakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> est un nombre négatif autre que -1 millisecondes, qui représente un délai d'expiration infini - ou - le délai d'attente est supérieur à <see cref="F:System.Int32.MaxValue" />.  
  
- ou - 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
    <Member MemberName="TryTakeFromAny">
      <MemberSignature Language="C#" Value="public static int TryTakeFromAny (System.Collections.Concurrent.BlockingCollection&lt;T&gt;[] collections, out T item, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 TryTakeFromAny(class System.Collections.Concurrent.BlockingCollection`1&lt;!T&gt;[] collections, [out] !T&amp; item, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.BlockingCollection`1.TryTakeFromAny(System.Collections.Concurrent.BlockingCollection{`0}[],`0@,System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int TryTakeFromAny(cli::array &lt;System::Collections::Concurrent::BlockingCollection&lt;T&gt; ^&gt; ^ collections, [Runtime::InteropServices::Out] T % item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member TryTakeFromAny : System.Collections.Concurrent.BlockingCollection&lt;'T&gt;[] *  * int * System.Threading.CancellationToken -&gt; int" Usage="System.Collections.Concurrent.BlockingCollection&lt;'T&gt;.TryTakeFromAny (collections, item, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collections" Type="System.Collections.Concurrent.BlockingCollection&lt;T&gt;[]" />
        <Parameter Name="item" Type="T" RefType="out" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="collections">Tableau de collections.</param>
        <param name="item">Élément supprimé de l’une des collections.</param>
        <param name="millisecondsTimeout">Nombre de millisecondes à attendre, ou <see cref="F:System.Threading.Timeout.Infinite" /> (-1) pour un délai d'attente infini.</param>
        <param name="cancellationToken">Jeton d'annulation à observer.</param>
        <summary>Tente de supprimer un élément de l'une des instances de <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> spécifiées.</summary>
        <returns>Index de la collection dans le tableau <paramref name="collections" /> dont l’élément a été supprimé, ou -1 si un élément n’a pas pu être supprimé.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un appel à TryTakeFromAny peut bloquer jusqu'à ce qu’un élément soit disponible pour être supprimé.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">Si le <see cref="T:System.Threading.CancellationToken" /> est annulé.</exception>
        <exception cref="T:System.InvalidOperationException">Au moins, l'une des collections sous-jacentes a été modifiée en dehors de son instance <see cref="T:System.Collections.Concurrent.BlockingCollection`1" />.</exception>
        <exception cref="T:System.ArgumentNullException">L’argument <paramref name="collections" /> a la valeur null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" /> est un nombre négatif différent de -1, qui représente un délai d’attente infini. 
ou 
Le compte de <paramref name="collections" /> est supérieur à la taille maximale de 62 pour STA et 63 pour le MTA.</exception>
        <exception cref="T:System.ArgumentException">L'argument <paramref name="collections" /> est un tableau de longueur 0 ou contient un élément null.</exception>
        <exception cref="T:System.ObjectDisposedException">Au moins, l'une des instances <see cref="T:System.Collections.Concurrent.BlockingCollection`1" /> a été supprimée.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/2e7ca21f-786c-4367-96be-0cf3f3dcc6bd">Collections thread-safe</related>
        <related type="Article" href="https://msdn.microsoft.com/library/987ea3d7-0ad5-4238-8b64-331ce4eb3f0b">Vue d'ensemble de BlockingCollection</related>
      </Docs>
    </Member>
  </Members>
</Type>